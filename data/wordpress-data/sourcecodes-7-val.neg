<?php/** * The template for displaying Archive pages. * * Used to display archive-type pages if nothing more specific matches a query. * For example, puts together date-based pages if no date.php file exists. * * Learn more: http://codex.wordpress.org/Template_Hierarchy * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main"><?php	/* Queue the first post, that way we know	 * what date we're dealing with (if that is the case).	 *	 * We reset this later so we can run the loop	 * properly with a call to rewind_posts().	 */	if ( have_posts() )		the_post();?>			<h1 class="page-title"><?php if ( is_day() ) : ?>				<?php printf( __( 'Daily Archives: <span>%s</span>', 'twentyten' ), get_the_date() ); ?><?php elseif ( is_month() ) : ?>				<?php printf( __( 'Monthly Archives: <span>%s</span>', 'twentyten' ), get_the_date('F Y') ); ?><?php elseif ( is_year() ) : ?>				<?php printf( __( 'Yearly Archives: <span>%s</span>', 'twentyten' ), get_the_date('Y') ); ?><?php else : ?>				<?php _e( 'Blog Archives', 'twentyten' ); ?><?php endif; ?>			</h1><?php	/* Since we called the_post() above, we need to	 * rewind the loop back to the beginning that way	 * we can run the loop properly, in full.	 */	rewind_posts();	/* Run the loop for the archives page to output the posts.	 * If you want to overload this in a child theme then include a file	 * called loop-archives.php and that will be used instead.	 */	 get_template_part( 'loop', 'archive' );?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
<?php/** * Revisions administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');wp_enqueue_script('list-revisions');wp_reset_vars(array('revision', 'left', 'right', 'action'));$revision_id = absint($revision);$left        = absint($left);$right       = absint($right);$redirect = 'edit.php';switch ( $action ) :case 'restore' :	if ( !$revision = wp_get_post_revision( $revision_id ) )		break;	if ( !current_user_can( 'edit_post', $revision->post_parent ) )		break;	if ( !$post = get_post( $revision->post_parent ) )		break;	// Revisions disabled and we're not looking at an autosave	if ( ( ! WP_POST_REVISIONS || !post_type_supports($post->post_type, 'revisions') ) && !wp_is_post_autosave( $revision ) ) {		$redirect = 'edit.php?post_type=' . $post->post_type;		break;	}	check_admin_referer( "restore-post_$post->ID|$revision->ID" );	wp_restore_post_revision( $revision->ID );	$redirect = add_query_arg( array( 'message' => 5, 'revision' => $revision->ID ), get_edit_post_link( $post->ID, 'url' ) );	break;case 'diff' :	if ( !$left_revision  = get_post( $left ) )		break;	if ( !$right_revision = get_post( $right ) )		break;	if ( !current_user_can( 'read_post', $left_revision->ID ) || !current_user_can( 'read_post', $right_revision->ID ) )		break;	// If we're comparing a revision to itself, redirect to the 'view' page for that revision or the edit page for that post	if ( $left_revision->ID == $right_revision->ID ) {		$redirect = get_edit_post_link( $left_revision->ID );		include( './js/revisions-js.php' );		break;	}	// Don't allow reverse diffs?	if ( strtotime($right_revision->post_modified_gmt) < strtotime($left_revision->post_modified_gmt) ) {		$redirect = add_query_arg( array( 'left' => $right, 'right' => $left ) );		break;	}	if ( $left_revision->ID == $right_revision->post_parent ) // right is a revision of left		$post =& $left_revision;	elseif ( $left_revision->post_parent == $right_revision->ID ) // left is a revision of right		$post =& $right_revision;	elseif ( $left_revision->post_parent == $right_revision->post_parent ) // both are revisions of common parent		$post = get_post( $left_revision->post_parent );	else		break; // Don't diff two unrelated revisions	if ( ! WP_POST_REVISIONS || !post_type_supports($post->post_type, 'revisions') ) { // Revisions disabled		if (			// we're not looking at an autosave			( !wp_is_post_autosave( $left_revision ) && !wp_is_post_autosave( $right_revision ) )		||			// we're not comparing an autosave to the current post			( $post->ID !== $left_revision->ID && $post->ID !== $right_revision->ID )		) {			$redirect = 'edit.php?post_type=' . $post->post_type;			break;		}	}	if (		// They're the same		$left_revision->ID == $right_revision->ID	||		// Neither is a revision		( !wp_get_post_revision( $left_revision->ID ) && !wp_get_post_revision( $right_revision->ID ) )	)		break;	$post_title = '<a href="' . get_edit_post_link() . '">' . get_the_title() . '</a>';	$h2 = sprintf( __( 'Compare Revisions of &#8220;%1$s&#8221;' ), $post_title );	$title = __( 'Revisions' );	$left  = $left_revision->ID;	$right = $right_revision->ID;	$redirect = false;	break;case 'view' :default :	if ( !$revision = wp_get_post_revision( $revision_id ) )		break;	if ( !$post = get_post( $revision->post_parent ) )		break;	if ( !current_user_can( 'read_post', $revision->ID ) || !current_user_can( 'read_post', $post->ID ) )		break;	// Revisions disabled and we're not looking at an autosave	if ( ( ! WP_POST_REVISIONS || !post_type_supports($post->post_type, 'revisions') ) && !wp_is_post_autosave( $revision ) ) {		$redirect = 'edit.php?post_type=' . $post->post_type;		break;	}	$post_title = '<a href="' . get_edit_post_link() . '">' . get_the_title() . '</a>';	$revision_title = wp_post_revision_title( $revision, false );	$h2 = sprintf( __( 'Revision for &#8220;%1$s&#8221; created on %2$s' ), $post_title, $revision_title );	$title = __( 'Revisions' );	// Sets up the diff radio buttons	$left  = $revision->ID;	$right = $post->ID;	$redirect = false;	break;endswitch;// Empty post_type means either malformed object found, or no valid parent was found.if ( !$redirect && empty($post->post_type) )	$redirect = 'edit.php';if ( !empty($redirect) ) {	wp_redirect( $redirect );	exit;}// This is so that the correct "Edit" menu item is selected.if ( !empty($post->post_type) && 'post' != $post->post_type )	$parent_file = $submenu_file = 'edit.php?post_type=' . $post->post_type;else	$parent_file = $submenu_file = 'edit.php';require_once( './admin-header.php' );?><div class="wrap"><h2 class="long-header"><?php echo $h2; ?></h2><table class="form-table ie-fixed">	<col class="th" /><?php if ( 'diff' == $action ) : ?><tr id="revision">	<th scope="row"></th>	<th scope="col" class="th-full">		<span class="alignleft"><?php printf( __('Older: %s'), wp_post_revision_title( $left_revision ) ); ?></span>		<span class="alignright"><?php printf( __('Newer: %s'), wp_post_revision_title( $right_revision ) ); ?></span>	</th></tr><?php endif;// use get_post_to_edit filters?$identical = true;foreach ( _wp_post_revision_fields() as $field => $field_title ) :	if ( 'diff' == $action ) {		$left_content = apply_filters( "_wp_post_revision_field_$field", $left_revision->$field, $field );		$right_content = apply_filters( "_wp_post_revision_field_$field", $right_revision->$field, $field );		if ( !$content = wp_text_diff( $left_content, $right_content ) )			continue; // There is no difference between left and right		$identical = false;	} else {		add_filter( "_wp_post_revision_field_$field", 'htmlspecialchars' );		$content = apply_filters( "_wp_post_revision_field_$field", $revision->$field, $field );	}	?>	<tr id="revision-field-<?php echo $field; ?>">		<th scope="row"><?php echo esc_html( $field_title ); ?></th>		<td><div class="pre"><?php echo $content; ?></div></td>	</tr>	<?phpendforeach;if ( 'diff' == $action && $identical ) :	?>	<tr><td colspan="2"><div class="updated"><p><?php _e( 'These revisions are identical.' ); ?></p></div></td></tr>	<?phpendif;?></table><br class="clear" /><h2><?php echo $title; ?></h2><?php$args = array( 'format' => 'form-table', 'parent' => true, 'right' => $right, 'left' => $left );if ( ! WP_POST_REVISIONS || !post_type_supports($post->post_type, 'revisions') )	$args['type'] = 'autosave';wp_list_post_revisions( $post, $args );?></div><?phprequire_once( './admin-footer.php' );
<?php/** * BackPress script procedural API. * * @package BackPress * @since r16 *//** * Prints script tags in document head. * * Called by admin-header.php and by wp_head hook. Since it is called by wp_head * on every page load, the function does not instantiate the WP_Scripts object * unless script names are explicitly passed. Does make use of already * instantiated $wp_scripts if present. Use provided wp_print_scripts hook to * register/enqueue new scripts. * * @since r16 * @see WP_Dependencies::print_scripts() */function wp_print_scripts( $handles = false ) {	do_action( 'wp_print_scripts' );	if ( '' === $handles ) // for wp_head		$handles = false;	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') ) {		if ( !$handles )			return array(); // No need to instantiate if nothing's there.		else			$wp_scripts = new WP_Scripts();	}	return $wp_scripts->do_items( $handles );}/** * Register new JavaScript file. * * @since r16 * @param string $handle Script name * @param string $src Script url * @param array $deps (optional) Array of script names on which this script depends * @param string|bool $ver (optional) Script version (used for cache busting), set to NULL to disable * @param bool (optional) Wether to enqueue the script before </head> or before </body> * @return null */function wp_register_script( $handle, $src, $deps = array(), $ver = false, $in_footer = false ) {	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') )		$wp_scripts = new WP_Scripts();	$wp_scripts->add( $handle, $src, $deps, $ver );	if ( $in_footer )		$wp_scripts->add_data( $handle, 'group', 1 );}/** * Localizes a script. * * Localizes only if script has already been added. * * @since r16 * @see WP_Scripts::localize() */function wp_localize_script( $handle, $object_name, $l10n ) {	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') )		return false;	return $wp_scripts->localize( $handle, $object_name, $l10n );}/** * Remove a registered script. * * @since r16 * @see WP_Scripts::remove() For parameter information. */function wp_deregister_script( $handle ) {	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') )		$wp_scripts = new WP_Scripts();	$wp_scripts->remove( $handle );}/** * Enqueues script. * * Registers the script if src provided (does NOT overwrite) and enqueues. * * @since r16 * @see wp_register_script() For parameter information. */function wp_enqueue_script( $handle, $src = false, $deps = array(), $ver = false, $in_footer = false ) {	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') )		$wp_scripts = new WP_Scripts();	if ( $src ) {		$_handle = explode('?', $handle);		$wp_scripts->add( $_handle[0], $src, $deps, $ver );		if ( $in_footer )			$wp_scripts->add_data( $_handle[0], 'group', 1 );	}	$wp_scripts->enqueue( $handle );}/** * Check whether script has been added to WordPress Scripts. * * The values for list defaults to 'queue', which is the same as enqueue for * scripts. * * @since WP unknown; BP unknown * * @param string $handle Handle used to add script. * @param string $list Optional, defaults to 'queue'. Others values are 'registered', 'queue', 'done', 'to_do' * @return bool */function wp_script_is( $handle, $list = 'queue' ) {	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') )		$wp_scripts = new WP_Scripts();	$query = $wp_scripts->query( $handle, $list );	if ( is_object( $query ) )		return true;	return $query;}
<?php/** * Comment Management Panel * * @package WordPress * @subpackage Administration *//** Load WordPress Bootstrap */require_once('./admin.php');$parent_file = 'edit-comments.php';$submenu_file = 'edit-comments.php';wp_reset_vars( array('action') );if ( isset( $_POST['deletecomment'] ) )	$action = 'deletecomment';if ( 'cdc' == $action )	$action = 'delete';elseif ( 'mac' == $action )	$action = 'approve';if ( isset( $_GET['dt'] ) ) {	if ( 'spam' == $_GET['dt'] )		$action = 'spam';	elseif ( 'trash' == $_GET['dt'] )		$action = 'trash';}/** * Display error message at bottom of comments. * * @param string $msg Error Message. Assumed to contain HTML and be sanitized. */function comment_footer_die( $msg ) {	echo "<div class='wrap'><p>$msg</p></div>";	include('./admin-footer.php');	die;}switch( $action ) {case 'editcomment' :	$title = __('Edit Comment');	add_contextual_help( $current_screen, '<p>' . __( 'You can edit the information left in a comment if needed. This is often useful when you notice that a commenter has made a typographical error.' ) . '</p>' .	'<p>' . __( 'You can also moderate the comment from this screen using the Status box, where you can also change the timestamp of the comment.' ) . '</p>' .	'<p><strong>' . __( 'For more information:' ) . '</strong></p>' .	'<p>' . __( '<a href="http://codex.wordpress.org/Administration_Panels#Comments" target="_blank">Comments Documentation</a>' ) . '</p>' .	'<p>' . __( '<a href="http://wordpress.org/support/" target="_blank" >Support Forums</a>' ) . '</p>'	);	wp_enqueue_script('comment');	require_once('./admin-header.php');	$comment_id = absint( $_GET['c'] );	if ( !$comment = get_comment( $comment_id ) )		comment_footer_die( __('Oops, no comment with this ID.') . sprintf(' <a href="%s">'.__('Go back').'</a>!', 'javascript:history.go(-1)') );	if ( !current_user_can('edit_post', $comment->comment_post_ID) )		comment_footer_die( __('You are not allowed to edit comments on this post.') );	if ( 'trash' == $comment->comment_approved )		comment_footer_die( __('This comment is in the Trash. Please move it out of the Trash if you want to edit it.') );	$comment = get_comment_to_edit( $comment_id );	include('./edit-form-comment.php');	break;case 'delete'  :case 'approve' :case 'trash'   :case 'spam'    :	$comment_id = absint( $_GET['c'] );	if ( !$comment = get_comment_to_edit( $comment_id ) ) {		wp_redirect( admin_url('edit-comments.php?error=1') );		die();	}	if ( !current_user_can( 'edit_post', $comment->comment_post_ID ) ) {		wp_redirect( admin_url('edit-comments.php?error=2') );		die();	}	// No need to re-approve/re-trash/re-spam a comment.	if ( $action == str_replace( '1', 'approve', $comment->comment_approved ) ) {		wp_redirect( admin_url( 'edit-comments.php?same=' . $comment_id ) );		die(); 	}	require_once('./admin-header.php');	$formaction    = $action . 'comment';	$nonce_action  = 'approve' == $action ? 'approve-comment_' : 'delete-comment_';	$nonce_action .= $comment_id;?><div class='wrap'><div class="narrow"><?php screen_icon(); ?><h2><?php esc_html_e( 'Moderate Comment' ); ?></h2><?phpswitch ( $action ) {	case 'spam' :		$caution_msg = __('You are about to mark the following comment as spam:');		$button      = __('Spam Comment');		break;	case 'trash' :		$caution_msg = __('You are about to move the following comment to the Trash:');		$button      = __('Trash Comment');		break;	case 'delete' :		$caution_msg = __('You are about to delete the following comment:');		$button      = __('Permanently Delete Comment');		break;	default :		$caution_msg = __('You are about to approve the following comment:');		$button      = __('Approve Comment');		break;}if ( $comment->comment_approved != '0' ) { // if not unapproved	$message = '';	switch ( $comment->comment_approved ) {		case '1' :			$message = __('This comment is currently approved.');			break;		case 'spam' :			$message  = __('This comment is currently marked as spam.');			break;		case 'trash' :			$message  = __('This comment is currently in the Trash.');			break;	}	if ( $message )		echo '<div class="updated"><p>' . $message . '</p></div>';}?><p><strong><?php _e('Caution:'); ?></strong> <?php echo $caution_msg; ?></p><table class="form-table comment-ays"><tr class="alt"><th scope="row"><?php _e('Author'); ?></th><td><?php echo $comment->comment_author; ?></td></tr><?php if ( $comment->comment_author_email ) { ?><tr><th scope="row"><?php _e('E-mail'); ?></th><td><?php echo $comment->comment_author_email; ?></td></tr><?php } ?><?php if ( $comment->comment_author_url ) { ?><tr><th scope="row"><?php _e('URL'); ?></th><td><a href="<?php echo $comment->comment_author_url; ?>"><?php echo $comment->comment_author_url; ?></a></td></tr><?php } ?><tr><th scope="row" valign="top"><?php /* translators: field name in comment form */ _ex('Comment', 'noun'); ?></th><td><?php echo $comment->comment_content; ?></td></tr></table><p><?php _e('Are you sure you want to do this?'); ?></p><form action='comment.php' method='get'><table width="100%"><tr><td><a class="button" href="<?php echo admin_url('edit-comments.php'); ?>"><?php esc_attr_e('No'); ?></a></td><td class="textright"><input type='submit' class="button" value='<?php echo esc_attr($button); ?>' /></td></tr></table><?php wp_nonce_field( $nonce_action ); ?><input type='hidden' name='action' value='<?php echo esc_attr($formaction); ?>' /><input type='hidden' name='p' value='<?php echo esc_attr($comment->comment_post_ID); ?>' /><input type='hidden' name='c' value='<?php echo esc_attr($comment->comment_ID); ?>' /><input type='hidden' name='noredir' value='1' /></form></div></div><?php	break;case 'deletecomment'    :case 'trashcomment'     :case 'untrashcomment'   :case 'spamcomment'      :case 'unspamcomment'    :case 'approvecomment'   :case 'unapprovecomment' :	$comment_id = absint( $_REQUEST['c'] );	if ( in_array( $action, array( 'approvecomment', 'unapprovecomment' ) ) )		check_admin_referer( 'approve-comment_' . $comment_id );	else		check_admin_referer( 'delete-comment_' . $comment_id );	$noredir = isset($_REQUEST['noredir']);	if ( !$comment = get_comment($comment_id) )		comment_footer_die( __('Oops, no comment with this ID.') . sprintf(' <a href="%s">'.__('Go back').'</a>!', 'edit-comments.php') );	if ( !current_user_can('edit_post', $comment->comment_post_ID ) )		comment_footer_die( __('You are not allowed to edit comments on this post.') );	if ( '' != wp_get_referer() && ! $noredir && false === strpos(wp_get_referer(), 'comment.php') )		$redir = wp_get_referer();	elseif ( '' != wp_get_original_referer() && ! $noredir )		$redir = wp_get_original_referer();	elseif ( in_array( $action, array( 'approvecomment', 'unapprovecomment' ) ) )		$redir = admin_url('edit-comments.php?p=' . absint( $comment->comment_post_ID ) );	else		$redir = admin_url('edit-comments.php');	$redir = remove_query_arg( array('spammed', 'unspammed', 'trashed', 'untrashed', 'deleted', 'ids', 'approved', 'unapproved'), $redir );	switch ( $action ) {		case 'deletecomment' :			wp_delete_comment( $comment_id );			$redir = add_query_arg( array('deleted' => '1'), $redir );			break;		case 'trashcomment' :			wp_trash_comment($comment_id);			$redir = add_query_arg( array('trashed' => '1', 'ids' => $comment_id), $redir );			break;		case 'untrashcomment' :			wp_untrash_comment($comment_id);			$redir = add_query_arg( array('untrashed' => '1'), $redir );			break;		case 'spamcomment' :			wp_spam_comment($comment_id);			$redir = add_query_arg( array('spammed' => '1', 'ids' => $comment_id), $redir );			break;		case 'unspamcomment' :			wp_unspam_comment($comment_id);			$redir = add_query_arg( array('unspammed' => '1'), $redir );			break;		case 'approvecomment' :			wp_set_comment_status( $comment_id, 'approve' );			$redir = add_query_arg( array( 'approved' => 1 ), $redir );			break;		case 'unapprovecomment' :			wp_set_comment_status( $comment_id, 'hold' );			$redir = add_query_arg( array( 'unapproved' => 1 ), $redir );			break;	}	wp_redirect( $redir );	die;	break;case 'editedcomment' :	$comment_id = absint( $_POST['comment_ID'] );	$comment_post_id = absint( $_POST['comment_post_ID'] );	check_admin_referer( 'update-comment_' . $comment_id );	edit_comment();	$location = ( empty( $_POST['referredby'] ) ? "edit-comments.php?p=$comment_post_id" : $_POST['referredby'] ) . '#comment-' . $comment_id;	$location = apply_filters( 'comment_edit_redirect', $location, $comment_id );	wp_redirect( $location );	exit();	break;default:	wp_die( __('Unknown action.') );	break;} // end switchinclude('./admin-footer.php');?>
<?php/** * WordPress core upgrade functionality. * * @package WordPress * @subpackage Administration * @since 2.7.0 *//** * Stores files to be deleted. * * @since 2.7.0 * @global array $_old_files * @var array * @name $_old_files */global $_old_files;$_old_files = array('wp-admin/bookmarklet.php','wp-admin/css/upload.css','wp-admin/css/upload-rtl.css','wp-admin/css/press-this-ie.css','wp-admin/css/press-this-ie-rtl.css','wp-admin/edit-form.php','wp-admin/link-import.php','wp-admin/images/box-bg-left.gif','wp-admin/images/box-bg-right.gif','wp-admin/images/box-bg.gif','wp-admin/images/box-butt-left.gif','wp-admin/images/box-butt-right.gif','wp-admin/images/box-butt.gif','wp-admin/images/box-head-left.gif','wp-admin/images/box-head-right.gif','wp-admin/images/box-head.gif','wp-admin/images/heading-bg.gif','wp-admin/images/login-bkg-bottom.gif','wp-admin/images/login-bkg-tile.gif','wp-admin/images/notice.gif','wp-admin/images/toggle.gif','wp-admin/images/comment-stalk-classic.gif','wp-admin/images/comment-stalk-fresh.gif','wp-admin/images/comment-stalk-rtl.gif','wp-admin/images/comment-pill.gif','wp-admin/images/del.png','wp-admin/images/media-button-gallery.gif','wp-admin/images/media-buttons.gif','wp-admin/images/tail.gif','wp-admin/images/gear.png','wp-admin/images/tab.png','wp-admin/images/postbox-bg.gif','wp-admin/includes/upload.php','wp-admin/js/dbx-admin-key.js','wp-admin/js/link-cat.js','wp-admin/js/forms.js','wp-admin/js/upload.js','wp-admin/js/set-post-thumbnail-handler.js','wp-admin/js/set-post-thumbnail-handler.dev.js','wp-admin/js/page.js','wp-admin/js/page.dev.js','wp-admin/js/slug.js','wp-admin/js/slug.dev.js','wp-admin/profile-update.php','wp-admin/templates.php','wp-includes/images/audio.png','wp-includes/images/css.png','wp-includes/images/default.png','wp-includes/images/doc.png','wp-includes/images/exe.png','wp-includes/images/html.png','wp-includes/images/js.png','wp-includes/images/pdf.png','wp-includes/images/swf.png','wp-includes/images/tar.png','wp-includes/images/text.png','wp-includes/images/video.png','wp-includes/images/zip.png','wp-includes/js/dbx.js','wp-includes/js/fat.js','wp-includes/js/list-manipulation.js','wp-includes/js/jquery/jquery.dimensions.min.js','wp-includes/js/tinymce/langs/en.js','wp-includes/js/tinymce/plugins/autosave/editor_plugin_src.js','wp-includes/js/tinymce/plugins/autosave/langs','wp-includes/js/tinymce/plugins/directionality/images','wp-includes/js/tinymce/plugins/directionality/langs','wp-includes/js/tinymce/plugins/inlinepopups/css','wp-includes/js/tinymce/plugins/inlinepopups/images','wp-includes/js/tinymce/plugins/inlinepopups/jscripts','wp-includes/js/tinymce/plugins/paste/images','wp-includes/js/tinymce/plugins/paste/jscripts','wp-includes/js/tinymce/plugins/paste/langs','wp-includes/js/tinymce/plugins/spellchecker/classes/HttpClient.class.php','wp-includes/js/tinymce/plugins/spellchecker/classes/TinyGoogleSpell.class.php','wp-includes/js/tinymce/plugins/spellchecker/classes/TinyPspell.class.php','wp-includes/js/tinymce/plugins/spellchecker/classes/TinyPspellShell.class.php','wp-includes/js/tinymce/plugins/spellchecker/css/spellchecker.css','wp-includes/js/tinymce/plugins/spellchecker/images','wp-includes/js/tinymce/plugins/spellchecker/langs','wp-includes/js/tinymce/plugins/spellchecker/tinyspell.php','wp-includes/js/tinymce/plugins/wordpress/images','wp-includes/js/tinymce/plugins/wordpress/langs','wp-includes/js/tinymce/plugins/wordpress/popups.css','wp-includes/js/tinymce/plugins/wordpress/wordpress.css','wp-includes/js/tinymce/plugins/wphelp','wp-includes/js/tinymce/themes/advanced/css','wp-includes/js/tinymce/themes/advanced/images','wp-includes/js/tinymce/themes/advanced/jscripts','wp-includes/js/tinymce/themes/advanced/langs','wp-includes/js/tinymce/tiny_mce_gzip.php','wp-includes/js/wp-ajax.js','wp-admin/admin-db.php','wp-admin/cat.js','wp-admin/categories.js','wp-admin/custom-fields.js','wp-admin/dbx-admin-key.js','wp-admin/edit-comments.js','wp-admin/install-rtl.css','wp-admin/install.css','wp-admin/upgrade-schema.php','wp-admin/upload-functions.php','wp-admin/upload-rtl.css','wp-admin/upload.css','wp-admin/upload.js','wp-admin/users.js','wp-admin/widgets-rtl.css','wp-admin/widgets.css','wp-admin/xfn.js','wp-includes/js/tinymce/license.html','wp-admin/cat-js.php','wp-admin/edit-form-ajax-cat.php','wp-admin/execute-pings.php','wp-admin/import/b2.php','wp-admin/import/btt.php','wp-admin/import/jkw.php','wp-admin/inline-uploading.php','wp-admin/link-categories.php','wp-admin/list-manipulation.js','wp-admin/list-manipulation.php','wp-includes/comment-functions.php','wp-includes/feed-functions.php','wp-includes/functions-compat.php','wp-includes/functions-formatting.php','wp-includes/functions-post.php','wp-includes/js/dbx-key.js','wp-includes/js/tinymce/plugins/autosave/langs/cs.js','wp-includes/js/tinymce/plugins/autosave/langs/sv.js','wp-includes/js/tinymce/themes/advanced/editor_template_src.js','wp-includes/links.php','wp-includes/pluggable-functions.php','wp-includes/template-functions-author.php','wp-includes/template-functions-category.php','wp-includes/template-functions-general.php','wp-includes/template-functions-links.php','wp-includes/template-functions-post.php','wp-includes/wp-l10n.php','wp-admin/import-b2.php','wp-admin/import-blogger.php','wp-admin/import-greymatter.php','wp-admin/import-livejournal.php','wp-admin/import-mt.php','wp-admin/import-rss.php','wp-admin/import-textpattern.php','wp-admin/quicktags.js','wp-images/fade-butt.png','wp-images/get-firefox.png','wp-images/header-shadow.png','wp-images/smilies','wp-images/wp-small.png','wp-images/wpminilogo.png','wp.php','wp-includes/gettext.php','wp-includes/streams.php',// MU'wp-admin/wpmu-admin.php','wp-admin/wpmu-blogs.php','wp-admin/wpmu-edit.php','wp-admin/wpmu-options.php','wp-admin/wpmu-themes.php','wp-admin/wpmu-upgrade-site.php','wp-admin/wpmu-users.php','wp-includes/wpmu-default-filters.php','wp-includes/wpmu-functions.php','wpmu-settings.php','index-install.php','README.txt','htaccess.dist','wp-admin/css/mu-rtl.css','wp-admin/css/mu.css','wp-admin/images/site-admin.png','wp-admin/includes/mu.php','wp-includes/images/wordpress-mu.png',// 3.0'wp-admin/categories.php','wp-admin/edit-category-form.php','wp-admin/edit-page-form.php','wp-admin/edit-pages.php','wp-admin/images/wp-logo.gif','wp-admin/js/wp-gears.dev.js','wp-admin/js/wp-gears.js','wp-admin/options-misc.php','wp-admin/page-new.php','wp-admin/page.php','wp-admin/rtl.css','wp-admin/rtl.dev.css','wp-admin/update-links.php','wp-admin/wp-admin.css','wp-admin/wp-admin.dev.css','wp-includes/js/codepress','wp-includes/js/jquery/autocomplete.dev.js','wp-includes/js/jquery/interface.js','wp-includes/js/jquery/autocomplete.js','wp-includes/js/scriptaculous/prototype.js','wp-includes/js/tinymce/wp-tinymce.js','wp-content/themes/twentyten/searchform.php','wp-admin/import','wp-admin/images/ico-edit.png','wp-admin/images/fav-top.png','wp-admin/images/ico-close.png','wp-admin/images/admin-header-footer.png','wp-admin/images/screen-options-left.gif','wp-admin/images/ico-add.png','wp-admin/images/browse-happy.gif','wp-admin/images/ico-viewpage.png',);/** * Upgrade the core of WordPress. * * This will create a .maintenance file at the base of the WordPress directory * to ensure that people can not access the web site, when the files are being * copied to their locations. * * The files in the {@link $_old_files} list will be removed and the new files * copied from the zip file after the database is upgraded. * * The steps for the upgrader for after the new release is downloaded and * unzipped is: *   1. Test unzipped location for select files to ensure that unzipped worked. *   2. Create the .maintenance file in current WordPress base. *   3. Copy new WordPress directory over old WordPress files. *   4. Upgrade WordPress to new version. *   5. Delete new WordPress directory path. *   6. Delete .maintenance file. *   7. Remove old files. *   8. Delete 'update_core' option. * * There are several areas of failure. For instance if PHP times out before step * 6, then you will not be able to access any portion of your site. Also, since * the upgrade will not continue where it left off, you will not be able to * automatically remove old files and remove the 'update_core' option. This * isn't that bad. * * If the copy of the new WordPress over the old fails, then the worse is that * the new WordPress directory will remain. * * If it is assumed that every file will be copied over, including plugins and * themes, then if you edit the default theme, you should rename it, so that * your changes remain. * * @since 2.7.0 * * @param string $from New release unzipped path. * @param string $to Path to old WordPress installation. * @return WP_Error|null WP_Error on failure, null on success. */function update_core($from, $to) {	global $wp_filesystem, $_old_files, $wpdb;	@set_time_limit( 300 );	$php_version    = phpversion();	$mysql_version  = $wpdb->db_version();	$required_php_version = '4.3';	$required_mysql_version = '4.1.2';	$wp_version = '3.0';	$php_compat     = version_compare( $php_version, $required_php_version, '>=' );	$mysql_compat   = version_compare( $mysql_version, $required_mysql_version, '>=' ) || file_exists( WP_CONTENT_DIR . '/db.php' );	if ( !$mysql_compat || !$php_compat )		$wp_filesystem->delete($from, true);	if ( !$mysql_compat && !$php_compat )		return new WP_Error( 'php_mysql_not_compatible', sprintf( __('The update cannot be installed because WordPress %1$s requires PHP version %2$s or higher and MySQL version %3$s or higher. You are running PHP version %4$s and MySQL version %5$s.'), $wp_version, $required_php_version, $required_mysql_version, $php_version, $mysql_version ) );	elseif ( !$php_compat )		return new WP_Error( 'php_not_compatible', sprintf( __('The update cannot be installed because WordPress %1$s requires PHP version %2$s or higher. You are running version %3$s.'), $wp_version, $required_php_version, $php_version ) );	elseif ( !$mysql_compat )		return new WP_Error( 'mysql_not_compatible', sprintf( __('The update cannot be installed because WordPress %1$s requires MySQL version %2$s or higher. You are running version %3$s.'), $wp_version, $required_mysql_version, $mysql_version ) );	// Sanity check the unzipped distribution	apply_filters('update_feedback', __('Verifying the unpacked files&#8230;'));	$distro = '';	$roots = array( '/wordpress', '/wordpress-mu' );	foreach( $roots as $root ) {		if ( $wp_filesystem->exists($from . $root . '/wp-settings.php') && $wp_filesystem->exists($from . $root . '/wp-admin/admin.php') &&			$wp_filesystem->exists($from . $root . '/wp-includes/functions.php') ) {			$distro = $root;			break;		}	}	if ( !$distro ) {		$wp_filesystem->delete($from, true);		return new WP_Error('insane_distro', __('The update could not be unpacked') );	}	apply_filters('update_feedback', __('Installing the latest version&#8230;'));	// Create maintenance file to signal that we are upgrading	$maintenance_string = '<?php $upgrading = ' . time() . '; ?>';	$maintenance_file = $to . '.maintenance';	$wp_filesystem->delete($maintenance_file);	$wp_filesystem->put_contents($maintenance_file, $maintenance_string, FS_CHMOD_FILE);	// Copy new versions of WP files into place.	$result = copy_dir($from . $distro, $to);	if ( is_wp_error($result) ) {		$wp_filesystem->delete($maintenance_file);		$wp_filesystem->delete($from, true);		return $result;	}	// Remove old files	foreach ( $_old_files as $old_file ) {		$old_file = $to . $old_file;		if ( !$wp_filesystem->exists($old_file) )			continue;		$wp_filesystem->delete($old_file, true);	}	// Upgrade DB with separate request	apply_filters('update_feedback', __('Upgrading database&#8230;'));	$db_upgrade_url = admin_url('upgrade.php?step=upgrade_db');	wp_remote_post($db_upgrade_url, array('timeout' => 60));	// Remove working directory	$wp_filesystem->delete($from, true);	// Force refresh of update information	if ( function_exists('delete_site_transient') )		delete_site_transient('update_core');	else		delete_option('update_core');	// Remove maintenance file, we're done.	$wp_filesystem->delete($maintenance_file);}?>
<?php/** * Atom Syndication Format PHP Library * * @package AtomLib * @link http://code.google.com/p/phpatomlib/ * * @author Elias Torres <elias@torrez.us> * @version 0.4 * @since 2.3 *//** * Structure that store common Atom Feed Properties * * @package AtomLib */class AtomFeed {	/**	 * Stores Links	 * @var array	 * @access public	 */    var $links = array();    /**     * Stores Categories     * @var array     * @access public     */    var $categories = array();	/**	 * Stores Entries	 *	 * @var array	 * @access public	 */    var $entries = array();}/** * Structure that store Atom Entry Properties * * @package AtomLib */class AtomEntry {	/**	 * Stores Links	 * @var array	 * @access public	 */    var $links = array();    /**     * Stores Categories     * @var array	 * @access public     */    var $categories = array();}/** * AtomLib Atom Parser API * * @package AtomLib */class AtomParser {    var $NS = 'http://www.w3.org/2005/Atom';    var $ATOM_CONTENT_ELEMENTS = array('content','summary','title','subtitle','rights');    var $ATOM_SIMPLE_ELEMENTS = array('id','updated','published','draft');    var $debug = false;    var $depth = 0;    var $indent = 2;    var $in_content;    var $ns_contexts = array();    var $ns_decls = array();    var $content_ns_decls = array();    var $content_ns_contexts = array();    var $is_xhtml = false;    var $is_html = false;    var $is_text = true;    var $skipped_div = false;    var $FILE = "php://input";    var $feed;    var $current;    function AtomParser() {        $this->feed = new AtomFeed();        $this->current = null;        $this->map_attrs_func = create_function('$k,$v', 'return "$k=\"$v\"";');        $this->map_xmlns_func = create_function('$p,$n', '$xd = "xmlns"; if(strlen($n[0])>0) $xd .= ":{$n[0]}"; return "{$xd}=\"{$n[1]}\"";');    }    function _p($msg) {        if($this->debug) {            print str_repeat(" ", $this->depth * $this->indent) . $msg ."\n";        }    }    function error_handler($log_level, $log_text, $error_file, $error_line) {        $this->error = $log_text;    }    function parse() {        set_error_handler(array(&$this, 'error_handler'));        array_unshift($this->ns_contexts, array());        $parser = xml_parser_create_ns();        xml_set_object($parser, $this);        xml_set_element_handler($parser, "start_element", "end_element");        xml_parser_set_option($parser,XML_OPTION_CASE_FOLDING,0);        xml_parser_set_option($parser,XML_OPTION_SKIP_WHITE,0);        xml_set_character_data_handler($parser, "cdata");        xml_set_default_handler($parser, "_default");        xml_set_start_namespace_decl_handler($parser, "start_ns");        xml_set_end_namespace_decl_handler($parser, "end_ns");        $this->content = '';        $ret = true;        $fp = fopen($this->FILE, "r");        while ($data = fread($fp, 4096)) {            if($this->debug) $this->content .= $data;            if(!xml_parse($parser, $data, feof($fp))) {                trigger_error(sprintf(__('XML error: %s at line %d')."\n",                    xml_error_string(xml_get_error_code($xml_parser)),                    xml_get_current_line_number($xml_parser)));                $ret = false;                break;            }        }        fclose($fp);        xml_parser_free($parser);        restore_error_handler();        return $ret;    }    function start_element($parser, $name, $attrs) {        $tag = array_pop(split(":", $name));        switch($name) {            case $this->NS . ':feed':                $this->current = $this->feed;                break;            case $this->NS . ':entry':                $this->current = new AtomEntry();                break;        };        $this->_p("start_element('$name')");        #$this->_p(print_r($this->ns_contexts,true));        #$this->_p('current(' . $this->current . ')');        array_unshift($this->ns_contexts, $this->ns_decls);        $this->depth++;        if(!empty($this->in_content)) {            $this->content_ns_decls = array();            if($this->is_html || $this->is_text)                trigger_error("Invalid content in element found. Content must not be of type text or html if it contains markup.");            $attrs_prefix = array();            // resolve prefixes for attributes            foreach($attrs as $key => $value) {                $with_prefix = $this->ns_to_prefix($key, true);                $attrs_prefix[$with_prefix[1]] = $this->xml_escape($value);            }            $attrs_str = join(' ', array_map($this->map_attrs_func, array_keys($attrs_prefix), array_values($attrs_prefix)));            if(strlen($attrs_str) > 0) {                $attrs_str = " " . $attrs_str;            }            $with_prefix = $this->ns_to_prefix($name);            if(!$this->is_declared_content_ns($with_prefix[0])) {                array_push($this->content_ns_decls, $with_prefix[0]);            }            $xmlns_str = '';            if(count($this->content_ns_decls) > 0) {                array_unshift($this->content_ns_contexts, $this->content_ns_decls);                $xmlns_str .= join(' ', array_map($this->map_xmlns_func, array_keys($this->content_ns_contexts[0]), array_values($this->content_ns_contexts[0])));                if(strlen($xmlns_str) > 0) {                    $xmlns_str = " " . $xmlns_str;                }            }            array_push($this->in_content, array($tag, $this->depth, "<". $with_prefix[1] ."{$xmlns_str}{$attrs_str}" . ">"));        } else if(in_array($tag, $this->ATOM_CONTENT_ELEMENTS) || in_array($tag, $this->ATOM_SIMPLE_ELEMENTS)) {            $this->in_content = array();            $this->is_xhtml = $attrs['type'] == 'xhtml';            $this->is_html = $attrs['type'] == 'html' || $attrs['type'] == 'text/html';            $this->is_text = !in_array('type',array_keys($attrs)) || $attrs['type'] == 'text';            $type = $this->is_xhtml ? 'XHTML' : ($this->is_html ? 'HTML' : ($this->is_text ? 'TEXT' : $attrs['type']));            if(in_array('src',array_keys($attrs))) {                $this->current->$tag = $attrs;            } else {                array_push($this->in_content, array($tag,$this->depth, $type));            }        } else if($tag == 'link') {            array_push($this->current->links, $attrs);        } else if($tag == 'category') {            array_push($this->current->categories, $attrs);        }        $this->ns_decls = array();    }    function end_element($parser, $name) {        $tag = array_pop(split(":", $name));        $ccount = count($this->in_content);        # if we are *in* content, then let's proceed to serialize it        if(!empty($this->in_content)) {            # if we are ending the original content element            # then let's finalize the content            if($this->in_content[0][0] == $tag &&                $this->in_content[0][1] == $this->depth) {                $origtype = $this->in_content[0][2];                array_shift($this->in_content);                $newcontent = array();                foreach($this->in_content as $c) {                    if(count($c) == 3) {                        array_push($newcontent, $c[2]);                    } else {                        if($this->is_xhtml || $this->is_text) {                            array_push($newcontent, $this->xml_escape($c));                        } else {                            array_push($newcontent, $c);                        }                    }                }                if(in_array($tag, $this->ATOM_CONTENT_ELEMENTS)) {                    $this->current->$tag = array($origtype, join('',$newcontent));                } else {                    $this->current->$tag = join('',$newcontent);                }                $this->in_content = array();            } else if($this->in_content[$ccount-1][0] == $tag &&                $this->in_content[$ccount-1][1] == $this->depth) {                $this->in_content[$ccount-1][2] = substr($this->in_content[$ccount-1][2],0,-1) . "/>";            } else {                # else, just finalize the current element's content                $endtag = $this->ns_to_prefix($name);                array_push($this->in_content, array($tag, $this->depth, "</$endtag[1]>"));            }        }        array_shift($this->ns_contexts);        $this->depth--;        if($name == ($this->NS . ':entry')) {            array_push($this->feed->entries, $this->current);            $this->current = null;        }        $this->_p("end_element('$name')");    }    function start_ns($parser, $prefix, $uri) {        $this->_p("starting: " . $prefix . ":" . $uri);        array_push($this->ns_decls, array($prefix,$uri));    }    function end_ns($parser, $prefix) {        $this->_p("ending: #" . $prefix . "#");    }    function cdata($parser, $data) {        $this->_p("data: #" . str_replace(array("\n"), array("\\n"), trim($data)) . "#");        if(!empty($this->in_content)) {            array_push($this->in_content, $data);        }    }    function _default($parser, $data) {        # when does this gets called?    }    function ns_to_prefix($qname, $attr=false) {        # split 'http://www.w3.org/1999/xhtml:div' into ('http','//www.w3.org/1999/xhtml','div')        $components = split(":", $qname);        # grab the last one (e.g 'div')        $name = array_pop($components);        if(!empty($components)) {            # re-join back the namespace component            $ns = join(":",$components);            foreach($this->ns_contexts as $context) {                foreach($context as $mapping) {                    if($mapping[1] == $ns && strlen($mapping[0]) > 0) {                        return array($mapping, "$mapping[0]:$name");                    }                }            }        }        if($attr) {            return array(null, $name);        } else {            foreach($this->ns_contexts as $context) {                foreach($context as $mapping) {                    if(strlen($mapping[0]) == 0) {                        return array($mapping, $name);                    }                }            }        }    }    function is_declared_content_ns($new_mapping) {        foreach($this->content_ns_contexts as $context) {            foreach($context as $mapping) {                if($new_mapping == $mapping) {                    return true;                }            }        }        return false;    }    function xml_escape($string)    {             return str_replace(array('&','"',"'",'<','>'),                array('&amp;','&quot;','&apos;','&lt;','&gt;'),                $string );    }}?>
<?php/** * Edit attachments table for inclusion in administration panels. * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');if ( have_posts() ) { ?><table class="widefat fixed" cellspacing="0">	<thead>	<tr><?php print_column_headers('upload'); ?>	</tr>	</thead>	<tfoot>	<tr><?php print_column_headers('upload', false); ?>	</tr>	</tfoot>	<tbody id="the-list" class="list:post"><?phpadd_filter('the_title','esc_html');$alt = '';$posts_columns = get_column_headers('upload');$hidden = get_hidden_columns('upload');while ( have_posts() ) : the_post();if ( $is_trash && $post->post_status != 'trash' )	continue;elseif ( !$is_trash && $post->post_status == 'trash' )	continue;$alt = ( 'alternate' == $alt ) ? '' : 'alternate';global $current_user;$post_owner = ( $current_user->ID == $post->post_author ? 'self' : 'other' );$att_title = _draft_or_post_title();?>	<tr id='post-<?php echo $id; ?>' class='<?php echo trim( $alt . ' author-' . $post_owner . ' status-' . $post->post_status ); ?>' valign="top"><?phpforeach ($posts_columns as $column_name => $column_display_name ) {	$class = "class=\"$column_name column-$column_name\"";	$style = '';	if ( in_array($column_name, $hidden) )		$style = ' style="display:none;"';	$attributes = "$class$style";	switch($column_name) {	case 'cb':		?>		<th scope="row" class="check-column"><?php if ( current_user_can('edit_post', $post->ID) ) { ?><input type="checkbox" name="media[]" value="<?php the_ID(); ?>" /><?php } ?></th>		<?php		break;	case 'icon':		$attributes = 'class="column-icon media-icon"' . $style;		?>		<td <?php echo $attributes ?>><?php			if ( $thumb = wp_get_attachment_image( $post->ID, array(80, 60), true ) ) {				if ( $is_trash ) echo $thumb;				else {?>				<a href="<?php echo get_edit_post_link( $post->ID, true ); ?>" title="<?php echo esc_attr(sprintf(__('Edit &#8220;%s&#8221;'), $att_title)); ?>">					<?php echo $thumb; ?>				</a><?php			}			}		?></td>		<?php		// TODO		break;	case 'media':		?>		<td <?php echo $attributes ?>><strong><?php if ( $is_trash ) echo $att_title; else { ?><a href="<?php echo get_edit_post_link( $post->ID, true ); ?>" title="<?php echo esc_attr(sprintf(__('Edit &#8220;%s&#8221;'), $att_title)); ?>"><?php echo $att_title; ?></a><?php } ?></strong>		<p>		<?php		if ( preg_match( '/^.*?\.(\w+)$/', get_attached_file( $post->ID ), $matches ) )			echo esc_html( strtoupper( $matches[1] ) );		else			echo strtoupper( str_replace( 'image/', '', get_post_mime_type() ) );		?>		</p>		<?php		$actions = array();		if ( current_user_can('edit_post', $post->ID) && !$is_trash )			$actions['edit'] = '<a href="' . get_edit_post_link($post->ID, true) . '">' . __('Edit') . '</a>';		if ( current_user_can('delete_post', $post->ID) ) {			if ( $is_trash )				$actions['untrash'] = "<a class='submitdelete' href='" . wp_nonce_url("post.php?action=untrash&amp;post=$post->ID", 'untrash-attachment_' . $post->ID) . "'>" . __('Restore') . "</a>";			elseif ( EMPTY_TRASH_DAYS && MEDIA_TRASH )				$actions['trash'] = "<a class='submitdelete' href='" . wp_nonce_url("post.php?action=trash&amp;post=$post->ID", 'trash-attachment_' . $post->ID) . "'>" . __('Trash') . "</a>";			if ( $is_trash || !EMPTY_TRASH_DAYS || !MEDIA_TRASH ) {				$delete_ays = (!$is_trash && !MEDIA_TRASH) ? " onclick='return showNotice.warn();'" : '';				$actions['delete'] = "<a class='submitdelete'$delete_ays href='" . wp_nonce_url("post.php?action=delete&amp;post=$post->ID", 'delete-attachment_' . $post->ID) . "'>" . __('Delete Permanently') . "</a>";			}		}		if ( !$is_trash ) {			$title =_draft_or_post_title($post->post_parent);			$actions['view'] = '<a href="' . get_permalink($post->ID) . '" title="' . esc_attr(sprintf(__('View &#8220;%s&#8221;'), $title)) . '" rel="permalink">' . __('View') . '</a>';		}		$actions = apply_filters( 'media_row_actions', $actions, $post );		$action_count = count($actions);		$i = 0;		echo '<div class="row-actions">';		foreach ( $actions as $action => $link ) {			++$i;			( $i == $action_count ) ? $sep = '' : $sep = ' | ';			echo "<span class='$action'>$link$sep</span>";		}		echo '</div>';		?></td>		<?php		break;	case 'author':		?>		<td <?php echo $attributes ?>><?php the_author() ?></td>		<?php		break;	case 'tags':		?>		<td <?php echo $attributes ?>><?php		$tags = get_the_tags();		if ( !empty( $tags ) ) {			$out = array();			foreach ( $tags as $c )				$out[] = "<a href='edit.php?tag=$c->slug'> " . esc_html(sanitize_term_field('name', $c->name, $c->term_id, 'post_tag', 'display')) . "</a>";			echo join( ', ', $out );		} else {			_e('No Tags');		}		?></td>		<?php		break;	case 'desc':		?>		<td <?php echo $attributes ?>><?php echo has_excerpt() ? $post->post_excerpt : ''; ?></td>		<?php		break;	case 'date':		if ( '0000-00-00 00:00:00' == $post->post_date && 'date' == $column_name ) {			$t_time = $h_time = __('Unpublished');		} else {			$t_time = get_the_time(__('Y/m/d g:i:s A'));			$m_time = $post->post_date;			$time = get_post_time( 'G', true, $post, false );			if ( ( abs($t_diff = time() - $time) ) < 86400 ) {				if ( $t_diff < 0 )					$h_time = sprintf( __('%s from now'), human_time_diff( $time ) );				else					$h_time = sprintf( __('%s ago'), human_time_diff( $time ) );			} else {				$h_time = mysql2date(__('Y/m/d'), $m_time);			}		}		?>		<td <?php echo $attributes ?>><?php echo $h_time ?></td>		<?php		break;	case 'parent':		if ( $post->post_parent > 0 ) {			if ( get_post($post->post_parent) ) {				$title =_draft_or_post_title($post->post_parent);			}			?>			<td <?php echo $attributes ?>><strong><a href="<?php echo get_edit_post_link( $post->post_parent ); ?>"><?php echo $title ?></a></strong>, <?php echo get_the_time(__('Y/m/d')); ?></td>			<?php		} else {			?>			<td <?php echo $attributes ?>><?php _e('(Unattached)'); ?><br />			<a class="hide-if-no-js" onclick="findPosts.open('media[]','<?php echo $post->ID ?>');return false;" href="#the-list"><?php _e('Attach'); ?></a></td>			<?php		}		break;	case 'comments':		$attributes = 'class="comments column-comments num"' . $style;		?>		<td <?php echo $attributes ?>><div class="post-com-count-wrapper">		<?php		$left = get_pending_comments_num( $post->ID );		$pending_phrase = sprintf( __('%s pending'), number_format( $left ) );		if ( $left )			echo '<strong>';		comments_number("<a href='edit-comments.php?p=$id' title='$pending_phrase' class='post-com-count'><span class='comment-count'>" . /* translators: comment count link */ _x('0', 'comment count') . '</span></a>', "<a href='edit-comments.php?p=$id' title='$pending_phrase' class='post-com-count'><span class='comment-count'>" . /* translators: comment count link */ _x('1', 'comment count') . '</span></a>', "<a href='edit-comments.php?p=$id' title='$pending_phrase' class='post-com-count'><span class='comment-count'>" . /* translators: comment count link: % will be substituted by comment count */ _x('%', 'comment count') . '</span></a>');		if ( $left )			echo '</strong>';		?>		</div></td>		<?php		break;	case 'actions':		?>		<td <?php echo $attributes ?>>		<a href="media.php?action=edit&amp;attachment_id=<?php the_ID(); ?>" title="<?php echo esc_attr(sprintf(__('Edit &#8220;%s&#8221;'), $att_title)); ?>"><?php _e('Edit'); ?></a> |		<a href="<?php the_permalink(); ?>"><?php _e('Get permalink'); ?></a>		</td>		<?php		break;	default:		?>		<td <?php echo $attributes ?>><?php do_action('manage_media_custom_column', $column_name, $id); ?></td>		<?php		break;	}}?>	</tr><?php endwhile; ?>	</tbody></table><?php } else { ?><p><?php _e('No media attachments found.') ?></p><?php} // end if ( have_posts() )?>
<?phpif ( !class_exists('SimplePie') )	require_once (ABSPATH . WPINC . '/class-simplepie.php');class WP_Feed_Cache extends SimplePie_Cache {	/**	 * Don't call the constructor. Please.	 *	 * @access private	 */	function WP_Feed_Cache() {		trigger_error('Please call SimplePie_Cache::create() instead of the constructor', E_USER_ERROR);	}	/**	 * Create a new SimplePie_Cache object	 *	 * @static	 * @access public	 */	function create($location, $filename, $extension) {		return new WP_Feed_Cache_Transient($location, $filename, $extension);	}}class WP_Feed_Cache_Transient {	var $name;	var $mod_name;	var $lifetime = 43200; //Default lifetime in cache of 12 hours	function WP_Feed_Cache_Transient($location, $filename, $extension) {		$this->name = 'feed_' . $filename;		$this->mod_name = 'feed_mod_' . $filename;		$this->lifetime = apply_filters('wp_feed_cache_transient_lifetime', $this->lifetime, $filename);	}	function save($data) {		if ( is_a($data, 'SimplePie') )			$data = $data->data;		set_transient($this->name, $data, $this->lifetime);		set_transient($this->mod_name, time(), $this->lifetime);		return true;	}	function load() {		return get_transient($this->name);	}	function mtime() {		return get_transient($this->mod_name);	}	function touch() {		return set_transient($this->mod_name, time(), $this->lifetime);	}	function unlink() {		delete_transient($this->name);		delete_transient($this->mod_name);		return true;	}}class WP_SimplePie_File extends SimplePie_File {	function WP_SimplePie_File($url, $timeout = 10, $redirects = 5, $headers = null, $useragent = null, $force_fsockopen = false) {		$this->url = $url;		$this->timeout = $timeout;		$this->redirects = $redirects;		$this->headers = $headers;		$this->useragent = $useragent;		$this->method = SIMPLEPIE_FILE_SOURCE_REMOTE;		if ( preg_match('/^http(s)?:\/\//i', $url) ) {			$args = array( 'timeout' => $this->timeout, 'redirection' => $this->redirects);			if ( !empty($this->headers) )				$args['headers'] = $this->headers;			if ( SIMPLEPIE_USERAGENT != $this->useragent ) //Use default WP user agent unless custom has been specified				$args['user-agent'] = $this->useragent;			$res = wp_remote_request($url, $args);			if ( is_wp_error($res) ) {				$this->error = 'WP HTTP Error: ' . $res->get_error_message();				$this->success = false;			} else {				$this->headers = $res['headers'];				$this->body = $res['body'];				$this->status_code = $res['response']['code'];			}		} else {			if ( ! $this->body = file_get_contents($url) ) {				$this->error = 'file_get_contents could not read the file';				$this->success = false;			}		}	}}
<?php/** * This holds the version number in a separate file so we can bump it without cluttering the SVN *//** * The WordPress version string * * @global string $wp_version */$wp_version = '3.0';/** * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema. * * @global int $wp_db_version */$wp_db_version = 15260;/** * Holds the TinyMCE version * * @global string $tinymce_version */$tinymce_version = '327-1235';/** * Holds the cache manifest version * * @global string $manifest_version */$manifest_version = '20100530';/** * Holds the required PHP version * * @global string $required_php_version */$required_php_version = '4.3';/** * Holds the required MySQL version * * @global string $required_mysql_version */$required_mysql_version = '4.1.2';
<?php/** * WordPress Upgrade Functions. Old file, must not be used. Include * wp-admin/includes/upgrade.php instead. * * @deprecated 2.5 * @package WordPress * @subpackage Administration */_deprecated_file( basename(__FILE__), '2.5', 'wp-admin/includes/upgrade.php' );require_once(ABSPATH . 'wp-admin/includes/upgrade.php');?>
<?php/** * Redirects to the RSS2 feed * This file is deprecated and only exists for backwards compatibility * * @package WordPress */require( './wp-load.php' );wp_redirect( get_bloginfo( 'rss2_url' ), 301 );?>
<?php/* Continent and city translations for timezone selection. * This file is not included anywhere. It exists solely for use by xgettext. */__('Africa', 'continents-cities');__('Abidjan', 'continents-cities');__('Accra', 'continents-cities');__('Addis Ababa', 'continents-cities');__('Algiers', 'continents-cities');__('Asmara', 'continents-cities');__('Asmera', 'continents-cities');__('Bamako', 'continents-cities');__('Bangui', 'continents-cities');__('Banjul', 'continents-cities');__('Bissau', 'continents-cities');__('Blantyre', 'continents-cities');__('Brazzaville', 'continents-cities');__('Bujumbura', 'continents-cities');__('Cairo', 'continents-cities');__('Casablanca', 'continents-cities');__('Ceuta', 'continents-cities');__('Conakry', 'continents-cities');__('Dakar', 'continents-cities');__('Dar es Salaam', 'continents-cities');__('Djibouti', 'continents-cities');__('Douala', 'continents-cities');__('El Aaiun', 'continents-cities');__('Freetown', 'continents-cities');__('Gaborone', 'continents-cities');__('Harare', 'continents-cities');__('Johannesburg', 'continents-cities');__('Kampala', 'continents-cities');__('Khartoum', 'continents-cities');__('Kigali', 'continents-cities');__('Kinshasa', 'continents-cities');__('Lagos', 'continents-cities');__('Libreville', 'continents-cities');__('Lome', 'continents-cities');__('Luanda', 'continents-cities');__('Lubumbashi', 'continents-cities');__('Lusaka', 'continents-cities');__('Malabo', 'continents-cities');__('Maputo', 'continents-cities');__('Maseru', 'continents-cities');__('Mbabane', 'continents-cities');__('Mogadishu', 'continents-cities');__('Monrovia', 'continents-cities');__('Nairobi', 'continents-cities');__('Ndjamena', 'continents-cities');__('Niamey', 'continents-cities');__('Nouakchott', 'continents-cities');__('Ouagadougou', 'continents-cities');__('Porto-Novo', 'continents-cities');__('Sao Tome', 'continents-cities');__('Timbuktu', 'continents-cities');__('Tripoli', 'continents-cities');__('Tunis', 'continents-cities');__('Windhoek', 'continents-cities');__('America', 'continents-cities');__('Adak', 'continents-cities');__('Anchorage', 'continents-cities');__('Anguilla', 'continents-cities');__('Antigua', 'continents-cities');__('Araguaina', 'continents-cities');__('Argentina', 'continents-cities');__('Buenos Aires', 'continents-cities');__('Catamarca', 'continents-cities');__('ComodRivadavia', 'continents-cities');__('Cordoba', 'continents-cities');__('Jujuy', 'continents-cities');__('La Rioja', 'continents-cities');__('Mendoza', 'continents-cities');__('Rio Gallegos', 'continents-cities');__('San Juan', 'continents-cities');__('San Luis', 'continents-cities');__('Tucuman', 'continents-cities');__('Ushuaia', 'continents-cities');__('Aruba', 'continents-cities');__('Asuncion', 'continents-cities');__('Atikokan', 'continents-cities');__('Atka', 'continents-cities');__('Bahia', 'continents-cities');__('Barbados', 'continents-cities');__('Belem', 'continents-cities');__('Belize', 'continents-cities');__('Blanc-Sablon', 'continents-cities');__('Boa Vista', 'continents-cities');__('Bogota', 'continents-cities');__('Boise', 'continents-cities');__('Cambridge Bay', 'continents-cities');__('Campo Grande', 'continents-cities');__('Cancun', 'continents-cities');__('Caracas', 'continents-cities');__('Cayenne', 'continents-cities');__('Cayman', 'continents-cities');__('Chicago', 'continents-cities');__('Chihuahua', 'continents-cities');__('Coral Harbour', 'continents-cities');__('Costa Rica', 'continents-cities');__('Cuiaba', 'continents-cities');__('Curacao', 'continents-cities');__('Danmarkshavn', 'continents-cities');__('Dawson', 'continents-cities');__('Dawson Creek', 'continents-cities');__('Denver', 'continents-cities');__('Detroit', 'continents-cities');__('Dominica', 'continents-cities');__('Edmonton', 'continents-cities');__('Eirunepe', 'continents-cities');__('El Salvador', 'continents-cities');__('Ensenada', 'continents-cities');__('Fort Wayne', 'continents-cities');__('Fortaleza', 'continents-cities');__('Glace Bay', 'continents-cities');__('Godthab', 'continents-cities');__('Goose Bay', 'continents-cities');__('Grand Turk', 'continents-cities');__('Grenada', 'continents-cities');__('Guadeloupe', 'continents-cities');__('Guatemala', 'continents-cities');__('Guayaquil', 'continents-cities');__('Guyana', 'continents-cities');__('Halifax', 'continents-cities');__('Havana', 'continents-cities');__('Hermosillo', 'continents-cities');__('Indiana', 'continents-cities');__('Indianapolis', 'continents-cities');__('Knox', 'continents-cities');__('Marengo', 'continents-cities');__('Petersburg', 'continents-cities');__('Tell City', 'continents-cities');__('Vevay', 'continents-cities');__('Vincennes', 'continents-cities');__('Winamac', 'continents-cities');__('Inuvik', 'continents-cities');__('Iqaluit', 'continents-cities');__('Jamaica', 'continents-cities');__('Juneau', 'continents-cities');__('Kentucky', 'continents-cities');__('Louisville', 'continents-cities');__('Monticello', 'continents-cities');__('Knox IN', 'continents-cities');__('La Paz', 'continents-cities');__('Lima', 'continents-cities');__('Los Angeles', 'continents-cities');__('Maceio', 'continents-cities');__('Managua', 'continents-cities');__('Manaus', 'continents-cities');__('Marigot', 'continents-cities');__('Martinique', 'continents-cities');__('Mazatlan', 'continents-cities');__('Menominee', 'continents-cities');__('Merida', 'continents-cities');__('Mexico City', 'continents-cities');__('Miquelon', 'continents-cities');__('Moncton', 'continents-cities');__('Monterrey', 'continents-cities');__('Montevideo', 'continents-cities');__('Montreal', 'continents-cities');__('Montserrat', 'continents-cities');__('Nassau', 'continents-cities');__('New York', 'continents-cities');__('Nipigon', 'continents-cities');__('Nome', 'continents-cities');__('Noronha', 'continents-cities');__('North Dakota', 'continents-cities');__('Center', 'continents-cities');__('New Salem', 'continents-cities');__('Panama', 'continents-cities');__('Pangnirtung', 'continents-cities');__('Paramaribo', 'continents-cities');__('Phoenix', 'continents-cities');__('Port-au-Prince', 'continents-cities');__('Port of Spain', 'continents-cities');__('Porto Acre', 'continents-cities');__('Porto Velho', 'continents-cities');__('Puerto Rico', 'continents-cities');__('Rainy River', 'continents-cities');__('Rankin Inlet', 'continents-cities');__('Recife', 'continents-cities');__('Regina', 'continents-cities');__('Resolute', 'continents-cities');__('Rio Branco', 'continents-cities');__('Rosario', 'continents-cities');__('Santiago', 'continents-cities');__('Santo Domingo', 'continents-cities');__('Sao Paulo', 'continents-cities');__('Scoresbysund', 'continents-cities');__('Shiprock', 'continents-cities');__('St Barthelemy', 'continents-cities');__('St Johns', 'continents-cities');__('St Kitts', 'continents-cities');__('St Lucia', 'continents-cities');__('St Thomas', 'continents-cities');__('St Vincent', 'continents-cities');__('Swift Current', 'continents-cities');__('Tegucigalpa', 'continents-cities');__('Thule', 'continents-cities');__('Thunder Bay', 'continents-cities');__('Tijuana', 'continents-cities');__('Toronto', 'continents-cities');__('Tortola', 'continents-cities');__('Vancouver', 'continents-cities');__('Virgin', 'continents-cities');__('Whitehorse', 'continents-cities');__('Winnipeg', 'continents-cities');__('Yakutat', 'continents-cities');__('Yellowknife', 'continents-cities');__('Antarctica', 'continents-cities');__('Casey', 'continents-cities');__('Davis', 'continents-cities');__('DumontDUrville', 'continents-cities');__('Mawson', 'continents-cities');__('McMurdo', 'continents-cities');__('Palmer', 'continents-cities');__('Rothera', 'continents-cities');__('South Pole', 'continents-cities');__('Syowa', 'continents-cities');__('Vostok', 'continents-cities');__('Arctic', 'continents-cities');__('Longyearbyen', 'continents-cities');__('Asia', 'continents-cities');__('Aden', 'continents-cities');__('Almaty', 'continents-cities');__('Amman', 'continents-cities');__('Anadyr', 'continents-cities');__('Aqtau', 'continents-cities');__('Aqtobe', 'continents-cities');__('Ashgabat', 'continents-cities');__('Ashkhabad', 'continents-cities');__('Baghdad', 'continents-cities');__('Bahrain', 'continents-cities');__('Baku', 'continents-cities');__('Bangkok', 'continents-cities');__('Beirut', 'continents-cities');__('Bishkek', 'continents-cities');__('Brunei', 'continents-cities');__('Calcutta', 'continents-cities');__('Choibalsan', 'continents-cities');__('Chongqing', 'continents-cities');__('Chungking', 'continents-cities');__('Colombo', 'continents-cities');__('Dacca', 'continents-cities');__('Damascus', 'continents-cities');__('Dhaka', 'continents-cities');__('Dili', 'continents-cities');__('Dubai', 'continents-cities');__('Dushanbe', 'continents-cities');__('Gaza', 'continents-cities');__('Harbin', 'continents-cities');__('Ho Chi Minh', 'continents-cities');__('Hong Kong', 'continents-cities');__('Hovd', 'continents-cities');__('Irkutsk', 'continents-cities');__('Istanbul', 'continents-cities');__('Jakarta', 'continents-cities');__('Jayapura', 'continents-cities');__('Jerusalem', 'continents-cities');__('Kabul', 'continents-cities');__('Kamchatka', 'continents-cities');__('Karachi', 'continents-cities');__('Kashgar', 'continents-cities');__('Katmandu', 'continents-cities');__('Kolkata', 'continents-cities');__('Krasnoyarsk', 'continents-cities');__('Kuala Lumpur', 'continents-cities');__('Kuching', 'continents-cities');__('Kuwait', 'continents-cities');__('Macao', 'continents-cities');__('Macau', 'continents-cities');__('Magadan', 'continents-cities');__('Makassar', 'continents-cities');__('Manila', 'continents-cities');__('Muscat', 'continents-cities');__('Nicosia', 'continents-cities');__('Novosibirsk', 'continents-cities');__('Omsk', 'continents-cities');__('Oral', 'continents-cities');__('Phnom Penh', 'continents-cities');__('Pontianak', 'continents-cities');__('Pyongyang', 'continents-cities');__('Qatar', 'continents-cities');__('Qyzylorda', 'continents-cities');__('Rangoon', 'continents-cities');__('Riyadh', 'continents-cities');__('Saigon', 'continents-cities');__('Sakhalin', 'continents-cities');__('Samarkand', 'continents-cities');__('Seoul', 'continents-cities');__('Shanghai', 'continents-cities');__('Singapore', 'continents-cities');__('Taipei', 'continents-cities');__('Tashkent', 'continents-cities');__('Tbilisi', 'continents-cities');__('Tehran', 'continents-cities');__('Tel Aviv', 'continents-cities');__('Thimbu', 'continents-cities');__('Thimphu', 'continents-cities');__('Tokyo', 'continents-cities');__('Ujung Pandang', 'continents-cities');__('Ulaanbaatar', 'continents-cities');__('Ulan Bator', 'continents-cities');__('Urumqi', 'continents-cities');__('Vientiane', 'continents-cities');__('Vladivostok', 'continents-cities');__('Yakutsk', 'continents-cities');__('Yekaterinburg', 'continents-cities');__('Yerevan', 'continents-cities');__('Atlantic', 'continents-cities');__('Azores', 'continents-cities');__('Bermuda', 'continents-cities');__('Canary', 'continents-cities');__('Cape Verde', 'continents-cities');__('Faeroe', 'continents-cities');__('Faroe', 'continents-cities');__('Jan Mayen', 'continents-cities');__('Madeira', 'continents-cities');__('Reykjavik', 'continents-cities');__('South Georgia', 'continents-cities');__('St Helena', 'continents-cities');__('Stanley', 'continents-cities');__('Australia', 'continents-cities');__('ACT', 'continents-cities');__('Adelaide', 'continents-cities');__('Brisbane', 'continents-cities');__('Broken Hill', 'continents-cities');__('Canberra', 'continents-cities');__('Currie', 'continents-cities');__('Darwin', 'continents-cities');__('Eucla', 'continents-cities');__('Hobart', 'continents-cities');__('LHI', 'continents-cities');__('Lindeman', 'continents-cities');__('Lord Howe', 'continents-cities');__('Melbourne', 'continents-cities');__('North', 'continents-cities');__('NSW', 'continents-cities');__('Perth', 'continents-cities');__('Queensland', 'continents-cities');__('South', 'continents-cities');__('Sydney', 'continents-cities');__('Tasmania', 'continents-cities');__('Victoria', 'continents-cities');__('West', 'continents-cities');__('Yancowinna', 'continents-cities');__('Etc', 'continents-cities');__('GMT', 'continents-cities');__('GMT+0', 'continents-cities');__('GMT+1', 'continents-cities');__('GMT+10', 'continents-cities');__('GMT+11', 'continents-cities');__('GMT+12', 'continents-cities');__('GMT+2', 'continents-cities');__('GMT+3', 'continents-cities');__('GMT+4', 'continents-cities');__('GMT+5', 'continents-cities');__('GMT+6', 'continents-cities');__('GMT+7', 'continents-cities');__('GMT+8', 'continents-cities');__('GMT+9', 'continents-cities');__('GMT-0', 'continents-cities');__('GMT-1', 'continents-cities');__('GMT-10', 'continents-cities');__('GMT-11', 'continents-cities');__('GMT-12', 'continents-cities');__('GMT-13', 'continents-cities');__('GMT-14', 'continents-cities');__('GMT-2', 'continents-cities');__('GMT-3', 'continents-cities');__('GMT-4', 'continents-cities');__('GMT-5', 'continents-cities');__('GMT-6', 'continents-cities');__('GMT-7', 'continents-cities');__('GMT-8', 'continents-cities');__('GMT-9', 'continents-cities');__('GMT0', 'continents-cities');__('Greenwich', 'continents-cities');__('UCT', 'continents-cities');__('Universal', 'continents-cities');__('UTC', 'continents-cities');__('Zulu', 'continents-cities');__('Europe', 'continents-cities');__('Amsterdam', 'continents-cities');__('Andorra', 'continents-cities');__('Athens', 'continents-cities');__('Belfast', 'continents-cities');__('Belgrade', 'continents-cities');__('Berlin', 'continents-cities');__('Bratislava', 'continents-cities');__('Brussels', 'continents-cities');__('Bucharest', 'continents-cities');__('Budapest', 'continents-cities');__('Chisinau', 'continents-cities');__('Copenhagen', 'continents-cities');__('Dublin', 'continents-cities');__('Gibraltar', 'continents-cities');__('Guernsey', 'continents-cities');__('Helsinki', 'continents-cities');__('Isle of Man', 'continents-cities');__('Jersey', 'continents-cities');__('Kaliningrad', 'continents-cities');__('Kiev', 'continents-cities');__('Lisbon', 'continents-cities');__('Ljubljana', 'continents-cities');__('London', 'continents-cities');__('Luxembourg', 'continents-cities');__('Madrid', 'continents-cities');__('Malta', 'continents-cities');__('Mariehamn', 'continents-cities');__('Minsk', 'continents-cities');__('Monaco', 'continents-cities');__('Moscow', 'continents-cities');__('Oslo', 'continents-cities');__('Paris', 'continents-cities');__('Podgorica', 'continents-cities');__('Prague', 'continents-cities');__('Riga', 'continents-cities');__('Rome', 'continents-cities');__('Samara', 'continents-cities');__('San Marino', 'continents-cities');__('Sarajevo', 'continents-cities');__('Simferopol', 'continents-cities');__('Skopje', 'continents-cities');__('Sofia', 'continents-cities');__('Stockholm', 'continents-cities');__('Tallinn', 'continents-cities');__('Tirane', 'continents-cities');__('Tiraspol', 'continents-cities');__('Uzhgorod', 'continents-cities');__('Vaduz', 'continents-cities');__('Vatican', 'continents-cities');__('Vienna', 'continents-cities');__('Vilnius', 'continents-cities');__('Volgograd', 'continents-cities');__('Warsaw', 'continents-cities');__('Zagreb', 'continents-cities');__('Zaporozhye', 'continents-cities');__('Zurich', 'continents-cities');__('Indian', 'continents-cities');__('Antananarivo', 'continents-cities');__('Chagos', 'continents-cities');__('Christmas', 'continents-cities');__('Cocos', 'continents-cities');__('Comoro', 'continents-cities');__('Kerguelen', 'continents-cities');__('Mahe', 'continents-cities');__('Maldives', 'continents-cities');__('Mauritius', 'continents-cities');__('Mayotte', 'continents-cities');__('Reunion', 'continents-cities');__('Pacific', 'continents-cities');__('Apia', 'continents-cities');__('Auckland', 'continents-cities');__('Chatham', 'continents-cities');__('Easter', 'continents-cities');__('Efate', 'continents-cities');__('Enderbury', 'continents-cities');__('Fakaofo', 'continents-cities');__('Fiji', 'continents-cities');__('Funafuti', 'continents-cities');__('Galapagos', 'continents-cities');__('Gambier', 'continents-cities');__('Guadalcanal', 'continents-cities');__('Guam', 'continents-cities');__('Honolulu', 'continents-cities');__('Johnston', 'continents-cities');__('Kiritimati', 'continents-cities');__('Kosrae', 'continents-cities');__('Kwajalein', 'continents-cities');__('Majuro', 'continents-cities');__('Marquesas', 'continents-cities');__('Midway', 'continents-cities');__('Nauru', 'continents-cities');__('Niue', 'continents-cities');__('Norfolk', 'continents-cities');__('Noumea', 'continents-cities');__('Pago Pago', 'continents-cities');__('Palau', 'continents-cities');__('Pitcairn', 'continents-cities');__('Ponape', 'continents-cities');__('Port Moresby', 'continents-cities');__('Rarotonga', 'continents-cities');__('Saipan', 'continents-cities');__('Samoa', 'continents-cities');__('Tahiti', 'continents-cities');__('Tarawa', 'continents-cities');__('Tongatapu', 'continents-cities');__('Truk', 'continents-cities');__('Wake', 'continents-cities');__('Wallis', 'continents-cities');__('Yap', 'continents-cities');
<?php/** * Privacy Options Settings Administration Panel. * * @package WordPress * @subpackage Administration *//** Load WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can( 'manage_options' ) )	wp_die( __( 'You do not have sufficient permissions to manage options for this site.' ) );$title = __('Privacy Settings');$parent_file = 'options-general.php';add_contextual_help($current_screen,	'<p>' . __('You can choose whether or not your site will be crawled by robots, ping services, and spiders. If you want those services to ignore your site, click the second option here. Note that your privacy is not complete; your site is still visible on the web.') . '</p>' .	'<p>' . __('When this setting is in effect a reminder is shown in the header of these administration screens that says, &#8220;Search Engines Blocked,&#8221; to remind you that your site is not being crawled.') . '</p>' .	'<p>' . __('You must click the Save Changes button at the bottom of the screen for new settings to take effect.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Settings_Privacy_SubPanel" target="_blank">Privacy Settings Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');include('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><form method="post" action="options.php"><?php settings_fields('privacy'); ?><table class="form-table"><tr valign="top"><th scope="row"><?php _e('Site Visibility') ?> </th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Site Visibility') ?> </span></legend><input id="blog-public" type="radio" name="blog_public" value="1" <?php checked('1', get_option('blog_public')); ?> /><label for="blog-public"><?php _e('I would like my site to be visible to everyone, including search engines (like Google, Bing, Technorati) and archivers');?></label><br/><input id="blog-norobots" type="radio" name="blog_public" value="0" <?php checked('0', get_option('blog_public')); ?> /><label for="blog-norobots"><?php _e('I would like to block search engines, but allow normal visitors'); ?></label><?php do_action('blog_privacy_selector'); ?></fieldset></td></tr><?php do_settings_fields('privacy', 'default'); ?></table><?php do_settings_sections('privacy'); ?><p class="submit">	<input type="submit" name="Submit" class="button-primary" value="<?php esc_attr_e('Save Changes') ?>" /></p></form></div><?php include('./admin-footer.php') ?>
<?php/** * Multisite upgrade administration panel. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */require_once('admin.php');if ( !is_multisite() )	wp_die( __( 'Multisite support is not enabled.' ) );require_once( ABSPATH . WPINC . '/http.php' );$title = __( 'Update Network' );$parent_file = 'ms-admin.php';add_contextual_help($current_screen,	'<p>' . __('Only use this screen once you have updated to a new version of WordPress through Dashboard > Updates. Clicking the Update Network button will step through each site in the network, five at a time, and make sure any database upgrades are applied.') . '</p>' .	'<p>' . __('If a version update to core has not happened, clicking this button won&#8217;t affect anything.') . '</p>' .	'<p>' . __('If this process fails for any reason, users logging in to their sites will force the same update.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Super_Admin_Update_SubPanel" target="_blank">Update Network Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once('admin-header.php');if ( ! current_user_can( 'manage_network' ) )	wp_die( __( 'You do not have permission to access this page.' ) );echo '<div class="wrap">';screen_icon();echo '<h2>' . __( 'Update Network' ) . '</h2>';$action = isset($_GET['action']) ? $_GET['action'] : 'show';switch ( $action ) {	case "upgrade":		$n = ( isset($_GET['n']) ) ? intval($_GET['n']) : 0;		if ( $n < 5 ) {			global $wp_db_version;			update_site_option( 'wpmu_upgrade_site', $wp_db_version );		}		$blogs = $wpdb->get_results( "SELECT * FROM {$wpdb->blogs} WHERE site_id = '{$wpdb->siteid}' AND spam = '0' AND deleted = '0' AND archived = '0' ORDER BY registered DESC LIMIT {$n}, 5", ARRAY_A );		if ( empty( $blogs ) ) {			echo '<p>' . __( 'All done!' ) . '</p>';			break;		}		echo "<ul>";		foreach ( (array) $blogs as $details ) {			$siteurl = get_blog_option( $details['blog_id'], 'siteurl' );			echo "<li>$siteurl</li>";			$response = wp_remote_get( trailingslashit( $siteurl ) . "wp-admin/upgrade.php?step=upgrade_db", array( 'timeout' => 120, 'httpversion' => '1.1' ) );			if ( is_wp_error( $response ) )				wp_die( sprintf( __( 'Warning! Problem updating %1$s. Your server may not be able to connect to sites running on it. Error message: <em>%2$s</em>' ), $siteurl, $response->get_error_message() ) );			do_action( 'after_mu_upgrade', $response );			do_action( 'wpmu_upgrade_site', $details[ 'blog_id' ] );		}		echo "</ul>";		?><p><?php _e( 'If your browser doesn&#8217;t start loading the next page automatically, click this link:' ); ?> <a class="button" href="ms-upgrade-network.php?action=upgrade&amp;n=<?php echo ($n + 5) ?>"><?php _e("Next Sites"); ?></a></p>		<script type='text/javascript'>		<!--		function nextpage() {			location.href = "ms-upgrade-network.php?action=upgrade&n=<?php echo ($n + 5) ?>";		}		setTimeout( "nextpage()", 250 );		//-->		</script><?php	break;	case 'show':	default:		?><p><?php _e( 'You can update all the sites on your network through this page. It works by calling the update script of each site automatically. Hit the link below to update.' ); ?></p>		<p><a class="button" href="ms-upgrade-network.php?action=upgrade"><?php _e("Update Network"); ?></a></p><?php		do_action( 'wpmu_upgrade_page' );	break;}?></div><?php include('./admin-footer.php'); ?>
<?php/** * Base WordPress Filesystem. * * @package WordPress * @subpackage Filesystem *//** * Base WordPress Filesystem class for which Filesystem implementations extend * * @since 2.5 */class WP_Filesystem_Base {	/**	 * Whether to display debug data for the connection.	 *	 * @since 2.5	 * @access public	 * @var bool	 */	var $verbose = false;	/**	 * Cached list of local filepaths to maped remote filepaths.	 *	 * @since 2.7	 * @access private	 * @var array	 */	var $cache = array();	/**	 * The Access method of the current connection, Set automatically.	 *	 * @since 2.5	 * @access public	 * @var string	 */	var $method = '';	/**	 * Returns the path on the remote filesystem of ABSPATH	 *	 * @since 2.7	 * @access public	 * @return string The location of the remote path.	 */	function abspath() {		$folder = $this->find_folder(ABSPATH);		//Perhaps the FTP folder is rooted at the WordPress install, Check for wp-includes folder in root, Could have some false positives, but rare.		if ( ! $folder && $this->is_dir('/wp-includes') )			$folder = '/';		return $folder;	}	/**	 * Returns the path on the remote filesystem of WP_CONTENT_DIR	 *	 * @since 2.7	 * @access public	 * @return string The location of the remote path.	 */	function wp_content_dir() {		return $this->find_folder(WP_CONTENT_DIR);	}	/**	 * Returns the path on the remote filesystem of WP_PLUGIN_DIR	 *	 * @since 2.7	 * @access public	 *	 * @return string The location of the remote path.	 */	function wp_plugins_dir() {		return $this->find_folder(WP_PLUGIN_DIR);	}	/**	 * Returns the path on the remote filesystem of the Themes Directory	 *	 * @since 2.7	 * @access public	 *	 * @return string The location of the remote path.	 */	function wp_themes_dir() {		return $this->wp_content_dir() . '/themes';	}	/**	 * Locates a folder on the remote filesystem.	 *	 * Deprecated; use WP_Filesystem::abspath() or WP_Filesystem::wp_*_dir() methods instead.	 *	 * @since 2.5	 * @deprecated 2.7	 * @access public	 *	 * @param string $base The folder to start searching from	 * @param bool $echo True to display debug information	 * @return string The location of the remote path.	 */	function find_base_dir($base = '.', $echo = false) {		_deprecated_function(__FUNCTION__, '2.7', 'WP_Filesystem::abspath() or WP_Filesystem::wp_*_dir()' );		$this->verbose = $echo;		return $this->abspath();	}	/**	 * Locates a folder on the remote filesystem.	 *	 * Deprecated; use WP_Filesystem::abspath() or WP_Filesystem::wp_*_dir() methods instead.	 *	 * @since 2.5	 * @deprecated 2.7	 * @access public	 *	 * @param string $base The folder to start searching from	 * @param bool $echo True to display debug information	 * @return string The location of the remote path.	 */	function get_base_dir($base = '.', $echo = false) {		_deprecated_function(__FUNCTION__, '2.7', 'WP_Filesystem::abspath() or WP_Filesystem::wp_*_dir()' );		$this->verbose = $echo;		return $this->abspath();	}	/**	 * Locates a folder on the remote filesystem.	 *	 * Assumes that on Windows systems, Stripping off the Drive letter is OK	 * Sanitizes \\ to / in windows filepaths.	 *	 * @since 2.7	 * @access public	 *	 * @param string $folder the folder to locate	 * @return string The location of the remote path.	 */	function find_folder($folder) {		if ( strpos($this->method, 'ftp') !== false ) {			$constant_overrides = array( 'FTP_BASE' => ABSPATH, 'FTP_CONTENT_DIR' => WP_CONTENT_DIR, 'FTP_PLUGIN_DIR' => WP_PLUGIN_DIR );			foreach ( $constant_overrides as $constant => $dir )				if ( defined($constant) && $folder === $dir )					return trailingslashit(constant($constant));		} elseif ( 'direct' == $this->method ) {			$folder = str_replace('\\', '/', $folder); //Windows path sanitiation			return trailingslashit($folder);		}		$folder = preg_replace('|^([a-z]{1}):|i', '', $folder); //Strip out windows driveletter if its there.		$folder = str_replace('\\', '/', $folder); //Windows path sanitiation		if ( isset($this->cache[ $folder ] ) )			return $this->cache[ $folder ];		if ( $this->exists($folder) ) { //Folder exists at that absolute path.			$folder = trailingslashit($folder);			$this->cache[ $folder ] = $folder;			return $folder;		}		if ( $return = $this->search_for_folder($folder) )			$this->cache[ $folder ] = $return;		return $return;	}	/**	 * Locates a folder on the remote filesystem.	 *	 * Expects Windows sanitized path	 *	 * @since 2.7	 * @access private	 *	 * @param string $folder the folder to locate	 * @param string $base the folder to start searching from	 * @param bool $loop if the function has recursed, Internal use only	 * @return string The location of the remote path.	 */	function search_for_folder($folder, $base = '.', $loop = false ) {		if ( empty( $base ) || '.' == $base )			$base = trailingslashit($this->cwd());		$folder = untrailingslashit($folder);		$folder_parts = explode('/', $folder);		$last_path = $folder_parts[ count($folder_parts) - 1 ];		$files = $this->dirlist( $base );		foreach ( $folder_parts as $key ) {			if ( $key == $last_path )				continue; //We want this to be caught by the next code block.			//Working from /home/ to /user/ to /wordpress/ see if that file exists within the current folder,			// If its found, change into it and follow through looking for it.			// If it cant find WordPress down that route, it'll continue onto the next folder level, and see if that matches, and so on.			// If it reaches the end, and still cant find it, it'll return false for the entire function.			if ( isset($files[ $key ]) ){				//Lets try that folder:				$newdir = trailingslashit(path_join($base, $key));				if ( $this->verbose )					printf( __('Changing to %s') . '<br/>', $newdir );				if ( $ret = $this->search_for_folder( $folder, $newdir, $loop) )					return $ret;			}		}		//Only check this as a last resort, to prevent locating the incorrect install. All above proceeedures will fail quickly if this is the right branch to take.		if (isset( $files[ $last_path ] ) ) {			if ( $this->verbose )				printf( __('Found %s') . '<br/>',  $base . $last_path );			return trailingslashit($base . $last_path);		}		if ( $loop )			return false; //Prevent tihs function looping again.		//As an extra last resort, Change back to / if the folder wasnt found. This comes into effect when the CWD is /home/user/ but WP is at /var/www/.... mainly dedicated setups.		return $this->search_for_folder($folder, '/', true);	}	/**	 * Returns the *nix style file permissions for a file	 *	 * From the PHP documentation page for fileperms()	 *	 * @link http://docs.php.net/fileperms	 * @since 2.5	 * @access public	 *	 * @param string $file string filename	 * @return int octal representation of permissions	 */	function gethchmod($file){		$perms = $this->getchmod($file);		if (($perms & 0xC000) == 0xC000) // Socket			$info = 's';		elseif (($perms & 0xA000) == 0xA000) // Symbolic Link			$info = 'l';		elseif (($perms & 0x8000) == 0x8000) // Regular			$info = '-';		elseif (($perms & 0x6000) == 0x6000) // Block special			$info = 'b';		elseif (($perms & 0x4000) == 0x4000) // Directory			$info = 'd';		elseif (($perms & 0x2000) == 0x2000) // Character special			$info = 'c';		elseif (($perms & 0x1000) == 0x1000) // FIFO pipe			$info = 'p';		else // Unknown			$info = 'u';		// Owner		$info .= (($perms & 0x0100) ? 'r' : '-');		$info .= (($perms & 0x0080) ? 'w' : '-');		$info .= (($perms & 0x0040) ?					(($perms & 0x0800) ? 's' : 'x' ) :					(($perms & 0x0800) ? 'S' : '-'));		// Group		$info .= (($perms & 0x0020) ? 'r' : '-');		$info .= (($perms & 0x0010) ? 'w' : '-');		$info .= (($perms & 0x0008) ?					(($perms & 0x0400) ? 's' : 'x' ) :					(($perms & 0x0400) ? 'S' : '-'));		// World		$info .= (($perms & 0x0004) ? 'r' : '-');		$info .= (($perms & 0x0002) ? 'w' : '-');		$info .= (($perms & 0x0001) ?					(($perms & 0x0200) ? 't' : 'x' ) :					(($perms & 0x0200) ? 'T' : '-'));		return $info;	}	/**	 * Converts *nix style file permissions to a octal number.	 *	 * Converts '-rw-r--r--' to 0644	 * From "info at rvgate dot nl"'s comment on the PHP documentation for chmod() 	 *	 * @link http://docs.php.net/manual/en/function.chmod.php#49614	 * @since 2.5	 * @access public	 *	 * @param string $mode string *nix style file permission	 * @return int octal representation	 */	function getnumchmodfromh($mode) {		$realmode = '';		$legal =  array('', 'w', 'r', 'x', '-');		$attarray = preg_split('//', $mode);		for ($i=0; $i < count($attarray); $i++)		   if ($key = array_search($attarray[$i], $legal))			   $realmode .= $legal[$key];		$mode = str_pad($realmode, 9, '-');		$trans = array('-'=>'0', 'r'=>'4', 'w'=>'2', 'x'=>'1');		$mode = strtr($mode,$trans);		$newmode = '';		$newmode .= $mode[0] + $mode[1] + $mode[2];		$newmode .= $mode[3] + $mode[4] + $mode[5];		$newmode .= $mode[6] + $mode[7] + $mode[8];		return $newmode;	}	/**	 * Determines if the string provided contains binary characters.	 *	 * @since 2.7	 * @access private	 *	 * @param string $text String to test against	 * @return bool true if string is binary, false otherwise	 */	function is_binary( $text ) {		return (bool) preg_match('|[^\x20-\x7E]|', $text); //chr(32)..chr(127)	}}?>
<?php/** * General API for generating and formatting diffs - the differences between * two sequences of strings. * * The original PHP version of this code was written by Geoffrey T. Dairiki * <dairiki@dairiki.org>, and is used/adapted with his permission. * * Copyright 2004 Geoffrey T. Dairiki <dairiki@dairiki.org> * Copyright 2004-2010 The Horde Project (http://www.horde.org/) * * See the enclosed file COPYING for license information (LGPL). If you did * not receive this file, see http://opensource.org/licenses/lgpl-license.php. * * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> */class Text_Diff {    /**     * Array of changes.     *     * @var array     */    var $_edits;    /**     * Computes diffs between sequences of strings.     *     * @param string $engine     Name of the diffing engine to use.  'auto'     *                           will automatically select the best.     * @param array $params      Parameters to pass to the diffing engine.     *                           Normally an array of two arrays, each     *                           containing the lines from a file.     */    function Text_Diff($engine, $params)    {        // Backward compatibility workaround.        if (!is_string($engine)) {            $params = array($engine, $params);            $engine = 'auto';        }        if ($engine == 'auto') {            $engine = extension_loaded('xdiff') ? 'xdiff' : 'native';        } else {            $engine = basename($engine);        }        // WP #7391        require_once dirname(__FILE__).'/Diff/Engine/' . $engine . '.php';        $class = 'Text_Diff_Engine_' . $engine;        $diff_engine = new $class();        $this->_edits = call_user_func_array(array($diff_engine, 'diff'), $params);    }    /**     * Returns the array of differences.     */    function getDiff()    {        return $this->_edits;    }    /**     * returns the number of new (added) lines in a given diff.     *     * @since Text_Diff 1.1.0     *     * @return integer The number of new lines     */    function countAddedLines()    {        $count = 0;        foreach ($this->_edits as $edit) {            if (is_a($edit, 'Text_Diff_Op_add') ||                is_a($edit, 'Text_Diff_Op_change')) {                $count += $edit->nfinal();            }        }        return $count;    }    /**     * Returns the number of deleted (removed) lines in a given diff.     *     * @since Text_Diff 1.1.0     *     * @return integer The number of deleted lines     */    function countDeletedLines()    {        $count = 0;        foreach ($this->_edits as $edit) {            if (is_a($edit, 'Text_Diff_Op_delete') ||                is_a($edit, 'Text_Diff_Op_change')) {                $count += $edit->norig();            }        }        return $count;    }    /**     * Computes a reversed diff.     *     * Example:     * <code>     * $diff = new Text_Diff($lines1, $lines2);     * $rev = $diff->reverse();     * </code>     *     * @return Text_Diff  A Diff object representing the inverse of the     *                    original diff.  Note that we purposely don't return a     *                    reference here, since this essentially is a clone()     *                    method.     */    function reverse()    {        if (version_compare(zend_version(), '2', '>')) {            $rev = clone($this);        } else {            $rev = $this;        }        $rev->_edits = array();        foreach ($this->_edits as $edit) {            $rev->_edits[] = $edit->reverse();        }        return $rev;    }    /**     * Checks for an empty diff.     *     * @return boolean  True if two sequences were identical.     */    function isEmpty()    {        foreach ($this->_edits as $edit) {            if (!is_a($edit, 'Text_Diff_Op_copy')) {                return false;            }        }        return true;    }    /**     * Computes the length of the Longest Common Subsequence (LCS).     *     * This is mostly for diagnostic purposes.     *     * @return integer  The length of the LCS.     */    function lcs()    {        $lcs = 0;        foreach ($this->_edits as $edit) {            if (is_a($edit, 'Text_Diff_Op_copy')) {                $lcs += count($edit->orig);            }        }        return $lcs;    }    /**     * Gets the original set of lines.     *     * This reconstructs the $from_lines parameter passed to the constructor.     *     * @return array  The original sequence of strings.     */    function getOriginal()    {        $lines = array();        foreach ($this->_edits as $edit) {            if ($edit->orig) {                array_splice($lines, count($lines), 0, $edit->orig);            }        }        return $lines;    }    /**     * Gets the final set of lines.     *     * This reconstructs the $to_lines parameter passed to the constructor.     *     * @return array  The sequence of strings.     */    function getFinal()    {        $lines = array();        foreach ($this->_edits as $edit) {            if ($edit->final) {                array_splice($lines, count($lines), 0, $edit->final);            }        }        return $lines;    }    /**     * Removes trailing newlines from a line of text. This is meant to be used     * with array_walk().     *     * @param string $line  The line to trim.     * @param integer $key  The index of the line in the array. Not used.     */    function trimNewlines(&$line, $key)    {        $line = str_replace(array("\n", "\r"), '', $line);    }    /**     * Determines the location of the system temporary directory.     *     * @static     *     * @access protected     *     * @return string  A directory name which can be used for temp files.     *                 Returns false if one could not be found.     */    function _getTempDir()    {        $tmp_locations = array('/tmp', '/var/tmp', 'c:\WUTemp', 'c:\temp',                               'c:\windows\temp', 'c:\winnt\temp');        /* Try PHP's upload_tmp_dir directive. */        $tmp = ini_get('upload_tmp_dir');        /* Otherwise, try to determine the TMPDIR environment variable. */        if (!strlen($tmp)) {            $tmp = getenv('TMPDIR');        }        /* If we still cannot determine a value, then cycle through a list of         * preset possibilities. */        while (!strlen($tmp) && count($tmp_locations)) {            $tmp_check = array_shift($tmp_locations);            if (@is_dir($tmp_check)) {                $tmp = $tmp_check;            }        }        /* If it is still empty, we have failed, so return false; otherwise         * return the directory determined. */        return strlen($tmp) ? $tmp : false;    }    /**     * Checks a diff for validity.     *     * This is here only for debugging purposes.     */    function _check($from_lines, $to_lines)    {        if (serialize($from_lines) != serialize($this->getOriginal())) {            trigger_error("Reconstructed original doesn't match", E_USER_ERROR);        }        if (serialize($to_lines) != serialize($this->getFinal())) {            trigger_error("Reconstructed final doesn't match", E_USER_ERROR);        }        $rev = $this->reverse();        if (serialize($to_lines) != serialize($rev->getOriginal())) {            trigger_error("Reversed original doesn't match", E_USER_ERROR);        }        if (serialize($from_lines) != serialize($rev->getFinal())) {            trigger_error("Reversed final doesn't match", E_USER_ERROR);        }        $prevtype = null;        foreach ($this->_edits as $edit) {            if ($prevtype == get_class($edit)) {                trigger_error("Edit sequence is non-optimal", E_USER_ERROR);            }            $prevtype = get_class($edit);        }        return true;    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> */class Text_MappedDiff extends Text_Diff {    /**     * Computes a diff between sequences of strings.     *     * This can be used to compute things like case-insensitve diffs, or diffs     * which ignore changes in white-space.     *     * @param array $from_lines         An array of strings.     * @param array $to_lines           An array of strings.     * @param array $mapped_from_lines  This array should have the same size     *                                  number of elements as $from_lines.  The     *                                  elements in $mapped_from_lines and     *                                  $mapped_to_lines are what is actually     *                                  compared when computing the diff.     * @param array $mapped_to_lines    This array should have the same number     *                                  of elements as $to_lines.     */    function Text_MappedDiff($from_lines, $to_lines,                             $mapped_from_lines, $mapped_to_lines)    {        assert(count($from_lines) == count($mapped_from_lines));        assert(count($to_lines) == count($mapped_to_lines));        parent::Text_Diff($mapped_from_lines, $mapped_to_lines);        $xi = $yi = 0;        for ($i = 0; $i < count($this->_edits); $i++) {            $orig = &$this->_edits[$i]->orig;            if (is_array($orig)) {                $orig = array_slice($from_lines, $xi, count($orig));                $xi += count($orig);            }            $final = &$this->_edits[$i]->final;            if (is_array($final)) {                $final = array_slice($to_lines, $yi, count($final));                $yi += count($final);            }        }    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * * @access private */class Text_Diff_Op {    var $orig;    var $final;    function &reverse()    {        trigger_error('Abstract method', E_USER_ERROR);    }    function norig()    {        return $this->orig ? count($this->orig) : 0;    }    function nfinal()    {        return $this->final ? count($this->final) : 0;    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * * @access private */class Text_Diff_Op_copy extends Text_Diff_Op {    function Text_Diff_Op_copy($orig, $final = false)    {        if (!is_array($final)) {            $final = $orig;        }        $this->orig = $orig;        $this->final = $final;    }    function &reverse()    {        $reverse = &new Text_Diff_Op_copy($this->final, $this->orig);        return $reverse;    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * * @access private */class Text_Diff_Op_delete extends Text_Diff_Op {    function Text_Diff_Op_delete($lines)    {        $this->orig = $lines;        $this->final = false;    }    function &reverse()    {        $reverse = &new Text_Diff_Op_add($this->orig);        return $reverse;    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * * @access private */class Text_Diff_Op_add extends Text_Diff_Op {    function Text_Diff_Op_add($lines)    {        $this->final = $lines;        $this->orig = false;    }    function &reverse()    {        $reverse = &new Text_Diff_Op_delete($this->final);        return $reverse;    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * * @access private */class Text_Diff_Op_change extends Text_Diff_Op {    function Text_Diff_Op_change($orig, $final)    {        $this->orig = $orig;        $this->final = $final;    }    function &reverse()    {        $reverse = &new Text_Diff_Op_change($this->final, $this->orig);        return $reverse;    }}
<?php/** * Manage link administration actions. * * This page is accessed by the link management pages and handles the forms and * AJAX processes for link actions. * * @package WordPress * @subpackage Administration *//** Load WordPress Administration Bootstrap */require_once ('admin.php');wp_reset_vars(array('action', 'cat_id', 'linkurl', 'name', 'image', 'description', 'visible', 'target', 'category', 'link_id', 'submit', 'order_by', 'links_show_cat_id', 'rating', 'rel', 'notes', 'linkcheck[]'));if ( ! current_user_can('manage_links') )	wp_die( __('You do not have sufficient permissions to edit the links for this site.') );if ( !empty($_POST['deletebookmarks']) )	$action = 'deletebookmarks';if ( !empty($_POST['move']) )	$action = 'move';if ( !empty($_POST['linkcheck']) )	$linkcheck = $_POST['linkcheck'];$this_file = 'link-manager.php';switch ($action) {	case 'deletebookmarks' :		check_admin_referer('bulk-bookmarks');		//for each link id (in $linkcheck[]) change category to selected value		if (count($linkcheck) == 0) {			wp_redirect($this_file);			exit;		}		$deleted = 0;		foreach ($linkcheck as $link_id) {			$link_id = (int) $link_id;			if ( wp_delete_link($link_id) )				$deleted++;		}		wp_redirect("$this_file?deleted=$deleted");		exit;		break;	case 'move' :		check_admin_referer('bulk-bookmarks');		//for each link id (in $linkcheck[]) change category to selected value		if (count($linkcheck) == 0) {			wp_redirect($this_file);			exit;		}		$all_links = join(',', $linkcheck);		// should now have an array of links we can change		//$q = $wpdb->query("update $wpdb->links SET link_category='$category' WHERE link_id IN ($all_links)");		wp_redirect($this_file);		exit;		break;	case 'add' :		check_admin_referer('add-bookmark');		$redir = wp_get_referer();		if ( add_link() )			$redir = add_query_arg( 'added', 'true', $redir );		wp_redirect( $redir );		exit;		break;	case 'save' :		$link_id = (int) $_POST['link_id'];		check_admin_referer('update-bookmark_' . $link_id);		edit_link($link_id);		wp_redirect($this_file);		exit;		break;	case 'delete' :		$link_id = (int) $_GET['link_id'];		check_admin_referer('delete-bookmark_' . $link_id);		wp_delete_link($link_id);		wp_redirect($this_file);		exit;		break;	case 'edit' :		wp_enqueue_script('link');		wp_enqueue_script('xfn');		$parent_file = 'link-manager.php';		$submenu_file = 'link-manager.php';		$title = __('Edit Link');		$link_id = (int) $_GET['link_id'];		if (!$link = get_link_to_edit($link_id))			wp_die(__('Link not found.'));		include ('edit-link-form.php');		include ('admin-footer.php');		break;	default :		break;}?>
<?php/** * Edit comment form for inclusion in another file. * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');/** * @var string */$submitbutton_text = __('Edit Comment');$toprow_title = sprintf(__('Editing Comment # %s'), $comment->comment_ID);$form_action = 'editedcomment';$form_extra = "' />\n<input type='hidden' name='comment_ID' value='" . esc_attr($comment->comment_ID) . "' />\n<input type='hidden' name='comment_post_ID' value='" . esc_attr($comment->comment_post_ID);$comment->comment_author_email = esc_attr($comment->comment_author_email);?><form name="post" action="comment.php" method="post" id="post"><?php wp_nonce_field('update-comment_' . $comment->comment_ID) ?><div class="wrap"><?php screen_icon(); ?><h2><?php _e('Edit Comment'); ?></h2><div id="poststuff" class="metabox-holder has-right-sidebar"><input type="hidden" name="user_ID" value="<?php echo (int) $user_ID ?>" /><input type="hidden" name="action" value='<?php echo $form_action . $form_extra ?>' /><div id="side-info-column" class="inner-sidebar"><div id="submitdiv" class="stuffbox" ><h3><span class='hndle'><?php _e('Status') ?></span></h3><div class="inside"><div class="submitbox" id="submitcomment"><div id="minor-publishing"><div id="minor-publishing-actions"><div id="preview-action"><a class="preview button" href="<?php echo get_comment_link(); ?>" target="_blank"><?php _e('View Comment'); ?></a></div><div class="clear"></div></div><div id="misc-publishing-actions"><div class="misc-pub-section" id="comment-status-radio"><label class="approved"><input type="radio"<?php checked( $comment->comment_approved, '1' ); ?> name="comment_status" value="1" /><?php /* translators: comment type radio button */ _ex('Approved', 'adjective') ?></label><br /><label class="waiting"><input type="radio"<?php checked( $comment->comment_approved, '0' ); ?> name="comment_status" value="0" /><?php /* translators: comment type radio button */ _ex('Pending', 'adjective') ?></label><br /><label class="spam"><input type="radio"<?php checked( $comment->comment_approved, 'spam' ); ?> name="comment_status" value="spam" /><?php /* translators: comment type radio button */ _ex('Spam', 'adjective'); ?></label></div><div class="misc-pub-section curtime misc-pub-section-last"><?php// translators: Publish box date formt, see http://php.net/date$datef = __( 'M j, Y @ G:i' );$stamp = __('Submitted on: <b>%1$s</b>');$date = date_i18n( $datef, strtotime( $comment->comment_date ) );?><span id="timestamp"><?php printf($stamp, $date); ?></span>&nbsp;<a href="#edit_timestamp" class="edit-timestamp hide-if-no-js" tabindex='4'><?php _e('Edit') ?></a><div id='timestampdiv' class='hide-if-js'><?php touch_time(('editcomment' == $action), 0, 5); ?></div></div></div> <!-- misc actions --><div class="clear"></div></div><div id="major-publishing-actions"><div id="delete-action"><?php echo "<a class='submitdelete deletion' href='" . wp_nonce_url("comment.php?action=" . ( !EMPTY_TRASH_DAYS ? 'deletecomment' : 'trashcomment' ) . "&amp;c=$comment->comment_ID&amp;_wp_original_http_referer=" . urlencode(wp_get_referer()), 'delete-comment_' . $comment->comment_ID) . "'>" . ( !EMPTY_TRASH_DAYS ? __('Delete Permanently') : __('Move to Trash') ) . "</a>\n"; ?></div><div id="publishing-action"><input type="submit" name="save" value="<?php esc_attr_e('Update Comment'); ?>" tabindex="4" class="button-primary" /></div><div class="clear"></div></div></div></div></div></div><div id="post-body"><div id="post-body-content"><div id="namediv" class="stuffbox"><h3><label for="name"><?php _e( 'Author' ) ?></label></h3><div class="inside"><table class="form-table editcomment"><tbody><tr valign="top">	<td class="first"><?php _e( 'Name:' ); ?></td>	<td><input type="text" name="newcomment_author" size="30" value="<?php echo esc_attr( $comment->comment_author ); ?>" tabindex="1" id="name" /></td></tr><tr valign="top">	<td class="first">	<?php		if ( $comment->comment_author_email ) {			printf( __( 'E-mail (%s):' ), get_comment_author_email_link( __( 'send e-mail' ), '', '' ) );		} else {			_e( 'E-mail:' );		}?></td>	<td><input type="text" name="newcomment_author_email" size="30" value="<?php echo $comment->comment_author_email; ?>" tabindex="2" id="email" /></td></tr><tr valign="top">	<td class="first">	<?php		if ( ! empty( $comment->comment_author_url ) && 'http://' != $comment->comment_author_url ) {			$link = '<a href="' . $comment->comment_author_url . '" rel="external nofollow" target="_blank">' . __('visit site') . '</a>';			printf( __( 'URL (%s):' ), apply_filters('get_comment_author_link', $link ) );		} else {			_e( 'URL:' );		} ?></td>	<td><input type="text" id="newcomment_author_url" name="newcomment_author_url" size="30" class="code" value="<?php echo esc_attr($comment->comment_author_url); ?>" tabindex="3" /></td></tr></tbody></table><br /></div></div><div id="postdiv" class="postarea"><?php the_editor($comment->comment_content, 'content', 'newcomment_author_url', false, 4); ?><?php wp_nonce_field( 'closedpostboxes', 'closedpostboxesnonce', false ); ?></div><?phpdo_action('add_meta_boxes', 'comment', $comment);do_action('add_meta_boxes_comment', $comment);do_meta_boxes('comment', 'normal', $comment);?><input type="hidden" name="c" value="<?php echo esc_attr($comment->comment_ID) ?>" /><input type="hidden" name="p" value="<?php echo esc_attr($comment->comment_post_ID) ?>" /><input name="referredby" type="hidden" id="referredby" value="<?php echo esc_url(stripslashes(wp_get_referer())); ?>" /><?php wp_original_referer_field(true, 'previous'); ?><input type="hidden" name="noredir" value="1" /></div></div></div></div></form><script type="text/javascript">try{document.post.name.focus();}catch(e){}</script>
<?php/** * Redirects to the default feed * This file is deprecated and only exists for backwards compatibility * * @package WordPress */require( './wp-load.php' );wp_redirect( get_bloginfo( get_default_feed() . '_url' ), 301 );?>
<?php/** * Tools Administration Panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');$title = __('Tools');add_contextual_help($current_screen,	'<p>' . __('Press This is a bookmarklet that makes it easy to blog about something you come across on the web. You can use it to just grab a link, or to post an excerpt. Press This will even allow you to choose from images included on the page and use them in your post. Just drag the Press This link on this screen to your bookmarks bar in your browser, and you&#8217;ll be on your way to easier content creation.') . '</p>' .	'<p>' . __('Note: Turbo/Gears is no longer promoted on this screen as it was in previous versions due to the fact that Google has discontinued support for it.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Tools_Tools_SubPanel" target="_blank">Tools Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><?php if ( current_user_can('edit_posts') ) : ?><div class="tool-box">	<h3 class="title"><?php _e('Press This') ?></h3>	<p><?php _e('Press This is a bookmarklet: a little app that runs in your browser and lets you grab bits of the web.');?></p>	<p><?php _e('Use Press This to clip text, images and videos from any web page. Then edit and add more straight from Press This before you save or publish it in a post on your site.'); ?></p>	<p><?php _e('Drag-and-drop the following link to your bookmarks bar or right click it and add it to your favorites for a posting shortcut.') ?></p>	<p class="pressthis"><a href="<?php echo htmlspecialchars( get_shortcut_link() ); ?>" title="<?php echo esc_attr(__('Press This')) ?>"><?php _e('Press This') ?></a></p></div><?phpendif;if ( current_user_can( 'import' ) ) :$cats = get_taxonomy('category');$tags = get_taxonomy('post_tag');if ( current_user_can($cats->cap->manage_terms) || current_user_can($tags->cap->manage_terms) ) : ?><div class="tool-box">    <h3 class="title"><?php _e( 'Categories and Tags Converter' ) ?></h3>    <p><?php printf( __('<a href="%s">Use this</a> to convert categories to tags or tags to categories.'), 'import.php' ); ?></p></div><?phpendif;endif;do_action( 'tool_box' );?></div><?phpinclude('./admin-footer.php');?>
<?phpif ( !class_exists( 'Services_JSON' ) ) :/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: *//** * Converts to and from JSON format. * * JSON (JavaScript Object Notation) is a lightweight data-interchange * format. It is easy for humans to read and write. It is easy for machines * to parse and generate. It is based on a subset of the JavaScript * Programming Language, Standard ECMA-262 3rd Edition - December 1999. * This feature can also be found in  Python. JSON is a text format that is * completely language independent but uses conventions that are familiar * to programmers of the C-family of languages, including C, C++, C#, Java, * JavaScript, Perl, TCL, and many others. These properties make JSON an * ideal data-interchange language. * * This package provides a simple encoder and decoder for JSON notation. It * is intended for use with client-side Javascript applications that make * use of HTTPRequest to perform server communication functions - data can * be encoded into JSON notation for use in a client-side javascript, or * decoded from incoming Javascript requests. JSON format is native to * Javascript, and can be directly eval()'ed with no further parsing * overhead * * All strings should be in ASCII or UTF-8 format! * * LICENSE: Redistribution and use in source and binary forms, with or * without modification, are permitted provided that the following * conditions are met: Redistributions of source code must retain the * above copyright notice, this list of conditions and the following * disclaimer. Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following disclaimer * in the documentation and/or other materials provided with the * distribution. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN * NO EVENT SHALL CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH * DAMAGE. * * @category * @package		Services_JSON * @author		Michal Migurski <mike-json@teczno.com> * @author		Matt Knapp <mdknapp[at]gmail[dot]com> * @author		Brett Stimmerman <brettstimmerman[at]gmail[dot]com> * @copyright	2005 Michal Migurski * @version     CVS: $Id: JSON.php 288200 2009-09-09 15:41:29Z alan_k $ * @license		http://www.opensource.org/licenses/bsd-license.php * @link		http://pear.php.net/pepr/pepr-proposal-show.php?id=198 *//** * Marker constant for Services_JSON::decode(), used to flag stack state */define('SERVICES_JSON_SLICE', 1);/** * Marker constant for Services_JSON::decode(), used to flag stack state */define('SERVICES_JSON_IN_STR',  2);/** * Marker constant for Services_JSON::decode(), used to flag stack state */define('SERVICES_JSON_IN_ARR',  3);/** * Marker constant for Services_JSON::decode(), used to flag stack state */define('SERVICES_JSON_IN_OBJ',  4);/** * Marker constant for Services_JSON::decode(), used to flag stack state */define('SERVICES_JSON_IN_CMT', 5);/** * Behavior switch for Services_JSON::decode() */define('SERVICES_JSON_LOOSE_TYPE', 16);/** * Behavior switch for Services_JSON::decode() */define('SERVICES_JSON_SUPPRESS_ERRORS', 32);/** * Converts to and from JSON format. * * Brief example of use: * * <code> * // create a new instance of Services_JSON * $json = new Services_JSON(); * * // convert a complexe value to JSON notation, and send it to the browser * $value = array('foo', 'bar', array(1, 2, 'baz'), array(3, array(4))); * $output = $json->encode($value); * * print($output); * // prints: ["foo","bar",[1,2,"baz"],[3,[4]]] * * // accept incoming POST data, assumed to be in JSON notation * $input = file_get_contents('php://input', 1000000); * $value = $json->decode($input); * </code> */class Services_JSON{ /**	* constructs a new JSON instance	*	* @param int $use object behavior flags; combine with boolean-OR	*	*						possible values:	*						- SERVICES_JSON_LOOSE_TYPE:  loose typing.	*								"{...}" syntax creates associative arrays	*								instead of objects in decode().	*						- SERVICES_JSON_SUPPRESS_ERRORS:  error suppression.	*								Values which can't be encoded (e.g. resources)	*								appear as NULL instead of throwing errors.	*								By default, a deeply-nested resource will	*								bubble up with an error, so all return values	*								from encode() should be checked with isError()	*/	function Services_JSON($use = 0)	{		$this->use = $use;	} /**	* convert a string from one UTF-16 char to one UTF-8 char	*	* Normally should be handled by mb_convert_encoding, but	* provides a slower PHP-only method for installations	* that lack the multibye string extension.	*	* @param	string  $utf16  UTF-16 character	* @return string  UTF-8 character	* @access private	*/	function utf162utf8($utf16)	{		// oh please oh please oh please oh please oh please		if(function_exists('mb_convert_encoding')) {			return mb_convert_encoding($utf16, 'UTF-8', 'UTF-16');		}		$bytes = (ord($utf16{0}) << 8) | ord($utf16{1});		switch(true) {			case ((0x7F & $bytes) == $bytes):				// this case should never be reached, because we are in ASCII range				// see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8				return chr(0x7F & $bytes);			case (0x07FF & $bytes) == $bytes:				// return a 2-byte UTF-8 character				// see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8				return chr(0xC0 | (($bytes >> 6) & 0x1F))					. chr(0x80 | ($bytes & 0x3F));			case (0xFFFF & $bytes) == $bytes:				// return a 3-byte UTF-8 character				// see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8				return chr(0xE0 | (($bytes >> 12) & 0x0F))					. chr(0x80 | (($bytes >> 6) & 0x3F))					. chr(0x80 | ($bytes & 0x3F));		}		// ignoring UTF-32 for now, sorry		return '';	} /**	* convert a string from one UTF-8 char to one UTF-16 char	*	* Normally should be handled by mb_convert_encoding, but	* provides a slower PHP-only method for installations	* that lack the multibye string extension.	*	* @param	string  $utf8 UTF-8 character	* @return string  UTF-16 character	* @access private	*/	function utf82utf16($utf8)	{		// oh please oh please oh please oh please oh please		if(function_exists('mb_convert_encoding')) {			return mb_convert_encoding($utf8, 'UTF-16', 'UTF-8');		}		switch(strlen($utf8)) {			case 1:				// this case should never be reached, because we are in ASCII range				// see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8				return $utf8;			case 2:				// return a UTF-16 character from a 2-byte UTF-8 char				// see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8				return chr(0x07 & (ord($utf8{0}) >> 2))					. chr((0xC0 & (ord($utf8{0}) << 6))						| (0x3F & ord($utf8{1})));			case 3:				// return a UTF-16 character from a 3-byte UTF-8 char				// see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8				return chr((0xF0 & (ord($utf8{0}) << 4))						| (0x0F & (ord($utf8{1}) >> 2)))					. chr((0xC0 & (ord($utf8{1}) << 6))						| (0x7F & ord($utf8{2})));		}		// ignoring UTF-32 for now, sorry		return '';	} /**	* encodes an arbitrary variable into JSON format (and sends JSON Header)	*	* @param	mixed $var	any number, boolean, string, array, or object to be encoded.	*						see argument 1 to Services_JSON() above for array-parsing behavior.	*						if var is a strng, note that encode() always expects it	*						to be in ASCII or UTF-8 format!	*	* @return mixed JSON string representation of input var or an error if a problem occurs	* @access public	*/	function encode($var)	{		header('Content-type: application/json');		return $this->_encode($var);	}	/**	* encodes an arbitrary variable into JSON format without JSON Header - warning - may allow CSS!!!!)	*	* @param	mixed $var	any number, boolean, string, array, or object to be encoded.	*						see argument 1 to Services_JSON() above for array-parsing behavior.	*						if var is a strng, note that encode() always expects it	*						to be in ASCII or UTF-8 format!	*	* @return mixed JSON string representation of input var or an error if a problem occurs	* @access public	*/	function encodeUnsafe($var)	{		return $this->_encode($var);	}	/**	* PRIVATE CODE that does the work of encodes an arbitrary variable into JSON format	*	* @param	mixed $var	any number, boolean, string, array, or object to be encoded.	*						see argument 1 to Services_JSON() above for array-parsing behavior.	*						if var is a strng, note that encode() always expects it	*						to be in ASCII or UTF-8 format!	*	* @return mixed JSON string representation of input var or an error if a problem occurs	* @access public	*/	function _encode($var)	{		switch (gettype($var)) {			case 'boolean':				return $var ? 'true' : 'false';			case 'NULL':				return 'null';			case 'integer':				return (int) $var;			case 'double':			case 'float':				return (float) $var;			case 'string':				// STRINGS ARE EXPECTED TO BE IN ASCII OR UTF-8 FORMAT				$ascii = '';				$strlen_var = strlen($var);			/*				* Iterate over every character in the string,				* escaping with a slash or encoding to UTF-8 where necessary				*/				for ($c = 0; $c < $strlen_var; ++$c) {					$ord_var_c = ord($var{$c});					switch (true) {						case $ord_var_c == 0x08:							$ascii .= '\b';							break;						case $ord_var_c == 0x09:							$ascii .= '\t';							break;						case $ord_var_c == 0x0A:							$ascii .= '\n';							break;						case $ord_var_c == 0x0C:							$ascii .= '\f';							break;						case $ord_var_c == 0x0D:							$ascii .= '\r';							break;						case $ord_var_c == 0x22:						case $ord_var_c == 0x2F:						case $ord_var_c == 0x5C:							// double quote, slash, slosh							$ascii .= '\\'.$var{$c};							break;						case (($ord_var_c >= 0x20) && ($ord_var_c <= 0x7F)):							// characters U-00000000 - U-0000007F (same as ASCII)							$ascii .= $var{$c};							break;						case (($ord_var_c & 0xE0) == 0xC0):							// characters U-00000080 - U-000007FF, mask 110XXXXX							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8							if ($c+1 >= $strlen_var) {								$c += 1;								$ascii .= '?';								break;							}							$char = pack('C*', $ord_var_c, ord($var{$c + 1}));							$c += 1;							$utf16 = $this->utf82utf16($char);							$ascii .= sprintf('\u%04s', bin2hex($utf16));							break;						case (($ord_var_c & 0xF0) == 0xE0):							if ($c+2 >= $strlen_var) {								$c += 2;								$ascii .= '?';								break;							}							// characters U-00000800 - U-0000FFFF, mask 1110XXXX							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8							$char = pack('C*', $ord_var_c,										@ord($var{$c + 1}),										@ord($var{$c + 2}));							$c += 2;							$utf16 = $this->utf82utf16($char);							$ascii .= sprintf('\u%04s', bin2hex($utf16));							break;						case (($ord_var_c & 0xF8) == 0xF0):							if ($c+3 >= $strlen_var) {								$c += 3;								$ascii .= '?';								break;							}							// characters U-00010000 - U-001FFFFF, mask 11110XXX							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8							$char = pack('C*', $ord_var_c,										ord($var{$c + 1}),										ord($var{$c + 2}),										ord($var{$c + 3}));							$c += 3;							$utf16 = $this->utf82utf16($char);							$ascii .= sprintf('\u%04s', bin2hex($utf16));							break;						case (($ord_var_c & 0xFC) == 0xF8):							// characters U-00200000 - U-03FFFFFF, mask 111110XX							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8							if ($c+4 >= $strlen_var) {								$c += 4;								$ascii .= '?';								break;							}							$char = pack('C*', $ord_var_c,										ord($var{$c + 1}),										ord($var{$c + 2}),										ord($var{$c + 3}),										ord($var{$c + 4}));							$c += 4;							$utf16 = $this->utf82utf16($char);							$ascii .= sprintf('\u%04s', bin2hex($utf16));							break;						case (($ord_var_c & 0xFE) == 0xFC):						if ($c+5 >= $strlen_var) {								$c += 5;								$ascii .= '?';								break;							}							// characters U-04000000 - U-7FFFFFFF, mask 1111110X							// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8							$char = pack('C*', $ord_var_c,										ord($var{$c + 1}),										ord($var{$c + 2}),										ord($var{$c + 3}),										ord($var{$c + 4}),										ord($var{$c + 5}));							$c += 5;							$utf16 = $this->utf82utf16($char);							$ascii .= sprintf('\u%04s', bin2hex($utf16));							break;					}				}				return  '"'.$ascii.'"';			case 'array':			/*				* As per JSON spec if any array key is not an integer				* we must treat the the whole array as an object. We				* also try to catch a sparsely populated associative				* array with numeric keys here because some JS engines				* will create an array with empty indexes up to				* max_index which can cause memory issues and because				* the keys, which may be relevant, will be remapped				* otherwise.				*				* As per the ECMA and JSON specification an object may				* have any string as a property. Unfortunately due to				* a hole in the ECMA specification if the key is a				* ECMA reserved word or starts with a digit the				* parameter is only accessible using ECMAScript's				* bracket notation.				*/				// treat as a JSON object				if (is_array($var) && count($var) && (array_keys($var) !== range(0, sizeof($var) - 1))) {					$properties = array_map(array($this, 'name_value'),											array_keys($var),											array_values($var));					foreach($properties as $property) {						if(Services_JSON::isError($property)) {							return $property;						}					}					return '{' . join(',', $properties) . '}';				}				// treat it like a regular array				$elements = array_map(array($this, '_encode'), $var);				foreach($elements as $element) {					if(Services_JSON::isError($element)) {						return $element;					}				}				return '[' . join(',', $elements) . ']';			case 'object':				$vars = get_object_vars($var);				$properties = array_map(array($this, 'name_value'),										array_keys($vars),										array_values($vars));				foreach($properties as $property) {					if(Services_JSON::isError($property)) {						return $property;					}				}				return '{' . join(',', $properties) . '}';			default:				return ($this->use & SERVICES_JSON_SUPPRESS_ERRORS)					? 'null'					: new Services_JSON_Error(gettype($var)." can not be encoded as JSON string");		}	} /**	* array-walking function for use in generating JSON-formatted name-value pairs	*	* @param	string  $name name of key to use	* @param	mixed $value  reference to an array element to be encoded	*	* @return string  JSON-formatted name-value pair, like '"name":value'	* @access private	*/	function name_value($name, $value)	{		$encoded_value = $this->_encode($value);		if(Services_JSON::isError($encoded_value)) {			return $encoded_value;		}		return $this->_encode(strval($name)) . ':' . $encoded_value;	} /**	* reduce a string by removing leading and trailing comments and whitespace	*	* @param	$str	string	string value to strip of comments and whitespace	*	* @return string  string value stripped of comments and whitespace	* @access private	*/	function reduce_string($str)	{		$str = preg_replace(array(				// eliminate single line comments in '// ...' form				'#^\s*//(.+)$#m',				// eliminate multi-line comments in '/* ... */' form, at start of string				'#^\s*/\*(.+)\*/#Us',				// eliminate multi-line comments in '/* ... */' form, at end of string				'#/\*(.+)\*/\s*$#Us'			), '', $str);		// eliminate extraneous space		return trim($str);	} /**	* decodes a JSON string into appropriate variable	*	* @param	string  $str	JSON-formatted string	*	* @return mixed number, boolean, string, array, or object	*				corresponding to given JSON input string.	*				See argument 1 to Services_JSON() above for object-output behavior.	*				Note that decode() always returns strings	*				in ASCII or UTF-8 format!	* @access public	*/	function decode($str)	{		$str = $this->reduce_string($str);		switch (strtolower($str)) {			case 'true':				return true;			case 'false':				return false;			case 'null':				return null;			default:				$m = array();				if (is_numeric($str)) {					// Lookie-loo, it's a number					// This would work on its own, but I'm trying to be					// good about returning integers where appropriate:					// return (float)$str;					// Return float or int, as appropriate					return ((float)$str == (integer)$str)						? (integer)$str						: (float)$str;				} elseif (preg_match('/^("|\').*(\1)$/s', $str, $m) && $m[1] == $m[2]) {					// STRINGS RETURNED IN UTF-8 FORMAT					$delim = substr($str, 0, 1);					$chrs = substr($str, 1, -1);					$utf8 = '';					$strlen_chrs = strlen($chrs);					for ($c = 0; $c < $strlen_chrs; ++$c) {						$substr_chrs_c_2 = substr($chrs, $c, 2);						$ord_chrs_c = ord($chrs{$c});						switch (true) {							case $substr_chrs_c_2 == '\b':								$utf8 .= chr(0x08);								++$c;								break;							case $substr_chrs_c_2 == '\t':								$utf8 .= chr(0x09);								++$c;								break;							case $substr_chrs_c_2 == '\n':								$utf8 .= chr(0x0A);								++$c;								break;							case $substr_chrs_c_2 == '\f':								$utf8 .= chr(0x0C);								++$c;								break;							case $substr_chrs_c_2 == '\r':								$utf8 .= chr(0x0D);								++$c;								break;							case $substr_chrs_c_2 == '\\"':							case $substr_chrs_c_2 == '\\\'':							case $substr_chrs_c_2 == '\\\\':							case $substr_chrs_c_2 == '\\/':								if (($delim == '"' && $substr_chrs_c_2 != '\\\'') ||								($delim == "'" && $substr_chrs_c_2 != '\\"')) {									$utf8 .= $chrs{++$c};								}								break;							case preg_match('/\\\u[0-9A-F]{4}/i', substr($chrs, $c, 6)):								// single, escaped unicode character								$utf16 = chr(hexdec(substr($chrs, ($c + 2), 2)))									. chr(hexdec(substr($chrs, ($c + 4), 2)));								$utf8 .= $this->utf162utf8($utf16);								$c += 5;								break;							case ($ord_chrs_c >= 0x20) && ($ord_chrs_c <= 0x7F):								$utf8 .= $chrs{$c};								break;							case ($ord_chrs_c & 0xE0) == 0xC0:								// characters U-00000080 - U-000007FF, mask 110XXXXX								//see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8								$utf8 .= substr($chrs, $c, 2);								++$c;								break;							case ($ord_chrs_c & 0xF0) == 0xE0:								// characters U-00000800 - U-0000FFFF, mask 1110XXXX								// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8								$utf8 .= substr($chrs, $c, 3);								$c += 2;								break;							case ($ord_chrs_c & 0xF8) == 0xF0:								// characters U-00010000 - U-001FFFFF, mask 11110XXX								// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8								$utf8 .= substr($chrs, $c, 4);								$c += 3;								break;							case ($ord_chrs_c & 0xFC) == 0xF8:								// characters U-00200000 - U-03FFFFFF, mask 111110XX								// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8								$utf8 .= substr($chrs, $c, 5);								$c += 4;								break;							case ($ord_chrs_c & 0xFE) == 0xFC:								// characters U-04000000 - U-7FFFFFFF, mask 1111110X								// see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8								$utf8 .= substr($chrs, $c, 6);								$c += 5;								break;						}					}					return $utf8;				} elseif (preg_match('/^\[.*\]$/s', $str) || preg_match('/^\{.*\}$/s', $str)) {					// array, or object notation					if ($str{0} == '[') {						$stk = array(SERVICES_JSON_IN_ARR);						$arr = array();					} else {						if ($this->use & SERVICES_JSON_LOOSE_TYPE) {							$stk = array(SERVICES_JSON_IN_OBJ);							$obj = array();						} else {							$stk = array(SERVICES_JSON_IN_OBJ);							$obj = new stdClass();						}					}					array_push($stk, array('what'  => SERVICES_JSON_SLICE,										'where' => 0,										'delim' => false));					$chrs = substr($str, 1, -1);					$chrs = $this->reduce_string($chrs);					if ($chrs == '') {						if (reset($stk) == SERVICES_JSON_IN_ARR) {							return $arr;						} else {							return $obj;						}					}					//print("\nparsing {$chrs}\n");					$strlen_chrs = strlen($chrs);					for ($c = 0; $c <= $strlen_chrs; ++$c) {						$top = end($stk);						$substr_chrs_c_2 = substr($chrs, $c, 2);						if (($c == $strlen_chrs) || (($chrs{$c} == ',') && ($top['what'] == SERVICES_JSON_SLICE))) {							// found a comma that is not inside a string, array, etc.,							// OR we've reached the end of the character list							$slice = substr($chrs, $top['where'], ($c - $top['where']));							array_push($stk, array('what' => SERVICES_JSON_SLICE, 'where' => ($c + 1), 'delim' => false));							//print("Found split at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");							if (reset($stk) == SERVICES_JSON_IN_ARR) {								// we are in an array, so just push an element onto the stack								array_push($arr, $this->decode($slice));							} elseif (reset($stk) == SERVICES_JSON_IN_OBJ) {								// we are in an object, so figure								// out the property name and set an								// element in an associative array,								// for now								$parts = array();								if (preg_match('/^\s*(["\'].*[^\\\]["\'])\s*:\s*(\S.*),?$/Uis', $slice, $parts)) {									// "name":value pair									$key = $this->decode($parts[1]);									$val = $this->decode($parts[2]);									if ($this->use & SERVICES_JSON_LOOSE_TYPE) {										$obj[$key] = $val;									} else {										$obj->$key = $val;									}								} elseif (preg_match('/^\s*(\w+)\s*:\s*(\S.*),?$/Uis', $slice, $parts)) {									// name:value pair, where name is unquoted									$key = $parts[1];									$val = $this->decode($parts[2]);									if ($this->use & SERVICES_JSON_LOOSE_TYPE) {										$obj[$key] = $val;									} else {										$obj->$key = $val;									}								}							}						} elseif ((($chrs{$c} == '"') || ($chrs{$c} == "'")) && ($top['what'] != SERVICES_JSON_IN_STR)) {							// found a quote, and we are not inside a string							array_push($stk, array('what' => SERVICES_JSON_IN_STR, 'where' => $c, 'delim' => $chrs{$c}));							//print("Found start of string at {$c}\n");						} elseif (($chrs{$c} == $top['delim']) &&								($top['what'] == SERVICES_JSON_IN_STR) &&								((strlen(substr($chrs, 0, $c)) - strlen(rtrim(substr($chrs, 0, $c), '\\'))) % 2 != 1)) {							// found a quote, we're in a string, and it's not escaped							// we know that it's not escaped becase there is _not_ an							// odd number of backslashes at the end of the string so far							array_pop($stk);							//print("Found end of string at {$c}: ".substr($chrs, $top['where'], (1 + 1 + $c - $top['where']))."\n");						} elseif (($chrs{$c} == '[') &&								in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {							// found a left-bracket, and we are in an array, object, or slice							array_push($stk, array('what' => SERVICES_JSON_IN_ARR, 'where' => $c, 'delim' => false));							//print("Found start of array at {$c}\n");						} elseif (($chrs{$c} == ']') && ($top['what'] == SERVICES_JSON_IN_ARR)) {							// found a right-bracket, and we're in an array							array_pop($stk);							//print("Found end of array at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");						} elseif (($chrs{$c} == '{') &&								in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {							// found a left-brace, and we are in an array, object, or slice							array_push($stk, array('what' => SERVICES_JSON_IN_OBJ, 'where' => $c, 'delim' => false));							//print("Found start of object at {$c}\n");						} elseif (($chrs{$c} == '}') && ($top['what'] == SERVICES_JSON_IN_OBJ)) {							// found a right-brace, and we're in an object							array_pop($stk);							//print("Found end of object at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");						} elseif (($substr_chrs_c_2 == '/*') &&								in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {							// found a comment start, and we are in an array, object, or slice							array_push($stk, array('what' => SERVICES_JSON_IN_CMT, 'where' => $c, 'delim' => false));							$c++;							//print("Found start of comment at {$c}\n");						} elseif (($substr_chrs_c_2 == '*/') && ($top['what'] == SERVICES_JSON_IN_CMT)) {							// found a comment end, and we're in one now							array_pop($stk);							$c++;							for ($i = $top['where']; $i <= $c; ++$i)								$chrs = substr_replace($chrs, ' ', $i, 1);							//print("Found end of comment at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");						}					}					if (reset($stk) == SERVICES_JSON_IN_ARR) {						return $arr;					} elseif (reset($stk) == SERVICES_JSON_IN_OBJ) {						return $obj;					}				}		}	}	/**	* @todo Ultimately, this should just call PEAR::isError()	*/	function isError($data, $code = null)	{		if (class_exists('pear')) {			return PEAR::isError($data, $code);		} elseif (is_object($data) && (get_class($data) == 'services_json_error' ||								is_subclass_of($data, 'services_json_error'))) {			return true;		}		return false;	}}if (class_exists('PEAR_Error')) {	class Services_JSON_Error extends PEAR_Error	{		function Services_JSON_Error($message = 'unknown error', $code = null,									$mode = null, $options = null, $userinfo = null)		{			parent::PEAR_Error($message, $code, $mode, $options, $userinfo);		}	}} else {	/**	* @todo Ultimately, this class shall be descended from PEAR_Error	*/	class Services_JSON_Error	{		function Services_JSON_Error($message = 'unknown error', $code = null,									$mode = null, $options = null, $userinfo = null)		{		}	}}endif;?>
<?php/** * The Header for our theme. * * Displays all of the <head> section and everything up till <div id="main"> * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */?><!DOCTYPE html><html <?php language_attributes(); ?>><head><meta charset="<?php bloginfo( 'charset' ); ?>" /><title><?php	/*	 * Print the <title> tag based on what is being viewed.	 * We filter the output of wp_title() a bit -- see	 * twentyten_filter_wp_title() in functions.php.	 */	wp_title( '|', true, 'right' );	?></title><link rel="profile" href="http://gmpg.org/xfn/11" /><link rel="stylesheet" type="text/css" media="all" href="<?php bloginfo( 'stylesheet_url' ); ?>" /><link rel="pingback" href="<?php bloginfo( 'pingback_url' ); ?>" /><?php	/* We add some JavaScript to pages with the comment form	 * to support sites with threaded comments (when in use).	 */	if ( is_singular() && get_option( 'thread_comments' ) )		wp_enqueue_script( 'comment-reply' );	/* Always have wp_head() just before the closing </head>	 * tag of your theme, or you will break many plugins, which	 * generally use this hook to add elements to <head> such	 * as styles, scripts, and meta tags.	 */	wp_head();?></head><body <?php body_class(); ?>><div id="wrapper" class="hfeed">	<div id="header">		<div id="masthead">			<div id="branding" role="banner">				<?php $heading_tag = ( is_home() || is_front_page() ) ? 'h1' : 'div'; ?>				<<?php echo $heading_tag; ?> id="site-title">					<span>						<a href="<?php echo home_url( '/' ); ?>" title="<?php echo esc_attr( get_bloginfo( 'name', 'display' ) ); ?>" rel="home"><?php bloginfo( 'name' ); ?></a>					</span>				</<?php echo $heading_tag; ?>>				<div id="site-description"><?php bloginfo( 'description' ); ?></div>				<?php					// Check if this is a post or page, if it has a thumbnail, and if it's a big one					if ( is_singular() &&							has_post_thumbnail( $post->ID ) &&							( /* $src, $width, $height */ $image = wp_get_attachment_image_src( get_post_thumbnail_id( $post->ID ), 'post-thumbnail' ) ) &&							$image[1] >= HEADER_IMAGE_WIDTH ) :						// Houston, we have a new header image!						echo get_the_post_thumbnail( $post->ID, 'post-thumbnail' );					else : ?>						<img src="<?php header_image(); ?>" width="<?php echo HEADER_IMAGE_WIDTH; ?>" height="<?php echo HEADER_IMAGE_HEIGHT; ?>" alt="" />					<?php endif; ?>			</div><!-- #branding -->			<div id="access" role="navigation">			  <?php /*  Allow screen readers / text browsers to skip the navigation menu and get right to the good stuff */ ?>				<div class="skip-link screen-reader-text"><a href="#content" title="<?php esc_attr_e( 'Skip to content', 'twentyten' ); ?>"><?php _e( 'Skip to content', 'twentyten' ); ?></a></div>				<?php /* Our navigation menu.  If one isn't filled out, wp_nav_menu falls back to wp_page_menu.  The menu assiged to the primary position is the one used.  If none is assigned, the menu with the lowest ID is used.  */ ?>				<?php wp_nav_menu( array( 'container_class' => 'menu-header', 'theme_location' => 'primary' ) ); ?>			</div><!-- #access -->		</div><!-- #masthead -->	</div><!-- #header -->	<div id="main">
<?php/** * WordPress Diff bastard child of old MediaWiki Diff Formatter. * * Basically all that remains is the table structure and some method names. * * @package WordPress * @subpackage Diff */if ( !class_exists( 'Text_Diff' ) ) {	/** Text_Diff class */	require( dirname(__FILE__).'/Text/Diff.php' );	/** Text_Diff_Renderer class */	require( dirname(__FILE__).'/Text/Diff/Renderer.php' );	/** Text_Diff_Renderer_inline class */	require( dirname(__FILE__).'/Text/Diff/Renderer/inline.php' );}/** * Table renderer to display the diff lines. * * @since 2.6.0 * @uses Text_Diff_Renderer Extends */class WP_Text_Diff_Renderer_Table extends Text_Diff_Renderer {	/**	 * @see Text_Diff_Renderer::_leading_context_lines	 * @var int	 * @access protected	 * @since 2.6.0	 */	var $_leading_context_lines  = 10000;	/**	 * @see Text_Diff_Renderer::_trailing_context_lines	 * @var int	 * @access protected	 * @since 2.6.0	 */	var $_trailing_context_lines = 10000;	/**	 * {@internal Missing Description}}	 *	 * @var float	 * @access protected	 * @since 2.6.0	 */	var $_diff_threshold = 0.6;	/**	 * Inline display helper object name.	 *	 * @var string	 * @access protected	 * @since 2.6.0	 */	var $inline_diff_renderer = 'WP_Text_Diff_Renderer_inline';	/**	 * PHP4 Constructor - Call parent constructor with params array.	 *	 * This will set class properties based on the key value pairs in the array.	 *	 * @since unknown	 *	 * @param array $params	 */	function Text_Diff_Renderer_Table( $params = array() ) {		$parent = get_parent_class($this);		$this->$parent( $params );	}	/**	 * @ignore	 *	 * @param string $header	 * @return string	 */	function _startBlock( $header ) {		return '';	}	/**	 * @ignore	 *	 * @param array $lines	 * @param string $prefix	 */	function _lines( $lines, $prefix=' ' ) {	}	/**	 * @ignore	 *	 * @param string $line HTML-escape the value.	 * @return string	 */	function addedLine( $line ) {		return "<td>+</td><td class='diff-addedline'>{$line}</td>";	}	/**	 * @ignore	 *	 * @param string $line HTML-escape the value.	 * @return string	 */	function deletedLine( $line ) {		return "<td>-</td><td class='diff-deletedline'>{$line}</td>";	}	/**	 * @ignore	 *	 * @param string $line HTML-escape the value.	 * @return string	 */	function contextLine( $line ) {		return "<td> </td><td class='diff-context'>{$line}</td>";	}	/**	 * @ignore	 *	 * @return string	 */	function emptyLine() {		return '<td colspan="2">&nbsp;</td>';	}	/**	 * @ignore	 * @access private	 *	 * @param array $lines	 * @param bool $encode	 * @return string	 */	function _added( $lines, $encode = true ) {		$r = '';		foreach ($lines as $line) {			if ( $encode )				$line = htmlspecialchars( $line );			$r .= '<tr>' . $this->emptyLine() . $this->addedLine( $line ) . "</tr>\n";		}		return $r;	}	/**	 * @ignore	 * @access private	 *	 * @param array $lines	 * @param bool $encode	 * @return string	 */	function _deleted( $lines, $encode = true ) {		$r = '';		foreach ($lines as $line) {			if ( $encode )				$line = htmlspecialchars( $line );			$r .= '<tr>' . $this->deletedLine( $line ) . $this->emptyLine() . "</tr>\n";		}		return $r;	}	/**	 * @ignore	 * @access private	 *	 * @param array $lines	 * @param bool $encode	 * @return string	 */	function _context( $lines, $encode = true ) {		$r = '';		foreach ($lines as $line) {			if ( $encode )				$line = htmlspecialchars( $line );			$r .= '<tr>' .				$this->contextLine( $line ) . $this->contextLine( $line ) . "</tr>\n";		}		return $r;	}	/**	 * Process changed lines to do word-by-word diffs for extra highlighting.	 *	 * (TRAC style) sometimes these lines can actually be deleted or added rows.	 * We do additional processing to figure that out	 *	 * @access private	 * @since 2.6.0	 *	 * @param array $orig	 * @param array $final	 * @return string	 */	function _changed( $orig, $final ) {		$r = '';		// Does the aforementioned additional processing		// *_matches tell what rows are "the same" in orig and final.  Those pairs will be diffed to get word changes		//	match is numeric: an index in other column		//	match is 'X': no match.  It is a new row		// *_rows are column vectors for the orig column and the final column.		//	row >= 0: an indix of the $orig or $final array		//	row  < 0: a blank row for that column		list($orig_matches, $final_matches, $orig_rows, $final_rows) = $this->interleave_changed_lines( $orig, $final );		// These will hold the word changes as determined by an inline diff		$orig_diffs  = array();		$final_diffs = array();		// Compute word diffs for each matched pair using the inline diff		foreach ( $orig_matches as $o => $f ) {			if ( is_numeric($o) && is_numeric($f) ) {				$text_diff = new Text_Diff( 'auto', array( array($orig[$o]), array($final[$f]) ) );				$renderer = new $this->inline_diff_renderer;				$diff = $renderer->render( $text_diff );				// If they're too different, don't include any <ins> or <dels>				if ( $diff_count = preg_match_all( '!(<ins>.*?</ins>|<del>.*?</del>)!', $diff, $diff_matches ) ) {					// length of all text between <ins> or <del>					$stripped_matches = strlen(strip_tags( join(' ', $diff_matches[0]) ));					// since we count lengith of text between <ins> or <del> (instead of picking just one),					//	we double the length of chars not in those tags.					$stripped_diff = strlen(strip_tags( $diff )) * 2 - $stripped_matches;					$diff_ratio = $stripped_matches / $stripped_diff;					if ( $diff_ratio > $this->_diff_threshold )						continue; // Too different.  Don't save diffs.				}				// Un-inline the diffs by removing del or ins				$orig_diffs[$o]  = preg_replace( '|<ins>.*?</ins>|', '', $diff );				$final_diffs[$f] = preg_replace( '|<del>.*?</del>|', '', $diff );			}		}		foreach ( array_keys($orig_rows) as $row ) {			// Both columns have blanks.  Ignore them.			if ( $orig_rows[$row] < 0 && $final_rows[$row] < 0 )				continue;			// If we have a word based diff, use it.  Otherwise, use the normal line.			if ( isset( $orig_diffs[$orig_rows[$row]] ) )				$orig_line = $orig_diffs[$orig_rows[$row]];			elseif ( isset( $orig[$orig_rows[$row]] ) )				$orig_line = htmlspecialchars($orig[$orig_rows[$row]]);			else				$orig_line = '';			if ( isset( $final_diffs[$final_rows[$row]] ) )				$final_line = $final_diffs[$final_rows[$row]];			elseif ( isset( $final[$final_rows[$row]] ) )				$final_line = htmlspecialchars($final[$final_rows[$row]]);			else				$final_line = '';			if ( $orig_rows[$row] < 0 ) { // Orig is blank.  This is really an added row.				$r .= $this->_added( array($final_line), false );			} elseif ( $final_rows[$row] < 0 ) { // Final is blank.  This is really a deleted row.				$r .= $this->_deleted( array($orig_line), false );			} else { // A true changed row.				$r .= '<tr>' . $this->deletedLine( $orig_line ) . $this->addedLine( $final_line ) . "</tr>\n";			}		}		return $r;	}	/**	 * Takes changed blocks and matches which rows in orig turned into which rows in final.	 *	 * Returns	 *	*_matches ( which rows match with which )	 *	*_rows ( order of rows in each column interleaved with blank rows as	 *		necessary )	 *	 * @since 2.6.0	 *	 * @param unknown_type $orig	 * @param unknown_type $final	 * @return unknown	 */	function interleave_changed_lines( $orig, $final ) {		// Contains all pairwise string comparisons.  Keys are such that this need only be a one dimensional array.		$matches = array();		foreach ( array_keys($orig) as $o ) {			foreach ( array_keys($final) as $f ) {				$matches["$o,$f"] = $this->compute_string_distance( $orig[$o], $final[$f] );			}		}		asort($matches); // Order by string distance.		$orig_matches  = array();		$final_matches = array();		foreach ( $matches as $keys => $difference ) {			list($o, $f) = explode(',', $keys);			$o = (int) $o;			$f = (int) $f;			// Already have better matches for these guys			if ( isset($orig_matches[$o]) && isset($final_matches[$f]) )				continue;			// First match for these guys.  Must be best match			if ( !isset($orig_matches[$o]) && !isset($final_matches[$f]) ) {				$orig_matches[$o] = $f;				$final_matches[$f] = $o;				continue;			}			// Best match of this final is already taken?  Must mean this final is a new row.			if ( isset($orig_matches[$o]) )				$final_matches[$f] = 'x';			// Best match of this orig is already taken?  Must mean this orig is a deleted row.			elseif ( isset($final_matches[$f]) )				$orig_matches[$o] = 'x';		}		// We read the text in this order		ksort($orig_matches);		ksort($final_matches);		// Stores rows and blanks for each column.		$orig_rows = $orig_rows_copy = array_keys($orig_matches);		$final_rows = array_keys($final_matches);		// Interleaves rows with blanks to keep matches aligned.		// We may end up with some extraneous blank rows, but we'll just ignore them later.		foreach ( $orig_rows_copy as $orig_row ) {			$final_pos = array_search($orig_matches[$orig_row], $final_rows, true);			$orig_pos = (int) array_search($orig_row, $orig_rows, true);			if ( false === $final_pos ) { // This orig is paired with a blank final.				array_splice( $final_rows, $orig_pos, 0, -1 );			} elseif ( $final_pos < $orig_pos ) { // This orig's match is up a ways.  Pad final with blank rows.				$diff_pos = $final_pos - $orig_pos;				while ( $diff_pos < 0 )					array_splice( $final_rows, $orig_pos, 0, $diff_pos++ );			} elseif ( $final_pos > $orig_pos ) { // This orig's match is down a ways.  Pad orig with blank rows.				$diff_pos = $orig_pos - $final_pos;				while ( $diff_pos < 0 )					array_splice( $orig_rows, $orig_pos, 0, $diff_pos++ );			}		}		// Pad the ends with blank rows if the columns aren't the same length		$diff_count = count($orig_rows) - count($final_rows);		if ( $diff_count < 0 ) {			while ( $diff_count < 0 )				array_push($orig_rows, $diff_count++);		} elseif ( $diff_count > 0 ) {			$diff_count = -1 * $diff_count;			while ( $diff_count < 0 )				array_push($final_rows, $diff_count++);		}		return array($orig_matches, $final_matches, $orig_rows, $final_rows);/*		// Debug		echo "\n\n\n\n\n";		echo "-- DEBUG Matches: Orig -> Final --";		foreach ( $orig_matches as $o => $f ) {			echo "\n\n\n\n\n";			echo "ORIG: $o, FINAL: $f\n";			var_dump($orig[$o],$final[$f]);		}		echo "\n\n\n\n\n";		echo "-- DEBUG Matches: Final -> Orig --";		foreach ( $final_matches as $f => $o ) {			echo "\n\n\n\n\n";			echo "FINAL: $f, ORIG: $o\n";			var_dump($final[$f],$orig[$o]);		}		echo "\n\n\n\n\n";		echo "-- DEBUG Rows: Orig -- Final --";		echo "\n\n\n\n\n";		foreach ( $orig_rows as $row => $o ) {			if ( $o < 0 )				$o = 'X';			$f = $final_rows[$row];			if ( $f < 0 )				$f = 'X';			echo "$o -- $f\n";		}		echo "\n\n\n\n\n";		echo "-- END DEBUG --";		echo "\n\n\n\n\n";		return array($orig_matches, $final_matches, $orig_rows, $final_rows);*/	}	/**	 * Computes a number that is intended to reflect the "distance" between two strings.	 *	 * @since 2.6.0	 *	 * @param string $string1	 * @param string $string2	 * @return int	 */	function compute_string_distance( $string1, $string2 ) {		// Vectors containing character frequency for all chars in each string		$chars1 = count_chars($string1);		$chars2 = count_chars($string2);		// L1-norm of difference vector.		$difference = array_sum( array_map( array(&$this, 'difference'), $chars1, $chars2 ) );		// $string1 has zero length? Odd.  Give huge penalty by not dividing.		if ( !$string1 )			return $difference;		// Return distance per charcter (of string1)		return $difference / strlen($string1);	}	/**	 * @ignore	 * @since 2.6.0	 *	 * @param int $a	 * @param int $b	 * @return int	 */	function difference( $a, $b ) {		return abs( $a - $b );	}}/** * Better word splitting than the PEAR package provides. * * @since 2.6.0 * @uses Text_Diff_Renderer_inline Extends */class WP_Text_Diff_Renderer_inline extends Text_Diff_Renderer_inline {	/**	 * @ignore	 * @since 2.6.0	 *	 * @param string $string	 * @param string $newlineEscape	 * @return string	 */	function _splitOnWords($string, $newlineEscape = "\n") {		$string = str_replace("\0", '', $string);		$words  = preg_split( '/([^\w])/u', $string, -1, PREG_SPLIT_DELIM_CAPTURE );		$words  = str_replace( "\n", $newlineEscape, $words );		return $words;	}}?>
<?php/** * Includes all of the WordPress Administration API files. * * @package WordPress * @subpackage Administration *//** WordPress Bookmark Administration API */require_once(ABSPATH . 'wp-admin/includes/bookmark.php');/** WordPress Comment Administration API */require_once(ABSPATH . 'wp-admin/includes/comment.php');/** WordPress Administration File API */require_once(ABSPATH . 'wp-admin/includes/file.php');/** WordPress Image Administration API */require_once(ABSPATH . 'wp-admin/includes/image.php');/** WordPress Media Administration API */require_once(ABSPATH . 'wp-admin/includes/media.php');/** WordPress Import Administration API */require_once(ABSPATH . 'wp-admin/includes/import.php');/** WordPress Misc Administration API */require_once(ABSPATH . 'wp-admin/includes/misc.php');/** WordPress Plugin Administration API */require_once(ABSPATH . 'wp-admin/includes/plugin.php');/** WordPress Post Administration API */require_once(ABSPATH . 'wp-admin/includes/post.php');/** WordPress Taxonomy Administration API */require_once(ABSPATH . 'wp-admin/includes/taxonomy.php');/** WordPress Template Administration API */require_once(ABSPATH . 'wp-admin/includes/template.php');/** WordPress Theme Administration API */require_once(ABSPATH . 'wp-admin/includes/theme.php');/** WordPress User Administration API */require_once(ABSPATH . 'wp-admin/includes/user.php');/** WordPress Update Administration API */require_once(ABSPATH . 'wp-admin/includes/update.php');/** WordPress Registration API */require_once(ABSPATH . WPINC . '/registration.php');/** WordPress Deprecated Administration API */require_once(ABSPATH . 'wp-admin/includes/deprecated.php');/** WordPress Multi-Site support API */if ( is_multisite() ) {	require_once(ABSPATH . 'wp-admin/includes/ms.php');	require_once(ABSPATH . 'wp-admin/includes/ms-deprecated.php');}?>
<?php/** * Redirects to the Comments RSS2 feed * This file is deprecated and only exists for backwards compatibility * * @package WordPress */require( './wp-load.php' );wp_redirect( get_bloginfo( 'comments_rss2_url' ), 301 );?>
<?php/** * Front to the WordPress application. This file doesn't do anything, but loads * wp-blog-header.php which does and tells WordPress to load the theme. * * @package WordPress *//** * Tells WordPress to load the WordPress theme and output it. * * @var bool */define('WP_USE_THEMES', true);/** Loads the WordPress Environment and Template */require('./wp-blog-header.php');?>
<?php/** * Class used internally by Diff to actually compute the diffs. * * This class uses the Unix `diff` program via shell_exec to compute the * differences between the two input arrays. * * Copyright 2007-2010 The Horde Project (http://www.horde.org/) * * See the enclosed file COPYING for license information (LGPL). If you did * not receive this file, see http://opensource.org/licenses/lgpl-license.php. * * @author  Milian Wolff <mail@milianw.de> * @package Text_Diff * @since   0.3.0 */class Text_Diff_Engine_shell {    /**     * Path to the diff executable     *     * @var string     */    var $_diffCommand = 'diff';    /**     * Returns the array of differences.     *     * @param array $from_lines lines of text from old file     * @param array $to_lines   lines of text from new file     *     * @return array all changes made (array with Text_Diff_Op_* objects)     */    function diff($from_lines, $to_lines)    {        array_walk($from_lines, array('Text_Diff', 'trimNewlines'));        array_walk($to_lines, array('Text_Diff', 'trimNewlines'));        $temp_dir = Text_Diff::_getTempDir();        // Execute gnu diff or similar to get a standard diff file.        $from_file = tempnam($temp_dir, 'Text_Diff');        $to_file = tempnam($temp_dir, 'Text_Diff');        $fp = fopen($from_file, 'w');        fwrite($fp, implode("\n", $from_lines));        fclose($fp);        $fp = fopen($to_file, 'w');        fwrite($fp, implode("\n", $to_lines));        fclose($fp);        $diff = shell_exec($this->_diffCommand . ' ' . $from_file . ' ' . $to_file);        unlink($from_file);        unlink($to_file);        if (is_null($diff)) {            // No changes were made            return array(new Text_Diff_Op_copy($from_lines));        }        $from_line_no = 1;        $to_line_no = 1;        $edits = array();        // Get changed lines by parsing something like:        // 0a1,2        // 1,2c4,6        // 1,5d6        preg_match_all('#^(\d+)(?:,(\d+))?([adc])(\d+)(?:,(\d+))?$#m', $diff,            $matches, PREG_SET_ORDER);        foreach ($matches as $match) {            if (!isset($match[5])) {                // This paren is not set every time (see regex).                $match[5] = false;            }            if ($match[3] == 'a') {                $from_line_no--;            }            if ($match[3] == 'd') {                $to_line_no--;            }            if ($from_line_no < $match[1] || $to_line_no < $match[4]) {                // copied lines                assert('$match[1] - $from_line_no == $match[4] - $to_line_no');                array_push($edits,                    new Text_Diff_Op_copy(                        $this->_getLines($from_lines, $from_line_no, $match[1] - 1),                        $this->_getLines($to_lines, $to_line_no, $match[4] - 1)));            }            switch ($match[3]) {            case 'd':                // deleted lines                array_push($edits,                    new Text_Diff_Op_delete(                        $this->_getLines($from_lines, $from_line_no, $match[2])));                $to_line_no++;                break;            case 'c':                // changed lines                array_push($edits,                    new Text_Diff_Op_change(                        $this->_getLines($from_lines, $from_line_no, $match[2]),                        $this->_getLines($to_lines, $to_line_no, $match[5])));                break;            case 'a':                // added lines                array_push($edits,                    new Text_Diff_Op_add(                        $this->_getLines($to_lines, $to_line_no, $match[5])));                $from_line_no++;                break;            }        }        if (!empty($from_lines)) {            // Some lines might still be pending. Add them as copied            array_push($edits,                new Text_Diff_Op_copy(                    $this->_getLines($from_lines, $from_line_no,                                     $from_line_no + count($from_lines) - 1),                    $this->_getLines($to_lines, $to_line_no,                                     $to_line_no + count($to_lines) - 1)));        }        return $edits;    }    /**     * Get lines from either the old or new text     *     * @access private     *     * @param array &$text_lines Either $from_lines or $to_lines     * @param int   &$line_no    Current line number     * @param int   $end         Optional end line, when we want to chop more     *                           than one line.     *     * @return array The chopped lines     */    function _getLines(&$text_lines, &$line_no, $end = false)    {        if (!empty($end)) {            $lines = array();            // We can shift even more            while ($line_no <= $end) {                array_push($lines, array_shift($text_lines));                $line_no++;            }        } else {            $lines = array(array_shift($text_lines));            $line_no++;        }        return $lines;    }}
<?php/** * The plugin API is located in this file, which allows for creating actions * and filters and hooking functions, and methods. The functions or methods will * then be run when the action or filter is called. * * The API callback examples reference functions, but can be methods of classes. * To hook methods, you'll need to pass an array one of two ways. * * Any of the syntaxes explained in the PHP documentation for the * {@link http://us2.php.net/manual/en/language.pseudo-types.php#language.types.callback 'callback'} * type are valid. * * Also see the {@link http://codex.wordpress.org/Plugin_API Plugin API} for * more information and examples on how to use a lot of these functions. * * @package WordPress * @subpackage Plugin * @since 1.5 *//** * Hooks a function or method to a specific filter action. * * Filters are the hooks that WordPress launches to modify text of various types * before adding it to the database or sending it to the browser screen. Plugins * can specify that one or more of its PHP functions is executed to * modify specific types of text at these times, using the Filter API. * * To use the API, the following code should be used to bind a callback to the * filter. * * <code> * function example_hook($example) { echo $example; } * add_filter('example_filter', 'example_hook'); * </code> * * In WordPress 1.5.1+, hooked functions can take extra arguments that are set * when the matching do_action() or apply_filters() call is run. The * $accepted_args allow for calling functions only when the number of args * match. Hooked functions can take extra arguments that are set when the * matching do_action() or apply_filters() call is run. For example, the action * comment_id_not_found will pass any functions that hook onto it the ID of the * requested comment. * * <strong>Note:</strong> the function will return true no matter if the * function was hooked fails or not. There are no checks for whether the * function exists beforehand and no checks to whether the <tt>$function_to_add * is even a string. It is up to you to take care and this is done for * optimization purposes, so everything is as quick as possible. * * @package WordPress * @subpackage Plugin * @since 0.71 * @global array $wp_filter Stores all of the filters added in the form of *	wp_filter['tag']['array of priorities']['array of functions serialized']['array of ['array (functions, accepted_args)']'] * @global array $merged_filters Tracks the tags that need to be merged for later. If the hook is added, it doesn't need to run through that process. * * @param string $tag The name of the filter to hook the $function_to_add to. * @param callback $function_to_add The name of the function to be called when the filter is applied. * @param int $priority optional. Used to specify the order in which the functions associated with a particular action are executed (default: 10). Lower numbers correspond with earlier execution, and functions with the same priority are executed in the order in which they were added to the action. * @param int $accepted_args optional. The number of arguments the function accept (default 1). * @return boolean true */function add_filter($tag, $function_to_add, $priority = 10, $accepted_args = 1) {	global $wp_filter, $merged_filters;	$idx = _wp_filter_build_unique_id($tag, $function_to_add, $priority);	$wp_filter[$tag][$priority][$idx] = array('function' => $function_to_add, 'accepted_args' => $accepted_args);	unset( $merged_filters[ $tag ] );	return true;}/** * Check if any filter has been registered for a hook. * * @package WordPress * @subpackage Plugin * @since 2.5 * @global array $wp_filter Stores all of the filters * * @param string $tag The name of the filter hook. * @param callback $function_to_check optional.  If specified, return the priority of that function on this hook or false if not attached. * @return int|boolean Optionally returns the priority on that hook for the specified function. */function has_filter($tag, $function_to_check = false) {	global $wp_filter;	$has = !empty($wp_filter[$tag]);	if ( false === $function_to_check || false == $has )		return $has;	if ( !$idx = _wp_filter_build_unique_id($tag, $function_to_check, false) )		return false;	foreach ( (array) array_keys($wp_filter[$tag]) as $priority ) {		if ( isset($wp_filter[$tag][$priority][$idx]) )			return $priority;	}	return false;}/** * Call the functions added to a filter hook. * * The callback functions attached to filter hook $tag are invoked by calling * this function. This function can be used to create a new filter hook by * simply calling this function with the name of the new hook specified using * the $tag parameter. * * The function allows for additional arguments to be added and passed to hooks. * <code> * function example_hook($string, $arg1, $arg2) * { *		//Do stuff *		return $string; * } * $value = apply_filters('example_filter', 'filter me', 'arg1', 'arg2'); * </code> * * @package WordPress * @subpackage Plugin * @since 0.71 * @global array $wp_filter Stores all of the filters * @global array $merged_filters Merges the filter hooks using this function. * @global array $wp_current_filter stores the list of current filters with the current one last * * @param string $tag The name of the filter hook. * @param mixed $value The value on which the filters hooked to <tt>$tag</tt> are applied on. * @param mixed $var,... Additional variables passed to the functions hooked to <tt>$tag</tt>. * @return mixed The filtered value after all hooked functions are applied to it. */function apply_filters($tag, $value) {	global $wp_filter, $merged_filters, $wp_current_filter;	$args = array();	$wp_current_filter[] = $tag;	// Do 'all' actions first	if ( isset($wp_filter['all']) ) {		$args = func_get_args();		_wp_call_all_hook($args);	}	if ( !isset($wp_filter[$tag]) ) {		array_pop($wp_current_filter);		return $value;	}	// Sort	if ( !isset( $merged_filters[ $tag ] ) ) {		ksort($wp_filter[$tag]);		$merged_filters[ $tag ] = true;	}	reset( $wp_filter[ $tag ] );	if ( empty($args) )		$args = func_get_args();	do {		foreach( (array) current($wp_filter[$tag]) as $the_ )			if ( !is_null($the_['function']) ){				$args[1] = $value;				$value = call_user_func_array($the_['function'], array_slice($args, 1, (int) $the_['accepted_args']));			}	} while ( next($wp_filter[$tag]) !== false );	array_pop( $wp_current_filter );	return $value;}/** * Execute functions hooked on a specific filter hook, specifying arguments in an array. * * @see apply_filters() This function is identical, but the arguments passed to the * functions hooked to <tt>$tag</tt> are supplied using an array. * * @package WordPress * @subpackage Plugin * @since 3.0.0 * @global array $wp_filter Stores all of the filters * @global array $merged_filters Merges the filter hooks using this function. * @global array $wp_current_filter stores the list of current filters with the current one last * * @param string $tag The name of the filter hook. * @param array $args The arguments supplied to the functions hooked to <tt>$tag</tt> * @return mixed The filtered value after all hooked functions are applied to it. */function apply_filters_ref_array($tag, $args) {	global $wp_filter, $merged_filters, $wp_current_filter;	$wp_current_filter[] = $tag;	// Do 'all' actions first	if ( isset($wp_filter['all']) ) {		$all_args = func_get_args();		_wp_call_all_hook($all_args);	}	if ( !isset($wp_filter[$tag]) ) {		array_pop($wp_current_filter);		return $args[0];	}	// Sort	if ( !isset( $merged_filters[ $tag ] ) ) {		ksort($wp_filter[$tag]);		$merged_filters[ $tag ] = true;	}	reset( $wp_filter[ $tag ] );	do {		foreach( (array) current($wp_filter[$tag]) as $the_ )			if ( !is_null($the_['function']) )				$args[0] = call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));	} while ( next($wp_filter[$tag]) !== false );	array_pop( $wp_current_filter );	return $args[0];}/** * Removes a function from a specified filter hook. * * This function removes a function attached to a specified filter hook. This * method can be used to remove default functions attached to a specific filter * hook and possibly replace them with a substitute. * * To remove a hook, the $function_to_remove and $priority arguments must match * when the hook was added. This goes for both filters and actions. No warning * will be given on removal failure. * * @package WordPress * @subpackage Plugin * @since 1.2 * * @param string $tag The filter hook to which the function to be removed is hooked. * @param callback $function_to_remove The name of the function which should be removed. * @param int $priority optional. The priority of the function (default: 10). * @param int $accepted_args optional. The number of arguments the function accpets (default: 1). * @return boolean Whether the function existed before it was removed. */function remove_filter($tag, $function_to_remove, $priority = 10, $accepted_args = 1) {	$function_to_remove = _wp_filter_build_unique_id($tag, $function_to_remove, $priority);	$r = isset($GLOBALS['wp_filter'][$tag][$priority][$function_to_remove]);	if ( true === $r) {		unset($GLOBALS['wp_filter'][$tag][$priority][$function_to_remove]);		if ( empty($GLOBALS['wp_filter'][$tag][$priority]) )			unset($GLOBALS['wp_filter'][$tag][$priority]);		unset($GLOBALS['merged_filters'][$tag]);	}	return $r;}/** * Remove all of the hooks from a filter. * * @since 2.7 * * @param string $tag The filter to remove hooks from. * @param int $priority The priority number to remove. * @return bool True when finished. */function remove_all_filters($tag, $priority = false) {	global $wp_filter, $merged_filters;	if( isset($wp_filter[$tag]) ) {		if( false !== $priority && isset($wp_filter[$tag][$priority]) )			unset($wp_filter[$tag][$priority]);		else			unset($wp_filter[$tag]);	}	if( isset($merged_filters[$tag]) )		unset($merged_filters[$tag]);	return true;}/** * Retrieve the name of the current filter or action. * * @package WordPress * @subpackage Plugin * @since 2.5 * * @return string Hook name of the current filter or action. */function current_filter() {	global $wp_current_filter;	return end( $wp_current_filter );}/** * Hooks a function on to a specific action. * * Actions are the hooks that the WordPress core launches at specific points * during execution, or when specific events occur. Plugins can specify that * one or more of its PHP functions are executed at these points, using the * Action API. * * @uses add_filter() Adds an action. Parameter list and functionality are the same. * * @package WordPress * @subpackage Plugin * @since 1.2 * * @param string $tag The name of the action to which the $function_to_add is hooked. * @param callback $function_to_add The name of the function you wish to be called. * @param int $priority optional. Used to specify the order in which the functions associated with a particular action are executed (default: 10). Lower numbers correspond with earlier execution, and functions with the same priority are executed in the order in which they were added to the action. * @param int $accepted_args optional. The number of arguments the function accept (default 1). */function add_action($tag, $function_to_add, $priority = 10, $accepted_args = 1) {	return add_filter($tag, $function_to_add, $priority, $accepted_args);}/** * Execute functions hooked on a specific action hook. * * This function invokes all functions attached to action hook $tag. It is * possible to create new action hooks by simply calling this function, * specifying the name of the new hook using the <tt>$tag</tt> parameter. * * You can pass extra arguments to the hooks, much like you can with * apply_filters(). * * @see apply_filters() This function works similar with the exception that * nothing is returned and only the functions or methods are called. * * @package WordPress * @subpackage Plugin * @since 1.2 * @global array $wp_filter Stores all of the filters * @global array $wp_actions Increments the amount of times action was triggered. * * @param string $tag The name of the action to be executed. * @param mixed $arg,... Optional additional arguments which are passed on to the functions hooked to the action. * @return null Will return null if $tag does not exist in $wp_filter array */function do_action($tag, $arg = '') {	global $wp_filter, $wp_actions, $merged_filters, $wp_current_filter;	if ( ! isset($wp_actions) )		$wp_actions = array();	if ( ! isset($wp_actions[$tag]) )		$wp_actions[$tag] = 1;	else		++$wp_actions[$tag];	$wp_current_filter[] = $tag;	// Do 'all' actions first	if ( isset($wp_filter['all']) ) {		$all_args = func_get_args();		_wp_call_all_hook($all_args);	}	if ( !isset($wp_filter[$tag]) ) {		array_pop($wp_current_filter);		return;	}	$args = array();	if ( is_array($arg) && 1 == count($arg) && isset($arg[0]) && is_object($arg[0]) ) // array(&$this)		$args[] =& $arg[0];	else		$args[] = $arg;	for ( $a = 2; $a < func_num_args(); $a++ )		$args[] = func_get_arg($a);	// Sort	if ( !isset( $merged_filters[ $tag ] ) ) {		ksort($wp_filter[$tag]);		$merged_filters[ $tag ] = true;	}	reset( $wp_filter[ $tag ] );	do {		foreach ( (array) current($wp_filter[$tag]) as $the_ )			if ( !is_null($the_['function']) )				call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));	} while ( next($wp_filter[$tag]) !== false );	array_pop($wp_current_filter);}/** * Retrieve the number times an action is fired. * * @package WordPress * @subpackage Plugin * @since 2.1 * @global array $wp_actions Increments the amount of times action was triggered. * * @param string $tag The name of the action hook. * @return int The number of times action hook <tt>$tag</tt> is fired */function did_action($tag) {	global $wp_actions;	if ( ! isset( $wp_actions ) || ! isset( $wp_actions[$tag] ) )		return 0;	return $wp_actions[$tag];}/** * Execute functions hooked on a specific action hook, specifying arguments in an array. * * @see do_action() This function is identical, but the arguments passed to the * functions hooked to <tt>$tag</tt> are supplied using an array. * * @package WordPress * @subpackage Plugin * @since 2.1 * @global array $wp_filter Stores all of the filters * @global array $wp_actions Increments the amount of times action was triggered. * * @param string $tag The name of the action to be executed. * @param array $args The arguments supplied to the functions hooked to <tt>$tag</tt> * @return null Will return null if $tag does not exist in $wp_filter array */function do_action_ref_array($tag, $args) {	global $wp_filter, $wp_actions, $merged_filters, $wp_current_filter;	if ( ! isset($wp_actions) )		$wp_actions = array();	if ( ! isset($wp_actions[$tag]) )		$wp_actions[$tag] = 1;	else		++$wp_actions[$tag];	$wp_current_filter[] = $tag;	// Do 'all' actions first	if ( isset($wp_filter['all']) ) {		$all_args = func_get_args();		_wp_call_all_hook($all_args);	}	if ( !isset($wp_filter[$tag]) ) {		array_pop($wp_current_filter);		return;	}	// Sort	if ( !isset( $merged_filters[ $tag ] ) ) {		ksort($wp_filter[$tag]);		$merged_filters[ $tag ] = true;	}	reset( $wp_filter[ $tag ] );	do {		foreach( (array) current($wp_filter[$tag]) as $the_ )			if ( !is_null($the_['function']) )				call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));	} while ( next($wp_filter[$tag]) !== false );	array_pop($wp_current_filter);}/** * Check if any action has been registered for a hook. * * @package WordPress * @subpackage Plugin * @since 2.5 * @see has_filter() has_action() is an alias of has_filter(). * * @param string $tag The name of the action hook. * @param callback $function_to_check optional.  If specified, return the priority of that function on this hook or false if not attached. * @return int|boolean Optionally returns the priority on that hook for the specified function. */function has_action($tag, $function_to_check = false) {	return has_filter($tag, $function_to_check);}/** * Removes a function from a specified action hook. * * This function removes a function attached to a specified action hook. This * method can be used to remove default functions attached to a specific filter * hook and possibly replace them with a substitute. * * @package WordPress * @subpackage Plugin * @since 1.2 * * @param string $tag The action hook to which the function to be removed is hooked. * @param callback $function_to_remove The name of the function which should be removed. * @param int $priority optional The priority of the function (default: 10). * @param int $accepted_args optional. The number of arguments the function accpets (default: 1). * @return boolean Whether the function is removed. */function remove_action($tag, $function_to_remove, $priority = 10, $accepted_args = 1) {	return remove_filter($tag, $function_to_remove, $priority, $accepted_args);}/** * Remove all of the hooks from an action. * * @since 2.7 * * @param string $tag The action to remove hooks from. * @param int $priority The priority number to remove them from. * @return bool True when finished. */function remove_all_actions($tag, $priority = false) {	return remove_all_filters($tag, $priority);}//// Functions for handling plugins.///** * Gets the basename of a plugin. * * This method extracts the name of a plugin from its filename. * * @package WordPress * @subpackage Plugin * @since 1.5 * * @access private * * @param string $file The filename of plugin. * @return string The name of a plugin. * @uses WP_PLUGIN_DIR */function plugin_basename($file) {	$file = str_replace('\\','/',$file); // sanitize for Win32 installs	$file = preg_replace('|/+|','/', $file); // remove any duplicate slash	$plugin_dir = str_replace('\\','/',WP_PLUGIN_DIR); // sanitize for Win32 installs	$plugin_dir = preg_replace('|/+|','/', $plugin_dir); // remove any duplicate slash	$mu_plugin_dir = str_replace('\\','/',WPMU_PLUGIN_DIR); // sanitize for Win32 installs	$mu_plugin_dir = preg_replace('|/+|','/', $mu_plugin_dir); // remove any duplicate slash	$file = preg_replace('#^' . preg_quote($plugin_dir, '#') . '/|^' . preg_quote($mu_plugin_dir, '#') . '/#','',$file); // get relative path from plugins dir	$file = trim($file, '/');	return $file;}/** * Gets the filesystem directory path (with trailing slash) for the plugin __FILE__ passed in * @package WordPress * @subpackage Plugin * @since 2.8 * * @param string $file The filename of the plugin (__FILE__) * @return string the filesystem path of the directory that contains the plugin */function plugin_dir_path( $file ) {	return trailingslashit( dirname( $file ) );}/** * Gets the URL directory path (with trailing slash) for the plugin __FILE__ passed in * @package WordPress * @subpackage Plugin * @since 2.8 * * @param string $file The filename of the plugin (__FILE__) * @return string the URL path of the directory that contains the plugin */function plugin_dir_url( $file ) {	return trailingslashit( plugins_url( '', $file ) );}/** * Set the activation hook for a plugin. * * When a plugin is activated, the action 'activate_PLUGINNAME' hook is * activated. In the name of this hook, PLUGINNAME is replaced with the name of * the plugin, including the optional subdirectory. For example, when the plugin * is located in wp-content/plugin/sampleplugin/sample.php, then the name of * this hook will become 'activate_sampleplugin/sample.php'. When the plugin * consists of only one file and is (as by default) located at * wp-content/plugin/sample.php the name of this hook will be * 'activate_sample.php'. * * @package WordPress * @subpackage Plugin * @since 2.0 * * @param string $file The filename of the plugin including the path. * @param callback $function the function hooked to the 'activate_PLUGIN' action. */function register_activation_hook($file, $function) {	$file = plugin_basename($file);	add_action('activate_' . $file, $function);}/** * Set the deactivation hook for a plugin. * * When a plugin is deactivated, the action 'deactivate_PLUGINNAME' hook is * deactivated. In the name of this hook, PLUGINNAME is replaced with the name * of the plugin, including the optional subdirectory. For example, when the * plugin is located in wp-content/plugin/sampleplugin/sample.php, then * the name of this hook will become 'activate_sampleplugin/sample.php'. * * When the plugin consists of only one file and is (as by default) located at * wp-content/plugin/sample.php the name of this hook will be * 'activate_sample.php'. * * @package WordPress * @subpackage Plugin * @since 2.0 * * @param string $file The filename of the plugin including the path. * @param callback $function the function hooked to the 'activate_PLUGIN' action. */function register_deactivation_hook($file, $function) {	$file = plugin_basename($file);	add_action('deactivate_' . $file, $function);}/** * Set the uninstallation hook for a plugin. * * Registers the uninstall hook that will be called when the user clicks on the * uninstall link that calls for the plugin to uninstall itself. The link won't * be active unless the plugin hooks into the action. * * The plugin should not run arbitrary code outside of functions, when * registering the uninstall hook. In order to run using the hook, the plugin * will have to be included, which means that any code laying outside of a * function will be run during the uninstall process. The plugin should not * hinder the uninstall process. * * If the plugin can not be written without running code within the plugin, then * the plugin should create a file named 'uninstall.php' in the base plugin * folder. This file will be called, if it exists, during the uninstall process * bypassing the uninstall hook. The plugin, when using the 'uninstall.php' * should always check for the 'WP_UNINSTALL_PLUGIN' constant, before * executing. * * @since 2.7 * * @param string $file * @param callback $callback The callback to run when the hook is called. */function register_uninstall_hook($file, $callback) {	// The option should not be autoloaded, because it is not needed in most	// cases. Emphasis should be put on using the 'uninstall.php' way of	// uninstalling the plugin.	$uninstallable_plugins = (array) get_option('uninstall_plugins');	$uninstallable_plugins[plugin_basename($file)] = $callback;	update_option('uninstall_plugins', $uninstallable_plugins);}/** * Calls the 'all' hook, which will process the functions hooked into it. * * The 'all' hook passes all of the arguments or parameters that were used for * the hook, which this function was called for. * * This function is used internally for apply_filters(), do_action(), and * do_action_ref_array() and is not meant to be used from outside those * functions. This function does not check for the existence of the all hook, so * it will fail unless the all hook exists prior to this function call. * * @package WordPress * @subpackage Plugin * @since 2.5 * @access private * * @uses $wp_filter Used to process all of the functions in the 'all' hook * * @param array $args The collected parameters from the hook that was called. * @param string $hook Optional. The hook name that was used to call the 'all' hook. */function _wp_call_all_hook($args) {	global $wp_filter;	reset( $wp_filter['all'] );	do {		foreach( (array) current($wp_filter['all']) as $the_ )			if ( !is_null($the_['function']) )				call_user_func_array($the_['function'], $args);	} while ( next($wp_filter['all']) !== false );}/** * Build Unique ID for storage and retrieval. * * The old way to serialize the callback caused issues and this function is the * solution. It works by checking for objects and creating an a new property in * the class to keep track of the object and new objects of the same class that * need to be added. * * It also allows for the removal of actions and filters for objects after they * change class properties. It is possible to include the property $wp_filter_id * in your class and set it to "null" or a number to bypass the workaround. * However this will prevent you from adding new classes and any new classes * will overwrite the previous hook by the same class. * * Functions and static method callbacks are just returned as strings and * shouldn't have any speed penalty. * * @package WordPress * @subpackage Plugin * @access private * @since 2.2.3 * @link http://trac.wordpress.org/ticket/3875 * * @global array $wp_filter Storage for all of the filters and actions * @param string $tag Used in counting how many hooks were applied * @param callback $function Used for creating unique id * @param int|bool $priority Used in counting how many hooks were applied.  If === false and $function is an object reference, we return the unique id only if it already has one, false otherwise. * @param string $type filter or action * @return string|bool Unique ID for usage as array key or false if $priority === false and $function is an object reference, and it does not already have a uniqe id. */function _wp_filter_build_unique_id($tag, $function, $priority) {	global $wp_filter;	static $filter_id_count = 0;	if ( is_string($function) )		return $function;	if ( is_object($function) ) {		// Closures are currently implemented as objects		$function = array( $function, '' );	} else {		$function = (array) $function;	}	if (is_object($function[0]) ) {		// Object Class Calling		if ( function_exists('spl_object_hash') ) {			return spl_object_hash($function[0]) . $function[1];		} else {			$obj_idx = get_class($function[0]).$function[1];			if ( !isset($function[0]->wp_filter_id) ) {				if ( false === $priority )					return false;				$obj_idx .= isset($wp_filter[$tag][$priority]) ? count((array)$wp_filter[$tag][$priority]) : $filter_id_count;				$function[0]->wp_filter_id = $filter_id_count;				++$filter_id_count;			} else {				$obj_idx .= $function[0]->wp_filter_id;			}			return $obj_idx;		}	} else if ( is_string($function[0]) ) {		// Static Calling		return $function[0].$function[1];	}}?>
<?php/** * WordPress Bookmark Administration API * * @package WordPress * @subpackage Administration *//** * {@internal Missing Short Description}} * * @since unknown * * @return unknown */function add_link() {	return edit_link();}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $link_id * @return unknown */function edit_link( $link_id = '' ) {	if (!current_user_can( 'manage_links' ))		wp_die( __( 'Cheatin&#8217; uh?' ));	$_POST['link_url'] = esc_html( $_POST['link_url'] );	$_POST['link_url'] = esc_url($_POST['link_url']);	$_POST['link_name'] = esc_html( $_POST['link_name'] );	$_POST['link_image'] = esc_html( $_POST['link_image'] );	$_POST['link_rss'] = esc_url($_POST['link_rss']);	if ( !isset($_POST['link_visible']) || 'N' != $_POST['link_visible'] )		$_POST['link_visible'] = 'Y';	if ( !empty( $link_id ) ) {		$_POST['link_id'] = $link_id;		return wp_update_link( $_POST);	} else {		return wp_insert_link( $_POST);	}}/** * {@internal Missing Short Description}} * * @since unknown * * @return unknown */function get_default_link_to_edit() {	if ( isset( $_GET['linkurl'] ) )		$link->link_url = esc_url( $_GET['linkurl']);	else		$link->link_url = '';	if ( isset( $_GET['name'] ) )		$link->link_name = esc_attr( $_GET['name']);	else		$link->link_name = '';	$link->link_visible = 'Y';	return $link;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $link_id * @return unknown */function wp_delete_link( $link_id ) {	global $wpdb;	do_action( 'delete_link', $link_id );	wp_delete_object_term_relationships( $link_id, 'link_category' );	$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->links WHERE link_id = %d", $link_id ) );	do_action( 'deleted_link', $link_id );	clean_bookmark_cache( $link_id );	return true;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $link_id * @return unknown */function wp_get_link_cats( $link_id = 0 ) {	$cats = wp_get_object_terms( $link_id, 'link_category', array('fields' => 'ids') );	return array_unique( $cats );}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $link_id * @return unknown */function get_link_to_edit( $link_id ) {	return get_bookmark( $link_id, OBJECT, 'edit' );}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $linkdata * @return unknown */function wp_insert_link( $linkdata, $wp_error = false ) {	global $wpdb, $current_user;	$defaults = array( 'link_id' => 0, 'link_name' => '', 'link_url' => '', 'link_rating' => 0 );	$linkdata = wp_parse_args( $linkdata, $defaults );	$linkdata = sanitize_bookmark( $linkdata, 'db' );	extract( stripslashes_deep( $linkdata ), EXTR_SKIP );	$update = false;	if ( !empty( $link_id ) )		$update = true;	if ( trim( $link_name ) == '' ) {		if ( trim( $link_url ) != '' ) {			$link_name = $link_url;		} else {			return 0;		}	}	if ( trim( $link_url ) == '' )		return 0;	if ( empty( $link_rating ) )		$link_rating = 0;	if ( empty( $link_image ) )		$link_image = '';	if ( empty( $link_target ) )		$link_target = '';	if ( empty( $link_visible ) )		$link_visible = 'Y';	if ( empty( $link_owner ) )		$link_owner = $current_user->id;	if ( empty( $link_notes ) )		$link_notes = '';	if ( empty( $link_description ) )		$link_description = '';	if ( empty( $link_rss ) )		$link_rss = '';	if ( empty( $link_rel ) )		$link_rel = '';	// Make sure we set a valid category	if ( ! isset( $link_category ) ||0 == count( $link_category ) || !is_array( $link_category ) ) {		$link_category = array( get_option( 'default_link_category' ) );	}	if ( $update ) {		if ( false === $wpdb->update( $wpdb->links, compact('link_url', 'link_name', 'link_image', 'link_target', 'link_description', 'link_visible', 'link_rating', 'link_rel', 'link_notes', 'link_rss'), compact('link_id') ) ) {			if ( $wp_error )				return new WP_Error( 'db_update_error', __( 'Could not update link in the database' ), $wpdb->last_error );			else				return 0;		}	} else {		if ( false === $wpdb->insert( $wpdb->links, compact('link_url', 'link_name', 'link_image', 'link_target', 'link_description', 'link_visible', 'link_owner', 'link_rating', 'link_rel', 'link_notes', 'link_rss') ) ) {			if ( $wp_error )				return new WP_Error( 'db_insert_error', __( 'Could not insert link into the database' ), $wpdb->last_error );			else				return 0;		}		$link_id = (int) $wpdb->insert_id;	}	wp_set_link_cats( $link_id, $link_category );	if ( $update )		do_action( 'edit_link', $link_id );	else		do_action( 'add_link', $link_id );	clean_bookmark_cache( $link_id );	return $link_id;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $link_id * @param unknown_type $link_categories */function wp_set_link_cats( $link_id = 0, $link_categories = array() ) {	// If $link_categories isn't already an array, make it one:	if ( !is_array( $link_categories ) || 0 == count( $link_categories ) )		$link_categories = array( get_option( 'default_link_category' ) );	$link_categories = array_map( 'intval', $link_categories );	$link_categories = array_unique( $link_categories );	wp_set_object_terms( $link_id, $link_categories, 'link_category' );	clean_bookmark_cache( $link_id );}	// wp_set_link_cats()/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $linkdata * @return unknown */function wp_update_link( $linkdata ) {	$link_id = (int) $linkdata['link_id'];	$link = get_bookmark( $link_id, ARRAY_A );	// Escape data pulled from DB.	$link = add_magic_quotes( $link );	// Passed link category list overwrites existing category list if not empty.	if ( isset( $linkdata['link_category'] ) && is_array( $linkdata['link_category'] )			 && 0 != count( $linkdata['link_category'] ) )		$link_cats = $linkdata['link_category'];	else		$link_cats = $link['link_category'];	// Merge old and new fields with new fields overwriting old ones.	$linkdata = array_merge( $link, $linkdata );	$linkdata['link_category'] = $link_cats;	return wp_insert_link( $linkdata );}?>
<?php/** * WordPress FTP Sockets Filesystem. * * @package WordPress * @subpackage Filesystem *//** * WordPress Filesystem Class for implementing FTP Sockets. * * @since 2.5 * @package WordPress * @subpackage Filesystem * @uses WP_Filesystem_Base Extends class */class WP_Filesystem_ftpsockets extends WP_Filesystem_Base {	var $ftp = false;	var $errors = null;	var $options = array();	function WP_Filesystem_ftpsockets($opt = '') {		$this->method = 'ftpsockets';		$this->errors = new WP_Error();		//Check if possible to use ftp functions.		if ( ! @include_once ABSPATH . 'wp-admin/includes/class-ftp.php' )				return false;		$this->ftp = new ftp();		//Set defaults:		if ( empty($opt['port']) )			$this->options['port'] = 21;		else			$this->options['port'] = $opt['port'];		if ( empty($opt['hostname']) )			$this->errors->add('empty_hostname', __('FTP hostname is required'));		else			$this->options['hostname'] = $opt['hostname'];		if ( ! empty($opt['base']) )			$this->wp_base = $opt['base'];		// Check if the options provided are OK.		if ( empty ($opt['username']) )			$this->errors->add('empty_username', __('FTP username is required'));		else			$this->options['username'] = $opt['username'];		if ( empty ($opt['password']) )			$this->errors->add('empty_password', __('FTP password is required'));		else			$this->options['password'] = $opt['password'];	}	function connect() {		if ( ! $this->ftp )			return false;		$this->ftp->setTimeout(FS_CONNECT_TIMEOUT);		if ( ! $this->ftp->SetServer($this->options['hostname'], $this->options['port']) ) {			$this->errors->add('connect', sprintf(__('Failed to connect to FTP Server %1$s:%2$s'), $this->options['hostname'], $this->options['port']));			return false;		}		if ( ! $this->ftp->connect() ) {			$this->errors->add('connect', sprintf(__('Failed to connect to FTP Server %1$s:%2$s'), $this->options['hostname'], $this->options['port']));			return false;		}		if ( ! $this->ftp->login($this->options['username'], $this->options['password']) ) {			$this->errors->add('auth', sprintf(__('Username/Password incorrect for %s'), $this->options['username']));			return false;		}		$this->ftp->SetType(FTP_AUTOASCII);		$this->ftp->Passive(true);		$this->ftp->setTimeout(FS_TIMEOUT);		return true;	}	function get_contents($file, $type = '', $resumepos = 0) {		if ( ! $this->exists($file) )			return false;		if ( empty($type) )			$type = FTP_AUTOASCII;		$this->ftp->SetType($type);		$temp = wp_tempnam( $file );		if ( ! $temphandle = fopen($temp, 'w+') )			return false;		if ( ! $this->ftp->fget($temphandle, $file) ) {			fclose($temphandle);			unlink($temp);			return ''; //Blank document, File does exist, Its just blank.		}		fseek($temphandle, 0); //Skip back to the start of the file being written to		$contents = '';		while ( ! feof($temphandle) )			$contents .= fread($temphandle, 8192);		fclose($temphandle);		unlink($temp);		return $contents;	}	function get_contents_array($file) {		return explode("\n", $this->get_contents($file) );	}	function put_contents($file, $contents, $mode = false ) {		$temp = wp_tempnam( $file );		if ( ! $temphandle = @fopen($temp, 'w+') ) {			unlink($temp);			return false;		}		fwrite($temphandle, $contents);		fseek($temphandle, 0); //Skip back to the start of the file being written to		$type = $this->is_binary($contents) ? FTP_BINARY : FTP_ASCII;		$this->ftp->SetType($type);		$ret = $this->ftp->fput($file, $temphandle);		fclose($temphandle);		unlink($temp);		$this->chmod($file, $mode);		return $ret;	}	function cwd() {		$cwd = $this->ftp->pwd();		if ( $cwd )			$cwd = trailingslashit($cwd);		return $cwd;	}	function chdir($file) {		return $this->ftp->chdir($file);	}	function chgrp($file, $group, $recursive = false ) {		return false;	}	function chmod($file, $mode = false, $recursive = false ) {		if ( ! $mode ) {			if ( $this->is_file($file) )				$mode = FS_CHMOD_FILE;			elseif ( $this->is_dir($file) )				$mode = FS_CHMOD_DIR;			else				return false;		}		// chmod any sub-objects if recursive.		if ( $recursive && $this->is_dir($file) ) {			$filelist = $this->dirlist($file);			foreach ( (array)$filelist as $filename => $filemeta )				$this->chmod($file . '/' . $filename, $mode, $recursive);		}		// chmod the file or directory		return $this->ftp->chmod($file, $mode);	}	function chown($file, $owner, $recursive = false ) {		return false;	}	function owner($file) {		$dir = $this->dirlist($file);		return $dir[$file]['owner'];	}	function getchmod($file) {		$dir = $this->dirlist($file);		return $dir[$file]['permsn'];	}	function group($file) {		$dir = $this->dirlist($file);		return $dir[$file]['group'];	}	function copy($source, $destination, $overwrite = false ) {		if ( ! $overwrite && $this->exists($destination) )			return false;		$content = $this->get_contents($source);		if ( false === $content )			return false;		return $this->put_contents($destination, $content);	}	function move($source, $destination, $overwrite = false ) {		return $this->ftp->rename($source, $destination);	}	function delete($file, $recursive = false ) {		if ( empty($file) )			return false;		if ( $this->is_file($file) )			return $this->ftp->delete($file);		if ( !$recursive )			return $this->ftp->rmdir($file);		return $this->ftp->mdel($file);	}	function exists($file) {		return $this->ftp->is_exists($file);	}	function is_file($file) {		if ( $this->is_dir($file) )			return false;		if ( $this->exists($file) )			return true;		return false;	}	function is_dir($path) {		$cwd = $this->cwd();		if ( $this->chdir($path) ) {			$this->chdir($cwd);			return true;		}		return false;	}	function is_readable($file) {		//Get dir list, Check if the file is writable by the current user??		return true;	}	function is_writable($file) {		//Get dir list, Check if the file is writable by the current user??		return true;	}	function atime($file) {		return false;	}	function mtime($file) {		return $this->ftp->mdtm($file);	}	function size($file) {		return $this->ftp->filesize($file);	}	function touch($file, $time = 0, $atime = 0 ) {		return false;	}	function mkdir($path, $chmod = false, $chown = false, $chgrp = false ) {		if ( ! $this->ftp->mkdir($path) )			return false;		if ( ! $chmod )			$chmod = FS_CHMOD_DIR;		$this->chmod($path, $chmod);		if ( $chown )			$this->chown($path, $chown);		if ( $chgrp )			$this->chgrp($path, $chgrp);		return true;	}	function rmdir($path, $recursive = false ) {		$this->delete($path, $recursive);	}	function dirlist($path = '.', $include_hidden = true, $recursive = false ) {		if ( $this->is_file($path) ) {			$limit_file = basename($path);			$path = dirname($path) . '/';		} else {			$limit_file = false;		}		$list = $this->ftp->dirlist($path);		if ( empty($list) && !$this->exists($path) )			return false;		$ret = array();		foreach ( $list as $struc ) {			if ( '.' == $struc['name'] || '..' == $struc['name'] )				continue;			if ( ! $include_hidden && '.' == $struc['name'][0] )				continue;			if ( $limit_file && $struc['name'] != $limit_file )				continue;			if ( 'd' == $struc['type'] ) {				if ( $recursive )					$struc['files'] = $this->dirlist($path . '/' . $struc['name'], $include_hidden, $recursive);				else					$struc['files'] = array();			}			$ret[ $struc['name'] ] = $struc;		}		return $ret;	}	function __destruct() {		$this->ftp->quit();	}}?>
<?php/** * API for creating dynamic sidebar without hardcoding functionality into * themes. Includes both internal WordPress routines and theme use routines. * * This functionality was found in a plugin before WordPress 2.2 release which * included it in the core from that point on. * * @link http://codex.wordpress.org/Plugins/WordPress_Widgets WordPress Widgets * @link http://codex.wordpress.org/Plugins/WordPress_Widgets_Api Widgets API * * @package WordPress * @subpackage Widgets *//** * This class must be extended for each widget and WP_Widget::widget(), WP_Widget::update() * and WP_Widget::form() need to be over-ridden. * * @package WordPress * @subpackage Widgets * @since 2.8 */class WP_Widget {	var $id_base;			// Root id for all widgets of this type.	var $name;				// Name for this widget type.	var $widget_options;	// Option array passed to wp_register_sidebar_widget()	var $control_options;	// Option array passed to wp_register_widget_control()	var $number = false;	// Unique ID number of the current instance.	var $id = false;		// Unique ID string of the current instance (id_base-number)	var $updated = false;	// Set true when we update the data after a POST submit - makes sure we don't do it twice.	// Member functions that you must over-ride.	/** Echo the widget content.	 *	 * Subclasses should over-ride this function to generate their widget code.	 *	 * @param array $args Display arguments including before_title, after_title, before_widget, and after_widget.	 * @param array $instance The settings for the particular instance of the widget	 */	function widget($args, $instance) {		die('function WP_Widget::widget() must be over-ridden in a sub-class.');	}	/** Update a particular instance.	 *	 * This function should check that $new_instance is set correctly.	 * The newly calculated value of $instance should be returned.	 * If "false" is returned, the instance won't be saved/updated.	 *	 * @param array $new_instance New settings for this instance as input by the user via form()	 * @param array $old_instance Old settings for this instance	 * @return array Settings to save or bool false to cancel saving	 */	function update($new_instance, $old_instance) {		return $new_instance;	}	/** Echo the settings update form	 *	 * @param array $instance Current settings	 */	function form($instance) {		echo '<p class="no-options-widget">' . __('There are no options for this widget.') . '</p>';		return 'noform';	}	// Functions you'll need to call.	/**	 * PHP4 constructor	 */	function WP_Widget( $id_base = false, $name, $widget_options = array(), $control_options = array() ) {		$this->__construct( $id_base, $name, $widget_options, $control_options );	}	/**	 * PHP5 constructor	 *	 * @param string $id_base Optional Base ID for the widget, lower case,	 * if left empty a portion of the widget's class name will be used. Has to be unique.	 * @param string $name Name for the widget displayed on the configuration page.	 * @param array $widget_options Optional Passed to wp_register_sidebar_widget()	 *	 - description: shown on the configuration page	 *	 - classname	 * @param array $control_options Optional Passed to wp_register_widget_control()	 *	 - width: required if more than 250px	 *	 - height: currently not used but may be needed in the future	 */	function __construct( $id_base = false, $name, $widget_options = array(), $control_options = array() ) {		$this->id_base = empty($id_base) ? preg_replace( '/(wp_)?widget_/', '', strtolower(get_class($this)) ) : strtolower($id_base);		$this->name = $name;		$this->option_name = 'widget_' . $this->id_base;		$this->widget_options = wp_parse_args( $widget_options, array('classname' => $this->option_name) );		$this->control_options = wp_parse_args( $control_options, array('id_base' => $this->id_base) );	}	/**	 * Constructs name attributes for use in form() fields	 *	 * This function should be used in form() methods to create name attributes for fields to be saved by update()	 *	 * @param string $field_name Field name	 * @return string Name attribute for $field_name	 */	function get_field_name($field_name) {		return 'widget-' . $this->id_base . '[' . $this->number . '][' . $field_name . ']';	}	/**	 * Constructs id attributes for use in form() fields	 *	 * This function should be used in form() methods to create id attributes for fields to be saved by update()	 *	 * @param string $field_name Field name	 * @return string ID attribute for $field_name	 */	function get_field_id($field_name) {		return 'widget-' . $this->id_base . '-' . $this->number . '-' . $field_name;	}	// Private Functions. Don't worry about these.	function _register() {		$settings = $this->get_settings();		$empty = true;		if ( is_array($settings) ) {			foreach ( array_keys($settings) as $number ) {				if ( is_numeric($number) ) {					$this->_set($number);					$this->_register_one($number);					$empty = false;				}			}		}		if ( $empty ) {			// If there are none, we register the widget's existance with a			// generic template			$this->_set(1);			$this->_register_one();		}	}	function _set($number) {		$this->number = $number;		$this->id = $this->id_base . '-' . $number;	}	function _get_display_callback() {		return array(&$this, 'display_callback');	}	function _get_update_callback() {		return array(&$this, 'update_callback');	}	function _get_form_callback() {		return array(&$this, 'form_callback');	}	/** Generate the actual widget content.	 *	Just finds the instance and calls widget().	 *	Do NOT over-ride this function. */	function display_callback( $args, $widget_args = 1 ) {		if ( is_numeric($widget_args) )			$widget_args = array( 'number' => $widget_args );		$widget_args = wp_parse_args( $widget_args, array( 'number' => -1 ) );		$this->_set( $widget_args['number'] );		$instance = $this->get_settings();		if ( array_key_exists( $this->number, $instance ) ) {			$instance = $instance[$this->number];			// filters the widget's settings, return false to stop displaying the widget			$instance = apply_filters('widget_display_callback', $instance, $this, $args);			if ( false !== $instance )				$this->widget($args, $instance);		}	}	/** Deal with changed settings.	 *	Do NOT over-ride this function. */	function update_callback( $widget_args = 1 ) {		global $wp_registered_widgets;		if ( is_numeric($widget_args) )			$widget_args = array( 'number' => $widget_args );		$widget_args = wp_parse_args( $widget_args, array( 'number' => -1 ) );		$all_instances = $this->get_settings();		// We need to update the data		if ( $this->updated )			return;		$sidebars_widgets = wp_get_sidebars_widgets();		if ( isset($_POST['delete_widget']) && $_POST['delete_widget'] ) {			// Delete the settings for this instance of the widget			if ( isset($_POST['the-widget-id']) )				$del_id = $_POST['the-widget-id'];			else				return;			if ( isset($wp_registered_widgets[$del_id]['params'][0]['number']) ) {				$number = $wp_registered_widgets[$del_id]['params'][0]['number'];				if ( $this->id_base . '-' . $number == $del_id )					unset($all_instances[$number]);			}		} else {			if ( isset($_POST['widget-' . $this->id_base]) && is_array($_POST['widget-' . $this->id_base]) ) {				$settings = $_POST['widget-' . $this->id_base];			} elseif ( isset($_POST['id_base']) && $_POST['id_base'] == $this->id_base ) {				$num = $_POST['multi_number'] ? (int) $_POST['multi_number'] : (int) $_POST['widget_number'];				$settings = array( $num => array() );			} else {				return;			}			foreach ( $settings as $number => $new_instance ) {				$new_instance = stripslashes_deep($new_instance);				$this->_set($number);				$old_instance = isset($all_instances[$number]) ? $all_instances[$number] : array();				$instance = $this->update($new_instance, $old_instance);				// filters the widget's settings before saving, return false to cancel saving (keep the old settings if updating)				$instance = apply_filters('widget_update_callback', $instance, $new_instance, $old_instance, $this);				if ( false !== $instance )					$all_instances[$number] = $instance;				break; // run only once			}		}		$this->save_settings($all_instances);		$this->updated = true;	}	/** Generate the control form.	 *	Do NOT over-ride this function. */	function form_callback( $widget_args = 1 ) {		if ( is_numeric($widget_args) )			$widget_args = array( 'number' => $widget_args );		$widget_args = wp_parse_args( $widget_args, array( 'number' => -1 ) );		$all_instances = $this->get_settings();		if ( -1 == $widget_args['number'] ) {			// We echo out a form where 'number' can be set later			$this->_set('__i__');			$instance = array();		} else {			$this->_set($widget_args['number']);			$instance = $all_instances[ $widget_args['number'] ];		}		// filters the widget admin form before displaying, return false to stop displaying it		$instance = apply_filters('widget_form_callback', $instance, $this);		$return = null;		if ( false !== $instance ) {			$return = $this->form($instance);			// add extra fields in the widget form - be sure to set $return to null if you add any			// if the widget has no form the text echoed from the default form method can be hidden using css			do_action_ref_array( 'in_widget_form', array(&$this, &$return, $instance) );		}		return $return;	}	/** Helper function: Registers a single instance. */	function _register_one($number = -1) {		wp_register_sidebar_widget(	$this->id, $this->name,	$this->_get_display_callback(), $this->widget_options, array( 'number' => $number ) );		_register_widget_update_callback( $this->id_base, $this->_get_update_callback(), $this->control_options, array( 'number' => -1 ) );		_register_widget_form_callback(	$this->id, $this->name,	$this->_get_form_callback(), $this->control_options, array( 'number' => $number ) );	}	function save_settings($settings) {		$settings['_multiwidget'] = 1;		update_option( $this->option_name, $settings );	}	function get_settings() {		$settings = get_option($this->option_name);		if ( false === $settings && isset($this->alt_option_name) )			$settings = get_option($this->alt_option_name);		if ( !is_array($settings) )			$settings = array();		if ( !array_key_exists('_multiwidget', $settings) ) {			// old format, conver if single widget			$settings = wp_convert_widget_settings($this->id_base, $this->option_name, $settings);		}		unset($settings['_multiwidget'], $settings['__i__']);		return $settings;	}}/** * Singleton that registers and instantiates WP_Widget classes. * * @package WordPress * @subpackage Widgets * @since 2.8 */class WP_Widget_Factory {	var $widgets = array();	function WP_Widget_Factory() {		add_action( 'widgets_init', array( &$this, '_register_widgets' ), 100 );	}	function register($widget_class) {		$this->widgets[$widget_class] = & new $widget_class();	}	function unregister($widget_class) {		if ( isset($this->widgets[$widget_class]) )			unset($this->widgets[$widget_class]);	}	function _register_widgets() {		global $wp_registered_widgets;		$keys = array_keys($this->widgets);		$registered = array_keys($wp_registered_widgets);		$registered = array_map('_get_widget_id_base', $registered);		foreach ( $keys as $key ) {			// don't register new widget if old widget with the same id is already registered			if ( in_array($this->widgets[$key]->id_base, $registered, true) ) {				unset($this->widgets[$key]);				continue;			}			$this->widgets[$key]->_register();		}	}}/* Global Variables *//** @ignore */global $wp_registered_sidebars, $wp_registered_widgets, $wp_registered_widget_controls, $wp_registered_widget_updates;/** * Stores the sidebars, since many themes can have more than one. * * @global array $wp_registered_sidebars * @since 2.2.0 */$wp_registered_sidebars = array();/** * Stores the registered widgets. * * @global array $wp_registered_widgets * @since 2.2.0 */$wp_registered_widgets = array();/** * Stores the registered widget control (options). * * @global array $wp_registered_widget_controls * @since 2.2.0 */$wp_registered_widget_controls = array();$wp_registered_widget_updates = array();/** * Private */$_wp_sidebars_widgets = array();/** * Private */ $_wp_deprecated_widgets_callbacks = array( 	'wp_widget_pages',	'wp_widget_pages_control',	'wp_widget_calendar',	'wp_widget_calendar_control',	'wp_widget_archives',	'wp_widget_archives_control',	'wp_widget_links',	'wp_widget_meta',	'wp_widget_meta_control',	'wp_widget_search',	'wp_widget_recent_entries',	'wp_widget_recent_entries_control',	'wp_widget_tag_cloud',	'wp_widget_tag_cloud_control',	'wp_widget_categories',	'wp_widget_categories_control',	'wp_widget_text',	'wp_widget_text_control',	'wp_widget_rss',	'wp_widget_rss_control',	'wp_widget_recent_comments',	'wp_widget_recent_comments_control' );/* Template tags & API functions *//** * Register a widget * * Registers a WP_Widget widget * * @since 2.8.0 * * @see WP_Widget * @see WP_Widget_Factory * @uses WP_Widget_Factory * * @param string $widget_class The name of a class that extends WP_Widget */function register_widget($widget_class) {	global $wp_widget_factory;	$wp_widget_factory->register($widget_class);}/** * Unregister a widget * * Unregisters a WP_Widget widget. Useful for unregistering default widgets. * Run within a function hooked to the widgets_init action. * * @since 2.8.0 * * @see WP_Widget * @see WP_Widget_Factory * @uses WP_Widget_Factory * * @param string $widget_class The name of a class that extends WP_Widget */function unregister_widget($widget_class) {	global $wp_widget_factory;	$wp_widget_factory->unregister($widget_class);}/** * Creates multiple sidebars. * * If you wanted to quickly create multiple sidebars for a theme or internally. * This function will allow you to do so. If you don't pass the 'name' and/or * 'id' in $args, then they will be built for you. * * The default for the name is "Sidebar #", with '#' being replaced with the * number the sidebar is currently when greater than one. If first sidebar, the * name will be just "Sidebar". The default for id is "sidebar-" followed by the * number the sidebar creation is currently at. If the id is provided, and mutliple * sidebars are being defined, the id will have "-2" appended, and so on. * * @since 2.2.0 * * @see register_sidebar() The second parameter is documented by register_sidebar() and is the same here. * @uses parse_str() Converts a string to an array to be used in the rest of the function. * @uses register_sidebar() Sends single sidebar information [name, id] to this *	function to handle building the sidebar. * * @param int $number Number of sidebars to create. * @param string|array $args Builds Sidebar based off of 'name' and 'id' values. */function register_sidebars($number = 1, $args = array()) {	global $wp_registered_sidebars;	$number = (int) $number;	if ( is_string($args) )		parse_str($args, $args);	for ( $i = 1; $i <= $number; $i++ ) {		$_args = $args;		if ( $number > 1 )			$_args['name'] = isset($args['name']) ? sprintf($args['name'], $i) : sprintf(__('Sidebar %d'), $i);		else			$_args['name'] = isset($args['name']) ? $args['name'] : __('Sidebar');		// Custom specified ID's are suffixed if they exist already.		// Automatically generated sidebar names need to be suffixed regardless starting at -0		if ( isset($args['id']) ) {			$_args['id'] = $args['id'];			$n = 2; // Start at -2 for conflicting custom ID's			while ( isset($wp_registered_sidebars[$_args['id']]) )				$_args['id'] = $args['id'] . '-' . $n++;		} else {			$n = count($wp_registered_sidebars);			do {				$_args['id'] = 'sidebar-' . ++$n;			} while ( isset($wp_registered_sidebars[$_args['id']]) );		}		register_sidebar($_args);	}}/** * Builds the definition for a single sidebar and returns the ID. * * The $args parameter takes either a string or an array with 'name' and 'id' * contained in either usage. It will be noted that the values will be applied * to all sidebars, so if creating more than one, it will be advised to allow * for WordPress to create the defaults for you. * * Example for string would be <code>'name=whatever;id=whatever1'</code> and for * the array it would be <code>array( *    'name' => 'whatever', *    'id' => 'whatever1')</code>. * * name - The name of the sidebar, which presumably the title which will be *     displayed. * id - The unique identifier by which the sidebar will be called by. * before_widget - The content that will prepended to the widgets when they are *     displayed. * after_widget - The content that will be appended to the widgets when they are *     displayed. * before_title - The content that will be prepended to the title when displayed. * after_title - the content that will be appended to the title when displayed. * * <em>Content</em> is assumed to be HTML and should be formatted as such, but * doesn't have to be. * * @since 2.2.0 * @uses $wp_registered_sidebars Stores the new sidebar in this array by sidebar ID. * * @param string|array $args Builds Sidebar based off of 'name' and 'id' values * @return string The sidebar id that was added. */function register_sidebar($args = array()) {	global $wp_registered_sidebars;	$i = count($wp_registered_sidebars) + 1;	$defaults = array(		'name' => sprintf(__('Sidebar %d'), $i ),		'id' => "sidebar-$i",		'description' => '',		'before_widget' => '<li id="%1$s" class="widget %2$s">',		'after_widget' => "</li>\n",		'before_title' => '<h2 class="widgettitle">',		'after_title' => "</h2>\n",	);	$sidebar = wp_parse_args( $args, $defaults );	$wp_registered_sidebars[$sidebar['id']] = $sidebar;	add_theme_support('widgets');	do_action( 'register_sidebar', $sidebar );	return $sidebar['id'];}/** * Removes a sidebar from the list. * * @since 2.2.0 * * @uses $wp_registered_sidebars Stores the new sidebar in this array by sidebar ID. * * @param string $name The ID of the sidebar when it was added. */function unregister_sidebar( $name ) {	global $wp_registered_sidebars;	if ( isset( $wp_registered_sidebars[$name] ) )		unset( $wp_registered_sidebars[$name] );}/** * Register widget for use in sidebars. * * The default widget option is 'classname' that can be override. * * The function can also be used to unregister widgets when $output_callback * parameter is an empty string. * * @since 2.2.0 * * @uses $wp_registered_widgets Uses stored registered widgets. * @uses $wp_register_widget_defaults Retrieves widget defaults. * * @param int|string $id Widget ID. * @param string $name Widget display title. * @param callback $output_callback Run when widget is called. * @param array|string Optional. $options Widget Options. * @param mixed $params,... Widget parameters to add to widget. * @return null Will return if $output_callback is empty after removing widget. */function wp_register_sidebar_widget($id, $name, $output_callback, $options = array()) {	global $wp_registered_widgets, $wp_registered_widget_controls, $wp_registered_widget_updates, $_wp_deprecated_widgets_callbacks;	$id = strtolower($id);	if ( empty($output_callback) ) {		unset($wp_registered_widgets[$id]);		return;	}	$id_base = _get_widget_id_base($id);	if ( in_array($output_callback, $_wp_deprecated_widgets_callbacks, true) && !is_callable($output_callback) ) {		if ( isset($wp_registered_widget_controls[$id]) )			unset($wp_registered_widget_controls[$id]);		if ( isset($wp_registered_widget_updates[$id_base]) )			unset($wp_registered_widget_updates[$id_base]);		return;	}	$defaults = array('classname' => $output_callback);	$options = wp_parse_args($options, $defaults);	$widget = array(		'name' => $name,		'id' => $id,		'callback' => $output_callback,		'params' => array_slice(func_get_args(), 4)	);	$widget = array_merge($widget, $options);	if ( is_callable($output_callback) && ( !isset($wp_registered_widgets[$id]) || did_action( 'widgets_init' ) ) ) {		do_action( 'wp_register_sidebar_widget', $widget );		$wp_registered_widgets[$id] = $widget;	}}/** * Retrieve description for widget. * * When registering widgets, the options can also include 'description' that * describes the widget for display on the widget administration panel or * in the theme. * * @since 2.5.0 * * @param int|string $id Widget ID. * @return string Widget description, if available. Null on failure to retrieve description. */function wp_widget_description( $id ) {	if ( !is_scalar($id) )		return;	global $wp_registered_widgets;	if ( isset($wp_registered_widgets[$id]['description']) )		return esc_html( $wp_registered_widgets[$id]['description'] );}/** * Retrieve description for a sidebar. * * When registering sidebars a 'description' parameter can be included that * describes the sidebar for display on the widget administration panel. * * @since 2.9.0 * * @param int|string $id sidebar ID. * @return string Sidebar description, if available. Null on failure to retrieve description. */function wp_sidebar_description( $id ) {	if ( !is_scalar($id) )		return;	global $wp_registered_sidebars;	if ( isset($wp_registered_sidebars[$id]['description']) )		return esc_html( $wp_registered_sidebars[$id]['description'] );}/** * Remove widget from sidebar. * * @since 2.2.0 * * @param int|string $id Widget ID. */function wp_unregister_sidebar_widget($id) {	do_action( 'wp_unregister_sidebar_widget', $id );	wp_register_sidebar_widget($id, '', '');	wp_unregister_widget_control($id);}/** * Registers widget control callback for customizing options. * * The options contains the 'height', 'width', and 'id_base' keys. The 'height' * option is never used. The 'width' option is the width of the fully expanded * control form, but try hard to use the default width. The 'id_base' is for * multi-widgets (widgets which allow multiple instances such as the text * widget), an id_base must be provided. The widget id will end up looking like * {$id_base}-{$unique_number}. * * @since 2.2.0 * * @param int|string $id Sidebar ID. * @param string $name Sidebar display name. * @param callback $control_callback Run when sidebar is displayed. * @param array|string $options Optional. Widget options. See above long description. * @param mixed $params,... Optional. Additional parameters to add to widget. */function wp_register_widget_control($id, $name, $control_callback, $options = array()) {	global $wp_registered_widget_controls, $wp_registered_widget_updates, $wp_registered_widgets, $_wp_deprecated_widgets_callbacks;	$id = strtolower($id);	$id_base = _get_widget_id_base($id);	if ( empty($control_callback) ) {		unset($wp_registered_widget_controls[$id]);		unset($wp_registered_widget_updates[$id_base]);		return;	}	if ( in_array($control_callback, $_wp_deprecated_widgets_callbacks, true) && !is_callable($control_callback) ) {		if ( isset($wp_registered_widgets[$id]) )			unset($wp_registered_widgets[$id]);		return;	}	if ( isset($wp_registered_widget_controls[$id]) && !did_action( 'widgets_init' ) )		return;	$defaults = array('width' => 250, 'height' => 200 ); // height is never used	$options = wp_parse_args($options, $defaults);	$options['width'] = (int) $options['width'];	$options['height'] = (int) $options['height'];	$widget = array(		'name' => $name,		'id' => $id,		'callback' => $control_callback,		'params' => array_slice(func_get_args(), 4)	);	$widget = array_merge($widget, $options);	$wp_registered_widget_controls[$id] = $widget;	if ( isset($wp_registered_widget_updates[$id_base]) )		return;	if ( isset($widget['params'][0]['number']) )		$widget['params'][0]['number'] = -1;	unset($widget['width'], $widget['height'], $widget['name'], $widget['id']);	$wp_registered_widget_updates[$id_base] = $widget;}function _register_widget_update_callback($id_base, $update_callback, $options = array()) {	global $wp_registered_widget_updates;	if ( isset($wp_registered_widget_updates[$id_base]) ) {		if ( empty($update_callback) )			unset($wp_registered_widget_updates[$id_base]);		return;	}	$widget = array(		'callback' => $update_callback,		'params' => array_slice(func_get_args(), 3)	);	$widget = array_merge($widget, $options);	$wp_registered_widget_updates[$id_base] = $widget;}function _register_widget_form_callback($id, $name, $form_callback, $options = array()) {	global $wp_registered_widget_controls;	$id = strtolower($id);	if ( empty($form_callback) ) {		unset($wp_registered_widget_controls[$id]);		return;	}	if ( isset($wp_registered_widget_controls[$id]) && !did_action( 'widgets_init' ) )		return;	$defaults = array('width' => 250, 'height' => 200 );	$options = wp_parse_args($options, $defaults);	$options['width'] = (int) $options['width'];	$options['height'] = (int) $options['height'];	$widget = array(		'name' => $name,		'id' => $id,		'callback' => $form_callback,		'params' => array_slice(func_get_args(), 4)	);	$widget = array_merge($widget, $options);	$wp_registered_widget_controls[$id] = $widget;}/** * Remove control callback for widget. * * @since 2.2.0 * @uses wp_register_widget_control() Unregisters by using empty callback. * * @param int|string $id Widget ID. */function wp_unregister_widget_control($id) {	return wp_register_widget_control($id, '', '');}/** * Display dynamic sidebar. * * By default it displays the default sidebar or 'sidebar-1'. The 'sidebar-1' is * not named by the theme, the actual name is '1', but 'sidebar-' is added to * the registered sidebars for the name. If you named your sidebar 'after-post', * then the parameter $index will still be 'after-post', but the lookup will be * for 'sidebar-after-post'. * * It is confusing for the $index parameter, but just know that it should just * work. When you register the sidebar in the theme, you will use the same name * for this function or "Pay no heed to the man behind the curtain." Just accept * it as an oddity of WordPress sidebar register and display. * * @since 2.2.0 * * @param int|string $index Optional, default is 1. Name or ID of dynamic sidebar. * @return bool True, if widget sidebar was found and called. False if not found or not called. */function dynamic_sidebar($index = 1) {	global $wp_registered_sidebars, $wp_registered_widgets;	if ( is_int($index) ) {		$index = "sidebar-$index";	} else {		$index = sanitize_title($index);		foreach ( (array) $wp_registered_sidebars as $key => $value ) {			if ( sanitize_title($value['name']) == $index ) {				$index = $key;				break;			}		}	}	$sidebars_widgets = wp_get_sidebars_widgets();	if ( empty($wp_registered_sidebars[$index]) || !array_key_exists($index, $sidebars_widgets) || !is_array($sidebars_widgets[$index]) || empty($sidebars_widgets[$index]) )		return false;	$sidebar = $wp_registered_sidebars[$index];	$did_one = false;	foreach ( (array) $sidebars_widgets[$index] as $id ) {		if ( !isset($wp_registered_widgets[$id]) ) continue;		$params = array_merge(			array( array_merge( $sidebar, array('widget_id' => $id, 'widget_name' => $wp_registered_widgets[$id]['name']) ) ),			(array) $wp_registered_widgets[$id]['params']		);		// Substitute HTML id and class attributes into before_widget		$classname_ = '';		foreach ( (array) $wp_registered_widgets[$id]['classname'] as $cn ) {			if ( is_string($cn) )				$classname_ .= '_' . $cn;			elseif ( is_object($cn) )				$classname_ .= '_' . get_class($cn);		}		$classname_ = ltrim($classname_, '_');		$params[0]['before_widget'] = sprintf($params[0]['before_widget'], $id, $classname_);		$params = apply_filters( 'dynamic_sidebar_params', $params );		$callback = $wp_registered_widgets[$id]['callback'];		do_action( 'dynamic_sidebar', $wp_registered_widgets[$id] );		if ( is_callable($callback) ) {			call_user_func_array($callback, $params);			$did_one = true;		}	}	return $did_one;}/** * Whether widget is displayied on the front-end. * * Either $callback or $id_base can be used * $id_base is the first argument when extending WP_Widget class * Without the optional $widget_id parameter, returns the ID of the first sidebar * in which the first instance of the widget with the given callback or $id_base is found. * With the $widget_id parameter, returns the ID of the sidebar where * the widget with that callback/$id_base AND that ID is found. * * NOTE: $widget_id and $id_base are the same for single widgets. To be effective * this function has to run after widgets have initialized, at action 'init' or later. * * @since 2.2.0 * * @param callback Optional, Widget callback to check. * @param int $widget_id Optional, but needed for checking. Widget ID. * @param string $id_base Optional, the base ID of a widget created by extending WP_Widget. * @param bool $skip_inactive Optional, whether to check in 'wp_inactive_widgets'. * @return mixed false if widget is not active or id of sidebar in which the widget is active. */function is_active_widget($callback = false, $widget_id = false, $id_base = false, $skip_inactive = true) {	global $wp_registered_widgets;	$sidebars_widgets = wp_get_sidebars_widgets();	if ( is_array($sidebars_widgets) ) {		foreach ( $sidebars_widgets as $sidebar => $widgets ) {			if ( $skip_inactive && 'wp_inactive_widgets' == $sidebar )				continue;			if ( is_array($widgets) ) {				foreach ( $widgets as $widget ) {					if ( ( $callback && isset($wp_registered_widgets[$widget]['callback']) && $wp_registered_widgets[$widget]['callback'] == $callback ) || ( $id_base && _get_widget_id_base($widget) == $id_base ) ) {						if ( !$widget_id || $widget_id == $wp_registered_widgets[$widget]['id'] )							return $sidebar;					}				}			}		}	}	return false;}/** * Whether the dynamic sidebar is enabled and used by theme. * * @since 2.2.0 * * @return bool True, if using widgets. False, if not using widgets. */function is_dynamic_sidebar() {	global $wp_registered_widgets, $wp_registered_sidebars;	$sidebars_widgets = get_option('sidebars_widgets');	foreach ( (array) $wp_registered_sidebars as $index => $sidebar ) {		if ( count($sidebars_widgets[$index]) ) {			foreach ( (array) $sidebars_widgets[$index] as $widget )				if ( array_key_exists($widget, $wp_registered_widgets) )					return true;		}	}	return false;}/** * Whether a sidebar is in use. * * @since 2.8 * * @param mixed $index, sidebar name, id or number to check. * @return bool true if the sidebar is in use, false otherwise. */function is_active_sidebar( $index ) {	$index = ( is_int($index) ) ? "sidebar-$index" : sanitize_title($index);	$sidebars_widgets = wp_get_sidebars_widgets();	if ( !empty($sidebars_widgets[$index]) )		return true;	return false;}/* Internal Functions *//** * Retrieve full list of sidebars and their widgets. * * Will upgrade sidebar widget list, if needed. Will also save updated list, if * needed. * * @since 2.2.0 * @access private * * @param bool $deprecated. Not used. * @return array Upgraded list of widgets to version 3 array format when called from the admin. */function wp_get_sidebars_widgets($deprecated = true) {	if ( $deprecated !== true )		_deprecated_argument( __FUNCTION__, '2.8.1' );	global $wp_registered_widgets, $wp_registered_sidebars, $_wp_sidebars_widgets;	// If loading from front page, consult $_wp_sidebars_widgets rather than options	// to see if wp_convert_widget_settings() has made manipulations in memory.	if ( !is_admin() ) {		if ( empty($_wp_sidebars_widgets) )			$_wp_sidebars_widgets = get_option('sidebars_widgets', array());		$sidebars_widgets = $_wp_sidebars_widgets;	} else {		$sidebars_widgets = get_option('sidebars_widgets', array());		$_sidebars_widgets = array();		if ( isset($sidebars_widgets['wp_inactive_widgets']) || empty($sidebars_widgets) )			$sidebars_widgets['array_version'] = 3;		elseif ( !isset($sidebars_widgets['array_version']) )			$sidebars_widgets['array_version'] = 1;		switch ( $sidebars_widgets['array_version'] ) {			case 1 :				foreach ( (array) $sidebars_widgets as $index => $sidebar )				if ( is_array($sidebar) )				foreach ( (array) $sidebar as $i => $name ) {					$id = strtolower($name);					if ( isset($wp_registered_widgets[$id]) ) {						$_sidebars_widgets[$index][$i] = $id;						continue;					}					$id = sanitize_title($name);					if ( isset($wp_registered_widgets[$id]) ) {						$_sidebars_widgets[$index][$i] = $id;						continue;					}					$found = false;					foreach ( $wp_registered_widgets as $widget_id => $widget ) {						if ( strtolower($widget['name']) == strtolower($name) ) {							$_sidebars_widgets[$index][$i] = $widget['id'];							$found = true;							break;						} elseif ( sanitize_title($widget['name']) == sanitize_title($name) ) {							$_sidebars_widgets[$index][$i] = $widget['id'];							$found = true;							break;						}					}					if ( $found )						continue;					unset($_sidebars_widgets[$index][$i]);				}				$_sidebars_widgets['array_version'] = 2;				$sidebars_widgets = $_sidebars_widgets;				unset($_sidebars_widgets);			case 2 :				$sidebars = array_keys( $wp_registered_sidebars );				if ( !empty( $sidebars ) ) {					// Move the known-good ones first					foreach ( (array) $sidebars as $id ) {						if ( array_key_exists( $id, $sidebars_widgets ) ) {							$_sidebars_widgets[$id] = $sidebars_widgets[$id];							unset($sidebars_widgets[$id], $sidebars[$id]);						}					}					// move the rest to wp_inactive_widgets					if ( !isset($_sidebars_widgets['wp_inactive_widgets']) )						$_sidebars_widgets['wp_inactive_widgets'] = array();					if ( !empty($sidebars_widgets) ) {						foreach ( $sidebars_widgets as $lost => $val ) {							if ( is_array($val) )								$_sidebars_widgets['wp_inactive_widgets'] = array_merge( (array) $_sidebars_widgets['wp_inactive_widgets'], $val );						}					}					$sidebars_widgets = $_sidebars_widgets;					unset($_sidebars_widgets);				}		}	}	if ( is_array( $sidebars_widgets ) && isset($sidebars_widgets['array_version']) )		unset($sidebars_widgets['array_version']);	$sidebars_widgets = apply_filters('sidebars_widgets', $sidebars_widgets);	return $sidebars_widgets;}/** * Set the sidebar widget option to update sidebars. * * @since 2.2.0 * @access private * * @param array $sidebars_widgets Sidebar widgets and their settings. */function wp_set_sidebars_widgets( $sidebars_widgets ) {	if ( !isset( $sidebars_widgets['array_version'] ) )		$sidebars_widgets['array_version'] = 3;	update_option( 'sidebars_widgets', $sidebars_widgets );}/** * Retrieve default registered sidebars list. * * @since 2.2.0 * @access private * * @return array */function wp_get_widget_defaults() {	global $wp_registered_sidebars;	$defaults = array();	foreach ( (array) $wp_registered_sidebars as $index => $sidebar )		$defaults[$index] = array();	return $defaults;}/** * Convert the widget settings from single to multi-widget format. * * @since 2.8.0 * * @return array */function wp_convert_widget_settings($base_name, $option_name, $settings) {	// This test may need expanding.	$single = $changed = false;	if ( empty($settings) ) {		$single = true;	} else {		foreach ( array_keys($settings) as $number ) {			if ( 'number' == $number )				continue;			if ( !is_numeric($number) ) {				$single = true;				break;			}		}	}	if ( $single ) {		$settings = array( 2 => $settings );		// If loading from the front page, update sidebar in memory but don't save to options		if ( is_admin() ) {			$sidebars_widgets = get_option('sidebars_widgets');		} else {			if ( empty($GLOBALS['_wp_sidebars_widgets']) )				$GLOBALS['_wp_sidebars_widgets'] = get_option('sidebars_widgets', array());			$sidebars_widgets = &$GLOBALS['_wp_sidebars_widgets'];		}		foreach ( (array) $sidebars_widgets as $index => $sidebar ) {			if ( is_array($sidebar) ) {				foreach ( $sidebar as $i => $name ) {					if ( $base_name == $name ) {						$sidebars_widgets[$index][$i] = "$name-2";						$changed = true;						break 2;					}				}			}		}		if ( is_admin() && $changed )			update_option('sidebars_widgets', $sidebars_widgets);	}	$settings['_multiwidget'] = 1;	if ( is_admin() )		update_option( $option_name, $settings );	return $settings;}/** * Output an arbitrary widget as a template tag * * @since 2.8 * * @param string $widget the widget's PHP class name (see default-widgets.php) * @param array $instance the widget's instance settings * @param array $args the widget's sidebar args * @return void **/function the_widget($widget, $instance = array(), $args = array()) {	global $wp_widget_factory;	$widget_obj = $wp_widget_factory->widgets[$widget];	if ( !is_a($widget_obj, 'WP_Widget') )		return;	$before_widget = sprintf('<div class="widget %s">', $widget_obj->widget_options['classname']);	$default_args = array('before_widget' => $before_widget, 'after_widget' => "</div>", 'before_title' => '<h2 class="widgettitle">', 'after_title' => '</h2>');	$args = wp_parse_args($args, $default_args);	$instance = wp_parse_args($instance);	do_action( 'the_widget', $widget, $instance, $args );	$widget_obj->_set(-1);	$widget_obj->widget($args, $instance);}/** * Private */function _get_widget_id_base($id) {	return preg_replace( '/-[0-9]+$/', '', $id );}
<?php/** * PemFTP - A Ftp implementation in pure PHP * * @package PemFTP * @since 2.5 * * @version 1.0 * @copyright Alexey Dotsenko * @author Alexey Dotsenko * @link http://www.phpclasses.org/browse/package/1743.html Site * @license LGPL License http://www.opensource.org/licenses/lgpl-license.html *//** * Socket Based FTP implementation * * @package PemFTP * @subpackage Socket * @since 2.5 * * @version 1.0 * @copyright Alexey Dotsenko * @author Alexey Dotsenko * @link http://www.phpclasses.org/browse/package/1743.html Site * @license LGPL License http://www.opensource.org/licenses/lgpl-license.html */class ftp extends ftp_base {	function ftp($verb=FALSE, $le=FALSE) {		$this->__construct($verb, $le);	}	function __construct($verb=FALSE, $le=FALSE) {		parent::__construct(true, $verb, $le);	}// <!-- --------------------------------------------------------------------------------------- -->// <!--       Private functions                                                                 -->// <!-- --------------------------------------------------------------------------------------- -->	function _settimeout($sock) {		if(!@socket_set_option($sock, SOL_SOCKET, SO_RCVTIMEO, array("sec"=>$this->_timeout, "usec"=>0))) {			$this->PushError('_connect','socket set receive timeout',socket_strerror(socket_last_error($sock)));			@socket_close($sock);			return FALSE;		}		if(!@socket_set_option($sock, SOL_SOCKET , SO_SNDTIMEO, array("sec"=>$this->_timeout, "usec"=>0))) {			$this->PushError('_connect','socket set send timeout',socket_strerror(socket_last_error($sock)));			@socket_close($sock);			return FALSE;		}		return true;	}	function _connect($host, $port) {		$this->SendMSG("Creating socket");		if(!($sock = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP))) {			$this->PushError('_connect','socket create failed',socket_strerror(socket_last_error($sock)));			return FALSE;		}		if(!$this->_settimeout($sock)) return FALSE;		$this->SendMSG("Connecting to \"".$host.":".$port."\"");		if (!($res = @socket_connect($sock, $host, $port))) {			$this->PushError('_connect','socket connect failed',socket_strerror(socket_last_error($sock)));			@socket_close($sock);			return FALSE;		}		$this->_connected=true;		return $sock;	}	function _readmsg($fnction="_readmsg"){		if(!$this->_connected) {			$this->PushError($fnction,'Connect first');			return FALSE;		}		$result=true;		$this->_message="";		$this->_code=0;		$go=true;		do {			$tmp=@socket_read($this->_ftp_control_sock, 4096, PHP_BINARY_READ);			if($tmp===false) {				$go=$result=false;				$this->PushError($fnction,'Read failed', socket_strerror(socket_last_error($this->_ftp_control_sock)));			} else {				$this->_message.=$tmp;				$go = !preg_match("/^([0-9]{3})(-.+\\1)? [^".CRLF."]+".CRLF."$/Us", $this->_message, $regs);			}		} while($go);		if($this->LocalEcho) echo "GET < ".rtrim($this->_message, CRLF).CRLF;		$this->_code=(int)$regs[1];		return $result;	}	function _exec($cmd, $fnction="_exec") {		if(!$this->_ready) {			$this->PushError($fnction,'Connect first');			return FALSE;		}		if($this->LocalEcho) echo "PUT > ",$cmd,CRLF;		$status=@socket_write($this->_ftp_control_sock, $cmd.CRLF);		if($status===false) {			$this->PushError($fnction,'socket write failed', socket_strerror(socket_last_error($this->stream)));			return FALSE;		}		$this->_lastaction=time();		if(!$this->_readmsg($fnction)) return FALSE;		return TRUE;	}	function _data_prepare($mode=FTP_ASCII) {		if(!$this->_settype($mode)) return FALSE;		$this->SendMSG("Creating data socket");		$this->_ftp_data_sock = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP);		if ($this->_ftp_data_sock < 0) {			$this->PushError('_data_prepare','socket create failed',socket_strerror(socket_last_error($this->_ftp_data_sock)));			return FALSE;		}		if(!$this->_settimeout($this->_ftp_data_sock)) {			$this->_data_close();			return FALSE;		}		if($this->_passive) {			if(!$this->_exec("PASV", "pasv")) {				$this->_data_close();				return FALSE;			}			if(!$this->_checkCode()) {				$this->_data_close();				return FALSE;			}			$ip_port = explode(",", ereg_replace("^.+ \\(?([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},[0-9]{1,3},[0-9]+,[0-9]+)\\)?.*".CRLF."$", "\\1", $this->_message));			$this->_datahost=$ip_port[0].".".$ip_port[1].".".$ip_port[2].".".$ip_port[3];            $this->_dataport=(((int)$ip_port[4])<<8) + ((int)$ip_port[5]);			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			if(!@socket_connect($this->_ftp_data_sock, $this->_datahost, $this->_dataport)) {				$this->PushError("_data_prepare","socket_connect", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			else $this->_ftp_temp_sock=$this->_ftp_data_sock;		} else {			if(!@socket_getsockname($this->_ftp_control_sock, $addr, $port)) {				$this->PushError("_data_prepare","can't get control socket information", socket_strerror(socket_last_error($this->_ftp_control_sock)));				$this->_data_close();				return FALSE;			}			if(!@socket_bind($this->_ftp_data_sock,$addr)){				$this->PushError("_data_prepare","can't bind data socket", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			if(!@socket_listen($this->_ftp_data_sock)) {				$this->PushError("_data_prepare","can't listen data socket", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			if(!@socket_getsockname($this->_ftp_data_sock, $this->_datahost, $this->_dataport)) {				$this->PushError("_data_prepare","can't get data socket information", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			if(!$this->_exec('PORT '.str_replace('.',',',$this->_datahost.'.'.($this->_dataport>>8).'.'.($this->_dataport&0x00FF)), "_port")) {				$this->_data_close();				return FALSE;			}			if(!$this->_checkCode()) {				$this->_data_close();				return FALSE;			}		}		return TRUE;	}	function _data_read($mode=FTP_ASCII, $fp=NULL) {		$NewLine=$this->_eol_code[$this->OS_local];		if(is_resource($fp)) $out=0;		else $out="";		if(!$this->_passive) {			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			$this->_ftp_temp_sock=socket_accept($this->_ftp_data_sock);			if($this->_ftp_temp_sock===FALSE) {				$this->PushError("_data_read","socket_accept", socket_strerror(socket_last_error($this->_ftp_temp_sock)));				$this->_data_close();				return FALSE;			}		}		while(($block=@socket_read($this->_ftp_temp_sock, $this->_ftp_buff_size, PHP_BINARY_READ))!==false) {			if($block==="") break;			if($mode!=FTP_BINARY) $block=preg_replace("/\r\n|\r|\n/", $this->_eol_code[$this->OS_local], $block);			if(is_resource($fp)) $out+=fwrite($fp, $block, strlen($block));			else $out.=$block;		}		return $out;	}	function _data_write($mode=FTP_ASCII, $fp=NULL) {		$NewLine=$this->_eol_code[$this->OS_local];		if(is_resource($fp)) $out=0;		else $out="";		if(!$this->_passive) {			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			$this->_ftp_temp_sock=socket_accept($this->_ftp_data_sock);			if($this->_ftp_temp_sock===FALSE) {				$this->PushError("_data_write","socket_accept", socket_strerror(socket_last_error($this->_ftp_temp_sock)));				$this->_data_close();				return false;			}		}		if(is_resource($fp)) {			while(!feof($fp)) {				$block=fread($fp, $this->_ftp_buff_size);				if(!$this->_data_write_block($mode, $block)) return false;			}		} elseif(!$this->_data_write_block($mode, $fp)) return false;		return true;	}	function _data_write_block($mode, $block) {		if($mode!=FTP_BINARY) $block=preg_replace("/\r\n|\r|\n/", $this->_eol_code[$this->OS_remote], $block);		do {			if(($t=@socket_write($this->_ftp_temp_sock, $block))===FALSE) {				$this->PushError("_data_write","socket_write", socket_strerror(socket_last_error($this->_ftp_temp_sock)));				$this->_data_close();				return FALSE;			}			$block=substr($block, $t);		} while(!empty($block));		return true;	}	function _data_close() {		@socket_close($this->_ftp_temp_sock);		@socket_close($this->_ftp_data_sock);		$this->SendMSG("Disconnected data from remote host");		return TRUE;	}	function _quit() {		if($this->_connected) {			@socket_close($this->_ftp_control_sock);			$this->_connected=false;			$this->SendMSG("Socket closed");		}	}}?>
<?php/** * PemFTP - A Ftp implementation in pure PHP * * @package PemFTP * @since 2.5 * * @version 1.0 * @copyright Alexey Dotsenko * @author Alexey Dotsenko * @link http://www.phpclasses.org/browse/package/1743.html Site * @license LGPL License http://www.opensource.org/licenses/lgpl-license.html *//** * FTP implementation using fsockopen to connect. * * @package PemFTP * @subpackage Pure * @since 2.5 * * @version 1.0 * @copyright Alexey Dotsenko * @author Alexey Dotsenko * @link http://www.phpclasses.org/browse/package/1743.html Site * @license LGPL License http://www.opensource.org/licenses/lgpl-license.html */class ftp extends ftp_base {	function ftp($verb=FALSE, $le=FALSE) {		$this->__construct($verb, $le);	}	function __construct($verb=FALSE, $le=FALSE) {		parent::__construct(false, $verb, $le);	}// <!-- --------------------------------------------------------------------------------------- -->// <!--       Private functions                                                                 -->// <!-- --------------------------------------------------------------------------------------- -->	function _settimeout($sock) {		if(!@stream_set_timeout($sock, $this->_timeout)) {			$this->PushError('_settimeout','socket set send timeout');			$this->_quit();			return FALSE;		}		return TRUE;	}	function _connect($host, $port) {		$this->SendMSG("Creating socket");		$sock = @fsockopen($host, $port, $errno, $errstr, $this->_timeout);		if (!$sock) {			$this->PushError('_connect','socket connect failed', $errstr." (".$errno.")");			return FALSE;		}		$this->_connected=true;		return $sock;	}	function _readmsg($fnction="_readmsg"){		if(!$this->_connected) {			$this->PushError($fnction, 'Connect first');			return FALSE;		}		$result=true;		$this->_message="";		$this->_code=0;		$go=true;		do {			$tmp=@fgets($this->_ftp_control_sock, 512);			if($tmp===false) {				$go=$result=false;				$this->PushError($fnction,'Read failed');			} else {				$this->_message.=$tmp;				if(preg_match("/^([0-9]{3})(-(.*[".CRLF."]{1,2})+\\1)? [^".CRLF."]+[".CRLF."]{1,2}$/", $this->_message, $regs)) $go=false;			}		} while($go);		if($this->LocalEcho) echo "GET < ".rtrim($this->_message, CRLF).CRLF;		$this->_code=(int)$regs[1];		return $result;	}	function _exec($cmd, $fnction="_exec") {		if(!$this->_ready) {			$this->PushError($fnction,'Connect first');			return FALSE;		}		if($this->LocalEcho) echo "PUT > ",$cmd,CRLF;		$status=@fputs($this->_ftp_control_sock, $cmd.CRLF);		if($status===false) {			$this->PushError($fnction,'socket write failed');			return FALSE;		}		$this->_lastaction=time();		if(!$this->_readmsg($fnction)) return FALSE;		return TRUE;	}	function _data_prepare($mode=FTP_ASCII) {		if(!$this->_settype($mode)) return FALSE;		if($this->_passive) {			if(!$this->_exec("PASV", "pasv")) {				$this->_data_close();				return FALSE;			}			if(!$this->_checkCode()) {				$this->_data_close();				return FALSE;			}			$ip_port = explode(",", ereg_replace("^.+ \\(?([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},[0-9]{1,3},[0-9]+,[0-9]+)\\)?.*".CRLF."$", "\\1", $this->_message));			$this->_datahost=$ip_port[0].".".$ip_port[1].".".$ip_port[2].".".$ip_port[3];            $this->_dataport=(((int)$ip_port[4])<<8) + ((int)$ip_port[5]);			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			$this->_ftp_data_sock=@fsockopen($this->_datahost, $this->_dataport, $errno, $errstr, $this->_timeout);			if(!$this->_ftp_data_sock) {				$this->PushError("_data_prepare","fsockopen fails", $errstr." (".$errno.")");				$this->_data_close();				return FALSE;			}			else $this->_ftp_data_sock;		} else {			$this->SendMSG("Only passive connections available!");			return FALSE;		}		return TRUE;	}	function _data_read($mode=FTP_ASCII, $fp=NULL) {		if(is_resource($fp)) $out=0;		else $out="";		if(!$this->_passive) {			$this->SendMSG("Only passive connections available!");			return FALSE;		}		while (!feof($this->_ftp_data_sock)) {			$block=fread($this->_ftp_data_sock, $this->_ftp_buff_size);			if($mode!=FTP_BINARY) $block=preg_replace("/\r\n|\r|\n/", $this->_eol_code[$this->OS_local], $block);			if(is_resource($fp)) $out+=fwrite($fp, $block, strlen($block));			else $out.=$block;		}		return $out;	}	function _data_write($mode=FTP_ASCII, $fp=NULL) {		if(is_resource($fp)) $out=0;		else $out="";		if(!$this->_passive) {			$this->SendMSG("Only passive connections available!");			return FALSE;		}		if(is_resource($fp)) {			while(!feof($fp)) {				$block=fread($fp, $this->_ftp_buff_size);				if(!$this->_data_write_block($mode, $block)) return false;			}		} elseif(!$this->_data_write_block($mode, $fp)) return false;		return TRUE;	}	function _data_write_block($mode, $block) {		if($mode!=FTP_BINARY) $block=preg_replace("/\r\n|\r|\n/", $this->_eol_code[$this->OS_remote], $block);		do {			if(($t=@fwrite($this->_ftp_data_sock, $block))===FALSE) {				$this->PushError("_data_write","Can't write to socket");				return FALSE;			}			$block=substr($block, $t);		} while(!empty($block));		return true;	}	function _data_close() {		@fclose($this->_ftp_data_sock);		$this->SendMSG("Disconnected data from remote host");		return TRUE;	}	function _quit($force=FALSE) {		if($this->_connected or $force) {			@fclose($this->_ftp_control_sock);			$this->_connected=false;			$this->SendMSG("Socket closed");		}	}}?>
<?php/** * IXR - The Inutio XML-RPC Library * * @package IXR * @since 1.5 * * @copyright Incutio Ltd 2002-2005 * @version 1.7 (beta) 23rd May 2005 * @author Simon Willison * @link http://scripts.incutio.com/xmlrpc/ Site * @link http://scripts.incutio.com/xmlrpc/manual.php Manual * @license BSD License http://www.opensource.org/licenses/bsd-license.php *//** * IXR_Value * * @package IXR * @since 1.5 */class IXR_Value {    var $data;    var $type;    function IXR_Value ($data, $type = false) {        $this->data = $data;        if (!$type) {            $type = $this->calculateType();        }        $this->type = $type;        if ($type == 'struct') {            /* Turn all the values in the array in to new IXR_Value objects */            foreach ($this->data as $key => $value) {                $this->data[$key] = new IXR_Value($value);            }        }        if ($type == 'array') {            for ($i = 0, $j = count($this->data); $i < $j; $i++) {                $this->data[$i] = new IXR_Value($this->data[$i]);            }        }    }    function calculateType() {        if ($this->data === true || $this->data === false) {            return 'boolean';        }        if (is_integer($this->data)) {            return 'int';        }        if (is_double($this->data)) {            return 'double';        }        // Deal with IXR object types base64 and date        if (is_object($this->data) && is_a($this->data, 'IXR_Date')) {            return 'date';        }        if (is_object($this->data) && is_a($this->data, 'IXR_Base64')) {            return 'base64';        }        // If it is a normal PHP object convert it in to a struct        if (is_object($this->data)) {            $this->data = get_object_vars($this->data);            return 'struct';        }        if (!is_array($this->data)) {            return 'string';        }        /* We have an array - is it an array or a struct ? */        if ($this->isStruct($this->data)) {            return 'struct';        } else {            return 'array';        }    }    function getXml() {        /* Return XML for this value */        switch ($this->type) {            case 'boolean':                return '<boolean>'.(($this->data) ? '1' : '0').'</boolean>';                break;            case 'int':                return '<int>'.$this->data.'</int>';                break;            case 'double':                return '<double>'.$this->data.'</double>';                break;            case 'string':                return '<string>'.htmlspecialchars($this->data).'</string>';                break;            case 'array':                $return = '<array><data>'."\n";                foreach ($this->data as $item) {                    $return .= '  <value>'.$item->getXml()."</value>\n";                }                $return .= '</data></array>';                return $return;                break;            case 'struct':                $return = '<struct>'."\n";                foreach ($this->data as $name => $value) {					$name = htmlspecialchars($name);                    $return .= "  <member><name>$name</name><value>";                    $return .= $value->getXml()."</value></member>\n";                }                $return .= '</struct>';                return $return;                break;            case 'date':            case 'base64':                return $this->data->getXml();                break;        }        return false;    }    function isStruct($array) {        /* Nasty function to check if an array is a struct or not */        $expected = 0;        foreach ($array as $key => $value) {            if ((string)$key != (string)$expected) {                return true;            }            $expected++;        }        return false;    }}/** * IXR_Message * * @package IXR * @since 1.5 */class IXR_Message {    var $message;    var $messageType;  // methodCall / methodResponse / fault    var $faultCode;    var $faultString;    var $methodName;    var $params;    // Current variable stacks    var $_arraystructs = array();   // The stack used to keep track of the current array/struct    var $_arraystructstypes = array(); // Stack keeping track of if things are structs or array    var $_currentStructName = array();  // A stack as well    var $_param;    var $_value;    var $_currentTag;    var $_currentTagContents;    // The XML parser    var $_parser;    function IXR_Message (&$message) {        $this->message = &$message;    }    function parse() {		// first remove the XML declaration		// this method avoids the RAM usage of preg_replace on very large messages		$header = preg_replace( '/<\?xml.*?\?'.'>/', '', substr( $this->message, 0, 100 ), 1 );		$this->message = substr_replace($this->message, $header, 0, 100);        if (trim($this->message) == '') {            return false;		}        $this->_parser = xml_parser_create();        // Set XML parser to take the case of tags in to account        xml_parser_set_option($this->_parser, XML_OPTION_CASE_FOLDING, false);        // Set XML parser callback functions        xml_set_object($this->_parser, $this);        xml_set_element_handler($this->_parser, 'tag_open', 'tag_close');		xml_set_character_data_handler($this->_parser, 'cdata');		$chunk_size = 262144; // 256Kb, parse in chunks to avoid the RAM usage on very large messages		do {			if ( strlen($this->message) <= $chunk_size )				$final=true;			$part = substr( $this->message, 0, $chunk_size );			$this->message = substr( $this->message, $chunk_size );			if ( !xml_parse( $this->_parser, $part, $final ) )				return false;			if ( $final )				break;		} while ( true );		xml_parser_free($this->_parser);        // Grab the error messages, if any        if ($this->messageType == 'fault') {            $this->faultCode = $this->params[0]['faultCode'];            $this->faultString = $this->params[0]['faultString'];		}        return true;    }    function tag_open($parser, $tag, $attr) {        $this->_currentTagContents = '';        $this->currentTag = $tag;        switch($tag) {            case 'methodCall':            case 'methodResponse':            case 'fault':                $this->messageType = $tag;                break;            /* Deal with stacks of arrays and structs */            case 'data':    // data is to all intents and puposes more interesting than array                $this->_arraystructstypes[] = 'array';                $this->_arraystructs[] = array();                break;            case 'struct':                $this->_arraystructstypes[] = 'struct';                $this->_arraystructs[] = array();                break;        }    }    function cdata($parser, $cdata) {        $this->_currentTagContents .= $cdata;    }    function tag_close($parser, $tag) {        $valueFlag = false;        switch($tag) {            case 'int':            case 'i4':                $value = (int) trim($this->_currentTagContents);                $valueFlag = true;                break;            case 'double':                $value = (double) trim($this->_currentTagContents);                $valueFlag = true;                break;            case 'string':                $value = $this->_currentTagContents;                $valueFlag = true;                break;            case 'dateTime.iso8601':                $value = new IXR_Date(trim($this->_currentTagContents));                // $value = $iso->getTimestamp();                $valueFlag = true;                break;            case 'value':                // "If no type is indicated, the type is string."                if (trim($this->_currentTagContents) != '') {                    $value = (string)$this->_currentTagContents;                    $valueFlag = true;                }                break;            case 'boolean':                $value = (boolean) trim($this->_currentTagContents);                $valueFlag = true;                break;            case 'base64':                $value = base64_decode( trim( $this->_currentTagContents ) );                $valueFlag = true;                break;            /* Deal with stacks of arrays and structs */            case 'data':            case 'struct':                $value = array_pop($this->_arraystructs);                array_pop($this->_arraystructstypes);                $valueFlag = true;                break;            case 'member':                array_pop($this->_currentStructName);                break;            case 'name':                $this->_currentStructName[] = trim($this->_currentTagContents);                break;            case 'methodName':                $this->methodName = trim($this->_currentTagContents);                break;        }        if ($valueFlag) {            if (count($this->_arraystructs) > 0) {                // Add value to struct or array                if ($this->_arraystructstypes[count($this->_arraystructstypes)-1] == 'struct') {                    // Add to struct                    $this->_arraystructs[count($this->_arraystructs)-1][$this->_currentStructName[count($this->_currentStructName)-1]] = $value;                } else {                    // Add to array                    $this->_arraystructs[count($this->_arraystructs)-1][] = $value;                }            } else {                // Just add as a paramater                $this->params[] = $value;            }        }        $this->_currentTagContents = '';    }}/** * IXR_Server * * @package IXR * @since 1.5 */class IXR_Server {    var $data;    var $callbacks = array();    var $message;    var $capabilities;    function IXR_Server($callbacks = false, $data = false) {        $this->setCapabilities();        if ($callbacks) {            $this->callbacks = $callbacks;        }        $this->setCallbacks();        $this->serve($data);    }    function serve($data = false) {        if (!$data) {            global $HTTP_RAW_POST_DATA;            if (!$HTTP_RAW_POST_DATA) {               header( 'Content-Type: text/plain' );               die('XML-RPC server accepts POST requests only.');            }            $data = &$HTTP_RAW_POST_DATA;        }        $this->message = new IXR_Message($data);        if (!$this->message->parse()) {            $this->error(-32700, 'parse error. not well formed');        }        if ($this->message->messageType != 'methodCall') {            $this->error(-32600, 'server error. invalid xml-rpc. not conforming to spec. Request must be a methodCall');        }        $result = $this->call($this->message->methodName, $this->message->params);        // Is the result an error?        if (is_a($result, 'IXR_Error')) {            $this->error($result);        }        // Encode the result        $r = new IXR_Value($result);        $resultxml = $r->getXml();        // Create the XML        $xml = <<<EOD<methodResponse>  <params>    <param>      <value>        $resultxml      </value>    </param>  </params></methodResponse>EOD;        // Send it        $this->output($xml);    }    function call($methodname, $args) {        if (!$this->hasMethod($methodname)) {            return new IXR_Error(-32601, 'server error. requested method '.                $methodname.' does not exist.');        }        $method = $this->callbacks[$methodname];        // Perform the callback and send the response        if (count($args) == 1) {            // If only one paramater just send that instead of the whole array            $args = $args[0];        }        // Are we dealing with a function or a method?        if ( is_string( $method ) && substr($method, 0, 5) == 'this:' ) {            // It's a class method - check it exists            $method = substr($method, 5);            if (!method_exists($this, $method)) {                return new IXR_Error(-32601, 'server error. requested class method "'.                    $method.'" does not exist.');            }            // Call the method            $result = $this->$method($args);        } else {            // It's a function - does it exist?            if (is_array($method)) {                if (!method_exists($method[0], $method[1])) {                    return new IXR_Error(-32601, 'server error. requested object method "'.                        $method[1].'" does not exist.');                }            } else if (!function_exists($method)) {                return new IXR_Error(-32601, 'server error. requested function "'.                    $method.'" does not exist.');            }            // Call the function            $result = call_user_func($method, $args);        }        return $result;    }    function error($error, $message = false) {        // Accepts either an error object or an error code and message        if ($message && !is_object($error)) {            $error = new IXR_Error($error, $message);        }        $this->output($error->getXml());    }    function output($xml) {        $xml = '<?xml version="1.0"?>'."\n".$xml;        $length = strlen($xml);        header('Connection: close');        header('Content-Length: '.$length);        header('Content-Type: text/xml');        header('Date: '.date('r'));        echo $xml;        exit;    }    function hasMethod($method) {        return in_array($method, array_keys($this->callbacks));    }    function setCapabilities() {        // Initialises capabilities array        $this->capabilities = array(            'xmlrpc' => array(                'specUrl' => 'http://www.xmlrpc.com/spec',                'specVersion' => 1            ),            'faults_interop' => array(                'specUrl' => 'http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php',                'specVersion' => 20010516            ),            'system.multicall' => array(                'specUrl' => 'http://www.xmlrpc.com/discuss/msgReader$1208',                'specVersion' => 1            ),        );    }    function getCapabilities($args) {        return $this->capabilities;    }    function setCallbacks() {        $this->callbacks['system.getCapabilities'] = 'this:getCapabilities';        $this->callbacks['system.listMethods'] = 'this:listMethods';        $this->callbacks['system.multicall'] = 'this:multiCall';    }    function listMethods($args) {        // Returns a list of methods - uses array_reverse to ensure user defined        // methods are listed before server defined methods        return array_reverse(array_keys($this->callbacks));    }    function multiCall($methodcalls) {        // See http://www.xmlrpc.com/discuss/msgReader$1208        $return = array();        foreach ($methodcalls as $call) {            $method = $call['methodName'];            $params = $call['params'];            if ($method == 'system.multicall') {                $result = new IXR_Error(-32600, 'Recursive calls to system.multicall are forbidden');            } else {                $result = $this->call($method, $params);            }            if (is_a($result, 'IXR_Error')) {                $return[] = array(                    'faultCode' => $result->code,                    'faultString' => $result->message                );            } else {                $return[] = array($result);            }        }        return $return;    }}/** * IXR_Request * * @package IXR * @since 1.5 */class IXR_Request {    var $method;    var $args;    var $xml;    function IXR_Request($method, $args) {        $this->method = $method;        $this->args = $args;        $this->xml = <<<EOD<?xml version="1.0"?><methodCall><methodName>{$this->method}</methodName><params>EOD;        foreach ($this->args as $arg) {            $this->xml .= '<param><value>';            $v = new IXR_Value($arg);            $this->xml .= $v->getXml();            $this->xml .= "</value></param>\n";        }        $this->xml .= '</params></methodCall>';    }    function getLength() {        return strlen($this->xml);    }    function getXml() {        return $this->xml;    }}/** * IXR_Client * * @package IXR * @since 1.5 */class IXR_Client {    var $server;    var $port;    var $path;    var $useragent;	var $headers;    var $response;    var $message = false;    var $debug = false;    var $timeout;    // Storage place for an error message    var $error = false;    function IXR_Client($server, $path = false, $port = 80, $timeout = false) {        if (!$path) {            // Assume we have been given a URL instead            $bits = parse_url($server);            $this->server = $bits['host'];            $this->port = isset($bits['port']) ? $bits['port'] : 80;            $this->path = isset($bits['path']) ? $bits['path'] : '/';            // Make absolutely sure we have a path            if (!$this->path) {                $this->path = '/';            }        } else {            $this->server = $server;            $this->path = $path;            $this->port = $port;        }        $this->useragent = 'The Incutio XML-RPC PHP Library';        $this->timeout = $timeout;    }    function query() {        $args = func_get_args();        $method = array_shift($args);        $request = new IXR_Request($method, $args);        $length = $request->getLength();        $xml = $request->getXml();        $r = "\r\n";        $request  = "POST {$this->path} HTTP/1.0$r";		$this->headers['Host']			= $this->server;		$this->headers['Content-Type']	= 'text/xml';		$this->headers['User-Agent']	= $this->useragent;		$this->headers['Content-Length']= $length;		foreach( $this->headers as $header => $value ) {			$request .= "{$header}: {$value}{$r}";		}		$request .= $r;        $request .= $xml;        // Now send the request        if ($this->debug) {            echo '<pre class="ixr_request">'.htmlspecialchars($request)."\n</pre>\n\n";        }        if ($this->timeout) {            $fp = @fsockopen($this->server, $this->port, $errno, $errstr, $this->timeout);        } else {            $fp = @fsockopen($this->server, $this->port, $errno, $errstr);        }        if (!$fp) {            $this->error = new IXR_Error(-32300, "transport error - could not open socket: $errno $errstr");            return false;        }        fputs($fp, $request);        $contents = '';        $debug_contents = '';        $gotFirstLine = false;        $gettingHeaders = true;        while (!feof($fp)) {            $line = fgets($fp, 4096);            if (!$gotFirstLine) {                // Check line for '200'                if (strstr($line, '200') === false) {                    $this->error = new IXR_Error(-32301, 'transport error - HTTP status code was not 200');                    return false;                }                $gotFirstLine = true;            }            if (trim($line) == '') {                $gettingHeaders = false;            }            if (!$gettingHeaders) {            	// WP#12559 remove trim so as to not strip newlines from received response.                $contents .= $line;            }            if ($this->debug) {                $debug_contents .= $line;            }        }        if ($this->debug) {            echo '<pre class="ixr_response">'.htmlspecialchars($debug_contents)."\n</pre>\n\n";        }        // Now parse what we've got back        $this->message = new IXR_Message($contents);        if (!$this->message->parse()) {            // XML error            $this->error = new IXR_Error(-32700, 'parse error. not well formed');            return false;        }        // Is the message a fault?        if ($this->message->messageType == 'fault') {            $this->error = new IXR_Error($this->message->faultCode, $this->message->faultString);            return false;        }        // Message must be OK        return true;    }    function getResponse() {        // methodResponses can only have one param - return that        return $this->message->params[0];    }    function isError() {        return (is_object($this->error));    }    function getErrorCode() {        return $this->error->code;    }    function getErrorMessage() {        return $this->error->message;    }}/** * IXR_Error * * @package IXR * @since 1.5 */class IXR_Error {    var $code;    var $message;    function IXR_Error($code, $message) {        $this->code = $code;        // WP adds htmlspecialchars(). See #5666        $this->message = htmlspecialchars($message);    }    function getXml() {        $xml = <<<EOD<methodResponse>  <fault>    <value>      <struct>        <member>          <name>faultCode</name>          <value><int>{$this->code}</int></value>        </member>        <member>          <name>faultString</name>          <value><string>{$this->message}</string></value>        </member>      </struct>    </value>  </fault></methodResponse>EOD;        return $xml;    }}/** * IXR_Date * * @package IXR * @since 1.5 */class IXR_Date {    var $year;    var $month;    var $day;    var $hour;    var $minute;    var $second;    var $timezone;    function IXR_Date($time) {        // $time can be a PHP timestamp or an ISO one        if (is_numeric($time)) {            $this->parseTimestamp($time);        } else {            $this->parseIso($time);        }    }    function parseTimestamp($timestamp) {        $this->year = date('Y', $timestamp);        $this->month = date('m', $timestamp);        $this->day = date('d', $timestamp);        $this->hour = date('H', $timestamp);        $this->minute = date('i', $timestamp);        $this->second = date('s', $timestamp);        // WP adds timezone. See #2036        $this->timezone = '';    }    function parseIso($iso) {        $this->year = substr($iso, 0, 4);        $this->month = substr($iso, 4, 2);        $this->day = substr($iso, 6, 2);        $this->hour = substr($iso, 9, 2);        $this->minute = substr($iso, 12, 2);        $this->second = substr($iso, 15, 2);        // WP adds timezone. See #2036        $this->timezone = substr($iso, 17);    }    function getIso() {    	// WP adds timezone. See #2036        return $this->year.$this->month.$this->day.'T'.$this->hour.':'.$this->minute.':'.$this->second.$this->timezone;    }    function getXml() {        return '<dateTime.iso8601>'.$this->getIso().'</dateTime.iso8601>';    }    function getTimestamp() {        return mktime($this->hour, $this->minute, $this->second, $this->month, $this->day, $this->year);    }}/** * IXR_Base64 * * @package IXR * @since 1.5 */class IXR_Base64 {    var $data;    function IXR_Base64($data) {        $this->data = $data;    }    function getXml() {        return '<base64>'.base64_encode($this->data).'</base64>';    }}/** * IXR_IntrospectionServer * * @package IXR * @since 1.5 */class IXR_IntrospectionServer extends IXR_Server {    var $signatures;    var $help;    function IXR_IntrospectionServer() {        $this->setCallbacks();        $this->setCapabilities();        $this->capabilities['introspection'] = array(            'specUrl' => 'http://xmlrpc.usefulinc.com/doc/reserved.html',            'specVersion' => 1        );        $this->addCallback(            'system.methodSignature',            'this:methodSignature',            array('array', 'string'),            'Returns an array describing the return type and required parameters of a method'        );        $this->addCallback(            'system.getCapabilities',            'this:getCapabilities',            array('struct'),            'Returns a struct describing the XML-RPC specifications supported by this server'        );        $this->addCallback(            'system.listMethods',            'this:listMethods',            array('array'),            'Returns an array of available methods on this server'        );        $this->addCallback(            'system.methodHelp',            'this:methodHelp',            array('string', 'string'),            'Returns a documentation string for the specified method'        );    }    function addCallback($method, $callback, $args, $help) {        $this->callbacks[$method] = $callback;        $this->signatures[$method] = $args;        $this->help[$method] = $help;    }    function call($methodname, $args) {        // Make sure it's in an array        if ($args && !is_array($args)) {            $args = array($args);        }        // Over-rides default call method, adds signature check        if (!$this->hasMethod($methodname)) {            return new IXR_Error(-32601, 'server error. requested method "'.$this->message->methodName.'" not specified.');        }        $method = $this->callbacks[$methodname];        $signature = $this->signatures[$methodname];        $returnType = array_shift($signature);        // Check the number of arguments        if (count($args) != count($signature)) {            return new IXR_Error(-32602, 'server error. wrong number of method parameters');        }        // Check the argument types        $ok = true;        $argsbackup = $args;        for ($i = 0, $j = count($args); $i < $j; $i++) {            $arg = array_shift($args);            $type = array_shift($signature);            switch ($type) {                case 'int':                case 'i4':                    if (is_array($arg) || !is_int($arg)) {                        $ok = false;                    }                    break;                case 'base64':                case 'string':                    if (!is_string($arg)) {                        $ok = false;                    }                    break;                case 'boolean':                    if ($arg !== false && $arg !== true) {                        $ok = false;                    }                    break;                case 'float':                case 'double':                    if (!is_float($arg)) {                        $ok = false;                    }                    break;                case 'date':                case 'dateTime.iso8601':                    if (!is_a($arg, 'IXR_Date')) {                        $ok = false;                    }                    break;            }            if (!$ok) {                return new IXR_Error(-32602, 'server error. invalid method parameters');            }        }        // It passed the test - run the "real" method call        return parent::call($methodname, $argsbackup);    }    function methodSignature($method) {        if (!$this->hasMethod($method)) {            return new IXR_Error(-32601, 'server error. requested method "'.$method.'" not specified.');        }        // We should be returning an array of types        $types = $this->signatures[$method];        $return = array();        foreach ($types as $type) {            switch ($type) {                case 'string':                    $return[] = 'string';                    break;                case 'int':                case 'i4':                    $return[] = 42;                    break;                case 'double':                    $return[] = 3.1415;                    break;                case 'dateTime.iso8601':                    $return[] = new IXR_Date(time());                    break;                case 'boolean':                    $return[] = true;                    break;                case 'base64':                    $return[] = new IXR_Base64('base64');                    break;                case 'array':                    $return[] = array('array');                    break;                case 'struct':                    $return[] = array('struct' => 'struct');                    break;            }        }        return $return;    }    function methodHelp($method) {        return $this->help[$method];    }}/** * IXR_ClientMulticall * * @package IXR * @since 1.5 */class IXR_ClientMulticall extends IXR_Client {    var $calls = array();    function IXR_ClientMulticall($server, $path = false, $port = 80) {        parent::IXR_Client($server, $path, $port);        $this->useragent = 'The Incutio XML-RPC PHP Library (multicall client)';    }    function addCall() {        $args = func_get_args();        $methodName = array_shift($args);        $struct = array(            'methodName' => $methodName,            'params' => $args        );        $this->calls[] = $struct;    }    function query() {        // Prepare multicall, then call the parent::query() method        return parent::query('system.multicall', $this->calls);    }}?>
<?php/** * The Footer widget areas. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */?><?php	/* The footer widget area is triggered if any of the areas	 * have widgets. So let's check that first.	 *	 * If none of the sidebars have widgets, then let's bail early.	 */	if (   ! is_active_sidebar( 'first-footer-widget-area'  )		&& ! is_active_sidebar( 'second-footer-widget-area' )		&& ! is_active_sidebar( 'third-footer-widget-area'  )		&& ! is_active_sidebar( 'fourth-footer-widget-area' )	)		return;	// If we get this far, we have widgets. Let do this.?>			<div id="footer-widget-area" role="complementary"><?php if ( is_active_sidebar( 'first-footer-widget-area' ) ) : ?>				<div id="first" class="widget-area">					<ul class="xoxo">						<?php dynamic_sidebar( 'first-footer-widget-area' ); ?>					</ul>				</div><!-- #first .widget-area --><?php endif; ?><?php if ( is_active_sidebar( 'second-footer-widget-area' ) ) : ?>				<div id="second" class="widget-area">					<ul class="xoxo">						<?php dynamic_sidebar( 'second-footer-widget-area' ); ?>					</ul>				</div><!-- #second .widget-area --><?php endif; ?><?php if ( is_active_sidebar( 'third-footer-widget-area' ) ) : ?>				<div id="third" class="widget-area">					<ul class="xoxo">						<?php dynamic_sidebar( 'third-footer-widget-area' ); ?>					</ul>				</div><!-- #third .widget-area --><?php endif; ?><?php if ( is_active_sidebar( 'fourth-footer-widget-area' ) ) : ?>				<div id="fourth" class="widget-area">					<ul class="xoxo">						<?php dynamic_sidebar( 'fourth-footer-widget-area' ); ?>					</ul>				</div><!-- #fourth .widget-area --><?php endif; ?>			</div><!-- #footer-widget-area -->
<?php/** * User Registration API * * @package WordPress *//** * Checks whether the given username exists. * * @since 2.0.0 * * @param string $username Username. * @return null|int The user's ID on success, and null on failure. */function username_exists( $username ) {	if ( $user = get_userdatabylogin( $username ) ) {		return $user->ID;	} else {		return null;	}}/** * Checks whether the given email exists. * * @since 2.1.0 * @uses $wpdb * * @param string $email Email. * @return bool|int The user's ID on success, and false on failure. */function email_exists( $email ) {	if ( $user = get_user_by_email($email) )		return $user->ID;	return false;}/** * Checks whether an username is valid. * * @since 2.0.1 * @uses apply_filters() Calls 'validate_username' hook on $valid check and $username as parameters * * @param string $username Username. * @return bool Whether username given is valid */function validate_username( $username ) {	$sanitized = sanitize_user( $username, true );	$valid = ( $sanitized == $username );	return apply_filters( 'validate_username', $valid, $username );}/** * Insert an user into the database. * * Can update a current user or insert a new user based on whether the user's ID * is present. * * Can be used to update the user's info (see below), set the user's role, and * set the user's preference on whether they want the rich editor on. * * Most of the $userdata array fields have filters associated with the values. * The exceptions are 'rich_editing', 'role', 'jabber', 'aim', 'yim', * 'user_registered', and 'ID'. The filters have the prefix 'pre_user_' followed * by the field name. An example using 'description' would have the filter * called, 'pre_user_description' that can be hooked into. * * The $userdata array can contain the following fields: * 'ID' - An integer that will be used for updating an existing user. * 'user_pass' - A string that contains the plain text password for the user. * 'user_login' - A string that contains the user's username for logging in. * 'user_nicename' - A string that contains a nicer looking name for the user. *		The default is the user's username. * 'user_url' - A string containing the user's URL for the user's web site. * 'user_email' - A string containing the user's email address. * 'display_name' - A string that will be shown on the site. Defaults to user's *		username. It is likely that you will want to change this, for both *		appearance and security through obscurity (that is if you don't use and *		delete the default 'admin' user). * 'nickname' - The user's nickname, defaults to the user's username. * 'first_name' - The user's first name. * 'last_name' - The user's last name. * 'description' - A string containing content about the user. * 'rich_editing' - A string for whether to enable the rich editor. False *		if not empty. * 'user_registered' - The date the user registered. Format is 'Y-m-d H:i:s'. * 'role' - A string used to set the user's role. * 'jabber' - User's Jabber account. * 'aim' - User's AOL IM account. * 'yim' - User's Yahoo IM account. * * @since 2.0.0 * @uses $wpdb WordPress database layer. * @uses apply_filters() Calls filters for most of the $userdata fields with the prefix 'pre_user'. See note above. * @uses do_action() Calls 'profile_update' hook when updating giving the user's ID * @uses do_action() Calls 'user_register' hook when creating a new user giving the user's ID * * @param array $userdata An array of user data. * @return int|WP_Error The newly created user's ID or a WP_Error object if the user could not be created. */function wp_insert_user($userdata) {	global $wpdb;	extract($userdata, EXTR_SKIP);	// Are we updating or creating?	if ( !empty($ID) ) {		$ID = (int) $ID;		$update = true;		$old_user_data = get_userdata($ID);	} else {		$update = false;		// Hash the password		$user_pass = wp_hash_password($user_pass);	}	$user_login = sanitize_user($user_login, true);	$user_login = apply_filters('pre_user_login', $user_login);	//Remove any non-printable chars from the login string to see if we have ended up with an empty username	$user_login = trim($user_login);	if ( empty($user_login) )		return new WP_Error('empty_user_login', __('Cannot create a user with an empty login name.') );	if ( !$update && username_exists( $user_login ) )		return new WP_Error('existing_user_login', __('This username is already registered.') );	if ( empty($user_nicename) )		$user_nicename = sanitize_title( $user_login );	$user_nicename = apply_filters('pre_user_nicename', $user_nicename);	if ( empty($user_url) )		$user_url = '';	$user_url = apply_filters('pre_user_url', $user_url);	if ( empty($user_email) )		$user_email = '';	$user_email = apply_filters('pre_user_email', $user_email);	if ( !$update && ! defined( 'WP_IMPORTING' ) && email_exists($user_email) )		return new WP_Error('existing_user_email', __('This email address is already registered.') );	if ( empty($display_name) )		$display_name = $user_login;	$display_name = apply_filters('pre_user_display_name', $display_name);	if ( empty($nickname) )		$nickname = $user_login;	$nickname = apply_filters('pre_user_nickname', $nickname);	if ( empty($first_name) )		$first_name = '';	$first_name = apply_filters('pre_user_first_name', $first_name);	if ( empty($last_name) )		$last_name = '';	$last_name = apply_filters('pre_user_last_name', $last_name);	if ( empty($description) )		$description = '';	$description = apply_filters('pre_user_description', $description);	if ( empty($rich_editing) )		$rich_editing = 'true';	if ( empty($comment_shortcuts) )		$comment_shortcuts = 'false';	if ( empty($admin_color) )		$admin_color = 'fresh';	$admin_color = preg_replace('|[^a-z0-9 _.\-@]|i', '', $admin_color);	if ( empty($use_ssl) )		$use_ssl = 0;	if ( empty($user_registered) )		$user_registered = gmdate('Y-m-d H:i:s');	$user_nicename_check = $wpdb->get_var( $wpdb->prepare("SELECT ID FROM $wpdb->users WHERE user_nicename = %s AND user_login != %s LIMIT 1" , $user_nicename, $user_login));	if ( $user_nicename_check ) {		$suffix = 2;		while ($user_nicename_check) {			$alt_user_nicename = $user_nicename . "-$suffix";			$user_nicename_check = $wpdb->get_var( $wpdb->prepare("SELECT ID FROM $wpdb->users WHERE user_nicename = %s AND user_login != %s LIMIT 1" , $alt_user_nicename, $user_login));			$suffix++;		}		$user_nicename = $alt_user_nicename;	}	$data = compact( 'user_pass', 'user_email', 'user_url', 'user_nicename', 'display_name', 'user_registered' );	$data = stripslashes_deep( $data );	if ( $update ) {		$wpdb->update( $wpdb->users, $data, compact( 'ID' ) );		$user_id = (int) $ID;	} else {		$wpdb->insert( $wpdb->users, $data + compact( 'user_login' ) );		$user_id = (int) $wpdb->insert_id;	}	update_user_meta( $user_id, 'first_name', $first_name);	update_user_meta( $user_id, 'last_name', $last_name);	update_user_meta( $user_id, 'nickname', $nickname );	update_user_meta( $user_id, 'description', $description );	update_user_meta( $user_id, 'rich_editing', $rich_editing);	update_user_meta( $user_id, 'comment_shortcuts', $comment_shortcuts);	update_user_meta( $user_id, 'admin_color', $admin_color);	update_user_meta( $user_id, 'use_ssl', $use_ssl);	foreach ( _wp_get_user_contactmethods() as $method => $name ) {		if ( empty($$method) )			$$method = '';		update_user_meta( $user_id, $method, $$method );	}	if ( isset($role) ) {		$user = new WP_User($user_id);		$user->set_role($role);	} elseif ( !$update ) {		$user = new WP_User($user_id);		$user->set_role(get_option('default_role'));	}	wp_cache_delete($user_id, 'users');	wp_cache_delete($user_login, 'userlogins');	if ( $update )		do_action('profile_update', $user_id, $old_user_data);	else		do_action('user_register', $user_id);	return $user_id;}/** * Update an user in the database. * * It is possible to update a user's password by specifying the 'user_pass' * value in the $userdata parameter array. * * If $userdata does not contain an 'ID' key, then a new user will be created * and the new user's ID will be returned. * * If current user's password is being updated, then the cookies will be * cleared. * * @since 2.0.0 * @see wp_insert_user() For what fields can be set in $userdata * @uses wp_insert_user() Used to update existing user or add new one if user doesn't exist already * * @param array $userdata An array of user data. * @return int The updated user's ID. */function wp_update_user($userdata) {	$ID = (int) $userdata['ID'];	// First, get all of the original fields	$user = get_userdata($ID);	// Escape data pulled from DB.	$user = add_magic_quotes(get_object_vars($user));	// If password is changing, hash it now.	if ( ! empty($userdata['user_pass']) ) {		$plaintext_pass = $userdata['user_pass'];		$userdata['user_pass'] = wp_hash_password($userdata['user_pass']);	}	wp_cache_delete($user[ 'user_email' ], 'useremail');	// Merge old and new fields with new fields overwriting old ones.	$userdata = array_merge($user, $userdata);	$user_id = wp_insert_user($userdata);	// Update the cookies if the password changed.	$current_user = wp_get_current_user();	if ( $current_user->id == $ID ) {		if ( isset($plaintext_pass) ) {			wp_clear_auth_cookie();			wp_set_auth_cookie($ID);		}	}	return $user_id;}/** * A simpler way of inserting an user into the database. * * Creates a new user with just the username, password, and email. For a more * detail creation of a user, use wp_insert_user() to specify more infomation. * * @since 2.0.0 * @see wp_insert_user() More complete way to create a new user * * @param string $username The user's username. * @param string $password The user's password. * @param string $email The user's email (optional). * @return int The new user's ID. */function wp_create_user($username, $password, $email = '') {	$user_login = esc_sql( $username );	$user_email = esc_sql( $email    );	$user_pass = $password;	$userdata = compact('user_login', 'user_email', 'user_pass');	return wp_insert_user($userdata);}/** * Set up the default contact methods * * @access private * @since * * @return array $user_contactmethods Array of contact methods and their labels. */function _wp_get_user_contactmethods() {	$user_contactmethods = array(		'aim' => __('AIM'),		'yim' => __('Yahoo IM'),		'jabber' => __('Jabber / Google Talk')	);	return apply_filters('user_contactmethods',$user_contactmethods);}?>
<?phpfunction mce_put_file( $path, $content ) {	if ( function_exists('file_put_contents') )		return @file_put_contents( $path, $content );	$newfile = false;	$fp = @fopen( $path, 'wb' );	if ($fp) {		$newfile = fwrite( $fp, $content );		fclose($fp);	}	return $newfile;}// escape text only if it needs translatingfunction mce_escape($text) {	global $language;	if ( 'en' == $language ) return $text;	else return esc_js($text);}$lang = 'tinyMCE.addI18n({' . $language . ':{common:{edit_confirm:"' . mce_escape( __('Do you want to use the WYSIWYG mode for this textarea?') ) . '",apply:"' . mce_escape( __('Apply') ) . '",insert:"' . mce_escape( __('Insert') ) . '",update:"' . mce_escape( __('Update') ) . '",cancel:"' . mce_escape( __('Cancel') ) . '",close:"' . mce_escape( __('Close') ) . '",browse:"' . mce_escape( __('Browse') ) . '",class_name:"' . mce_escape( __('Class') ) . '",not_set:"' . mce_escape( __('-- Not set --') ) . '",clipboard_msg:"' . mce_escape( __('Copy/Cut/Paste is not available in Mozilla and Firefox.') ) . '",clipboard_no_support:"' . mce_escape( __('Currently not supported by your browser, use keyboard shortcuts instead.') ) . '",popup_blocked:"' . mce_escape( __('Sorry, but we have noticed that your popup-blocker has disabled a window that provides application functionality. You will need to disable popup blocking on this site in order to fully utilize this tool.') ) . '",invalid_data:"' . mce_escape( __('Error: Invalid values entered, these are marked in red.') ) . '",more_colors:"' . mce_escape( __('More colors') ) . '"},contextmenu:{align:"' . mce_escape( /* translators: alignment */ __('Alignment') ) . '",left:"' . mce_escape( /* translators: alignment */ __('Left') ) . '",center:"' . mce_escape( /* translators: alignment */ __('Center') ) . '",right:"' . mce_escape( /* translators: alignment */ __('Right') ) . '",full:"' . mce_escape( /* translators: alignment */ __('Full') ) . '"},insertdatetime:{date_fmt:"' . mce_escape( /* translators: year, month, date */ __('%Y-%m-%d') ) . '",time_fmt:"' . mce_escape( /* translators: hours, minutes, seconds */ __('%H:%M:%S') ) . '",insertdate_desc:"' . mce_escape( __('Insert date') ) . '",inserttime_desc:"' . mce_escape( __('Insert time') ) . '",months_long:"' . mce_escape( __('January').','.__('February').','.__('March').','.__('April').','.__('May').','.__('June').','.__('July').','.__('August').','.__('September').','.__('October').','.__('November').','.__('December') ) . '",months_short:"' . mce_escape( __('Jan_January_abbreviation').','.__('Feb_February_abbreviation').','.__('Mar_March_abbreviation').','.__('Apr_April_abbreviation').','.__('May_May_abbreviation').','.__('Jun_June_abbreviation').','.__('Jul_July_abbreviation').','.__('Aug_August_abbreviation').','.__('Sep_September_abbreviation').','.__('Oct_October_abbreviation').','.__('Nov_November_abbreviation').','.__('Dec_December_abbreviation') ) . '",day_long:"' . mce_escape( __('Sunday').','.__('Monday').','.__('Tuesday').','.__('Wednesday').','.__('Thursday').','.__('Friday').','.__('Saturday') ) . '",day_short:"' . mce_escape( __('Sun').','.__('Mon').','.__('Tue').','.__('Wed').','.__('Thu').','.__('Fri').','.__('Sat') ) . '"},print:{print_desc:"' . mce_escape( __('Print') ) . '"},preview:{preview_desc:"' . mce_escape( __('Preview') ) . '"},directionality:{ltr_desc:"' . mce_escape( __('Direction left to right') ) . '",rtl_desc:"' . mce_escape( __('Direction right to left') ) . '"},layer:{insertlayer_desc:"' . mce_escape( __('Insert new layer') ) . '",forward_desc:"' . mce_escape( __('Move forward') ) . '",backward_desc:"' . mce_escape( __('Move backward') ) . '",absolute_desc:"' . mce_escape( __('Toggle absolute positioning') ) . '",content:"' . mce_escape( __('New layer...') ) . '"},save:{save_desc:"' . mce_escape( __('Save') ) . '",cancel_desc:"' . mce_escape( __('Cancel all changes') ) . '"},nonbreaking:{nonbreaking_desc:"' . mce_escape( __('Insert non-breaking space character') ) . '"},iespell:{iespell_desc:"' . mce_escape( __('Run spell checking') ) . '",download:"' . mce_escape( __('ieSpell not detected. Do you want to install it now?') ) . '"},advhr:{advhr_desc:"' . mce_escape( __('Horizontale rule') ) . '"},emotions:{emotions_desc:"' . mce_escape( __('Emotions') ) . '"},searchreplace:{search_desc:"' . mce_escape( __('Find') ) . '",replace_desc:"' . mce_escape( __('Find/Replace') ) . '"},advimage:{image_desc:"' . mce_escape( __('Insert/edit image') ) . '"},advlink:{link_desc:"' . mce_escape( __('Insert/edit link') ) . '"},xhtmlxtras:{cite_desc:"' . mce_escape( __('Citation') ) . '",abbr_desc:"' . mce_escape( __('Abbreviation') ) . '",acronym_desc:"' . mce_escape( __('Acronym') ) . '",del_desc:"' . mce_escape( __('Deletion') ) . '",ins_desc:"' . mce_escape( __('Insertion') ) . '",attribs_desc:"' . mce_escape( __('Insert/Edit Attributes') ) . '"},style:{desc:"' . mce_escape( __('Edit CSS Style') ) . '"},paste:{paste_text_desc:"' . mce_escape( __('Paste as Plain Text') ) . '",paste_word_desc:"' . mce_escape( __('Paste from Word') ) . '",selectall_desc:"' . mce_escape( __('Select All') ) . '"},paste_dlg:{text_title:"' . mce_escape( __('Use CTRL+V on your keyboard to paste the text into the window.') ) . '",text_linebreaks:"' . mce_escape( __('Keep linebreaks') ) . '",word_title:"' . mce_escape( __('Use CTRL+V on your keyboard to paste the text into the window.') ) . '"},table:{desc:"' . mce_escape( __('Inserts a new table') ) . '",row_before_desc:"' . mce_escape( __('Insert row before') ) . '",row_after_desc:"' . mce_escape( __('Insert row after') ) . '",delete_row_desc:"' . mce_escape( __('Delete row') ) . '",col_before_desc:"' . mce_escape( __('Insert column before') ) . '",col_after_desc:"' . mce_escape( __('Insert column after') ) . '",delete_col_desc:"' . mce_escape( __('Remove column') ) . '",split_cells_desc:"' . mce_escape( __('Split merged table cells') ) . '",merge_cells_desc:"' . mce_escape( __('Merge table cells') ) . '",row_desc:"' . mce_escape( __('Table row properties') ) . '",cell_desc:"' . mce_escape( __('Table cell properties') ) . '",props_desc:"' . mce_escape( __('Table properties') ) . '",paste_row_before_desc:"' . mce_escape( __('Paste table row before') ) . '",paste_row_after_desc:"' . mce_escape( __('Paste table row after') ) . '",cut_row_desc:"' . mce_escape( __('Cut table row') ) . '",copy_row_desc:"' . mce_escape( __('Copy table row') ) . '",del:"' . mce_escape( __('Delete table') ) . '",row:"' . mce_escape( __('Row') ) . '",col:"' . mce_escape( __('Column') ) . '",cell:"' . mce_escape( __('Cell') ) . '"},autosave:{unload_msg:"' . mce_escape( __('The changes you made will be lost if you navigate away from this page.') ) . '"},fullscreen:{desc:"' . mce_escape( __('Toggle fullscreen mode') ) . ' (Alt+Shift+G)"},media:{desc:"' . mce_escape( __('Insert / edit embedded media') ) . '",delta_width:"' . /* translators: Extra width for the media popup in pixels */ mce_escape( _x('0', 'media popup width') ) . '",delta_height:"' . /* translators: Extra height for the media popup in pixels */ mce_escape( _x('0', 'media popup height') ) . '",edit:"' . mce_escape( __('Edit embedded media') ) . '"},fullpage:{desc:"' . mce_escape( __('Document properties') ) . '"},template:{desc:"' . mce_escape( __('Insert predefined template content') ) . '"},visualchars:{desc:"' . mce_escape( __('Visual control characters on/off.') ) . '"},spellchecker:{desc:"' . mce_escape( __('Toggle spellchecker') ) . ' (Alt+Shift+N)",menu:"' . mce_escape( __('Spellchecker settings') ) . '",ignore_word:"' . mce_escape( __('Ignore word') ) . '",ignore_words:"' . mce_escape( __('Ignore all') ) . '",langs:"' . mce_escape( __('Languages') ) . '",wait:"' . mce_escape( __('Please wait...') ) . '",sug:"' . mce_escape( __('Suggestions') ) . '",no_sug:"' . mce_escape( __('No suggestions') ) . '",no_mpell:"' . mce_escape( __('No misspellings found.') ) . '"},pagebreak:{desc:"' . mce_escape( __('Insert Page Break') ) . '"}}});tinyMCE.addI18n("' . $language . '.advanced",{style_select:"' . mce_escape( /* translators: TinyMCE font styles */ _x('Styles', 'TinyMCE font styles') ) . '",font_size:"' . mce_escape( __('Font size') ) . '",fontdefault:"' . mce_escape( __('Font family') ) . '",block:"' . mce_escape( __('Format') ) . '",paragraph:"' . mce_escape( __('Paragraph') ) . '",div:"' . mce_escape( __('Div') ) . '",address:"' . mce_escape( __('Address') ) . '",pre:"' . mce_escape( __('Preformatted') ) . '",h1:"' . mce_escape( __('Heading 1') ) . '",h2:"' . mce_escape( __('Heading 2') ) . '",h3:"' . mce_escape( __('Heading 3') ) . '",h4:"' . mce_escape( __('Heading 4') ) . '",h5:"' . mce_escape( __('Heading 5') ) . '",h6:"' . mce_escape( __('Heading 6') ) . '",blockquote:"' . mce_escape( __('Blockquote') ) . '",code:"' . mce_escape( __('Code') ) . '",samp:"' . mce_escape( __('Code sample') ) . '",dt:"' . mce_escape( __('Definition term ') ) . '",dd:"' . mce_escape( __('Definition description') ) . '",bold_desc:"' . mce_escape( __('Bold') ) . ' (Ctrl / Alt+Shift + B)",italic_desc:"' . mce_escape( __('Italic') ) . ' (Ctrl / Alt+Shift + I)",underline_desc:"' . mce_escape( __('Underline') ) . '",striketrough_desc:"' . mce_escape( __('Strikethrough') ) . ' (Alt+Shift+D)",justifyleft_desc:"' . mce_escape( __('Align Left') ) . ' (Alt+Shift+L)",justifycenter_desc:"' . mce_escape( __('Align Center') ) . ' (Alt+Shift+C)",justifyright_desc:"' . mce_escape( __('Align Right') ) . ' (Alt+Shift+R)",justifyfull_desc:"' . mce_escape( __('Align Full') ) . ' (Alt+Shift+J)",bullist_desc:"' . mce_escape( __('Unordered list') ) . ' (Alt+Shift+U)",numlist_desc:"' . mce_escape( __('Ordered list') ) . ' (Alt+Shift+O)",outdent_desc:"' . mce_escape( __('Outdent') ) . '",indent_desc:"' . mce_escape( __('Indent') ) . '",undo_desc:"' . mce_escape( __('Undo') ) . ' (Ctrl+Z)",redo_desc:"' . mce_escape( __('Redo') ) . ' (Ctrl+Y)",link_desc:"' . mce_escape( __('Insert/edit link') ) . ' (Alt+Shift+A)",link_delta_width:"' . /* translators: Extra width for the link popup in pixels */ mce_escape( _x('0', 'link popup width') ) . '",link_delta_height:"' . /* translators: Extra height for the link popup in pixels */ mce_escape( _x('0', 'link popup height') ) . '",unlink_desc:"' . mce_escape( __('Unlink') ) . ' (Alt+Shift+S)",image_desc:"' . mce_escape( __('Insert/edit image') ) . ' (Alt+Shift+M)",image_delta_width:"' . /* translators: Extra width for the image popup in pixels */ mce_escape( _x('0', 'image popup width') ) . '",image_delta_height:"' . /* translators: Extra height for the image popup in pixels */ mce_escape( _x('0', 'image popup height') ) . '",cleanup_desc:"' . mce_escape( __('Cleanup messy code') ) . '",code_desc:"' . mce_escape( __('Edit HTML Source') ) . '",sub_desc:"' . mce_escape( __('Subscript') ) . '",sup_desc:"' . mce_escape( __('Superscript') ) . '",hr_desc:"' . mce_escape( __('Insert horizontal ruler') ) . '",removeformat_desc:"' . mce_escape( __('Remove formatting') ) . '",forecolor_desc:"' . mce_escape( __('Select text color') ) . '",backcolor_desc:"' . mce_escape( __('Select background color') ) . '",charmap_desc:"' . mce_escape( __('Insert custom character') ) . '",visualaid_desc:"' . mce_escape( __('Toggle guidelines/invisible elements') ) . '",anchor_desc:"' . mce_escape( __('Insert/edit anchor') ) . '",cut_desc:"' . mce_escape( __('Cut') ) . '",copy_desc:"' . mce_escape( __('Copy') ) . '",paste_desc:"' . mce_escape( __('Paste') ) . '",image_props_desc:"' . mce_escape( __('Image properties') ) . '",newdocument_desc:"' . mce_escape( __('New document') ) . '",help_desc:"' . mce_escape( __('Help') ) . '",blockquote_desc:"' . mce_escape( __('Blockquote') ) . ' (Alt+Shift+Q)",clipboard_msg:"' . mce_escape( __('Copy/Cut/Paste is not available in Mozilla and Firefox.') ) . '",path:"' . mce_escape( __('Path') ) . '",newdocument:"' . mce_escape( __('Are you sure you want to clear all contents?') ) . '",toolbar_focus:"' . mce_escape( __('Jump to tool buttons - Alt+Q, Jump to editor - Alt-Z, Jump to element path - Alt-X') ) . '",more_colors:"' . mce_escape( __('More colors') ) . '",colorpicker_delta_width:"' . /* translators: Extra width for the colorpicker popup in pixels */ mce_escape( _x('0', 'colorpicker popup width') ) . '",colorpicker_delta_height:"' . /* translators: Extra height for the colorpicker popup in pixels */ mce_escape( _x('0', 'colorpicker popup height') ) . '"});tinyMCE.addI18n("' . $language . '.advanced_dlg",{about_title:"' . mce_escape( __('About TinyMCE') ) . '",about_general:"' . mce_escape( __('About') ) . '",about_help:"' . mce_escape( __('Help') ) . '",about_license:"' . mce_escape( __('License') ) . '",about_plugins:"' . mce_escape( __('Plugins') ) . '",about_plugin:"' . mce_escape( __('Plugin') ) . '",about_author:"' . mce_escape( __('Author') ) . '",about_version:"' . mce_escape( __('Version') ) . '",about_loaded:"' . mce_escape( __('Loaded plugins') ) . '",anchor_title:"' . mce_escape( __('Insert/edit anchor') ) . '",anchor_name:"' . mce_escape( __('Anchor name') ) . '",code_title:"' . mce_escape( __('HTML Source Editor') ) . '",code_wordwrap:"' . mce_escape( __('Word wrap') ) . '",colorpicker_title:"' . mce_escape( __('Select a color') ) . '",colorpicker_picker_tab:"' . mce_escape( __('Picker') ) . '",colorpicker_picker_title:"' . mce_escape( __('Color picker') ) . '",colorpicker_palette_tab:"' . mce_escape( __('Palette') ) . '",colorpicker_palette_title:"' . mce_escape( __('Palette colors') ) . '",colorpicker_named_tab:"' . mce_escape( __('Named') ) . '",colorpicker_named_title:"' . mce_escape( __('Named colors') ) . '",colorpicker_color:"' . mce_escape( __('Color:') ) . '",colorpicker_name:"' . mce_escape( __('Name:') ) . '",charmap_title:"' . mce_escape( __('Select custom character') ) . '",image_title:"' . mce_escape( __('Insert/edit image') ) . '",image_src:"' . mce_escape( __('Image URL') ) . '",image_alt:"' . mce_escape( __('Image description') ) . '",image_list:"' . mce_escape( __('Image list') ) . '",image_border:"' . mce_escape( __('Border') ) . '",image_dimensions:"' . mce_escape( __('Dimensions') ) . '",image_vspace:"' . mce_escape( __('Vertical space') ) . '",image_hspace:"' . mce_escape( __('Horizontal space') ) . '",image_align:"' . mce_escape( __('Alignment') ) . '",image_align_baseline:"' . mce_escape( __('Baseline') ) . '",image_align_top:"' . mce_escape( __('Top') ) . '",image_align_middle:"' . mce_escape( __('Middle') ) . '",image_align_bottom:"' . mce_escape( __('Bottom') ) . '",image_align_texttop:"' . mce_escape( __('Text top') ) . '",image_align_textbottom:"' . mce_escape( __('Text bottom') ) . '",image_align_left:"' . mce_escape( __('Left') ) . '",image_align_right:"' . mce_escape( __('Right') ) . '",link_title:"' . mce_escape( __('Insert/edit link') ) . '",link_url:"' . mce_escape( __('Link URL') ) . '",link_target:"' . mce_escape( __('Target') ) . '",link_target_same:"' . mce_escape( __('Open link in the same window') ) . '",link_target_blank:"' . mce_escape( __('Open link in a new window') ) . '",link_titlefield:"' . mce_escape( __('Title') ) . '",link_is_email:"' . mce_escape( __('The URL you entered seems to be an email address, do you want to add the required mailto: prefix?') ) . '",link_is_external:"' . mce_escape( __('The URL you entered seems to external link, do you want to add the required http:// prefix?') ) . '",link_list:"' . mce_escape( __('Link list') ) . '"});tinyMCE.addI18n("' . $language . '.media_dlg",{title:"' . mce_escape( __('Insert / edit embedded media') ) . '",general:"' . mce_escape( __('General') ) . '",advanced:"' . mce_escape( __('Advanced') ) . '",file:"' . mce_escape( __('File/URL') ) . '",list:"' . mce_escape( __('List') ) . '",size:"' . mce_escape( __('Dimensions') ) . '",preview:"' . mce_escape( __('Preview') ) . '",constrain_proportions:"' . mce_escape( __('Constrain proportions') ) . '",type:"' . mce_escape( __('Type') ) . '",id:"' . mce_escape( __('Id') ) . '",name:"' . mce_escape( __('Name') ) . '",class_name:"' . mce_escape( __('Class') ) . '",vspace:"' . mce_escape( __('V-Space') ) . '",hspace:"' . mce_escape( __('H-Space') ) . '",play:"' . mce_escape( __('Auto play') ) . '",loop:"' . mce_escape( __('Loop') ) . '",menu:"' . mce_escape( __('Show menu') ) . '",quality:"' . mce_escape( __('Quality') ) . '",scale:"' . mce_escape( __('Scale') ) . '",align:"' . mce_escape( __('Align') ) . '",salign:"' . mce_escape( __('SAlign') ) . '",wmode:"' . mce_escape( __('WMode') ) . '",bgcolor:"' . mce_escape( __('Background') ) . '",base:"' . mce_escape( __('Base') ) . '",flashvars:"' . mce_escape( __('Flashvars') ) . '",liveconnect:"' . mce_escape( __('SWLiveConnect') ) . '",autohref:"' . mce_escape( __('AutoHREF') ) . '",cache:"' . mce_escape( __('Cache') ) . '",hidden:"' . mce_escape( __('Hidden') ) . '",controller:"' . mce_escape( __('Controller') ) . '",kioskmode:"' . mce_escape( __('Kiosk mode') ) . '",playeveryframe:"' . mce_escape( __('Play every frame') ) . '",targetcache:"' . mce_escape( __('Target cache') ) . '",correction:"' . mce_escape( __('No correction') ) . '",enablejavascript:"' . mce_escape( __('Enable JavaScript') ) . '",starttime:"' . mce_escape( __('Start time') ) . '",endtime:"' . mce_escape( __('End time') ) . '",href:"' . mce_escape( __('href') ) . '",qtsrcchokespeed:"' . mce_escape( __('Choke speed') ) . '",target:"' . mce_escape( __('Target') ) . '",volume:"' . mce_escape( __('Volume') ) . '",autostart:"' . mce_escape( __('Auto start') ) . '",enabled:"' . mce_escape( __('Enabled') ) . '",fullscreen:"' . mce_escape( __('Fullscreen') ) . '",invokeurls:"' . mce_escape( __('Invoke URLs') ) . '",mute:"' . mce_escape( __('Mute') ) . '",stretchtofit:"' . mce_escape( __('Stretch to fit') ) . '",windowlessvideo:"' . mce_escape( __('Windowless video') ) . '",balance:"' . mce_escape( __('Balance') ) . '",baseurl:"' . mce_escape( __('Base URL') ) . '",captioningid:"' . mce_escape( __('Captioning id') ) . '",currentmarker:"' . mce_escape( __('Current marker') ) . '",currentposition:"' . mce_escape( __('Current position') ) . '",defaultframe:"' . mce_escape( __('Default frame') ) . '",playcount:"' . mce_escape( __('Play count') ) . '",rate:"' . mce_escape( __('Rate') ) . '",uimode:"' . mce_escape( __('UI Mode') ) . '",flash_options:"' . mce_escape( __('Flash options') ) . '",qt_options:"' . mce_escape( __('Quicktime options') ) . '",wmp_options:"' . mce_escape( __('Windows media player options') ) . '",rmp_options:"' . mce_escape( __('Real media player options') ) . '",shockwave_options:"' . mce_escape( __('Shockwave options') ) . '",autogotourl:"' . mce_escape( __('Auto goto URL') ) . '",center:"' . mce_escape( __('Center') ) . '",imagestatus:"' . mce_escape( __('Image status') ) . '",maintainaspect:"' . mce_escape( __('Maintain aspect') ) . '",nojava:"' . mce_escape( __('No java') ) . '",prefetch:"' . mce_escape( __('Prefetch') ) . '",shuffle:"' . mce_escape( __('Shuffle') ) . '",console:"' . mce_escape( __('Console') ) . '",numloop:"' . mce_escape( __('Num loops') ) . '",controls:"' . mce_escape( __('Controls') ) . '",scriptcallbacks:"' . mce_escape( __('Script callbacks') ) . '",swstretchstyle:"' . mce_escape( __('Stretch style') ) . '",swstretchhalign:"' . mce_escape( __('Stretch H-Align') ) . '",swstretchvalign:"' . mce_escape( __('Stretch V-Align') ) . '",sound:"' . mce_escape( __('Sound') ) . '",progress:"' . mce_escape( __('Progress') ) . '",qtsrc:"' . mce_escape( __('QT Src') ) . '",qt_stream_warn:"' . mce_escape( __('Streamed rtsp resources should be added to the QT Src field under the advanced tab.') ) . '",align_top:"' . mce_escape( __('Top') ) . '",align_right:"' . mce_escape( __('Right') ) . '",align_bottom:"' . mce_escape( __('Bottom') ) . '",align_left:"' . mce_escape( __('Left') ) . '",align_center:"' . mce_escape( __('Center') ) . '",align_top_left:"' . mce_escape( __('Top left') ) . '",align_top_right:"' . mce_escape( __('Top right') ) . '",align_bottom_left:"' . mce_escape( __('Bottom left') ) . '",align_bottom_right:"' . mce_escape( __('Bottom right') ) . '",flv_options:"' . mce_escape( __('Flash video options') ) . '",flv_scalemode:"' . mce_escape( __('Scale mode') ) . '",flv_buffer:"' . mce_escape( __('Buffer') ) . '",flv_startimage:"' . mce_escape( __('Start image') ) . '",flv_starttime:"' . mce_escape( __('Start time') ) . '",flv_defaultvolume:"' . mce_escape( __('Default volume') ) . '",flv_hiddengui:"' . mce_escape( __('Hidden GUI') ) . '",flv_autostart:"' . mce_escape( __('Auto start') ) . '",flv_loop:"' . mce_escape( __('Loop') ) . '",flv_showscalemodes:"' . mce_escape( __('Show scale modes') ) . '",flv_smoothvideo:"' . mce_escape( __('Smooth video') ) . '",flv_jscallback:"' . mce_escape( __('JS Callback') ) . '"});tinyMCE.addI18n("' . $language . '.wordpress",{wp_adv_desc:"' . mce_escape( __('Show/Hide Kitchen Sink') )  . ' (Alt+Shift+Z)",wp_more_desc:"' . mce_escape( __('Insert More Tag') ) . ' (Alt+Shift+T)",wp_page_desc:"' . mce_escape( __('Insert Page break') ) . ' (Alt+Shift+P)",wp_help_desc:"' . mce_escape( __('Help') ) . ' (Alt+Shift+H)",wp_more_alt:"' . mce_escape( __('More...') ) . '",wp_page_alt:"' . mce_escape( __('Next page...') ) . '",add_media:"' . mce_escape( __('Add Media') ) . '",add_image:"' . mce_escape( __('Add an Image') ) . '",add_video:"' . mce_escape( __('Add Video') ) . '",add_audio:"' . mce_escape( __('Add Audio') ) . '",editgallery:"' . mce_escape( __('Edit Gallery') ) . '",delgallery:"' . mce_escape( __('Delete Gallery') ) . '"});tinyMCE.addI18n("' . $language . '.wpeditimage",{edit_img:"' . mce_escape( __('Edit Image') )  . '",del_img:"' . mce_escape( __('Delete Image') )  . '",adv_settings:"' . mce_escape( __('Advanced Settings') )  . '",none:"' . mce_escape( __('None') )  . '",size:"' . mce_escape( __('Size') ) . '",thumbnail:"' . mce_escape( __('Thumbnail') ) . '",medium:"' . mce_escape( __('Medium') ) . '",full_size:"' . mce_escape( __('Full Size') ) . '",current_link:"' . mce_escape( __('Current Link') ) . '",link_to_img:"' . mce_escape( __('Link to Image') ) . '",link_help:"' . mce_escape( __('Enter a link URL or click above for presets.') ) . '",adv_img_settings:"' . mce_escape( __('Advanced Image Settings') ) . '",source:"' . mce_escape( __('Source') )  . '",width:"' . mce_escape( __('Width') ) . '",height:"' . mce_escape( __('Height') ) . '",orig_size:"' . mce_escape( __('Original Size') ) . '",css:"' . mce_escape( __('CSS Class') ) . '",adv_link_settings:"' . mce_escape( __('Advanced Link Settings') )  . '",link_rel:"' . mce_escape( __('Link Rel') ) . '",height:"' . mce_escape( __('Height') ) . '",orig_size:"' . mce_escape( __('Original Size') ) . '",css:"' . mce_escape( __('CSS Class') ) . '",s60:"' . mce_escape( __('60%') ) . '",s70:"' . mce_escape( __('70%') ) . '",s80:"' . mce_escape( __('80%') ) . '",s90:"' . mce_escape( __('90%') ) . '",s100:"' . mce_escape( __('100%') ) . '",s110:"' . mce_escape( __('110%') ) . '",s120:"' . mce_escape( __('120%') ) . '",s130:"' . mce_escape( __('130%') ) . '",img_title:"' . mce_escape( __('Edit Image Title') ) . '",caption:"' . mce_escape( __('Edit Image Caption') ) . '",alt:"' . mce_escape( __('Edit Alternate Text') ) . '"});';
<?php/** * Creates the password cookie and redirects back to where the * visitor was before. * * @package WordPress *//** Make sure that the WordPress bootstrap has run before continuing. */require( dirname(__FILE__) . '/wp-load.php');if ( get_magic_quotes_gpc() )	$_POST['post_password'] = stripslashes($_POST['post_password']);// 10 dayssetcookie('wp-postpass_' . COOKIEHASH, $_POST['post_password'], time() + 864000, COOKIEPATH);wp_safe_redirect(wp_get_referer());?>
<?php/** * Edit links form for inclusion in administration panels. * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');if ( ! empty($link_id) ) {	$heading = sprintf( __( '<a href="%s">Links</a> / Edit Link' ), 'link-manager.php' );	$submit_text = __('Update Link');	$form = '<form name="editlink" id="editlink" method="post" action="link.php">';	$nonce_action = 'update-bookmark_' . $link_id;} else {	$heading = sprintf( __( '<a href="%s">Links</a> / Add New Link' ), 'link-manager.php' );	$submit_text = __('Add Link');	$form = '<form name="addlink" id="addlink" method="post" action="link.php">';	$nonce_action = 'add-bookmark';}require_once('./includes/meta-boxes.php');add_meta_box('linksubmitdiv', __('Save'), 'link_submit_meta_box', 'link', 'side', 'core');add_meta_box('linkcategorydiv', __('Categories'), 'link_categories_meta_box', 'link', 'normal', 'core');add_meta_box('linktargetdiv', __('Target'), 'link_target_meta_box', 'link', 'normal', 'core');add_meta_box('linkxfndiv', __('Link Relationship (XFN)'), 'link_xfn_meta_box', 'link', 'normal', 'core');add_meta_box('linkadvanceddiv', __('Advanced'), 'link_advanced_meta_box', 'link', 'normal', 'core');do_action('add_meta_boxes', 'link', $link);do_action('add_meta_boxes_link', $link);do_action('do_meta_boxes', 'link', 'normal', $link);do_action('do_meta_boxes', 'link', 'advanced', $link);do_action('do_meta_boxes', 'link', 'side', $link);add_contextual_help($current_screen,	'<p>' . __( 'You can add or edit links on this screen by entering information in each of the boxes. Only the link&#8217;s web address and name (the text you want to display on your site as the link) are required fields.' ) . '</p>' .	'<p>' . __( 'The boxes for link name, web address, and description have fixed positions, while the others may be repositioned using drag and drop. You can also hide boxes you don&#8217;t use in the Screen Options tab, or minimize boxes by clicking on the title bar of the box.' ) . '</p>' .	'<p>' . __( 'XFN stands for <a href="http://gmpg.org/xfn/" target="_blank">XHTML Friends Network</a>, which is optional. WordPress allows the generation of XFN attributes to show how you are related to the authors/owners of the site to which you are linking.' ) . '</p>' .	'<p><strong>' . __( 'For more information:' ) . '</strong></p>' .	'<p>' . __( '<a href="http://codex.wordpress.org/Links_Add_New_SubPanel" target="_blank">Documentation on Creating Links</a>' ) . '</p>' .	'<p>' . __( '<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>' ) . '</p>');require_once ('admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><?php if ( isset( $_GET['added'] ) ) : ?><div id="message" class="updated"><p><?php _e('Link added.'); ?></p></div><?php endif; ?><?phpif ( !empty($form) )	echo $form;if ( !empty($link_added) )	echo $link_added;wp_nonce_field( $nonce_action );wp_nonce_field( 'closedpostboxes', 'closedpostboxesnonce', false );wp_nonce_field( 'meta-box-order', 'meta-box-order-nonce', false ); ?><div id="poststuff" class="metabox-holder<?php echo 2 == $screen_layout_columns ? ' has-right-sidebar' : ''; ?>"><div id="side-info-column" class="inner-sidebar"><?phpdo_action('submitlink_box');$side_meta_boxes = do_meta_boxes( 'link', 'side', $link );?></div><div id="post-body"><div id="post-body-content"><div id="namediv" class="stuffbox"><h3><label for="link_name"><?php _e('Name') ?></label></h3><div class="inside">	<input type="text" name="link_name" size="30" tabindex="1" value="<?php echo esc_attr($link->link_name); ?>" id="link_name" />    <p><?php _e('Example: Nifty blogging software'); ?></p></div></div><div id="addressdiv" class="stuffbox"><h3><label for="link_url"><?php _e('Web Address') ?></label></h3><div class="inside">	<input type="text" name="link_url" size="30" class="code" tabindex="1" value="<?php echo esc_attr($link->link_url); ?>" id="link_url" />    <p><?php _e('Example: <code>http://wordpress.org/</code> &#8212; don&#8217;t forget the <code>http://</code>'); ?></p></div></div><div id="descriptiondiv" class="stuffbox"><h3><label for="link_description"><?php _e('Description') ?></label></h3><div class="inside">	<input type="text" name="link_description" size="30" tabindex="1" value="<?php echo isset($link->link_description) ? esc_attr($link->link_description) : ''; ?>" id="link_description" />    <p><?php _e('This will be shown when someone hovers over the link in the blogroll, or optionally below the link.'); ?></p></div></div><?phpdo_meta_boxes('link', 'normal', $link);do_meta_boxes('link', 'advanced', $link);if ( $link_id ) : ?><input type="hidden" name="action" value="save" /><input type="hidden" name="link_id" value="<?php echo (int) $link_id; ?>" /><input type="hidden" name="order_by" value="<?php echo esc_attr($order_by); ?>" /><input type="hidden" name="cat_id" value="<?php echo (int) $cat_id ?>" /><?php else: ?><input type="hidden" name="action" value="add" /><?php endif; ?></div></div></div></form></div>
<?php// Silence is golden.?>
<?php/** * New Post Administration Panel. * * @package WordPress * @subpackage Administration *//** Load WordPress Administration Bootstrap */require_once('./admin.php');if ( !isset($_GET['post_type']) )	$post_type = 'post';elseif ( in_array( $_GET['post_type'], get_post_types( array('show_ui' => true ) ) ) )	$post_type = $_GET['post_type'];else	wp_die( __('Invalid post type') );if ( 'post' != $post_type ) {	$parent_file = "edit.php?post_type=$post_type";	$submenu_file = "post-new.php?post_type=$post_type";} else {	$parent_file = 'edit.php';	$submenu_file = 'post-new.php';}$post_type_object = get_post_type_object($post_type);$title = $post_type_object->labels->add_new_item;$editing = true;if ( 'post' == $post_type && !current_user_can('edit_posts') ) {	include('./admin-header.php'); ?><div class="wrap"><p><?php printf(__('Since you&#8217;re a newcomer, you&#8217;ll have to wait for an admin to add the <code>edit_posts</code> capability to your user, in order to be authorized to post.<br />You can also <a href="mailto:%s?subject=Promotion?">e-mail the admin</a> to ask for a promotion.<br />When you&#8217;re promoted, just reload this page and you&#8217;ll be able to blog. :)'), get_option('admin_email')); ?></p></div><?php	include('./admin-footer.php');	exit();}wp_enqueue_script('autosave');// Show post form.if ( current_user_can($post_type_object->cap->edit_posts) ) {	$post = get_default_post_to_edit( $post_type, true );	$post_ID = $post->ID;	include('edit-form-advanced.php');}include('./admin-footer.php');?>
<?php/** * The template for displaying Tag Archive pages. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main">				<h1 class="page-title"><?php					printf( __( 'Tag Archives: %s', 'twentyten' ), '<span>' . single_tag_title( '', false ) . '</span>' );				?></h1><?php/* Run the loop for the tag archive to output the posts * If you want to overload this in a child theme then include a file * called loop-tag.php and that will be used instead. */ get_template_part( 'loop', 'tag' );?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
<?php/** * WordPress Administration Template Footer * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');?><div class="clear"></div></div><!-- wpbody-content --><div class="clear"></div></div><!-- wpbody --><div class="clear"></div></div><!-- wpcontent --></div><!-- wpwrap --><div id="footer"><p id="footer-left" class="alignleft"><?phpdo_action( 'in_admin_footer' );$upgrade = apply_filters( 'update_footer', '' );echo apply_filters( 'admin_footer_text', '<span id="footer-thankyou">' . __('Thank you for creating with <a href="http://wordpress.org/">WordPress</a>.').'</span> | '.__('<a href="http://codex.wordpress.org/">Documentation</a>').' | '.__('<a href="http://wordpress.org/support/forum/4">Feedback</a>') ); ?></p><p id="footer-upgrade" class="alignright"><?php echo $upgrade; ?></p><div class="clear"></div></div><?phpdo_action('admin_footer', '');do_action('admin_print_footer_scripts');do_action("admin_footer-" . $GLOBALS['hook_suffix']);// get_site_option() won't exist when auto upgrading from <= 2.7if ( function_exists('get_site_option') ) {	if ( false === get_site_option('can_compress_scripts') )		compression_test();}?><script type="text/javascript">if(typeof wpOnload=='function')wpOnload();</script></body></html>
<?php/** * WordPress Cron Implementation for hosts, which do not offer CRON or for which * the user has not set up a CRON job pointing to this file. * * The HTTP request to this file will not slow down the visitor who happens to * visit when the cron job is needed to run. * * @package WordPress */ignore_user_abort(true);if ( !empty($_POST) || defined('DOING_AJAX') || defined('DOING_CRON') )	die();/** * Tell WordPress we are doing the CRON task. * * @var bool */define('DOING_CRON', true);if ( !defined('ABSPATH') ) {	/** Set up WordPress environment */	require_once('./wp-load.php');}if ( false === $crons = _get_cron_array() )	die();$keys = array_keys( $crons );$local_time = time();if ( isset($keys[0]) && $keys[0] > $local_time )	die();foreach ($crons as $timestamp => $cronhooks) {	if ( $timestamp > $local_time )		break;	foreach ($cronhooks as $hook => $keys) {		foreach ($keys as $k => $v) {			$schedule = $v['schedule'];			if ($schedule != false) {				$new_args = array($timestamp, $schedule, $hook, $v['args']);				call_user_func_array('wp_reschedule_event', $new_args);			}			wp_unschedule_event($timestamp, $hook, $v['args']); 			do_action_ref_array($hook, $v['args']);		}	}}die();
<?php/** * WordPress API for creating bbcode like tags or what WordPress calls * "shortcodes." The tag and attribute parsing or regular expression code is * based on the Textpattern tag parser. * * A few examples are below: * * [shortcode /] * [shortcode foo="bar" baz="bing" /] * [shortcode foo="bar"]content[/shortcode] * * Shortcode tags support attributes and enclosed content, but does not entirely * support inline shortcodes in other shortcodes. You will have to call the * shortcode parser in your function to account for that. * * {@internal * Please be aware that the above note was made during the beta of WordPress 2.6 * and in the future may not be accurate. Please update the note when it is no * longer the case.}} * * To apply shortcode tags to content: * * <code> * $out = do_shortcode($content); * </code> * * @link http://codex.wordpress.org/Shortcode_API * * @package WordPress * @subpackage Shortcodes * @since 2.5 *//** * Container for storing shortcode tags and their hook to call for the shortcode * * @since 2.5 * @name $shortcode_tags * @var array * @global array $shortcode_tags */$shortcode_tags = array();/** * Add hook for shortcode tag. * * There can only be one hook for each shortcode. Which means that if another * plugin has a similar shortcode, it will override yours or yours will override * theirs depending on which order the plugins are included and/or ran. * * Simplest example of a shortcode tag using the API: * * <code> * // [footag foo="bar"] * function footag_func($atts) { * 	return "foo = {$atts[foo]}"; * } * add_shortcode('footag', 'footag_func'); * </code> * * Example with nice attribute defaults: * * <code> * // [bartag foo="bar"] * function bartag_func($atts) { * 	extract(shortcode_atts(array( * 		'foo' => 'no foo', * 		'baz' => 'default baz', * 	), $atts)); * * 	return "foo = {$foo}"; * } * add_shortcode('bartag', 'bartag_func'); * </code> * * Example with enclosed content: * * <code> * // [baztag]content[/baztag] * function baztag_func($atts, $content='') { * 	return "content = $content"; * } * add_shortcode('baztag', 'baztag_func'); * </code> * * @since 2.5 * @uses $shortcode_tags * * @param string $tag Shortcode tag to be searched in post content. * @param callable $func Hook to run when shortcode is found. */function add_shortcode($tag, $func) {	global $shortcode_tags;	if ( is_callable($func) )		$shortcode_tags[$tag] = $func;}/** * Removes hook for shortcode. * * @since 2.5 * @uses $shortcode_tags * * @param string $tag shortcode tag to remove hook for. */function remove_shortcode($tag) {	global $shortcode_tags;	unset($shortcode_tags[$tag]);}/** * Clear all shortcodes. * * This function is simple, it clears all of the shortcode tags by replacing the * shortcodes global by a empty array. This is actually a very efficient method * for removing all shortcodes. * * @since 2.5 * @uses $shortcode_tags */function remove_all_shortcodes() {	global $shortcode_tags;	$shortcode_tags = array();}/** * Search content for shortcodes and filter shortcodes through their hooks. * * If there are no shortcode tags defined, then the content will be returned * without any filtering. This might cause issues when plugins are disabled but * the shortcode will still show up in the post or content. * * @since 2.5 * @uses $shortcode_tags * @uses get_shortcode_regex() Gets the search pattern for searching shortcodes. * * @param string $content Content to search for shortcodes * @return string Content with shortcodes filtered out. */function do_shortcode($content) {	global $shortcode_tags;	if (empty($shortcode_tags) || !is_array($shortcode_tags))		return $content;	$pattern = get_shortcode_regex();	return preg_replace_callback('/'.$pattern.'/s', 'do_shortcode_tag', $content);}/** * Retrieve the shortcode regular expression for searching. * * The regular expression combines the shortcode tags in the regular expression * in a regex class. * * The regular expresion contains 6 different sub matches to help with parsing. * * 1/6 - An extra [ or ] to allow for escaping shortcodes with double [[]] * 2 - The shortcode name * 3 - The shortcode argument list * 4 - The self closing / * 5 - The content of a shortcode when it wraps some content. * * @since 2.5 * @uses $shortcode_tags * * @return string The shortcode search regular expression */function get_shortcode_regex() {	global $shortcode_tags;	$tagnames = array_keys($shortcode_tags);	$tagregexp = join( '|', array_map('preg_quote', $tagnames) );	// WARNING! Do not change this regex without changing do_shortcode_tag() and strip_shortcodes()	return '(.?)\[('.$tagregexp.')\b(.*?)(?:(\/))?\](?:(.+?)\[\/\2\])?(.?)';}/** * Regular Expression callable for do_shortcode() for calling shortcode hook. * @see get_shortcode_regex for details of the match array contents. * * @since 2.5 * @access private * @uses $shortcode_tags * * @param array $m Regular expression match array * @return mixed False on failure. */function do_shortcode_tag( $m ) {	global $shortcode_tags;	// allow [[foo]] syntax for escaping a tag	if ( $m[1] == '[' && $m[6] == ']' ) {		return substr($m[0], 1, -1);	}	$tag = $m[2];	$attr = shortcode_parse_atts( $m[3] );	if ( isset( $m[5] ) ) {		// enclosing tag - extra parameter		return $m[1] . call_user_func( $shortcode_tags[$tag], $attr, $m[5], $tag ) . $m[6];	} else {		// self-closing tag		return $m[1] . call_user_func( $shortcode_tags[$tag], $attr, NULL,  $tag ) . $m[6];	}}/** * Retrieve all attributes from the shortcodes tag. * * The attributes list has the attribute name as the key and the value of the * attribute as the value in the key/value pair. This allows for easier * retrieval of the attributes, since all attributes have to be known. * * @since 2.5 * * @param string $text * @return array List of attributes and their value. */function shortcode_parse_atts($text) {	$atts = array();	$pattern = '/(\w+)\s*=\s*"([^"]*)"(?:\s|$)|(\w+)\s*=\s*\'([^\']*)\'(?:\s|$)|(\w+)\s*=\s*([^\s\'"]+)(?:\s|$)|"([^"]*)"(?:\s|$)|(\S+)(?:\s|$)/';	$text = preg_replace("/[\x{00a0}\x{200b}]+/u", " ", $text);	if ( preg_match_all($pattern, $text, $match, PREG_SET_ORDER) ) {		foreach ($match as $m) {			if (!empty($m[1]))				$atts[strtolower($m[1])] = stripcslashes($m[2]);			elseif (!empty($m[3]))				$atts[strtolower($m[3])] = stripcslashes($m[4]);			elseif (!empty($m[5]))				$atts[strtolower($m[5])] = stripcslashes($m[6]);			elseif (isset($m[7]) and strlen($m[7]))				$atts[] = stripcslashes($m[7]);			elseif (isset($m[8]))				$atts[] = stripcslashes($m[8]);		}	} else {		$atts = ltrim($text);	}	return $atts;}/** * Combine user attributes with known attributes and fill in defaults when needed. * * The pairs should be considered to be all of the attributes which are * supported by the caller and given as a list. The returned attributes will * only contain the attributes in the $pairs list. * * If the $atts list has unsupported attributes, then they will be ignored and * removed from the final returned list. * * @since 2.5 * * @param array $pairs Entire list of supported attributes and their defaults. * @param array $atts User defined attributes in shortcode tag. * @return array Combined and filtered attribute list. */function shortcode_atts($pairs, $atts) {	$atts = (array)$atts;	$out = array();	foreach($pairs as $name => $default) {		if ( array_key_exists($name, $atts) )			$out[$name] = $atts[$name];		else			$out[$name] = $default;	}	return $out;}/** * Remove all shortcode tags from the given content. * * @since 2.5 * @uses $shortcode_tags * * @param string $content Content to remove shortcode tags. * @return string Content without shortcode tags. */function strip_shortcodes( $content ) {	global $shortcode_tags;	if (empty($shortcode_tags) || !is_array($shortcode_tags))		return $content;	$pattern = get_shortcode_regex();	return preg_replace('/'.$pattern.'/s', '$1$6', $content);}add_filter('the_content', 'do_shortcode', 11); // AFTER wpautop()?>
<?php/** * Defines the Gears manifest file for Google Gears offline storage. * * @package WordPress * @subpackage Administration *//** * Disable error reporting * * Set this to error_reporting( E_ALL ) or error_reporting( E_ALL | E_STRICT ) for debugging */error_reporting(0);/** Set ABSPATH for execution */define( 'ABSPATH', dirname(dirname(__FILE__)) . '/' );require(ABSPATH . '/wp-admin/includes/manifest.php');$files = get_manifest();header( 'Expires: Wed, 11 Jan 1984 05:00:00 GMT' );header( 'Last-Modified: ' . gmdate( 'D, d M Y H:i:s' ) . ' GMT' );header( 'Cache-Control: no-cache, must-revalidate, max-age=0' );header( 'Pragma: no-cache' );header( 'Content-Type: application/x-javascript; charset=UTF-8' );?>{"betaManifestVersion" : 1,"version" : "<?php echo $man_version; ?>","entries" : [<?php$entries = '';foreach ( $files as $file ) {	// Set ignoreQuery, defaulting to true	$ignore_query = ( isset($file[2]) && !$file[2] ) ? '' : ', "ignoreQuery" : true ';	// If version is not set, just output the file	if ( !isset($file[1]) )		$entries .= '{ "url" : "' . $file[0] . '"' . $ignore_query . ' }' . "\n";	// Output url and src	else		$entries .= '{ "url" : "' . $file[0] . '", "src" : "' . $file[0] . '?' . $file[1] . '"' . $ignore_query . ' },' . "\n";}echo trim( trim($entries), ',' );?>]}
<?php// --------------------------------------------------------------------------------// PhpConcept Library - Zip Module 2.8.2// --------------------------------------------------------------------------------// License GNU/LGPL - Vincent Blavet - August 2009// http://www.phpconcept.net// --------------------------------------------------------------------------------//// Presentation ://   PclZip is a PHP library that manage ZIP archives.//   So far tests show that archives generated by PclZip are readable by//   WinZip application and other tools.//// Description ://   See readme.txt and http://www.phpconcept.net//// Warning ://   This library and the associated files are non commercial, non professional//   work.//   It should not have unexpected results. However if any damage is caused by//   this software the author can not be responsible.//   The use of this software is at the risk of the user.//// --------------------------------------------------------------------------------// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $// --------------------------------------------------------------------------------  // ----- Constants  if (!defined('PCLZIP_READ_BLOCK_SIZE')) {    define( 'PCLZIP_READ_BLOCK_SIZE', 2048 );  }  // ----- File list separator  // In version 1.x of PclZip, the separator for file list is a space  // (which is not a very smart choice, specifically for windows paths !).  // A better separator should be a comma (,). This constant gives you the  // abilty to change that.  // However notice that changing this value, may have impact on existing  // scripts, using space separated filenames.  // Recommanded values for compatibility with older versions :  //define( 'PCLZIP_SEPARATOR', ' ' );  // Recommanded values for smart separation of filenames.  if (!defined('PCLZIP_SEPARATOR')) {    define( 'PCLZIP_SEPARATOR', ',' );  }  // ----- Error configuration  // 0 : PclZip Class integrated error handling  // 1 : PclError external library error handling. By enabling this  //     you must ensure that you have included PclError library.  // [2,...] : reserved for futur use  if (!defined('PCLZIP_ERROR_EXTERNAL')) {    define( 'PCLZIP_ERROR_EXTERNAL', 0 );  }  // ----- Optional static temporary directory  //       By default temporary files are generated in the script current  //       path.  //       If defined :  //       - MUST BE terminated by a '/'.  //       - MUST be a valid, already created directory  //       Samples :  // define( 'PCLZIP_TEMPORARY_DIR', '/temp/' );  // define( 'PCLZIP_TEMPORARY_DIR', 'C:/Temp/' );  if (!defined('PCLZIP_TEMPORARY_DIR')) {    define( 'PCLZIP_TEMPORARY_DIR', '' );  }  // ----- Optional threshold ratio for use of temporary files  //       Pclzip sense the size of the file to add/extract and decide to  //       use or not temporary file. The algorythm is looking for  //       memory_limit of PHP and apply a ratio.  //       threshold = memory_limit * ratio.  //       Recommended values are under 0.5. Default 0.47.  //       Samples :  // define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.5 );  if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) {    define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.47 );  }// --------------------------------------------------------------------------------// ***** UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED *****// --------------------------------------------------------------------------------  // ----- Global variables  $g_pclzip_version = "2.8.2";  // ----- Error codes  //   -1 : Unable to open file in binary write mode  //   -2 : Unable to open file in binary read mode  //   -3 : Invalid parameters  //   -4 : File does not exist  //   -5 : Filename is too long (max. 255)  //   -6 : Not a valid zip file  //   -7 : Invalid extracted file size  //   -8 : Unable to create directory  //   -9 : Invalid archive extension  //  -10 : Invalid archive format  //  -11 : Unable to delete file (unlink)  //  -12 : Unable to rename file (rename)  //  -13 : Invalid header checksum  //  -14 : Invalid archive size  define( 'PCLZIP_ERR_USER_ABORTED', 2 );  define( 'PCLZIP_ERR_NO_ERROR', 0 );  define( 'PCLZIP_ERR_WRITE_OPEN_FAIL', -1 );  define( 'PCLZIP_ERR_READ_OPEN_FAIL', -2 );  define( 'PCLZIP_ERR_INVALID_PARAMETER', -3 );  define( 'PCLZIP_ERR_MISSING_FILE', -4 );  define( 'PCLZIP_ERR_FILENAME_TOO_LONG', -5 );  define( 'PCLZIP_ERR_INVALID_ZIP', -6 );  define( 'PCLZIP_ERR_BAD_EXTRACTED_FILE', -7 );  define( 'PCLZIP_ERR_DIR_CREATE_FAIL', -8 );  define( 'PCLZIP_ERR_BAD_EXTENSION', -9 );  define( 'PCLZIP_ERR_BAD_FORMAT', -10 );  define( 'PCLZIP_ERR_DELETE_FILE_FAIL', -11 );  define( 'PCLZIP_ERR_RENAME_FILE_FAIL', -12 );  define( 'PCLZIP_ERR_BAD_CHECKSUM', -13 );  define( 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14 );  define( 'PCLZIP_ERR_MISSING_OPTION_VALUE', -15 );  define( 'PCLZIP_ERR_INVALID_OPTION_VALUE', -16 );  define( 'PCLZIP_ERR_ALREADY_A_DIRECTORY', -17 );  define( 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18 );  define( 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19 );  define( 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20 );  define( 'PCLZIP_ERR_DIRECTORY_RESTRICTION', -21 );  // ----- Options values  define( 'PCLZIP_OPT_PATH', 77001 );  define( 'PCLZIP_OPT_ADD_PATH', 77002 );  define( 'PCLZIP_OPT_REMOVE_PATH', 77003 );  define( 'PCLZIP_OPT_REMOVE_ALL_PATH', 77004 );  define( 'PCLZIP_OPT_SET_CHMOD', 77005 );  define( 'PCLZIP_OPT_EXTRACT_AS_STRING', 77006 );  define( 'PCLZIP_OPT_NO_COMPRESSION', 77007 );  define( 'PCLZIP_OPT_BY_NAME', 77008 );  define( 'PCLZIP_OPT_BY_INDEX', 77009 );  define( 'PCLZIP_OPT_BY_EREG', 77010 );  define( 'PCLZIP_OPT_BY_PREG', 77011 );  define( 'PCLZIP_OPT_COMMENT', 77012 );  define( 'PCLZIP_OPT_ADD_COMMENT', 77013 );  define( 'PCLZIP_OPT_PREPEND_COMMENT', 77014 );  define( 'PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015 );  define( 'PCLZIP_OPT_REPLACE_NEWER', 77016 );  define( 'PCLZIP_OPT_STOP_ON_ERROR', 77017 );  // Having big trouble with crypt. Need to multiply 2 long int  // which is not correctly supported by PHP ...  //define( 'PCLZIP_OPT_CRYPT', 77018 );  define( 'PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019 );  define( 'PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020 );  define( 'PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD', 77020 ); // alias  define( 'PCLZIP_OPT_TEMP_FILE_ON', 77021 );  define( 'PCLZIP_OPT_ADD_TEMP_FILE_ON', 77021 ); // alias  define( 'PCLZIP_OPT_TEMP_FILE_OFF', 77022 );  define( 'PCLZIP_OPT_ADD_TEMP_FILE_OFF', 77022 ); // alias  // ----- File description attributes  define( 'PCLZIP_ATT_FILE_NAME', 79001 );  define( 'PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002 );  define( 'PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003 );  define( 'PCLZIP_ATT_FILE_MTIME', 79004 );  define( 'PCLZIP_ATT_FILE_CONTENT', 79005 );  define( 'PCLZIP_ATT_FILE_COMMENT', 79006 );  // ----- Call backs values  define( 'PCLZIP_CB_PRE_EXTRACT', 78001 );  define( 'PCLZIP_CB_POST_EXTRACT', 78002 );  define( 'PCLZIP_CB_PRE_ADD', 78003 );  define( 'PCLZIP_CB_POST_ADD', 78004 );  /* For futur use  define( 'PCLZIP_CB_PRE_LIST', 78005 );  define( 'PCLZIP_CB_POST_LIST', 78006 );  define( 'PCLZIP_CB_PRE_DELETE', 78007 );  define( 'PCLZIP_CB_POST_DELETE', 78008 );  */  // --------------------------------------------------------------------------------  // Class : PclZip  // Description :  //   PclZip is the class that represent a Zip archive.  //   The public methods allow the manipulation of the archive.  // Attributes :  //   Attributes must not be accessed directly.  // Methods :  //   PclZip() : Object creator  //   create() : Creates the Zip archive  //   listContent() : List the content of the Zip archive  //   extract() : Extract the content of the archive  //   properties() : List the properties of the archive  // --------------------------------------------------------------------------------  class PclZip  {    // ----- Filename of the zip file    var $zipname = '';    // ----- File descriptor of the zip file    var $zip_fd = 0;    // ----- Internal error handling    var $error_code = 1;    var $error_string = '';    // ----- Current status of the magic_quotes_runtime    // This value store the php configuration for magic_quotes    // The class can then disable the magic_quotes and reset it after    var $magic_quotes_status;  // --------------------------------------------------------------------------------  // Function : PclZip()  // Description :  //   Creates a PclZip object and set the name of the associated Zip archive  //   filename.  //   Note that no real action is taken, if the archive does not exist it is not  //   created. Use create() for that.  // --------------------------------------------------------------------------------  function PclZip($p_zipname)  {    // ----- Tests the zlib    if (!function_exists('gzopen'))    {      die('Abort '.basename(__FILE__).' : Missing zlib extensions');    }    // ----- Set the attributes    $this->zipname = $p_zipname;    $this->zip_fd = 0;    $this->magic_quotes_status = -1;    // ----- Return    return;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   create($p_filelist, $p_add_dir="", $p_remove_dir="")  //   create($p_filelist, $p_option, $p_option_value, ...)  // Description :  //   This method supports two different synopsis. The first one is historical.  //   This method creates a Zip Archive. The Zip file is created in the  //   filesystem. The files and directories indicated in $p_filelist  //   are added in the archive. See the parameters description for the  //   supported format of $p_filelist.  //   When a directory is in the list, the directory and its content is added  //   in the archive.  //   In this synopsis, the function takes an optional variable list of  //   options. See bellow the supported options.  // Parameters :  //   $p_filelist : An array containing file or directory names, or  //                 a string containing one filename or one directory name, or  //                 a string containing a list of filenames and/or directory  //                 names separated by spaces.  //   $p_add_dir : A path to add before the real path of the archived file,  //                in order to have it memorized in the archive.  //   $p_remove_dir : A path to remove from the real path of the file to archive,  //                   in order to have a shorter path memorized in the archive.  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir  //                   is removed first, before $p_add_dir is added.  // Options :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_OPT_COMMENT :  //   PCLZIP_CB_PRE_ADD :  //   PCLZIP_CB_POST_ADD :  // Return Values :  //   0 on failure,  //   The list of the added files, with a status of the add action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function create($p_filelist)  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Set default values    $v_options = array();    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Look for arguments    if ($v_size > 1) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Remove from the options list the first argument      array_shift($v_arg_list);      $v_size--;      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_ADD => 'optional',                                                   PCLZIP_CB_POST_ADD => 'optional',                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',                                                   PCLZIP_OPT_COMMENT => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'                                                   //, PCLZIP_OPT_CRYPT => 'optional'                                             ));        if ($v_result != 1) {          return 0;        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];        }        else if ($v_size > 2) {          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,		                       "Invalid number / type of arguments");          return 0;        }      }    }    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Init    $v_string_list = array();    $v_att_list = array();    $v_filedescr_list = array();    $p_result_list = array();    // ----- Look if the $p_filelist is really an array    if (is_array($p_filelist)) {      // ----- Look if the first element is also an array      //       This will mean that this is a file description entry      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {        $v_att_list = $p_filelist;      }      // ----- The list is a list of string names      else {        $v_string_list = $p_filelist;      }    }    // ----- Look if the $p_filelist is a string    else if (is_string($p_filelist)) {      // ----- Create a list from the string      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);    }    // ----- Invalid variable type for $p_filelist    else {      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_filelist");      return 0;    }    // ----- Reformat the string list    if (sizeof($v_string_list) != 0) {      foreach ($v_string_list as $v_string) {        if ($v_string != '') {          $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;        }        else {        }      }    }    // ----- For each file in the list check the attributes    $v_supported_attributes    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'             ,PCLZIP_ATT_FILE_MTIME => 'optional'             ,PCLZIP_ATT_FILE_CONTENT => 'optional'             ,PCLZIP_ATT_FILE_COMMENT => 'optional'						);    foreach ($v_att_list as $v_entry) {      $v_result = $this->privFileDescrParseAtt($v_entry,                                               $v_filedescr_list[],                                               $v_options,                                               $v_supported_attributes);      if ($v_result != 1) {        return 0;      }    }    // ----- Expand the filelist (expand directories)    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Call the create fct    $v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Return    return $p_result_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   add($p_filelist, $p_add_dir="", $p_remove_dir="")  //   add($p_filelist, $p_option, $p_option_value, ...)  // Description :  //   This method supports two synopsis. The first one is historical.  //   This methods add the list of files in an existing archive.  //   If a file with the same name already exists, it is added at the end of the  //   archive, the first one is still present.  //   If the archive does not exist, it is created.  // Parameters :  //   $p_filelist : An array containing file or directory names, or  //                 a string containing one filename or one directory name, or  //                 a string containing a list of filenames and/or directory  //                 names separated by spaces.  //   $p_add_dir : A path to add before the real path of the archived file,  //                in order to have it memorized in the archive.  //   $p_remove_dir : A path to remove from the real path of the file to archive,  //                   in order to have a shorter path memorized in the archive.  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir  //                   is removed first, before $p_add_dir is added.  // Options :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_OPT_COMMENT :  //   PCLZIP_OPT_ADD_COMMENT :  //   PCLZIP_OPT_PREPEND_COMMENT :  //   PCLZIP_CB_PRE_ADD :  //   PCLZIP_CB_POST_ADD :  // Return Values :  //   0 on failure,  //   The list of the added files, with a status of the add action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function add($p_filelist)  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Set default values    $v_options = array();    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Look for arguments    if ($v_size > 1) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Remove form the options list the first argument      array_shift($v_arg_list);      $v_size--;      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_ADD => 'optional',                                                   PCLZIP_CB_POST_ADD => 'optional',                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',                                                   PCLZIP_OPT_COMMENT => 'optional',                                                   PCLZIP_OPT_ADD_COMMENT => 'optional',                                                   PCLZIP_OPT_PREPEND_COMMENT => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'                                                   //, PCLZIP_OPT_CRYPT => 'optional'												   ));        if ($v_result != 1) {          return 0;        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];        }        else if ($v_size > 2) {          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");          // ----- Return          return 0;        }      }    }    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Init    $v_string_list = array();    $v_att_list = array();    $v_filedescr_list = array();    $p_result_list = array();    // ----- Look if the $p_filelist is really an array    if (is_array($p_filelist)) {      // ----- Look if the first element is also an array      //       This will mean that this is a file description entry      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {        $v_att_list = $p_filelist;      }      // ----- The list is a list of string names      else {        $v_string_list = $p_filelist;      }    }    // ----- Look if the $p_filelist is a string    else if (is_string($p_filelist)) {      // ----- Create a list from the string      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);    }    // ----- Invalid variable type for $p_filelist    else {      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type '".gettype($p_filelist)."' for p_filelist");      return 0;    }    // ----- Reformat the string list    if (sizeof($v_string_list) != 0) {      foreach ($v_string_list as $v_string) {        $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;      }    }    // ----- For each file in the list check the attributes    $v_supported_attributes    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'             ,PCLZIP_ATT_FILE_MTIME => 'optional'             ,PCLZIP_ATT_FILE_CONTENT => 'optional'             ,PCLZIP_ATT_FILE_COMMENT => 'optional'						);    foreach ($v_att_list as $v_entry) {      $v_result = $this->privFileDescrParseAtt($v_entry,                                               $v_filedescr_list[],                                               $v_options,                                               $v_supported_attributes);      if ($v_result != 1) {        return 0;      }    }    // ----- Expand the filelist (expand directories)    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Call the create fct    $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Return    return $p_result_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : listContent()  // Description :  //   This public method, gives the list of the files and directories, with their  //   properties.  //   The properties of each entries in the list are (used also in other functions) :  //     filename : Name of the file. For a create or add action it is the filename  //                given by the user. For an extract function it is the filename  //                of the extracted file.  //     stored_filename : Name of the file / directory stored in the archive.  //     size : Size of the stored file.  //     compressed_size : Size of the file's data compressed in the archive  //                       (without the headers overhead)  //     mtime : Last known modification date of the file (UNIX timestamp)  //     comment : Comment associated with the file  //     folder : true | false  //     index : index of the file in the archive  //     status : status of the action (depending of the action) :  //              Values are :  //                ok : OK !  //                filtered : the file / dir is not extracted (filtered by user)  //                already_a_directory : the file can not be extracted because a  //                                      directory with the same name already exists  //                write_protected : the file can not be extracted because a file  //                                  with the same name already exists and is  //                                  write protected  //                newer_exist : the file was not extracted because a newer file exists  //                path_creation_fail : the file is not extracted because the folder  //                                     does not exist and can not be created  //                write_error : the file was not extracted because there was a  //                              error while writing the file  //                read_error : the file was not extracted because there was a error  //                             while reading the file  //                invalid_header : the file was not extracted because of an archive  //                                 format error (bad file header)  //   Note that each time a method can continue operating when there  //   is an action error on a file, the error is only logged in the file status.  // Return Values :  //   0 on an unrecoverable failure,  //   The list of the files in the archive.  // --------------------------------------------------------------------------------  function listContent()  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Call the extracting fct    $p_list = array();    if (($v_result = $this->privList($p_list)) != 1)    {      unset($p_list);      return(0);    }    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   extract($p_path="./", $p_remove_path="")  //   extract([$p_option, $p_option_value, ...])  // Description :  //   This method supports two synopsis. The first one is historical.  //   This method extract all the files / directories from the archive to the  //   folder indicated in $p_path.  //   If you want to ignore the 'root' part of path of the memorized files  //   you can indicate this in the optional $p_remove_path parameter.  //   By default, if a newer file with the same name already exists, the  //   file is not extracted.  //  //   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions  //   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append  //   at the end of the path value of PCLZIP_OPT_PATH.  // Parameters :  //   $p_path : Path where the files and directories are to be extracted  //   $p_remove_path : First part ('root' part) of the memorized path  //                    (if any similar) to remove while extracting.  // Options :  //   PCLZIP_OPT_PATH :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_CB_PRE_EXTRACT :  //   PCLZIP_CB_POST_EXTRACT :  // Return Values :  //   0 or a negative value on failure,  //   The list of the extracted files, with a status of the action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function extract()  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Set default values    $v_options = array();//    $v_path = "./";    $v_path = '';    $v_remove_path = "";    $v_remove_all_path = false;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Default values for option    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;    // ----- Look for arguments    if ($v_size > 0) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',                                                   PCLZIP_CB_POST_EXTRACT => 'optional',                                                   PCLZIP_OPT_SET_CHMOD => 'optional',                                                   PCLZIP_OPT_BY_NAME => 'optional',                                                   PCLZIP_OPT_BY_EREG => 'optional',                                                   PCLZIP_OPT_BY_PREG => 'optional',                                                   PCLZIP_OPT_BY_INDEX => 'optional',                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',                                                   PCLZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'												    ));        if ($v_result != 1) {          return 0;        }        // ----- Set the arguments        if (isset($v_options[PCLZIP_OPT_PATH])) {          $v_path = $v_options[PCLZIP_OPT_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];        }        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {          // ----- Check for '/' in last path char          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {            $v_path .= '/';          }          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_path = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_remove_path = $v_arg_list[1];        }        else if ($v_size > 2) {          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");          // ----- Return          return 0;        }      }    }    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Trace    // ----- Call the extracting fct    $p_list = array();    $v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path,	                                     $v_remove_all_path, $v_options);    if ($v_result < 1) {      unset($p_list);      return(0);    }    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   extractByIndex($p_index, $p_path="./", $p_remove_path="")  //   extractByIndex($p_index, [$p_option, $p_option_value, ...])  // Description :  //   This method supports two synopsis. The first one is historical.  //   This method is doing a partial extract of the archive.  //   The extracted files or folders are identified by their index in the  //   archive (from 0 to n).  //   Note that if the index identify a folder, only the folder entry is  //   extracted, not all the files included in the archive.  // Parameters :  //   $p_index : A single index (integer) or a string of indexes of files to  //              extract. The form of the string is "0,4-6,8-12" with only numbers  //              and '-' for range or ',' to separate ranges. No spaces or ';'  //              are allowed.  //   $p_path : Path where the files and directories are to be extracted  //   $p_remove_path : First part ('root' part) of the memorized path  //                    (if any similar) to remove while extracting.  // Options :  //   PCLZIP_OPT_PATH :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and  //     not as files.  //     The resulting content is in a new field 'content' in the file  //     structure.  //     This option must be used alone (any other options are ignored).  //   PCLZIP_CB_PRE_EXTRACT :  //   PCLZIP_CB_POST_EXTRACT :  // Return Values :  //   0 on failure,  //   The list of the extracted files, with a status of the action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  //function extractByIndex($p_index, options...)  function extractByIndex($p_index)  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Set default values    $v_options = array();//    $v_path = "./";    $v_path = '';    $v_remove_path = "";    $v_remove_all_path = false;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Default values for option    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;    // ----- Look for arguments    if ($v_size > 1) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Remove form the options list the first argument      array_shift($v_arg_list);      $v_size--;      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',                                                   PCLZIP_CB_POST_EXTRACT => 'optional',                                                   PCLZIP_OPT_SET_CHMOD => 'optional',                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'												   ));        if ($v_result != 1) {          return 0;        }        // ----- Set the arguments        if (isset($v_options[PCLZIP_OPT_PATH])) {          $v_path = $v_options[PCLZIP_OPT_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];        }        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {          // ----- Check for '/' in last path char          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {            $v_path .= '/';          }          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];        }        if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {          $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;        }        else {        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_path = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_remove_path = $v_arg_list[1];        }        else if ($v_size > 2) {          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");          // ----- Return          return 0;        }      }    }    // ----- Trace    // ----- Trick    // Here I want to reuse extractByRule(), so I need to parse the $p_index    // with privParseOptions()    $v_arg_trick = array (PCLZIP_OPT_BY_INDEX, $p_index);    $v_options_trick = array();    $v_result = $this->privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick,                                        array (PCLZIP_OPT_BY_INDEX => 'optional' ));    if ($v_result != 1) {        return 0;    }    $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Call the extracting fct    if (($v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) < 1) {        return(0);    }    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   delete([$p_option, $p_option_value, ...])  // Description :  //   This method removes files from the archive.  //   If no parameters are given, then all the archive is emptied.  // Parameters :  //   None or optional arguments.  // Options :  //   PCLZIP_OPT_BY_INDEX :  //   PCLZIP_OPT_BY_NAME :  //   PCLZIP_OPT_BY_EREG :  //   PCLZIP_OPT_BY_PREG :  // Return Values :  //   0 on failure,  //   The list of the files which are still present in the archive.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function delete()  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Set default values    $v_options = array();    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Look for arguments    if ($v_size > 0) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Parse the options      $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                        array (PCLZIP_OPT_BY_NAME => 'optional',                                               PCLZIP_OPT_BY_EREG => 'optional',                                               PCLZIP_OPT_BY_PREG => 'optional',                                               PCLZIP_OPT_BY_INDEX => 'optional' ));      if ($v_result != 1) {          return 0;      }    }    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Call the delete fct    $v_list = array();    if (($v_result = $this->privDeleteByRule($v_list, $v_options)) != 1) {      $this->privSwapBackMagicQuotes();      unset($v_list);      return(0);    }    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : deleteByIndex()  // Description :  //   ***** Deprecated *****  //   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.  // --------------------------------------------------------------------------------  function deleteByIndex($p_index)  {    $p_list = $this->delete(PCLZIP_OPT_BY_INDEX, $p_index);    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : properties()  // Description :  //   This method gives the properties of the archive.  //   The properties are :  //     nb : Number of files in the archive  //     comment : Comment associated with the archive file  //     status : not_exist, ok  // Parameters :  //   None  // Return Values :  //   0 on failure,  //   An array with the archive properties.  // --------------------------------------------------------------------------------  function properties()  {    // ----- Reset the error handler    $this->privErrorReset();    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Check archive    if (!$this->privCheckFormat()) {      $this->privSwapBackMagicQuotes();      return(0);    }    // ----- Default properties    $v_prop = array();    $v_prop['comment'] = '';    $v_prop['nb'] = 0;    $v_prop['status'] = 'not_exist';    // ----- Look if file exists    if (@is_file($this->zipname))    {      // ----- Open the zip file      if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)      {        $this->privSwapBackMagicQuotes();        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in binary read mode');        // ----- Return        return 0;      }      // ----- Read the central directory informations      $v_central_dir = array();      if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)      {        $this->privSwapBackMagicQuotes();        return 0;      }      // ----- Close the zip file      $this->privCloseFd();      // ----- Set the user attributes      $v_prop['comment'] = $v_central_dir['comment'];      $v_prop['nb'] = $v_central_dir['entries'];      $v_prop['status'] = 'ok';    }    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_prop;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : duplicate()  // Description :  //   This method creates an archive by copying the content of an other one. If  //   the archive already exist, it is replaced by the new one without any warning.  // Parameters :  //   $p_archive : The filename of a valid archive, or  //                a valid PclZip object.  // Return Values :  //   1 on success.  //   0 or a negative value on error (error code).  // --------------------------------------------------------------------------------  function duplicate($p_archive)  {    $v_result = 1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Look if the $p_archive is a PclZip object    if ((is_object($p_archive)) && (get_class($p_archive) == 'pclzip'))    {      // ----- Duplicate the archive      $v_result = $this->privDuplicate($p_archive->zipname);    }    // ----- Look if the $p_archive is a string (so a filename)    else if (is_string($p_archive))    {      // ----- Check that $p_archive is a valid zip file      // TBC : Should also check the archive format      if (!is_file($p_archive)) {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "No file with filename '".$p_archive."'");        $v_result = PCLZIP_ERR_MISSING_FILE;      }      else {        // ----- Duplicate the archive        $v_result = $this->privDuplicate($p_archive);      }    }    // ----- Invalid variable    else    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add");      $v_result = PCLZIP_ERR_INVALID_PARAMETER;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : merge()  // Description :  //   This method merge the $p_archive_to_add archive at the end of the current  //   one ($this).  //   If the archive ($this) does not exist, the merge becomes a duplicate.  //   If the $p_archive_to_add archive does not exist, the merge is a success.  // Parameters :  //   $p_archive_to_add : It can be directly the filename of a valid zip archive,  //                       or a PclZip object archive.  // Return Values :  //   1 on success,  //   0 or negative values on error (see below).  // --------------------------------------------------------------------------------  function merge($p_archive_to_add)  {    $v_result = 1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Look if the $p_archive_to_add is a PclZip object    if ((is_object($p_archive_to_add)) && (get_class($p_archive_to_add) == 'pclzip'))    {      // ----- Merge the archive      $v_result = $this->privMerge($p_archive_to_add);    }    // ----- Look if the $p_archive_to_add is a string (so a filename)    else if (is_string($p_archive_to_add))    {      // ----- Create a temporary archive      $v_object_archive = new PclZip($p_archive_to_add);      // ----- Merge the archive      $v_result = $this->privMerge($v_object_archive);    }    // ----- Invalid variable    else    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add");      $v_result = PCLZIP_ERR_INVALID_PARAMETER;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : errorCode()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function errorCode()  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      return(PclErrorCode());    }    else {      return($this->error_code);    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : errorName()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function errorName($p_with_code=false)  {    $v_name = array ( PCLZIP_ERR_NO_ERROR => 'PCLZIP_ERR_NO_ERROR',                      PCLZIP_ERR_WRITE_OPEN_FAIL => 'PCLZIP_ERR_WRITE_OPEN_FAIL',                      PCLZIP_ERR_READ_OPEN_FAIL => 'PCLZIP_ERR_READ_OPEN_FAIL',                      PCLZIP_ERR_INVALID_PARAMETER => 'PCLZIP_ERR_INVALID_PARAMETER',                      PCLZIP_ERR_MISSING_FILE => 'PCLZIP_ERR_MISSING_FILE',                      PCLZIP_ERR_FILENAME_TOO_LONG => 'PCLZIP_ERR_FILENAME_TOO_LONG',                      PCLZIP_ERR_INVALID_ZIP => 'PCLZIP_ERR_INVALID_ZIP',                      PCLZIP_ERR_BAD_EXTRACTED_FILE => 'PCLZIP_ERR_BAD_EXTRACTED_FILE',                      PCLZIP_ERR_DIR_CREATE_FAIL => 'PCLZIP_ERR_DIR_CREATE_FAIL',                      PCLZIP_ERR_BAD_EXTENSION => 'PCLZIP_ERR_BAD_EXTENSION',                      PCLZIP_ERR_BAD_FORMAT => 'PCLZIP_ERR_BAD_FORMAT',                      PCLZIP_ERR_DELETE_FILE_FAIL => 'PCLZIP_ERR_DELETE_FILE_FAIL',                      PCLZIP_ERR_RENAME_FILE_FAIL => 'PCLZIP_ERR_RENAME_FILE_FAIL',                      PCLZIP_ERR_BAD_CHECKSUM => 'PCLZIP_ERR_BAD_CHECKSUM',                      PCLZIP_ERR_INVALID_ARCHIVE_ZIP => 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP',                      PCLZIP_ERR_MISSING_OPTION_VALUE => 'PCLZIP_ERR_MISSING_OPTION_VALUE',                      PCLZIP_ERR_INVALID_OPTION_VALUE => 'PCLZIP_ERR_INVALID_OPTION_VALUE',                      PCLZIP_ERR_UNSUPPORTED_COMPRESSION => 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION',                      PCLZIP_ERR_UNSUPPORTED_ENCRYPTION => 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION'                      ,PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE => 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE'                      ,PCLZIP_ERR_DIRECTORY_RESTRICTION => 'PCLZIP_ERR_DIRECTORY_RESTRICTION'                    );    if (isset($v_name[$this->error_code])) {      $v_value = $v_name[$this->error_code];    }    else {      $v_value = 'NoName';    }    if ($p_with_code) {      return($v_value.' ('.$this->error_code.')');    }    else {      return($v_value);    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : errorInfo()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function errorInfo($p_full=false)  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      return(PclErrorString());    }    else {      if ($p_full) {        return($this->errorName(true)." : ".$this->error_string);      }      else {        return($this->error_string." [code ".$this->error_code."]");      }    }  }  // --------------------------------------------------------------------------------// --------------------------------------------------------------------------------// ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****// *****                                                        *****// *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****// --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCheckFormat()  // Description :  //   This method check that the archive exists and is a valid zip archive.  //   Several level of check exists. (futur)  // Parameters :  //   $p_level : Level of check. Default 0.  //              0 : Check the first bytes (magic codes) (default value))  //              1 : 0 + Check the central directory (futur)  //              2 : 1 + Check each file header (futur)  // Return Values :  //   true on success,  //   false on error, the error code is set.  // --------------------------------------------------------------------------------  function privCheckFormat($p_level=0)  {    $v_result = true;	// ----- Reset the file system cache    clearstatcache();    // ----- Reset the error handler    $this->privErrorReset();    // ----- Look if the file exits    if (!is_file($this->zipname)) {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "Missing archive file '".$this->zipname."'");      return(false);    }    // ----- Check that the file is readeable    if (!is_readable($this->zipname)) {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to read archive '".$this->zipname."'");      return(false);    }    // ----- Check the magic code    // TBC    // ----- Check the central header    // TBC    // ----- Check each file header    // TBC    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privParseOptions()  // Description :  //   This internal methods reads the variable list of arguments ($p_options_list,  //   $p_size) and generate an array with the options and values ($v_result_list).  //   $v_requested_options contains the options that can be present and those that  //   must be present.  //   $v_requested_options is an array, with the option value as key, and 'optional',  //   or 'mandatory' as value.  // Parameters :  //   See above.  // Return Values :  //   1 on success.  //   0 on failure.  // --------------------------------------------------------------------------------  function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options=false)  {    $v_result=1;    // ----- Read the options    $i=0;    while ($i<$p_size) {      // ----- Check if the option is supported      if (!isset($v_requested_options[$p_options_list[$i]])) {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid optional parameter '".$p_options_list[$i]."' for this method");        // ----- Return        return PclZip::errorCode();      }      // ----- Look for next option      switch ($p_options_list[$i]) {        // ----- Look for options that request a path value        case PCLZIP_OPT_PATH :        case PCLZIP_OPT_REMOVE_PATH :        case PCLZIP_OPT_ADD_PATH :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);          $i++;        break;        case PCLZIP_OPT_TEMP_FILE_THRESHOLD :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            return PclZip::errorCode();          }          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");            return PclZip::errorCode();          }          // ----- Check the value          $v_value = $p_options_list[$i+1];          if ((!is_integer($v_value)) || ($v_value<0)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Integer expected for option '".PclZipUtilOptionText($p_options_list[$i])."'");            return PclZip::errorCode();          }          // ----- Get the value (and convert it in bytes)          $v_result_list[$p_options_list[$i]] = $v_value*1048576;          $i++;        break;        case PCLZIP_OPT_TEMP_FILE_ON :          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");            return PclZip::errorCode();          }          $v_result_list[$p_options_list[$i]] = true;        break;        case PCLZIP_OPT_TEMP_FILE_OFF :          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'");            return PclZip::errorCode();          }          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'");            return PclZip::errorCode();          }          $v_result_list[$p_options_list[$i]] = true;        break;        case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (   is_string($p_options_list[$i+1])              && ($p_options_list[$i+1] != '')) {            $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);            $i++;          }          else {          }        break;        // ----- Look for options that request an array of string for value        case PCLZIP_OPT_BY_NAME :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (is_string($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i+1];          }          else if (is_array($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          $i++;        break;        // ----- Look for options that request an EREG or PREG expression        case PCLZIP_OPT_BY_EREG :          // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG          // to PCLZIP_OPT_BY_PREG          $p_options_list[$i] = PCLZIP_OPT_BY_PREG;        case PCLZIP_OPT_BY_PREG :        //case PCLZIP_OPT_CRYPT :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (is_string($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          $i++;        break;        // ----- Look for options that takes a string        case PCLZIP_OPT_COMMENT :        case PCLZIP_OPT_ADD_COMMENT :        case PCLZIP_OPT_PREPEND_COMMENT :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE,			                     "Missing parameter value for option '"								 .PclZipUtilOptionText($p_options_list[$i])								 ."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (is_string($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE,			                     "Wrong parameter value for option '"								 .PclZipUtilOptionText($p_options_list[$i])								 ."'");            // ----- Return            return PclZip::errorCode();          }          $i++;        break;        // ----- Look for options that request an array of index        case PCLZIP_OPT_BY_INDEX :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_work_list = array();          if (is_string($p_options_list[$i+1])) {              // ----- Remove spaces              $p_options_list[$i+1] = strtr($p_options_list[$i+1], ' ', '');              // ----- Parse items              $v_work_list = explode(",", $p_options_list[$i+1]);          }          else if (is_integer($p_options_list[$i+1])) {              $v_work_list[0] = $p_options_list[$i+1].'-'.$p_options_list[$i+1];          }          else if (is_array($p_options_list[$i+1])) {              $v_work_list = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Value must be integer, string or array for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Reduce the index list          // each index item in the list must be a couple with a start and          // an end value : [0,3], [5-5], [8-10], ...          // ----- Check the format of each item          $v_sort_flag=false;          $v_sort_value=0;          for ($j=0; $j<sizeof($v_work_list); $j++) {              // ----- Explode the item              $v_item_list = explode("-", $v_work_list[$j]);              $v_size_item_list = sizeof($v_item_list);              // ----- TBC : Here we might check that each item is a              // real integer ...              // ----- Look for single value              if ($v_size_item_list == 1) {                  // ----- Set the option value                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];              }              elseif ($v_size_item_list == 2) {                  // ----- Set the option value                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];              }              else {                  // ----- Error log                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Too many values in index range for option '".PclZipUtilOptionText($p_options_list[$i])."'");                  // ----- Return                  return PclZip::errorCode();              }              // ----- Look for list sort              if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {                  $v_sort_flag=true;                  // ----- TBC : An automatic sort should be writen ...                  // ----- Error log                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Invalid order of index range for option '".PclZipUtilOptionText($p_options_list[$i])."'");                  // ----- Return                  return PclZip::errorCode();              }              $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];          }          // ----- Sort the items          if ($v_sort_flag) {              // TBC : To Be Completed          }          // ----- Next option          $i++;        break;        // ----- Look for options that request no value        case PCLZIP_OPT_REMOVE_ALL_PATH :        case PCLZIP_OPT_EXTRACT_AS_STRING :        case PCLZIP_OPT_NO_COMPRESSION :        case PCLZIP_OPT_EXTRACT_IN_OUTPUT :        case PCLZIP_OPT_REPLACE_NEWER :        case PCLZIP_OPT_STOP_ON_ERROR :          $v_result_list[$p_options_list[$i]] = true;        break;        // ----- Look for options that request an octal value        case PCLZIP_OPT_SET_CHMOD :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          $i++;        break;        // ----- Look for options that request a call-back        case PCLZIP_CB_PRE_EXTRACT :        case PCLZIP_CB_POST_EXTRACT :        case PCLZIP_CB_PRE_ADD :        case PCLZIP_CB_POST_ADD :        /* for futur use        case PCLZIP_CB_PRE_DELETE :        case PCLZIP_CB_POST_DELETE :        case PCLZIP_CB_PRE_LIST :        case PCLZIP_CB_POST_LIST :        */          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_function_name = $p_options_list[$i+1];          // ----- Check that the value is a valid existing function          if (!function_exists($v_function_name)) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Function '".$v_function_name."()' is not an existing function for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Set the attribute          $v_result_list[$p_options_list[$i]] = $v_function_name;          $i++;        break;        default :          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,		                       "Unknown parameter '"							   .$p_options_list[$i]."'");          // ----- Return          return PclZip::errorCode();      }      // ----- Next options      $i++;    }    // ----- Look for mandatory options    if ($v_requested_options !== false) {      for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {        // ----- Look for mandatory option        if ($v_requested_options[$key] == 'mandatory') {          // ----- Look if present          if (!isset($v_result_list[$key])) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter ".PclZipUtilOptionText($key)."(".$key.")");            // ----- Return            return PclZip::errorCode();          }        }      }    }    // ----- Look for default values    if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privOptionDefaultThreshold()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privOptionDefaultThreshold(&$p_options)  {    $v_result=1;    if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])        || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {      return $v_result;    }    // ----- Get 'memory_limit' configuration value    $v_memory_limit = ini_get('memory_limit');    $v_memory_limit = trim($v_memory_limit);    $last = strtolower(substr($v_memory_limit, -1));    if($last == 'g')        //$v_memory_limit = $v_memory_limit*1024*1024*1024;        $v_memory_limit = $v_memory_limit*1073741824;    if($last == 'm')        //$v_memory_limit = $v_memory_limit*1024*1024;        $v_memory_limit = $v_memory_limit*1048576;    if($last == 'k')        $v_memory_limit = $v_memory_limit*1024;    $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit*PCLZIP_TEMPORARY_FILE_RATIO);    // ----- Sanity check : No threshold if value lower than 1M    if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) {      unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privFileDescrParseAtt()  // Description :  // Parameters :  // Return Values :  //   1 on success.  //   0 on failure.  // --------------------------------------------------------------------------------  function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options=false)  {    $v_result=1;    // ----- For each file in the list check the attributes    foreach ($p_file_list as $v_key => $v_value) {      // ----- Check if the option is supported      if (!isset($v_requested_options[$v_key])) {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file attribute '".$v_key."' for this file");        // ----- Return        return PclZip::errorCode();      }      // ----- Look for attribute      switch ($v_key) {        case PCLZIP_ATT_FILE_NAME :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['filename'] = PclZipUtilPathReduction($v_value);          if ($p_filedescr['filename'] == '') {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty filename for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }        break;        case PCLZIP_ATT_FILE_NEW_SHORT_NAME :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value);          if ($p_filedescr['new_short_name'] == '') {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty short filename for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }        break;        case PCLZIP_ATT_FILE_NEW_FULL_NAME :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value);          if ($p_filedescr['new_full_name'] == '') {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty full filename for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }        break;        // ----- Look for options that takes a string        case PCLZIP_ATT_FILE_COMMENT :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['comment'] = $v_value;        break;        case PCLZIP_ATT_FILE_MTIME :          if (!is_integer($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". Integer expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['mtime'] = $v_value;        break;        case PCLZIP_ATT_FILE_CONTENT :          $p_filedescr['content'] = $v_value;        break;        default :          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,		                           "Unknown parameter '".$v_key."'");          // ----- Return          return PclZip::errorCode();      }      // ----- Look for mandatory options      if ($v_requested_options !== false) {        for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {          // ----- Look for mandatory option          if ($v_requested_options[$key] == 'mandatory') {            // ----- Look if present            if (!isset($p_file_list[$key])) {              PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter ".PclZipUtilOptionText($key)."(".$key.")");              return PclZip::errorCode();            }          }        }      }    // end foreach    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privFileDescrExpand()  // Description :  //   This method look for each item of the list to see if its a file, a folder  //   or a string to be added as file. For any other type of files (link, other)  //   just ignore the item.  //   Then prepare the information that will be stored for that file.  //   When its a folder, expand the folder with all the files that are in that  //   folder (recursively).  // Parameters :  // Return Values :  //   1 on success.  //   0 on failure.  // --------------------------------------------------------------------------------  function privFileDescrExpand(&$p_filedescr_list, &$p_options)  {    $v_result=1;    // ----- Create a result list    $v_result_list = array();    // ----- Look each entry    for ($i=0; $i<sizeof($p_filedescr_list); $i++) {      // ----- Get filedescr      $v_descr = $p_filedescr_list[$i];      // ----- Reduce the filename      $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false);      $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']);      // ----- Look for real file or folder      if (file_exists($v_descr['filename'])) {        if (@is_file($v_descr['filename'])) {          $v_descr['type'] = 'file';        }        else if (@is_dir($v_descr['filename'])) {          $v_descr['type'] = 'folder';        }        else if (@is_link($v_descr['filename'])) {          // skip          continue;        }        else {          // skip          continue;        }      }      // ----- Look for string added as file      else if (isset($v_descr['content'])) {        $v_descr['type'] = 'virtual_file';      }      // ----- Missing file      else {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '".$v_descr['filename']."' does not exist");        // ----- Return        return PclZip::errorCode();      }      // ----- Calculate the stored filename      $this->privCalculateStoredFilename($v_descr, $p_options);      // ----- Add the descriptor in result list      $v_result_list[sizeof($v_result_list)] = $v_descr;      // ----- Look for folder      if ($v_descr['type'] == 'folder') {        // ----- List of items in folder        $v_dirlist_descr = array();        $v_dirlist_nb = 0;        if ($v_folder_handler = @opendir($v_descr['filename'])) {          while (($v_item_handler = @readdir($v_folder_handler)) !== false) {            // ----- Skip '.' and '..'            if (($v_item_handler == '.') || ($v_item_handler == '..')) {                continue;            }            // ----- Compose the full filename            $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'].'/'.$v_item_handler;            // ----- Look for different stored filename            // Because the name of the folder was changed, the name of the            // files/sub-folders also change            if (($v_descr['stored_filename'] != $v_descr['filename'])                 && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {              if ($v_descr['stored_filename'] != '') {                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'].'/'.$v_item_handler;              }              else {                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler;              }            }            $v_dirlist_nb++;          }          @closedir($v_folder_handler);        }        else {          // TBC : unable to open folder in read mode        }        // ----- Expand each element of the list        if ($v_dirlist_nb != 0) {          // ----- Expand          if (($v_result = $this->privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) {            return $v_result;          }          // ----- Concat the resulting list          $v_result_list = array_merge($v_result_list, $v_dirlist_descr);        }        else {        }        // ----- Free local array        unset($v_dirlist_descr);      }    }    // ----- Get the result list    $p_filedescr_list = $v_result_list;    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCreate()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privCreate($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    $v_list_detail = array();    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Open the file in write mode    if (($v_result = $this->privOpenFd('wb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Add the list of files    $v_result = $this->privAddList($p_filedescr_list, $p_result_list, $p_options);    // ----- Close    $this->privCloseFd();    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAdd()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privAdd($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    $v_list_detail = array();    // ----- Look if the archive exists or is empty    if ((!is_file($this->zipname)) || (filesize($this->zipname) == 0))    {      // ----- Do a create      $v_result = $this->privCreate($p_filedescr_list, $p_result_list, $p_options);      // ----- Return      return $v_result;    }    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Open the zip file    if (($v_result=$this->privOpenFd('rb')) != 1)    {      // ----- Magic quotes trick      $this->privSwapBackMagicQuotes();      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privCloseFd();      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Go to beginning of File    @rewind($this->zip_fd);    // ----- Creates a temporay file    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';    // ----- Open the temporary file in write mode    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)    {      $this->privCloseFd();      $this->privSwapBackMagicQuotes();      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_zip_temp_name.'\' in binary write mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Copy the files from the archive to the temporary file    // TBC : Here I should better append the file and go back to erase the central dir    $v_size = $v_central_dir['offset'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($this->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Swap the file descriptor    // Here is a trick : I swap the temporary fd with the zip fd, in order to use    // the following methods on the temporary fil and not the real archive    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Add the files    $v_header_list = array();    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)    {      fclose($v_zip_temp_fd);      $this->privCloseFd();      @unlink($v_zip_temp_name);      $this->privSwapBackMagicQuotes();      // ----- Return      return $v_result;    }    // ----- Store the offset of the central dir    $v_offset = @ftell($this->zip_fd);    // ----- Copy the block of file headers from the old archive    $v_size = $v_central_dir['size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($v_zip_temp_fd, $v_read_size);      @fwrite($this->zip_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Create the Central Dir files header    for ($i=0, $v_count=0; $i<sizeof($v_header_list); $i++)    {      // ----- Create the file header      if ($v_header_list[$i]['status'] == 'ok') {        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {          fclose($v_zip_temp_fd);          $this->privCloseFd();          @unlink($v_zip_temp_name);          $this->privSwapBackMagicQuotes();          // ----- Return          return $v_result;        }        $v_count++;      }      // ----- Transform the header to a 'usable' info      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);    }    // ----- Zip file comment    $v_comment = $v_central_dir['comment'];    if (isset($p_options[PCLZIP_OPT_COMMENT])) {      $v_comment = $p_options[PCLZIP_OPT_COMMENT];    }    if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) {      $v_comment = $v_comment.$p_options[PCLZIP_OPT_ADD_COMMENT];    }    if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) {      $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT].$v_comment;    }    // ----- Calculate the size of the central header    $v_size = @ftell($this->zip_fd)-$v_offset;    // ----- Create the central dir footer    if (($v_result = $this->privWriteCentralHeader($v_count+$v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1)    {      // ----- Reset the file list      unset($v_header_list);      $this->privSwapBackMagicQuotes();      // ----- Return      return $v_result;    }    // ----- Swap back the file descriptor    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Close    $this->privCloseFd();    // ----- Close the temporary file    @fclose($v_zip_temp_fd);    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Delete the zip file    // TBC : I should test the result ...    @unlink($this->zipname);    // ----- Rename the temporary file    // TBC : I should test the result ...    //@rename($v_zip_temp_name, $this->zipname);    PclZipUtilRename($v_zip_temp_name, $this->zipname);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privOpenFd()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privOpenFd($p_mode)  {    $v_result=1;    // ----- Look if already open    if ($this->zip_fd != 0)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \''.$this->zipname.'\' already open');      // ----- Return      return PclZip::errorCode();    }    // ----- Open the zip file    if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in '.$p_mode.' mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCloseFd()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privCloseFd()  {    $v_result=1;    if ($this->zip_fd != 0)      @fclose($this->zip_fd);    $this->zip_fd = 0;    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddList()  // Description :  //   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is  //   different from the real path of the file. This is usefull if you want to have PclTar  //   running in any directory, and memorize relative path from an other directory.  // Parameters :  //   $p_list : An array containing the file or directory names to add in the tar  //   $p_result_list : list of added files with their properties (specially the status field)  //   $p_add_dir : Path to add in the filename path archived  //   $p_remove_dir : Path to remove in the filename path archived  // Return Values :  // --------------------------------------------------------------------------------//  function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)  function privAddList($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    // ----- Add the files    $v_header_list = array();    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)    {      // ----- Return      return $v_result;    }    // ----- Store the offset of the central dir    $v_offset = @ftell($this->zip_fd);    // ----- Create the Central Dir files header    for ($i=0,$v_count=0; $i<sizeof($v_header_list); $i++)    {      // ----- Create the file header      if ($v_header_list[$i]['status'] == 'ok') {        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {          // ----- Return          return $v_result;        }        $v_count++;      }      // ----- Transform the header to a 'usable' info      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);    }    // ----- Zip file comment    $v_comment = '';    if (isset($p_options[PCLZIP_OPT_COMMENT])) {      $v_comment = $p_options[PCLZIP_OPT_COMMENT];    }    // ----- Calculate the size of the central header    $v_size = @ftell($this->zip_fd)-$v_offset;    // ----- Create the central dir footer    if (($v_result = $this->privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1)    {      // ----- Reset the file list      unset($v_header_list);      // ----- Return      return $v_result;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddFileList()  // Description :  // Parameters :  //   $p_filedescr_list : An array containing the file description  //                      or directory names to add in the zip  //   $p_result_list : list of added files with their properties (specially the status field)  // Return Values :  // --------------------------------------------------------------------------------  function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    $v_header = array();    // ----- Recuperate the current number of elt in list    $v_nb = sizeof($p_result_list);    // ----- Loop on the files    for ($j=0; ($j<sizeof($p_filedescr_list)) && ($v_result==1); $j++) {      // ----- Format the filename      $p_filedescr_list[$j]['filename']      = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false);      // ----- Skip empty file names      // TBC : Can this be possible ? not checked in DescrParseAtt ?      if ($p_filedescr_list[$j]['filename'] == "") {        continue;      }      // ----- Check the filename      if (   ($p_filedescr_list[$j]['type'] != 'virtual_file')          && (!file_exists($p_filedescr_list[$j]['filename']))) {        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '".$p_filedescr_list[$j]['filename']."' does not exist");        return PclZip::errorCode();      }      // ----- Look if it is a file or a dir with no all path remove option      // or a dir with all its path removed//      if (   (is_file($p_filedescr_list[$j]['filename']))//          || (   is_dir($p_filedescr_list[$j]['filename'])      if (   ($p_filedescr_list[$j]['type'] == 'file')          || ($p_filedescr_list[$j]['type'] == 'virtual_file')          || (   ($p_filedescr_list[$j]['type'] == 'folder')              && (   !isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])                  || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))          ) {        // ----- Add the file        $v_result = $this->privAddFile($p_filedescr_list[$j], $v_header,                                       $p_options);        if ($v_result != 1) {          return $v_result;        }        // ----- Store the file infos        $p_result_list[$v_nb++] = $v_header;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddFile()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privAddFile($p_filedescr, &$p_header, &$p_options)  {    $v_result=1;    // ----- Working variable    $p_filename = $p_filedescr['filename'];    // TBC : Already done in the fileAtt check ... ?    if ($p_filename == "") {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file list parameter (invalid or empty list)");      // ----- Return      return PclZip::errorCode();    }    // ----- Look for a stored different filename    /* TBC : Removed    if (isset($p_filedescr['stored_filename'])) {      $v_stored_filename = $p_filedescr['stored_filename'];    }    else {      $v_stored_filename = $p_filedescr['stored_filename'];    }    */    // ----- Set the file properties    clearstatcache();    $p_header['version'] = 20;    $p_header['version_extracted'] = 10;    $p_header['flag'] = 0;    $p_header['compression'] = 0;    $p_header['crc'] = 0;    $p_header['compressed_size'] = 0;    $p_header['filename_len'] = strlen($p_filename);    $p_header['extra_len'] = 0;    $p_header['disk'] = 0;    $p_header['internal'] = 0;    $p_header['offset'] = 0;    $p_header['filename'] = $p_filename;// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;    $p_header['stored_filename'] = $p_filedescr['stored_filename'];    $p_header['extra'] = '';    $p_header['status'] = 'ok';    $p_header['index'] = -1;    // ----- Look for regular file    if ($p_filedescr['type']=='file') {      $p_header['external'] = 0x00000000;      $p_header['size'] = filesize($p_filename);    }    // ----- Look for regular folder    else if ($p_filedescr['type']=='folder') {      $p_header['external'] = 0x00000010;      $p_header['mtime'] = filemtime($p_filename);      $p_header['size'] = filesize($p_filename);    }    // ----- Look for virtual file    else if ($p_filedescr['type'] == 'virtual_file') {      $p_header['external'] = 0x00000000;      $p_header['size'] = strlen($p_filedescr['content']);    }    // ----- Look for filetime    if (isset($p_filedescr['mtime'])) {      $p_header['mtime'] = $p_filedescr['mtime'];    }    else if ($p_filedescr['type'] == 'virtual_file') {      $p_header['mtime'] = time();    }    else {      $p_header['mtime'] = filemtime($p_filename);    }    // ------ Look for file comment    if (isset($p_filedescr['comment'])) {      $p_header['comment_len'] = strlen($p_filedescr['comment']);      $p_header['comment'] = $p_filedescr['comment'];    }    else {      $p_header['comment_len'] = 0;      $p_header['comment'] = '';    }    // ----- Look for pre-add callback    if (isset($p_options[PCLZIP_CB_PRE_ADD])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_header, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_header['status'] = "skipped";        $v_result = 1;      }      // ----- Update the informations      // Only some fields can be modified      if ($p_header['stored_filename'] != $v_local_header['stored_filename']) {        $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']);      }    }    // ----- Look for empty stored filename    if ($p_header['stored_filename'] == "") {      $p_header['status'] = "filtered";    }    // ----- Check the path length    if (strlen($p_header['stored_filename']) > 0xFF) {      $p_header['status'] = 'filename_too_long';    }    // ----- Look if no error, or file not skipped    if ($p_header['status'] == 'ok') {      // ----- Look for a file      if ($p_filedescr['type'] == 'file') {        // ----- Look for using temporary file to zip        if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))            && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])                || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])                    && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_header['size'])) ) ) {          $v_result = $this->privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);          if ($v_result < PCLZIP_ERR_NO_ERROR) {            return $v_result;          }        }        // ----- Use "in memory" zip algo        else {        // ----- Open the source file        if (($v_file = @fopen($p_filename, "rb")) == 0) {          PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode");          return PclZip::errorCode();        }        // ----- Read the file content        $v_content = @fread($v_file, $p_header['size']);        // ----- Close the file        @fclose($v_file);        // ----- Calculate the CRC        $p_header['crc'] = @crc32($v_content);        // ----- Look for no compression        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {          // ----- Set header parameters          $p_header['compressed_size'] = $p_header['size'];          $p_header['compression'] = 0;        }        // ----- Look for normal compression        else {          // ----- Compress the content          $v_content = @gzdeflate($v_content);          // ----- Set header parameters          $p_header['compressed_size'] = strlen($v_content);          $p_header['compression'] = 8;        }        // ----- Call the header generation        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {          @fclose($v_file);          return $v_result;        }        // ----- Write the compressed (or not) content        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);        }      }      // ----- Look for a virtual file (a file from string)      else if ($p_filedescr['type'] == 'virtual_file') {        $v_content = $p_filedescr['content'];        // ----- Calculate the CRC        $p_header['crc'] = @crc32($v_content);        // ----- Look for no compression        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {          // ----- Set header parameters          $p_header['compressed_size'] = $p_header['size'];          $p_header['compression'] = 0;        }        // ----- Look for normal compression        else {          // ----- Compress the content          $v_content = @gzdeflate($v_content);          // ----- Set header parameters          $p_header['compressed_size'] = strlen($v_content);          $p_header['compression'] = 8;        }        // ----- Call the header generation        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {          @fclose($v_file);          return $v_result;        }        // ----- Write the compressed (or not) content        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);      }      // ----- Look for a directory      else if ($p_filedescr['type'] == 'folder') {        // ----- Look for directory last '/'        if (@substr($p_header['stored_filename'], -1) != '/') {          $p_header['stored_filename'] .= '/';        }        // ----- Set the file properties        $p_header['size'] = 0;        //$p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked        $p_header['external'] = 0x00000010;   // Value for a folder : to be checked        // ----- Call the header generation        if (($v_result = $this->privWriteFileHeader($p_header)) != 1)        {          return $v_result;        }      }    }    // ----- Look for post-add callback    if (isset($p_options[PCLZIP_CB_POST_ADD])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_header, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);      if ($v_result == 0) {        // ----- Ignored        $v_result = 1;      }      // ----- Update the informations      // Nothing can be modified    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddFileUsingTempFile()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options)  {    $v_result=PCLZIP_ERR_NO_ERROR;    // ----- Working variable    $p_filename = $p_filedescr['filename'];    // ----- Open the source file    if (($v_file = @fopen($p_filename, "rb")) == 0) {      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode");      return PclZip::errorCode();    }    // ----- Creates a compressed temporary file    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';    if (($v_file_compressed = @gzopen($v_gzip_temp_name, "wb")) == 0) {      fclose($v_file);      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary write mode');      return PclZip::errorCode();    }    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    $v_size = filesize($p_filename);    while ($v_size != 0) {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($v_file, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @gzputs($v_file_compressed, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Close the file    @fclose($v_file);    @gzclose($v_file_compressed);    // ----- Check the minimum file size    if (filesize($v_gzip_temp_name) < 18) {      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'gzip temporary file \''.$v_gzip_temp_name.'\' has invalid filesize - should be minimum 18 bytes');      return PclZip::errorCode();    }    // ----- Extract the compressed attributes    if (($v_file_compressed = @fopen($v_gzip_temp_name, "rb")) == 0) {      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');      return PclZip::errorCode();    }    // ----- Read the gzip file header    $v_binary_data = @fread($v_file_compressed, 10);    $v_data_header = unpack('a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os', $v_binary_data);    // ----- Check some parameters    $v_data_header['os'] = bin2hex($v_data_header['os']);    // ----- Read the gzip file footer    @fseek($v_file_compressed, filesize($v_gzip_temp_name)-8);    $v_binary_data = @fread($v_file_compressed, 8);    $v_data_footer = unpack('Vcrc/Vcompressed_size', $v_binary_data);    // ----- Set the attributes    $p_header['compression'] = ord($v_data_header['cm']);    //$p_header['mtime'] = $v_data_header['mtime'];    $p_header['crc'] = $v_data_footer['crc'];    $p_header['compressed_size'] = filesize($v_gzip_temp_name)-18;    // ----- Close the file    @fclose($v_file_compressed);    // ----- Call the header generation    if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {      return $v_result;    }    // ----- Add the compressed data    if (($v_file_compressed = @fopen($v_gzip_temp_name, "rb")) == 0)    {      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');      return PclZip::errorCode();    }    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    fseek($v_file_compressed, 10);    $v_size = $p_header['compressed_size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($v_file_compressed, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @fwrite($this->zip_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Close the file    @fclose($v_file_compressed);    // ----- Unlink the temporary file    @unlink($v_gzip_temp_name);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCalculateStoredFilename()  // Description :  //   Based on file descriptor properties and global options, this method  //   calculate the filename that will be stored in the archive.  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privCalculateStoredFilename(&$p_filedescr, &$p_options)  {    $v_result=1;    // ----- Working variables    $p_filename = $p_filedescr['filename'];    if (isset($p_options[PCLZIP_OPT_ADD_PATH])) {      $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH];    }    else {      $p_add_dir = '';    }    if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) {      $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH];    }    else {      $p_remove_dir = '';    }    if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {      $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH];    }    else {      $p_remove_all_dir = 0;    }    // ----- Look for full name change    if (isset($p_filedescr['new_full_name'])) {      // ----- Remove drive letter if any      $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']);    }    // ----- Look for path and/or short name change    else {      // ----- Look for short name change      // Its when we cahnge just the filename but not the path      if (isset($p_filedescr['new_short_name'])) {        $v_path_info = pathinfo($p_filename);        $v_dir = '';        if ($v_path_info['dirname'] != '') {          $v_dir = $v_path_info['dirname'].'/';        }        $v_stored_filename = $v_dir.$p_filedescr['new_short_name'];      }      else {        // ----- Calculate the stored filename        $v_stored_filename = $p_filename;      }      // ----- Look for all path to remove      if ($p_remove_all_dir) {        $v_stored_filename = basename($p_filename);      }      // ----- Look for partial path remove      else if ($p_remove_dir != "") {        if (substr($p_remove_dir, -1) != '/')          $p_remove_dir .= "/";        if (   (substr($p_filename, 0, 2) == "./")            || (substr($p_remove_dir, 0, 2) == "./")) {          if (   (substr($p_filename, 0, 2) == "./")              && (substr($p_remove_dir, 0, 2) != "./")) {            $p_remove_dir = "./".$p_remove_dir;          }          if (   (substr($p_filename, 0, 2) != "./")              && (substr($p_remove_dir, 0, 2) == "./")) {            $p_remove_dir = substr($p_remove_dir, 2);          }        }        $v_compare = PclZipUtilPathInclusion($p_remove_dir,                                             $v_stored_filename);        if ($v_compare > 0) {          if ($v_compare == 2) {            $v_stored_filename = "";          }          else {            $v_stored_filename = substr($v_stored_filename,                                        strlen($p_remove_dir));          }        }      }      // ----- Remove drive letter if any      $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);      // ----- Look for path to add      if ($p_add_dir != "") {        if (substr($p_add_dir, -1) == "/")          $v_stored_filename = $p_add_dir.$v_stored_filename;        else          $v_stored_filename = $p_add_dir."/".$v_stored_filename;      }    }    // ----- Filename (reduce the path of stored name)    $v_stored_filename = PclZipUtilPathReduction($v_stored_filename);    $p_filedescr['stored_filename'] = $v_stored_filename;    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privWriteFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privWriteFileHeader(&$p_header)  {    $v_result=1;    // ----- Store the offset position of the file    $p_header['offset'] = ftell($this->zip_fd);    // ----- Transform UNIX mtime to DOS format mdate/mtime    $v_date = getdate($p_header['mtime']);    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];    // ----- Packed data    $v_binary_data = pack("VvvvvvVVVvv", 0x04034b50,	                      $p_header['version_extracted'], $p_header['flag'],                          $p_header['compression'], $v_mtime, $v_mdate,                          $p_header['crc'], $p_header['compressed_size'],						  $p_header['size'],                          strlen($p_header['stored_filename']),						  $p_header['extra_len']);    // ----- Write the first 148 bytes of the header in the archive    fputs($this->zip_fd, $v_binary_data, 30);    // ----- Write the variable fields    if (strlen($p_header['stored_filename']) != 0)    {      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));    }    if ($p_header['extra_len'] != 0)    {      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privWriteCentralFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privWriteCentralFileHeader(&$p_header)  {    $v_result=1;    // TBC    //for(reset($p_header); $key = key($p_header); next($p_header)) {    //}    // ----- Transform UNIX mtime to DOS format mdate/mtime    $v_date = getdate($p_header['mtime']);    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];    // ----- Packed data    $v_binary_data = pack("VvvvvvvVVVvvvvvVV", 0x02014b50,	                      $p_header['version'], $p_header['version_extracted'],                          $p_header['flag'], $p_header['compression'],						  $v_mtime, $v_mdate, $p_header['crc'],                          $p_header['compressed_size'], $p_header['size'],                          strlen($p_header['stored_filename']),						  $p_header['extra_len'], $p_header['comment_len'],                          $p_header['disk'], $p_header['internal'],						  $p_header['external'], $p_header['offset']);    // ----- Write the 42 bytes of the header in the zip file    fputs($this->zip_fd, $v_binary_data, 46);    // ----- Write the variable fields    if (strlen($p_header['stored_filename']) != 0)    {      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));    }    if ($p_header['extra_len'] != 0)    {      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);    }    if ($p_header['comment_len'] != 0)    {      fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']);    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privWriteCentralHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment)  {    $v_result=1;    // ----- Packed data    $v_binary_data = pack("VvvvvVVv", 0x06054b50, 0, 0, $p_nb_entries,	                      $p_nb_entries, $p_size,						  $p_offset, strlen($p_comment));    // ----- Write the 22 bytes of the header in the zip file    fputs($this->zip_fd, $v_binary_data, 22);    // ----- Write the variable fields    if (strlen($p_comment) != 0)    {      fputs($this->zip_fd, $p_comment, strlen($p_comment));    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privList()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privList(&$p_list)  {    $v_result=1;    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Open the zip file    if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)    {      // ----- Magic quotes trick      $this->privSwapBackMagicQuotes();      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in binary read mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Go to beginning of Central Dir    @rewind($this->zip_fd);    if (@fseek($this->zip_fd, $v_central_dir['offset']))    {      $this->privSwapBackMagicQuotes();      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');      // ----- Return      return PclZip::errorCode();    }    // ----- Read each entry    for ($i=0; $i<$v_central_dir['entries']; $i++)    {      // ----- Read the file header      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)      {        $this->privSwapBackMagicQuotes();        return $v_result;      }      $v_header['index'] = $i;      // ----- Get the only interesting attributes      $this->privConvertHeader2FileInfo($v_header, $p_list[$i]);      unset($v_header);    }    // ----- Close the zip file    $this->privCloseFd();    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privConvertHeader2FileInfo()  // Description :  //   This function takes the file informations from the central directory  //   entries and extract the interesting parameters that will be given back.  //   The resulting file infos are set in the array $p_info  //     $p_info['filename'] : Filename with full path. Given by user (add),  //                           extracted in the filesystem (extract).  //     $p_info['stored_filename'] : Stored filename in the archive.  //     $p_info['size'] = Size of the file.  //     $p_info['compressed_size'] = Compressed size of the file.  //     $p_info['mtime'] = Last modification date of the file.  //     $p_info['comment'] = Comment associated with the file.  //     $p_info['folder'] = true/false : indicates if the entry is a folder or not.  //     $p_info['status'] = status of the action on the file.  //     $p_info['crc'] = CRC of the file content.  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privConvertHeader2FileInfo($p_header, &$p_info)  {    $v_result=1;    // ----- Get the interesting attributes    $v_temp_path = PclZipUtilPathReduction($p_header['filename']);    $p_info['filename'] = $v_temp_path;    $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']);    $p_info['stored_filename'] = $v_temp_path;    $p_info['size'] = $p_header['size'];    $p_info['compressed_size'] = $p_header['compressed_size'];    $p_info['mtime'] = $p_header['mtime'];    $p_info['comment'] = $p_header['comment'];    $p_info['folder'] = (($p_header['external']&0x00000010)==0x00000010);    $p_info['index'] = $p_header['index'];    $p_info['status'] = $p_header['status'];    $p_info['crc'] = $p_header['crc'];    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractByRule()  // Description :  //   Extract a file or directory depending of rules (by index, by name, ...)  // Parameters :  //   $p_file_list : An array where will be placed the properties of each  //                  extracted file  //   $p_path : Path to add while writing the extracted files  //   $p_remove_path : Path to remove (from the file memorized path) while writing the  //                    extracted files. If the path does not match the file path,  //                    the file is extracted with its memorized path.  //                    $p_remove_path does not apply to 'list' mode.  //                    $p_path and $p_remove_path are commulative.  // Return Values :  //   1 on success,0 or less on error (see error code list)  // --------------------------------------------------------------------------------  function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)  {    $v_result=1;    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Check the path    if (   ($p_path == "")	    || (   (substr($p_path, 0, 1) != "/")		    && (substr($p_path, 0, 3) != "../")			&& (substr($p_path,1,2)!=":/")))      $p_path = "./".$p_path;    // ----- Reduce the path last (and duplicated) '/'    if (($p_path != "./") && ($p_path != "/"))    {      // ----- Look for the path end '/'      while (substr($p_path, -1) == "/")      {        $p_path = substr($p_path, 0, strlen($p_path)-1);      }    }    // ----- Look for path to remove format (should end by /)    if (($p_remove_path != "") && (substr($p_remove_path, -1) != '/'))    {      $p_remove_path .= '/';    }    $p_remove_path_size = strlen($p_remove_path);    // ----- Open the zip file    if (($v_result = $this->privOpenFd('rb')) != 1)    {      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      // ----- Close the zip file      $this->privCloseFd();      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Start at beginning of Central Dir    $v_pos_entry = $v_central_dir['offset'];    // ----- Read each entry    $j_start = 0;    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)    {      // ----- Read next Central dir entry      @rewind($this->zip_fd);      if (@fseek($this->zip_fd, $v_pos_entry))      {        // ----- Close the zip file        $this->privCloseFd();        $this->privSwapBackMagicQuotes();        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');        // ----- Return        return PclZip::errorCode();      }      // ----- Read the file header      $v_header = array();      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)      {        // ----- Close the zip file        $this->privCloseFd();        $this->privSwapBackMagicQuotes();        return $v_result;      }      // ----- Store the index      $v_header['index'] = $i;      // ----- Store the file position      $v_pos_entry = ftell($this->zip_fd);      // ----- Look for the specific extract rules      $v_extract = false;      // ----- Look for extract by name rule      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {          // ----- Look if the filename is in the list          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {              // ----- Look for a directory              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == "/") {                  // ----- Look if the directory is in the filename path                  if (   (strlen($v_header['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))                      && (substr($v_header['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {                      $v_extract = true;                  }              }              // ----- Look for a filename              elseif ($v_header['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {                  $v_extract = true;              }          }      }      // ----- Look for extract by ereg rule      // ereg() is deprecated with PHP 5.3      /*      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))               && ($p_options[PCLZIP_OPT_BY_EREG] != "")) {          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header['stored_filename'])) {              $v_extract = true;          }      }      */      // ----- Look for extract by preg rule      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))               && ($p_options[PCLZIP_OPT_BY_PREG] != "")) {          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header['stored_filename'])) {              $v_extract = true;          }      }      // ----- Look for extract by index rule      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {          // ----- Look if the index is in the list          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {                  $v_extract = true;              }              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {                  $j_start = $j+1;              }              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {                  break;              }          }      }      // ----- Look for no rule, which means extract all the archive      else {          $v_extract = true;      }	  // ----- Check compression method	  if (   ($v_extract)	      && (   ($v_header['compression'] != 8)		      && ($v_header['compression'] != 0))) {          $v_header['status'] = 'unsupported_compression';          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		      && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {              $this->privSwapBackMagicQuotes();              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION,			                       "Filename '".$v_header['stored_filename']."' is "				  	    	  	   ."compressed by an unsupported compression "				  	    	  	   ."method (".$v_header['compression'].") ");              return PclZip::errorCode();		  }	  }	  // ----- Check encrypted files	  if (($v_extract) && (($v_header['flag'] & 1) == 1)) {          $v_header['status'] = 'unsupported_encryption';          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		      && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {              $this->privSwapBackMagicQuotes();              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION,			                       "Unsupported encryption for "				  	    	  	   ." filename '".$v_header['stored_filename']								   ."'");              return PclZip::errorCode();		  }    }      // ----- Look for real extraction      if (($v_extract) && ($v_header['status'] != 'ok')) {          $v_result = $this->privConvertHeader2FileInfo($v_header,		                                        $p_file_list[$v_nb_extracted++]);          if ($v_result != 1) {              $this->privCloseFd();              $this->privSwapBackMagicQuotes();              return $v_result;          }          $v_extract = false;      }      // ----- Look for real extraction      if ($v_extract)      {        // ----- Go to the file position        @rewind($this->zip_fd);        if (@fseek($this->zip_fd, $v_header['offset']))        {          // ----- Close the zip file          $this->privCloseFd();          $this->privSwapBackMagicQuotes();          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');          // ----- Return          return PclZip::errorCode();        }        // ----- Look for extraction as string        if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {          $v_string = '';          // ----- Extracting the file          $v_result1 = $this->privExtractFileAsString($v_header, $v_string, $p_options);          if ($v_result1 < 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result1;          }          // ----- Get the only interesting attributes          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1)          {            // ----- Close the zip file            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result;          }          // ----- Set the file content          $p_file_list[$v_nb_extracted]['content'] = $v_string;          // ----- Next extracted file          $v_nb_extracted++;          // ----- Look for user callback abort          if ($v_result1 == 2) {          	break;          }        }        // ----- Look for extraction in standard output        elseif (   (isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT]))		        && ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {          // ----- Extracting the file in standard output          $v_result1 = $this->privExtractFileInOutput($v_header, $p_options);          if ($v_result1 < 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result1;          }          // ----- Get the only interesting attributes          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result;          }          // ----- Look for user callback abort          if ($v_result1 == 2) {          	break;          }        }        // ----- Look for normal extraction        else {          // ----- Extracting the file          $v_result1 = $this->privExtractFile($v_header,		                                      $p_path, $p_remove_path,											  $p_remove_all_path,											  $p_options);          if ($v_result1 < 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result1;          }          // ----- Get the only interesting attributes          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1)          {            // ----- Close the zip file            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result;          }          // ----- Look for user callback abort          if ($v_result1 == 2) {          	break;          }        }      }    }    // ----- Close the zip file    $this->privCloseFd();    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFile()  // Description :  // Parameters :  // Return Values :  //  // 1 : ... ?  // PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback  // --------------------------------------------------------------------------------  function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)  {    $v_result=1;    // ----- Read the file header    if (($v_result = $this->privReadFileHeader($v_header)) != 1)    {      // ----- Return      return $v_result;    }    // ----- Check that the file header is coherent with $p_entry info    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {        // TBC    }    // ----- Look for all path to remove    if ($p_remove_all_path == true) {        // ----- Look for folder entry that not need to be extracted        if (($p_entry['external']&0x00000010)==0x00000010) {            $p_entry['status'] = "filtered";            return $v_result;        }        // ----- Get the basename of the path        $p_entry['filename'] = basename($p_entry['filename']);    }    // ----- Look for path to remove    else if ($p_remove_path != "")    {      if (PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2)      {        // ----- Change the file status        $p_entry['status'] = "filtered";        // ----- Return        return $v_result;      }      $p_remove_path_size = strlen($p_remove_path);      if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path)      {        // ----- Remove the path        $p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);      }    }    // ----- Add the path    if ($p_path != '') {      $p_entry['filename'] = $p_path."/".$p_entry['filename'];    }    // ----- Check a base_dir_restriction    if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {      $v_inclusion      = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION],                                $p_entry['filename']);      if ($v_inclusion == 0) {        PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION,			                     "Filename '".$p_entry['filename']."' is "								 ."outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION");        return PclZip::errorCode();      }    }    // ----- Look for pre-extract callback    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_entry['status'] = "skipped";        $v_result = 1;      }      // ----- Look for abort result      if ($v_result == 2) {        // ----- This status is internal and will be changed in 'skipped'        $p_entry['status'] = "aborted";      	$v_result = PCLZIP_ERR_USER_ABORTED;      }      // ----- Update the informations      // Only some fields can be modified      $p_entry['filename'] = $v_local_header['filename'];    }    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {    // ----- Look for specific actions while the file exist    if (file_exists($p_entry['filename']))    {      // ----- Look if file is a directory      if (is_dir($p_entry['filename']))      {        // ----- Change the file status        $p_entry['status'] = "already_a_directory";        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR        // For historical reason first PclZip implementation does not stop        // when this kind of error occurs.        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		    && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {            PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY,			                     "Filename '".$p_entry['filename']."' is "								 ."already used by an existing directory");            return PclZip::errorCode();		    }      }      // ----- Look if file is write protected      else if (!is_writeable($p_entry['filename']))      {        // ----- Change the file status        $p_entry['status'] = "write_protected";        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR        // For historical reason first PclZip implementation does not stop        // when this kind of error occurs.        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		    && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,			                     "Filename '".$p_entry['filename']."' exists "								 ."and is write protected");            return PclZip::errorCode();		    }      }      // ----- Look if the extracted file is older      else if (filemtime($p_entry['filename']) > $p_entry['mtime'])      {        // ----- Change the file status        if (   (isset($p_options[PCLZIP_OPT_REPLACE_NEWER]))		    && ($p_options[PCLZIP_OPT_REPLACE_NEWER]===true)) {	  	  }		    else {            $p_entry['status'] = "newer_exist";            // ----- Look for PCLZIP_OPT_STOP_ON_ERROR            // For historical reason first PclZip implementation does not stop            // when this kind of error occurs.            if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		        && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {                PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,			             "Newer version of '".$p_entry['filename']."' exists "					    ."and option PCLZIP_OPT_REPLACE_NEWER is not selected");                return PclZip::errorCode();		      }		    }      }      else {      }    }    // ----- Check the directory availability and create it if necessary    else {      if ((($p_entry['external']&0x00000010)==0x00000010) || (substr($p_entry['filename'], -1) == '/'))        $v_dir_to_check = $p_entry['filename'];      else if (!strstr($p_entry['filename'], "/"))        $v_dir_to_check = "";      else        $v_dir_to_check = dirname($p_entry['filename']);        if (($v_result = $this->privDirCheck($v_dir_to_check, (($p_entry['external']&0x00000010)==0x00000010))) != 1) {          // ----- Change the file status          $p_entry['status'] = "path_creation_fail";          // ----- Return          //return $v_result;          $v_result = 1;        }      }    }    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {      // ----- Do the extraction (if not a folder)      if (!(($p_entry['external']&0x00000010)==0x00000010))      {        // ----- Look for not compressed file        if ($p_entry['compression'] == 0) {    		  // ----- Opening destination file          if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0)          {            // ----- Change the file status            $p_entry['status'] = "write_error";            // ----- Return            return $v_result;          }          // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks          $v_size = $p_entry['compressed_size'];          while ($v_size != 0)          {            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);            $v_buffer = @fread($this->zip_fd, $v_read_size);            /* Try to speed up the code            $v_binary_data = pack('a'.$v_read_size, $v_buffer);            @fwrite($v_dest_file, $v_binary_data, $v_read_size);            */            @fwrite($v_dest_file, $v_buffer, $v_read_size);            $v_size -= $v_read_size;          }          // ----- Closing the destination file          fclose($v_dest_file);          // ----- Change the file mtime          touch($p_entry['filename'], $p_entry['mtime']);        }        else {          // ----- TBC          // Need to be finished          if (($p_entry['flag'] & 1) == 1) {            PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, 'File \''.$p_entry['filename'].'\' is encrypted. Encrypted files are not supported.');            return PclZip::errorCode();          }          // ----- Look for using temporary file to unzip          if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))              && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])                  || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])                      && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_entry['size'])) ) ) {            $v_result = $this->privExtractFileUsingTempFile($p_entry, $p_options);            if ($v_result < PCLZIP_ERR_NO_ERROR) {              return $v_result;            }          }          // ----- Look for extract in memory          else {            // ----- Read the compressed file in a buffer (one shot)            $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);            // ----- Decompress the file            $v_file_content = @gzinflate($v_buffer);            unset($v_buffer);            if ($v_file_content === FALSE) {              // ----- Change the file status              // TBC              $p_entry['status'] = "error";              return $v_result;            }            // ----- Opening destination file            if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {              // ----- Change the file status              $p_entry['status'] = "write_error";              return $v_result;            }            // ----- Write the uncompressed data            @fwrite($v_dest_file, $v_file_content, $p_entry['size']);            unset($v_file_content);            // ----- Closing the destination file            @fclose($v_dest_file);          }          // ----- Change the file mtime          @touch($p_entry['filename'], $p_entry['mtime']);        }        // ----- Look for chmod option        if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {          // ----- Change the mode of the file          @chmod($p_entry['filename'], $p_options[PCLZIP_OPT_SET_CHMOD]);        }      }    }  	// ----- Change abort status  	if ($p_entry['status'] == "aborted") {        $p_entry['status'] = "skipped";  	}    // ----- Look for post-extract callback    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);      // ----- Look for abort result      if ($v_result == 2) {      	$v_result = PCLZIP_ERR_USER_ABORTED;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFileUsingTempFile()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privExtractFileUsingTempFile(&$p_entry, &$p_options)  {    $v_result=1;    // ----- Creates a temporary file    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';    if (($v_dest_file = @fopen($v_gzip_temp_name, "wb")) == 0) {      fclose($v_file);      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary write mode');      return PclZip::errorCode();    }    // ----- Write gz file format header    $v_binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($p_entry['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));    @fwrite($v_dest_file, $v_binary_data, 10);    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    $v_size = $p_entry['compressed_size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($this->zip_fd, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @fwrite($v_dest_file, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Write gz file format footer    $v_binary_data = pack('VV', $p_entry['crc'], $p_entry['size']);    @fwrite($v_dest_file, $v_binary_data, 8);    // ----- Close the temporary file    @fclose($v_dest_file);    // ----- Opening destination file    if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {      $p_entry['status'] = "write_error";      return $v_result;    }    // ----- Open the temporary gz file    if (($v_src_file = @gzopen($v_gzip_temp_name, 'rb')) == 0) {      @fclose($v_dest_file);      $p_entry['status'] = "read_error";      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');      return PclZip::errorCode();    }    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    $v_size = $p_entry['size'];    while ($v_size != 0) {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @gzread($v_src_file, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @fwrite($v_dest_file, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    @fclose($v_dest_file);    @gzclose($v_src_file);    // ----- Delete the temporary file    @unlink($v_gzip_temp_name);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFileInOutput()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privExtractFileInOutput(&$p_entry, &$p_options)  {    $v_result=1;    // ----- Read the file header    if (($v_result = $this->privReadFileHeader($v_header)) != 1) {      return $v_result;    }    // ----- Check that the file header is coherent with $p_entry info    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {        // TBC    }    // ----- Look for pre-extract callback    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_entry['status'] = "skipped";        $v_result = 1;      }      // ----- Look for abort result      if ($v_result == 2) {        // ----- This status is internal and will be changed in 'skipped'        $p_entry['status'] = "aborted";      	$v_result = PCLZIP_ERR_USER_ABORTED;      }      // ----- Update the informations      // Only some fields can be modified      $p_entry['filename'] = $v_local_header['filename'];    }    // ----- Trace    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {      // ----- Do the extraction (if not a folder)      if (!(($p_entry['external']&0x00000010)==0x00000010)) {        // ----- Look for not compressed file        if ($p_entry['compressed_size'] == $p_entry['size']) {          // ----- Read the file in a buffer (one shot)          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);          // ----- Send the file to the output          echo $v_buffer;          unset($v_buffer);        }        else {          // ----- Read the compressed file in a buffer (one shot)          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);          // ----- Decompress the file          $v_file_content = gzinflate($v_buffer);          unset($v_buffer);          // ----- Send the file to the output          echo $v_file_content;          unset($v_file_content);        }      }    }	// ----- Change abort status	if ($p_entry['status'] == "aborted") {      $p_entry['status'] = "skipped";	}    // ----- Look for post-extract callback    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);      // ----- Look for abort result      if ($v_result == 2) {      	$v_result = PCLZIP_ERR_USER_ABORTED;      }    }    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFileAsString()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privExtractFileAsString(&$p_entry, &$p_string, &$p_options)  {    $v_result=1;    // ----- Read the file header    $v_header = array();    if (($v_result = $this->privReadFileHeader($v_header)) != 1)    {      // ----- Return      return $v_result;    }    // ----- Check that the file header is coherent with $p_entry info    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {        // TBC    }    // ----- Look for pre-extract callback    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_entry['status'] = "skipped";        $v_result = 1;      }      // ----- Look for abort result      if ($v_result == 2) {        // ----- This status is internal and will be changed in 'skipped'        $p_entry['status'] = "aborted";      	$v_result = PCLZIP_ERR_USER_ABORTED;      }      // ----- Update the informations      // Only some fields can be modified      $p_entry['filename'] = $v_local_header['filename'];    }    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {      // ----- Do the extraction (if not a folder)      if (!(($p_entry['external']&0x00000010)==0x00000010)) {        // ----- Look for not compressed file  //      if ($p_entry['compressed_size'] == $p_entry['size'])        if ($p_entry['compression'] == 0) {          // ----- Reading the file          $p_string = @fread($this->zip_fd, $p_entry['compressed_size']);        }        else {          // ----- Reading the file          $v_data = @fread($this->zip_fd, $p_entry['compressed_size']);          // ----- Decompress the file          if (($p_string = @gzinflate($v_data)) === FALSE) {              // TBC          }        }        // ----- Trace      }      else {          // TBC : error : can not extract a folder in a string      }    }  	// ----- Change abort status  	if ($p_entry['status'] == "aborted") {        $p_entry['status'] = "skipped";  	}    // ----- Look for post-extract callback    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Swap the content to header      $v_local_header['content'] = $p_string;      $p_string = '';      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);      // ----- Swap back the content to header      $p_string = $v_local_header['content'];      unset($v_local_header['content']);      // ----- Look for abort result      if ($v_result == 2) {      	$v_result = PCLZIP_ERR_USER_ABORTED;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privReadFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privReadFileHeader(&$p_header)  {    $v_result=1;    // ----- Read the 4 bytes signature    $v_binary_data = @fread($this->zip_fd, 4);    $v_data = unpack('Vid', $v_binary_data);    // ----- Check signature    if ($v_data['id'] != 0x04034b50)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');      // ----- Return      return PclZip::errorCode();    }    // ----- Read the first 42 bytes of the header    $v_binary_data = fread($this->zip_fd, 26);    // ----- Look for invalid block size    if (strlen($v_binary_data) != 26)    {      $p_header['filename'] = "";      $p_header['status'] = "invalid_header";      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : ".strlen($v_binary_data));      // ----- Return      return PclZip::errorCode();    }    // ----- Extract the values    $v_data = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);    // ----- Get filename    $p_header['filename'] = fread($this->zip_fd, $v_data['filename_len']);    // ----- Get extra_fields    if ($v_data['extra_len'] != 0) {      $p_header['extra'] = fread($this->zip_fd, $v_data['extra_len']);    }    else {      $p_header['extra'] = '';    }    // ----- Extract properties    $p_header['version_extracted'] = $v_data['version'];    $p_header['compression'] = $v_data['compression'];    $p_header['size'] = $v_data['size'];    $p_header['compressed_size'] = $v_data['compressed_size'];    $p_header['crc'] = $v_data['crc'];    $p_header['flag'] = $v_data['flag'];    $p_header['filename_len'] = $v_data['filename_len'];    // ----- Recuperate date in UNIX format    $p_header['mdate'] = $v_data['mdate'];    $p_header['mtime'] = $v_data['mtime'];    if ($p_header['mdate'] && $p_header['mtime'])    {      // ----- Extract time      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;      $v_seconde = ($p_header['mtime'] & 0x001F)*2;      // ----- Extract date      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;      $v_day = $p_header['mdate'] & 0x001F;      // ----- Get UNIX date format      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);    }    else    {      $p_header['mtime'] = time();    }    // TBC    //for(reset($v_data); $key = key($v_data); next($v_data)) {    //}    // ----- Set the stored filename    $p_header['stored_filename'] = $p_header['filename'];    // ----- Set the status field    $p_header['status'] = "ok";    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privReadCentralFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privReadCentralFileHeader(&$p_header)  {    $v_result=1;    // ----- Read the 4 bytes signature    $v_binary_data = @fread($this->zip_fd, 4);    $v_data = unpack('Vid', $v_binary_data);    // ----- Check signature    if ($v_data['id'] != 0x02014b50)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');      // ----- Return      return PclZip::errorCode();    }    // ----- Read the first 42 bytes of the header    $v_binary_data = fread($this->zip_fd, 42);    // ----- Look for invalid block size    if (strlen($v_binary_data) != 42)    {      $p_header['filename'] = "";      $p_header['status'] = "invalid_header";      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : ".strlen($v_binary_data));      // ----- Return      return PclZip::errorCode();    }    // ----- Extract the values    $p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);    // ----- Get filename    if ($p_header['filename_len'] != 0)      $p_header['filename'] = fread($this->zip_fd, $p_header['filename_len']);    else      $p_header['filename'] = '';    // ----- Get extra    if ($p_header['extra_len'] != 0)      $p_header['extra'] = fread($this->zip_fd, $p_header['extra_len']);    else      $p_header['extra'] = '';    // ----- Get comment    if ($p_header['comment_len'] != 0)      $p_header['comment'] = fread($this->zip_fd, $p_header['comment_len']);    else      $p_header['comment'] = '';    // ----- Extract properties    // ----- Recuperate date in UNIX format    //if ($p_header['mdate'] && $p_header['mtime'])    // TBC : bug : this was ignoring time with 0/0/0    if (1)    {      // ----- Extract time      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;      $v_seconde = ($p_header['mtime'] & 0x001F)*2;      // ----- Extract date      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;      $v_day = $p_header['mdate'] & 0x001F;      // ----- Get UNIX date format      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);    }    else    {      $p_header['mtime'] = time();    }    // ----- Set the stored filename    $p_header['stored_filename'] = $p_header['filename'];    // ----- Set default status to ok    $p_header['status'] = 'ok';    // ----- Look if it is a directory    if (substr($p_header['filename'], -1) == '/') {      //$p_header['external'] = 0x41FF0010;      $p_header['external'] = 0x00000010;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCheckFileHeaders()  // Description :  // Parameters :  // Return Values :  //   1 on success,  //   0 on error;  // --------------------------------------------------------------------------------  function privCheckFileHeaders(&$p_local_header, &$p_central_header)  {    $v_result=1;  	// ----- Check the static values  	// TBC  	if ($p_local_header['filename'] != $p_central_header['filename']) {  	}  	if ($p_local_header['version_extracted'] != $p_central_header['version_extracted']) {  	}  	if ($p_local_header['flag'] != $p_central_header['flag']) {  	}  	if ($p_local_header['compression'] != $p_central_header['compression']) {  	}  	if ($p_local_header['mtime'] != $p_central_header['mtime']) {  	}  	if ($p_local_header['filename_len'] != $p_central_header['filename_len']) {  	}  	// ----- Look for flag bit 3  	if (($p_local_header['flag'] & 8) == 8) {          $p_local_header['size'] = $p_central_header['size'];          $p_local_header['compressed_size'] = $p_central_header['compressed_size'];          $p_local_header['crc'] = $p_central_header['crc'];  	}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privReadEndCentralDir()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privReadEndCentralDir(&$p_central_dir)  {    $v_result=1;    // ----- Go to the end of the zip file    $v_size = filesize($this->zipname);    @fseek($this->zip_fd, $v_size);    if (@ftell($this->zip_fd) != $v_size)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \''.$this->zipname.'\'');      // ----- Return      return PclZip::errorCode();    }    // ----- First try : look if this is an archive with no commentaries (most of the time)    // in this case the end of central dir is at 22 bytes of the file end    $v_found = 0;    if ($v_size > 26) {      @fseek($this->zip_fd, $v_size-22);      if (($v_pos = @ftell($this->zip_fd)) != ($v_size-22))      {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\'');        // ----- Return        return PclZip::errorCode();      }      // ----- Read for bytes      $v_binary_data = @fread($this->zip_fd, 4);      $v_data = @unpack('Vid', $v_binary_data);      // ----- Check signature      if ($v_data['id'] == 0x06054b50) {        $v_found = 1;      }      $v_pos = ftell($this->zip_fd);    }    // ----- Go back to the maximum possible size of the Central Dir End Record    if (!$v_found) {      $v_maximum_size = 65557; // 0xFFFF + 22;      if ($v_maximum_size > $v_size)        $v_maximum_size = $v_size;      @fseek($this->zip_fd, $v_size-$v_maximum_size);      if (@ftell($this->zip_fd) != ($v_size-$v_maximum_size))      {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\'');        // ----- Return        return PclZip::errorCode();      }      // ----- Read byte per byte in order to find the signature      $v_pos = ftell($this->zip_fd);      $v_bytes = 0x00000000;      while ($v_pos < $v_size)      {        // ----- Read a byte        $v_byte = @fread($this->zip_fd, 1);        // -----  Add the byte        //$v_bytes = ($v_bytes << 8) | Ord($v_byte);        // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number        // Otherwise on systems where we have 64bit integers the check below for the magic number will fail.        $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte);        // ----- Compare the bytes        if ($v_bytes == 0x504b0506)        {          $v_pos++;          break;        }        $v_pos++;      }      // ----- Look if not found end of central dir      if ($v_pos == $v_size)      {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Unable to find End of Central Dir Record signature");        // ----- Return        return PclZip::errorCode();      }    }    // ----- Read the first 18 bytes of the header    $v_binary_data = fread($this->zip_fd, 18);    // ----- Look for invalid block size    if (strlen($v_binary_data) != 18)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid End of Central Dir Record size : ".strlen($v_binary_data));      // ----- Return      return PclZip::errorCode();    }    // ----- Extract the values    $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);    // ----- Check the global size    if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {	  // ----- Removed in release 2.2 see readme file	  // The check of the file size is a little too strict.	  // Some bugs where found when a zip is encrypted/decrypted with 'crypt'.	  // While decrypted, zip has training 0 bytes	  if (0) {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT,	                       'The central dir is not at the end of the archive.'						   .' Some trailing bytes exists after the archive.');      // ----- Return      return PclZip::errorCode();	  }    }    // ----- Get comment    if ($v_data['comment_size'] != 0) {      $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);    }    else      $p_central_dir['comment'] = '';    $p_central_dir['entries'] = $v_data['entries'];    $p_central_dir['disk_entries'] = $v_data['disk_entries'];    $p_central_dir['offset'] = $v_data['offset'];    $p_central_dir['size'] = $v_data['size'];    $p_central_dir['disk'] = $v_data['disk'];    $p_central_dir['disk_start'] = $v_data['disk_start'];    // TBC    //for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {    //}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDeleteByRule()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privDeleteByRule(&$p_result_list, &$p_options)  {    $v_result=1;    $v_list_detail = array();    // ----- Open the zip file    if (($v_result=$this->privOpenFd('rb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privCloseFd();      return $v_result;    }    // ----- Go to beginning of File    @rewind($this->zip_fd);    // ----- Scan all the files    // ----- Start at beginning of Central Dir    $v_pos_entry = $v_central_dir['offset'];    @rewind($this->zip_fd);    if (@fseek($this->zip_fd, $v_pos_entry))    {      // ----- Close the zip file      $this->privCloseFd();      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');      // ----- Return      return PclZip::errorCode();    }    // ----- Read each entry    $v_header_list = array();    $j_start = 0;    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)    {      // ----- Read the file header      $v_header_list[$v_nb_extracted] = array();      if (($v_result = $this->privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1)      {        // ----- Close the zip file        $this->privCloseFd();        return $v_result;      }      // ----- Store the index      $v_header_list[$v_nb_extracted]['index'] = $i;      // ----- Look for the specific extract rules      $v_found = false;      // ----- Look for extract by name rule      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {          // ----- Look if the filename is in the list          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_found); $j++) {              // ----- Look for a directory              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == "/") {                  // ----- Look if the directory is in the filename path                  if (   (strlen($v_header_list[$v_nb_extracted]['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))                      && (substr($v_header_list[$v_nb_extracted]['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {                      $v_found = true;                  }                  elseif (   (($v_header_list[$v_nb_extracted]['external']&0x00000010)==0x00000010) /* Indicates a folder */                          && ($v_header_list[$v_nb_extracted]['stored_filename'].'/' == $p_options[PCLZIP_OPT_BY_NAME][$j])) {                      $v_found = true;                  }              }              // ----- Look for a filename              elseif ($v_header_list[$v_nb_extracted]['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {                  $v_found = true;              }          }      }      // ----- Look for extract by ereg rule      // ereg() is deprecated with PHP 5.3      /*      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))               && ($p_options[PCLZIP_OPT_BY_EREG] != "")) {          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {              $v_found = true;          }      }      */      // ----- Look for extract by preg rule      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))               && ($p_options[PCLZIP_OPT_BY_PREG] != "")) {          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {              $v_found = true;          }      }      // ----- Look for extract by index rule      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {          // ----- Look if the index is in the list          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_found); $j++) {              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {                  $v_found = true;              }              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {                  $j_start = $j+1;              }              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {                  break;              }          }      }      else {      	$v_found = true;      }      // ----- Look for deletion      if ($v_found)      {        unset($v_header_list[$v_nb_extracted]);      }      else      {        $v_nb_extracted++;      }    }    // ----- Look if something need to be deleted    if ($v_nb_extracted > 0) {        // ----- Creates a temporay file        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';        // ----- Creates a temporary zip archive        $v_temp_zip = new PclZip($v_zip_temp_name);        // ----- Open the temporary zip file in write mode        if (($v_result = $v_temp_zip->privOpenFd('wb')) != 1) {            $this->privCloseFd();            // ----- Return            return $v_result;        }        // ----- Look which file need to be kept        for ($i=0; $i<sizeof($v_header_list); $i++) {            // ----- Calculate the position of the header            @rewind($this->zip_fd);            if (@fseek($this->zip_fd,  $v_header_list[$i]['offset'])) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Error log                PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');                // ----- Return                return PclZip::errorCode();            }            // ----- Read the file header            $v_local_header = array();            if (($v_result = $this->privReadFileHeader($v_local_header)) != 1) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }            // ----- Check that local file header is same as central file header            if ($this->privCheckFileHeaders($v_local_header,			                                $v_header_list[$i]) != 1) {                // TBC            }            unset($v_local_header);            // ----- Write the file header            if (($v_result = $v_temp_zip->privWriteFileHeader($v_header_list[$i])) != 1) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }            // ----- Read/write the data block            if (($v_result = PclZipUtilCopyBlock($this->zip_fd, $v_temp_zip->zip_fd, $v_header_list[$i]['compressed_size'])) != 1) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }        }        // ----- Store the offset of the central dir        $v_offset = @ftell($v_temp_zip->zip_fd);        // ----- Re-Create the Central Dir files header        for ($i=0; $i<sizeof($v_header_list); $i++) {            // ----- Create the file header            if (($v_result = $v_temp_zip->privWriteCentralFileHeader($v_header_list[$i])) != 1) {                $v_temp_zip->privCloseFd();                $this->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }            // ----- Transform the header to a 'usable' info            $v_temp_zip->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);        }        // ----- Zip file comment        $v_comment = '';        if (isset($p_options[PCLZIP_OPT_COMMENT])) {          $v_comment = $p_options[PCLZIP_OPT_COMMENT];        }        // ----- Calculate the size of the central header        $v_size = @ftell($v_temp_zip->zip_fd)-$v_offset;        // ----- Create the central dir footer        if (($v_result = $v_temp_zip->privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) {            // ----- Reset the file list            unset($v_header_list);            $v_temp_zip->privCloseFd();            $this->privCloseFd();            @unlink($v_zip_temp_name);            // ----- Return            return $v_result;        }        // ----- Close        $v_temp_zip->privCloseFd();        $this->privCloseFd();        // ----- Delete the zip file        // TBC : I should test the result ...        @unlink($this->zipname);        // ----- Rename the temporary file        // TBC : I should test the result ...        //@rename($v_zip_temp_name, $this->zipname);        PclZipUtilRename($v_zip_temp_name, $this->zipname);        // ----- Destroy the temporary archive        unset($v_temp_zip);    }    // ----- Remove every files : reset the file    else if ($v_central_dir['entries'] != 0) {        $this->privCloseFd();        if (($v_result = $this->privOpenFd('wb')) != 1) {          return $v_result;        }        if (($v_result = $this->privWriteCentralHeader(0, 0, 0, '')) != 1) {          return $v_result;        }        $this->privCloseFd();    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDirCheck()  // Description :  //   Check if a directory exists, if not it creates it and all the parents directory  //   which may be useful.  // Parameters :  //   $p_dir : Directory path to check.  // Return Values :  //    1 : OK  //   -1 : Unable to create directory  // --------------------------------------------------------------------------------  function privDirCheck($p_dir, $p_is_dir=false)  {    $v_result = 1;    // ----- Remove the final '/'    if (($p_is_dir) && (substr($p_dir, -1)=='/'))    {      $p_dir = substr($p_dir, 0, strlen($p_dir)-1);    }    // ----- Check the directory availability    if ((is_dir($p_dir)) || ($p_dir == ""))    {      return 1;    }    // ----- Extract parent directory    $p_parent_dir = dirname($p_dir);    // ----- Just a check    if ($p_parent_dir != $p_dir)    {      // ----- Look for parent directory      if ($p_parent_dir != "")      {        if (($v_result = $this->privDirCheck($p_parent_dir)) != 1)        {          return $v_result;        }      }    }    // ----- Create the directory    if (!@mkdir($p_dir, 0777))    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, "Unable to create directory '$p_dir'");      // ----- Return      return PclZip::errorCode();    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privMerge()  // Description :  //   If $p_archive_to_add does not exist, the function exit with a success result.  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privMerge(&$p_archive_to_add)  {    $v_result=1;    // ----- Look if the archive_to_add exists    if (!is_file($p_archive_to_add->zipname))    {      // ----- Nothing to merge, so merge is a success      $v_result = 1;      // ----- Return      return $v_result;    }    // ----- Look if the archive exists    if (!is_file($this->zipname))    {      // ----- Do a duplicate      $v_result = $this->privDuplicate($p_archive_to_add->zipname);      // ----- Return      return $v_result;    }    // ----- Open the zip file    if (($v_result=$this->privOpenFd('rb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privCloseFd();      return $v_result;    }    // ----- Go to beginning of File    @rewind($this->zip_fd);    // ----- Open the archive_to_add file    if (($v_result=$p_archive_to_add->privOpenFd('rb')) != 1)    {      $this->privCloseFd();      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir_to_add = array();    if (($v_result = $p_archive_to_add->privReadEndCentralDir($v_central_dir_to_add)) != 1)    {      $this->privCloseFd();      $p_archive_to_add->privCloseFd();      return $v_result;    }    // ----- Go to beginning of File    @rewind($p_archive_to_add->zip_fd);    // ----- Creates a temporay file    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';    // ----- Open the temporary file in write mode    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)    {      $this->privCloseFd();      $p_archive_to_add->privCloseFd();      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_zip_temp_name.'\' in binary write mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Copy the files from the archive to the temporary file    // TBC : Here I should better append the file and go back to erase the central dir    $v_size = $v_central_dir['offset'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($this->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Copy the files from the archive_to_add into the temporary file    $v_size = $v_central_dir_to_add['offset'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($p_archive_to_add->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Store the offset of the central dir    $v_offset = @ftell($v_zip_temp_fd);    // ----- Copy the block of file headers from the old archive    $v_size = $v_central_dir['size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($this->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Copy the block of file headers from the archive_to_add    $v_size = $v_central_dir_to_add['size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($p_archive_to_add->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Merge the file comments    $v_comment = $v_central_dir['comment'].' '.$v_central_dir_to_add['comment'];    // ----- Calculate the size of the (new) central header    $v_size = @ftell($v_zip_temp_fd)-$v_offset;    // ----- Swap the file descriptor    // Here is a trick : I swap the temporary fd with the zip fd, in order to use    // the following methods on the temporary fil and not the real archive fd    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Create the central dir footer    if (($v_result = $this->privWriteCentralHeader($v_central_dir['entries']+$v_central_dir_to_add['entries'], $v_size, $v_offset, $v_comment)) != 1)    {      $this->privCloseFd();      $p_archive_to_add->privCloseFd();      @fclose($v_zip_temp_fd);      $this->zip_fd = null;      // ----- Reset the file list      unset($v_header_list);      // ----- Return      return $v_result;    }    // ----- Swap back the file descriptor    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Close    $this->privCloseFd();    $p_archive_to_add->privCloseFd();    // ----- Close the temporary file    @fclose($v_zip_temp_fd);    // ----- Delete the zip file    // TBC : I should test the result ...    @unlink($this->zipname);    // ----- Rename the temporary file    // TBC : I should test the result ...    //@rename($v_zip_temp_name, $this->zipname);    PclZipUtilRename($v_zip_temp_name, $this->zipname);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDuplicate()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privDuplicate($p_archive_filename)  {    $v_result=1;    // ----- Look if the $p_archive_filename exists    if (!is_file($p_archive_filename))    {      // ----- Nothing to duplicate, so duplicate is a success.      $v_result = 1;      // ----- Return      return $v_result;    }    // ----- Open the zip file    if (($v_result=$this->privOpenFd('wb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Open the temporary file in write mode    if (($v_zip_temp_fd = @fopen($p_archive_filename, 'rb')) == 0)    {      $this->privCloseFd();      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive file \''.$p_archive_filename.'\' in binary write mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Copy the files from the archive to the temporary file    // TBC : Here I should better append the file and go back to erase the central dir    $v_size = filesize($p_archive_filename);    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($v_zip_temp_fd, $v_read_size);      @fwrite($this->zip_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Close    $this->privCloseFd();    // ----- Close the temporary file    @fclose($v_zip_temp_fd);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privErrorLog()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privErrorLog($p_error_code=0, $p_error_string='')  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      PclError($p_error_code, $p_error_string);    }    else {      $this->error_code = $p_error_code;      $this->error_string = $p_error_string;    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privErrorReset()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privErrorReset()  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      PclErrorReset();    }    else {      $this->error_code = 0;      $this->error_string = '';    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDisableMagicQuotes()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privDisableMagicQuotes()  {    $v_result=1;    // ----- Look if function exists    if (   (!function_exists("get_magic_quotes_runtime"))	    || (!function_exists("set_magic_quotes_runtime"))) {      return $v_result;	}    // ----- Look if already done    if ($this->magic_quotes_status != -1) {      return $v_result;	}	// ----- Get and memorize the magic_quote value	$this->magic_quotes_status = @get_magic_quotes_runtime();	// ----- Disable magic_quotes	if ($this->magic_quotes_status == 1) {	  @set_magic_quotes_runtime(0);	}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privSwapBackMagicQuotes()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privSwapBackMagicQuotes()  {    $v_result=1;    // ----- Look if function exists    if (   (!function_exists("get_magic_quotes_runtime"))	    || (!function_exists("set_magic_quotes_runtime"))) {      return $v_result;	}    // ----- Look if something to do    if ($this->magic_quotes_status != -1) {      return $v_result;	}	// ----- Swap back magic_quotes	if ($this->magic_quotes_status == 1) {  	  @set_magic_quotes_runtime($this->magic_quotes_status);	}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  }  // End of class  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilPathReduction()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function PclZipUtilPathReduction($p_dir)  {    $v_result = "";    // ----- Look for not empty path    if ($p_dir != "") {      // ----- Explode path by directory names      $v_list = explode("/", $p_dir);      // ----- Study directories from last to first      $v_skip = 0;      for ($i=sizeof($v_list)-1; $i>=0; $i--) {        // ----- Look for current path        if ($v_list[$i] == ".") {          // ----- Ignore this directory          // Should be the first $i=0, but no check is done        }        else if ($v_list[$i] == "..") {		  $v_skip++;        }        else if ($v_list[$i] == "") {		  // ----- First '/' i.e. root slash		  if ($i == 0) {            $v_result = "/".$v_result;		    if ($v_skip > 0) {		        // ----- It is an invalid path, so the path is not modified		        // TBC		        $v_result = $p_dir;                $v_skip = 0;		    }		  }		  // ----- Last '/' i.e. indicates a directory		  else if ($i == (sizeof($v_list)-1)) {            $v_result = $v_list[$i];		  }		  // ----- Double '/' inside the path		  else {            // ----- Ignore only the double '//' in path,            // but not the first and last '/'		  }        }        else {		  // ----- Look for item to skip		  if ($v_skip > 0) {		    $v_skip--;		  }		  else {            $v_result = $v_list[$i].($i!=(sizeof($v_list)-1)?"/".$v_result:"");		  }        }      }      // ----- Look for skip      if ($v_skip > 0) {        while ($v_skip > 0) {            $v_result = '../'.$v_result;            $v_skip--;        }      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilPathInclusion()  // Description :  //   This function indicates if the path $p_path is under the $p_dir tree. Or,  //   said in an other way, if the file or sub-dir $p_path is inside the dir  //   $p_dir.  //   The function indicates also if the path is exactly the same as the dir.  //   This function supports path with duplicated '/' like '//', but does not  //   support '.' or '..' statements.  // Parameters :  // Return Values :  //   0 if $p_path is not inside directory $p_dir  //   1 if $p_path is inside directory $p_dir  //   2 if $p_path is exactly the same as $p_dir  // --------------------------------------------------------------------------------  function PclZipUtilPathInclusion($p_dir, $p_path)  {    $v_result = 1;    // ----- Look for path beginning by ./    if (   ($p_dir == '.')        || ((strlen($p_dir) >=2) && (substr($p_dir, 0, 2) == './'))) {      $p_dir = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_dir, 1);    }    if (   ($p_path == '.')        || ((strlen($p_path) >=2) && (substr($p_path, 0, 2) == './'))) {      $p_path = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_path, 1);    }    // ----- Explode dir and path by directory separator    $v_list_dir = explode("/", $p_dir);    $v_list_dir_size = sizeof($v_list_dir);    $v_list_path = explode("/", $p_path);    $v_list_path_size = sizeof($v_list_path);    // ----- Study directories paths    $i = 0;    $j = 0;    while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {      // ----- Look for empty dir (path reduction)      if ($v_list_dir[$i] == '') {        $i++;        continue;      }      if ($v_list_path[$j] == '') {        $j++;        continue;      }      // ----- Compare the items      if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != ''))  {        $v_result = 0;      }      // ----- Next items      $i++;      $j++;    }    // ----- Look if everything seems to be the same    if ($v_result) {      // ----- Skip all the empty items      while (($j < $v_list_path_size) && ($v_list_path[$j] == '')) $j++;      while (($i < $v_list_dir_size) && ($v_list_dir[$i] == '')) $i++;      if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) {        // ----- There are exactly the same        $v_result = 2;      }      else if ($i < $v_list_dir_size) {        // ----- The path is shorter than the dir        $v_result = 0;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilCopyBlock()  // Description :  // Parameters :  //   $p_mode : read/write compression mode  //             0 : src & dest normal  //             1 : src gzip, dest normal  //             2 : src normal, dest gzip  //             3 : src & dest gzip  // Return Values :  // --------------------------------------------------------------------------------  function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode=0)  {    $v_result = 1;    if ($p_mode==0)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @fread($p_src, $v_read_size);        @fwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    else if ($p_mode==1)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @gzread($p_src, $v_read_size);        @fwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    else if ($p_mode==2)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @fread($p_src, $v_read_size);        @gzwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    else if ($p_mode==3)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @gzread($p_src, $v_read_size);        @gzwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilRename()  // Description :  //   This function tries to do a simple rename() function. If it fails, it  //   tries to copy the $p_src file in a new $p_dest file and then unlink the  //   first one.  // Parameters :  //   $p_src : Old filename  //   $p_dest : New filename  // Return Values :  //   1 on success, 0 on failure.  // --------------------------------------------------------------------------------  function PclZipUtilRename($p_src, $p_dest)  {    $v_result = 1;    // ----- Try to rename the files    if (!@rename($p_src, $p_dest)) {      // ----- Try to copy & unlink the src      if (!@copy($p_src, $p_dest)) {        $v_result = 0;      }      else if (!@unlink($p_src)) {        $v_result = 0;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilOptionText()  // Description :  //   Translate option value in text. Mainly for debug purpose.  // Parameters :  //   $p_option : the option value.  // Return Values :  //   The option text value.  // --------------------------------------------------------------------------------  function PclZipUtilOptionText($p_option)  {    $v_list = get_defined_constants();    for (reset($v_list); $v_key = key($v_list); next($v_list)) {	    $v_prefix = substr($v_key, 0, 10);	    if ((   ($v_prefix == 'PCLZIP_OPT')           || ($v_prefix == 'PCLZIP_CB_')           || ($v_prefix == 'PCLZIP_ATT'))	        && ($v_list[$v_key] == $p_option)) {        return $v_key;	    }    }    $v_result = 'Unknown';    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilTranslateWinPath()  // Description :  //   Translate windows path by replacing '\' by '/' and optionally removing  //   drive letter.  // Parameters :  //   $p_path : path to translate.  //   $p_remove_disk_letter : true | false  // Return Values :  //   The path translated.  // --------------------------------------------------------------------------------  function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter=true)  {    if (stristr(php_uname(), 'windows')) {      // ----- Look for potential disk letter      if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {          $p_path = substr($p_path, $v_position+1);      }      // ----- Change potential windows directory separator      if ((strpos($p_path, '\\') > 0) || (substr($p_path, 0,1) == '\\')) {          $p_path = strtr($p_path, '\\', '/');      }    }    return $p_path;  }  // --------------------------------------------------------------------------------?>
<?php/** * WordPress CRON API * * @package WordPress *//** * Schedules a hook to run only once. * * Schedules a hook which will be executed once by the WordPress actions core at * a time which you specify. The action will fire off when someone visits your * WordPress site, if the schedule time has passed. * * @since 2.1.0 * @link http://codex.wordpress.org/Function_Reference/wp_schedule_single_event * * @param int $timestamp Timestamp for when to run the event. * @param string $hook Action hook to execute when cron is run. * @param array $args Optional. Arguments to pass to the hook's callback function. */function wp_schedule_single_event( $timestamp, $hook, $args = array()) {	// don't schedule a duplicate if there's already an identical event due in the next 10 minutes	$next = wp_next_scheduled($hook, $args);	if ( $next && $next <= $timestamp + 600 )		return;	$crons = _get_cron_array();	$key = md5(serialize($args));	$crons[$timestamp][$hook][$key] = array( 'schedule' => false, 'args' => $args );	uksort( $crons, "strnatcasecmp" );	_set_cron_array( $crons );}/** * Schedule a periodic event. * * Schedules a hook which will be executed by the WordPress actions core on a * specific interval, specified by you. The action will trigger when someone * visits your WordPress site, if the scheduled time has passed. * * Valid values for the recurrence are hourly, daily and twicedaily.  These can * be extended using the cron_schedules filter in wp_get_schedules(). * * @since 2.1.0 * * @param int $timestamp Timestamp for when to run the event. * @param string $recurrence How often the event should recur. * @param string $hook Action hook to execute when cron is run. * @param array $args Optional. Arguments to pass to the hook's callback function. * @return bool|null False on failure, null when complete with scheduling event. */function wp_schedule_event( $timestamp, $recurrence, $hook, $args = array()) {	$crons = _get_cron_array();	$schedules = wp_get_schedules();	$key = md5(serialize($args));	if ( !isset( $schedules[$recurrence] ) )		return false;	$crons[$timestamp][$hook][$key] = array( 'schedule' => $recurrence, 'args' => $args, 'interval' => $schedules[$recurrence]['interval'] );	uksort( $crons, "strnatcasecmp" );	_set_cron_array( $crons );}/** * Reschedule a recurring event. * * @since 2.1.0 * * @param int $timestamp Timestamp for when to run the event. * @param string $recurrence How often the event should recur. * @param string $hook Action hook to execute when cron is run. * @param array $args Optional. Arguments to pass to the hook's callback function. * @return bool|null False on failure. Null when event is rescheduled. */function wp_reschedule_event( $timestamp, $recurrence, $hook, $args = array()) {	$crons = _get_cron_array();	$schedules = wp_get_schedules();	$key = md5(serialize($args));	$interval = 0;	// First we try to get it from the schedule	if ( 0 == $interval )		$interval = $schedules[$recurrence]['interval'];	// Now we try to get it from the saved interval in case the schedule disappears	if ( 0 == $interval )		$interval = $crons[$timestamp][$hook][$key]['interval'];	// Now we assume something is wrong and fail to schedule	if ( 0 == $interval )		return false;	$now = time();    if ( $timestamp >= $now )        $timestamp = $now + $interval;    else        $timestamp = $now + ($interval - (($now - $timestamp) % $interval));	wp_schedule_event( $timestamp, $recurrence, $hook, $args );}/** * Unschedule a previously scheduled cron job. * * The $timestamp and $hook parameters are required, so that the event can be * identified. * * @since 2.1.0 * * @param int $timestamp Timestamp for when to run the event. * @param string $hook Action hook, the execution of which will be unscheduled. * @param array $args Arguments to pass to the hook's callback function. * Although not passed to a callback function, these arguments are used * to uniquely identify the scheduled event, so they should be the same * as those used when originally scheduling the event. */function wp_unschedule_event( $timestamp, $hook, $args = array() ) {	$crons = _get_cron_array();	$key = md5(serialize($args));	unset( $crons[$timestamp][$hook][$key] );	if ( empty($crons[$timestamp][$hook]) )		unset( $crons[$timestamp][$hook] );	if ( empty($crons[$timestamp]) )		unset( $crons[$timestamp] );	_set_cron_array( $crons );}/** * Unschedule all cron jobs attached to a specific hook. * * @since 2.1.0 * * @param string $hook Action hook, the execution of which will be unscheduled. * @param array $args Optional. Arguments that were to be pass to the hook's callback function. */function wp_clear_scheduled_hook( $hook, $args = array() ) {	// Backward compatibility	// Previously this function took the arguments as discrete vars rather than an array like the rest of the API	if ( !is_array($args) ) {		_deprecated_argument( __FUNCTION__, '3.0.0', __('This argument has changed to an array to match the behavior of the other cron functions.') );		$args = array_slice( func_get_args(), 1 );	}	while ( $timestamp = wp_next_scheduled( $hook, $args ) )		wp_unschedule_event( $timestamp, $hook, $args );}/** * Retrieve the next timestamp for a cron event. * * @since 2.1.0 * * @param string $hook Action hook to execute when cron is run. * @param array $args Optional. Arguments to pass to the hook's callback function. * @return bool|int The UNIX timestamp of the next time the scheduled event will occur. */function wp_next_scheduled( $hook, $args = array() ) {	$crons = _get_cron_array();	$key = md5(serialize($args));	if ( empty($crons) )		return false;	foreach ( $crons as $timestamp => $cron ) {		if ( isset( $cron[$hook][$key] ) )			return $timestamp;	}	return false;}/** * Send request to run cron through HTTP request that doesn't halt page loading. * * @since 2.1.0 * * @return null Cron could not be spawned, because it is not needed to run. */function spawn_cron( $local_time = 0 ) {	if ( !$local_time )		$local_time = time();	if ( defined('DOING_CRON') || isset($_GET['doing_wp_cron']) )		return;	/*	 * do not even start the cron if local server timer has drifted	 * such as due to power failure, or misconfiguration	 */	$timer_accurate = check_server_timer( $local_time );	if ( !$timer_accurate )		return;	/*	* multiple processes on multiple web servers can run this code concurrently	* try to make this as atomic as possible by setting doing_cron switch	*/	$flag = get_transient('doing_cron');	if ( $flag > $local_time + 10*60 )		$flag = 0;	// don't run if another process is currently running it or more than once every 60 sec.	if ( $flag + 60 > $local_time )		return;	//sanity check	$crons = _get_cron_array();	if ( !is_array($crons) )		return;	$keys = array_keys( $crons );	if ( isset($keys[0]) && $keys[0] > $local_time )		return;	if ( defined('ALTERNATE_WP_CRON') && ALTERNATE_WP_CRON ) {		if ( !empty($_POST) || defined('DOING_AJAX') )			return;		set_transient( 'doing_cron', $local_time );		ob_start();		wp_redirect( add_query_arg('doing_wp_cron', '', stripslashes($_SERVER['REQUEST_URI'])) );		echo ' ';		// flush any buffers and send the headers		while ( @ob_end_flush() );		flush();		WP_DEBUG ? include_once( ABSPATH . 'wp-cron.php' ) : @include_once( ABSPATH . 'wp-cron.php' );		return;	}	set_transient( 'doing_cron', $local_time );	$cron_url = get_option( 'siteurl' ) . '/wp-cron.php?doing_wp_cron';	wp_remote_post( $cron_url, array('timeout' => 0.01, 'blocking' => false, 'sslverify' => apply_filters('https_local_ssl_verify', true)) );}/** * Run scheduled callbacks or spawn cron for all scheduled events. * * @since 2.1.0 * * @return null When doesn't need to run Cron. */function wp_cron() {	// Prevent infinite loops caused by lack of wp-cron.php	if ( strpos($_SERVER['REQUEST_URI'], '/wp-cron.php') !== false || ( defined('DISABLE_WP_CRON') && DISABLE_WP_CRON ) )		return;	if ( false === $crons = _get_cron_array() )		return;	$local_time = time();	$keys = array_keys( $crons );	if ( isset($keys[0]) && $keys[0] > $local_time )		return;	$schedules = wp_get_schedules();	foreach ( $crons as $timestamp => $cronhooks ) {		if ( $timestamp > $local_time ) break;		foreach ( (array) $cronhooks as $hook => $args ) {			if ( isset($schedules[$hook]['callback']) && !call_user_func( $schedules[$hook]['callback'] ) )				continue;			spawn_cron( $local_time );			break 2;		}	}}/** * Retrieve supported and filtered Cron recurrences. * * The supported recurrences are 'hourly' and 'daily'. A plugin may add more by * hooking into the 'cron_schedules' filter. The filter accepts an array of * arrays. The outer array has a key that is the name of the schedule or for * example 'weekly'. The value is an array with two keys, one is 'interval' and * the other is 'display'. * * The 'interval' is a number in seconds of when the cron job should run. So for * 'hourly', the time is 3600 or 60*60. For weekly, the value would be * 60*60*24*7 or 604800. The value of 'interval' would then be 604800. * * The 'display' is the description. For the 'weekly' key, the 'display' would * be <code>__('Once Weekly')</code>. * * For your plugin, you will be passed an array. you can easily add your * schedule by doing the following. * <code> * // filter parameter variable name is 'array' *	$array['weekly'] = array( *		'interval' => 604800, *		'display' => __('Once Weekly') *	); * </code> * * @since 2.1.0 * * @return array */function wp_get_schedules() {	$schedules = array(		'hourly' => array( 'interval' => 3600, 'display' => __('Once Hourly') ),		'twicedaily' => array( 'interval' => 43200, 'display' => __('Twice Daily') ),		'daily' => array( 'interval' => 86400, 'display' => __('Once Daily') ),	);	return array_merge( apply_filters( 'cron_schedules', array() ), $schedules );}/** * Retrieve Cron schedule for hook with arguments. * * @since 2.1.0 * * @param string $hook Action hook to execute when cron is run. * @param array $args Optional. Arguments to pass to the hook's callback function. * @return string|bool False, if no schedule. Schedule on success. */function wp_get_schedule($hook, $args = array()) {	$crons = _get_cron_array();	$key = md5(serialize($args));	if ( empty($crons) )		return false;	foreach ( $crons as $timestamp => $cron ) {		if ( isset( $cron[$hook][$key] ) )			return $cron[$hook][$key]['schedule'];	}	return false;}//// Private functions///** * Retrieve cron info array option. * * @since 2.1.0 * @access private * * @return array CRON info array. */function _get_cron_array()  {	$cron = get_option('cron');	if ( ! is_array($cron) )		return false;	if ( !isset($cron['version']) )		$cron = _upgrade_cron_array($cron);	unset($cron['version']);	return $cron;}/** * Updates the CRON option with the new CRON array. * * @since 2.1.0 * @access private * * @param array $cron Cron info array from {@link _get_cron_array()}. */function _set_cron_array($cron) {	$cron['version'] = 2;	update_option( 'cron', $cron );}/** * Upgrade a Cron info array. * * This function upgrades the Cron info array to version 2. * * @since 2.1.0 * @access private * * @param array $cron Cron info array from {@link _get_cron_array()}. * @return array An upgraded Cron info array. */function _upgrade_cron_array($cron) {	if ( isset($cron['version']) && 2 == $cron['version'])		return $cron;	$new_cron = array();	foreach ( (array) $cron as $timestamp => $hooks) {		foreach ( (array) $hooks as $hook => $args ) {			$key = md5(serialize($args['args']));			$new_cron[$timestamp][$hook][$key] = $args;		}	}	$new_cron['version'] = 2;	update_option( 'cron', $new_cron );	return $new_cron;}// stub for checking server timer accuracy, using outside standard time sourcesfunction check_server_timer( $local_time ) {	return true;}
<?php/** * Class for working with PO files * * @version $Id: po.php 406 2010-02-07 11:10:24Z nbachiyski $ * @package pomo * @subpackage po */require_once dirname(__FILE__) . '/translations.php';define('PO_MAX_LINE_LEN', 79);ini_set('auto_detect_line_endings', 1);/** * Routines for working with PO files */if ( !class_exists( 'PO' ) ):class PO extends Gettext_Translations {	/**	 * Exports headers to a PO entry	 *	 * @return string msgid/msgstr PO entry for this PO file headers, doesn't contain newline at the end	 */	function export_headers() {		$header_string = '';		foreach($this->headers as $header => $value) {			$header_string.= "$header: $value\n";		}		$poified = PO::poify($header_string);		return rtrim("msgid \"\"\nmsgstr $poified");	}	/**	 * Exports all entries to PO format	 *	 * @return string sequence of mgsgid/msgstr PO strings, doesn't containt newline at the end	 */	function export_entries() {		//TODO sorting		return implode("\n\n", array_map(array('PO', 'export_entry'), $this->entries));	}	/**	 * Exports the whole PO file as a string	 *	 * @param bool $include_headers whether to include the headers in the export	 * @return string ready for inclusion in PO file string for headers and all the enrtries	 */	function export($include_headers = true) {		$res = '';		if ($include_headers) {			$res .= $this->export_headers();			$res .= "\n\n";		}		$res .= $this->export_entries();		return $res;	}	/**	 * Same as {@link export}, but writes the result to a file	 *	 * @param string $filename where to write the PO string	 * @param bool $include_headers whether to include tje headers in the export	 * @return bool true on success, false on error	 */	function export_to_file($filename, $include_headers = true) {		$fh = fopen($filename, 'w');		if (false === $fh) return false;		$export = $this->export($include_headers);		$res = fwrite($fh, $export);		if (false === $res) return false;		return fclose($fh);	}	/**	 * Formats a string in PO-style	 *	 * @static	 * @param string $string the string to format	 * @return string the poified string	 */	function poify($string) {		$quote = '"';		$slash = '\\';		$newline = "\n";		$replaces = array(			"$slash" 	=> "$slash$slash",			"$quote"	=> "$slash$quote",			"\t" 		=> '\t',		);		$string = str_replace(array_keys($replaces), array_values($replaces), $string);		$po = $quote.implode("${slash}n$quote$newline$quote", explode($newline, $string)).$quote;		// add empty string on first line for readbility		if (false !== strpos($string, $newline) &&				(substr_count($string, $newline) > 1 || !($newline === substr($string, -strlen($newline))))) {			$po = "$quote$quote$newline$po";		}		// remove empty strings		$po = str_replace("$newline$quote$quote", '', $po);		return $po;	}	/**	 * Gives back the original string from a PO-formatted string	 *	 * @static	 * @param string $string PO-formatted string	 * @return string enascaped string	 */	function unpoify($string) {		$escapes = array('t' => "\t", 'n' => "\n", '\\' => '\\');		$lines = array_map('trim', explode("\n", $string));		$lines = array_map(array('PO', 'trim_quotes'), $lines);		$unpoified = '';		$previous_is_backslash = false;		foreach($lines as $line) {			preg_match_all('/./u', $line, $chars);			$chars = $chars[0];			foreach($chars as $char) {				if (!$previous_is_backslash) {					if ('\\' == $char)						$previous_is_backslash = true;					else						$unpoified .= $char;				} else {					$previous_is_backslash = false;					$unpoified .= isset($escapes[$char])? $escapes[$char] : $char;				}			}		}		return $unpoified;	}	/**	 * Inserts $with in the beginning of every new line of $string and	 * returns the modified string	 *	 * @static	 * @param string $string prepend lines in this string	 * @param string $with prepend lines with this string	 */	function prepend_each_line($string, $with) {		$php_with = var_export($with, true);		$lines = explode("\n", $string);		// do not prepend the string on the last empty line, artefact by explode		if ("\n" == substr($string, -1)) unset($lines[count($lines) - 1]);		$res = implode("\n", array_map(create_function('$x', "return $php_with.\$x;"), $lines));		// give back the empty line, we ignored above		if ("\n" == substr($string, -1)) $res .= "\n";		return $res;	}	/**	 * Prepare a text as a comment -- wraps the lines and prepends #	 * and a special character to each line	 *	 * @access private	 * @param string $text the comment text	 * @param string $char character to denote a special PO comment,	 * 	like :, default is a space	 */	function comment_block($text, $char=' ') {		$text = wordwrap($text, PO_MAX_LINE_LEN - 3);		return PO::prepend_each_line($text, "#$char ");	}	/**	 * Builds a string from the entry for inclusion in PO file	 *	 * @static	 * @param object &$entry the entry to convert to po string	 * @return string|bool PO-style formatted string for the entry or	 * 	false if the entry is empty	 */	function export_entry(&$entry) {		if (is_null($entry->singular)) return false;		$po = array();		if (!empty($entry->translator_comments)) $po[] = PO::comment_block($entry->translator_comments);		if (!empty($entry->extracted_comments)) $po[] = PO::comment_block($entry->extracted_comments, '.');		if (!empty($entry->references)) $po[] = PO::comment_block(implode(' ', $entry->references), ':');		if (!empty($entry->flags)) $po[] = PO::comment_block(implode(", ", $entry->flags), ',');		if (!is_null($entry->context)) $po[] = 'msgctxt '.PO::poify($entry->context);		$po[] = 'msgid '.PO::poify($entry->singular);		if (!$entry->is_plural) {			$translation = empty($entry->translations)? '' : $entry->translations[0];			$po[] = 'msgstr '.PO::poify($translation);		} else {			$po[] = 'msgid_plural '.PO::poify($entry->plural);			$translations = empty($entry->translations)? array('', '') : $entry->translations;			foreach($translations as $i => $translation) {				$po[] = "msgstr[$i] ".PO::poify($translation);			}		}		return implode("\n", $po);	}	function import_from_file($filename) {		$f = fopen($filename, 'r');		if (!$f) return false;		$lineno = 0;		while (true) {			$res = $this->read_entry($f, $lineno);			if (!$res) break;			if ($res['entry']->singular == '') {				$this->set_headers($this->make_headers($res['entry']->translations[0]));			} else {				$this->add_entry($res['entry']);			}		}		PO::read_line($f, 'clear');		return $res !== false;	}	function read_entry($f, $lineno = 0) {		$entry = new Translation_Entry();		// where were we in the last step		// can be: comment, msgctxt, msgid, msgid_plural, msgstr, msgstr_plural		$context = '';		$msgstr_index = 0;		$is_final = create_function('$context', 'return $context == "msgstr" || $context == "msgstr_plural";');		while (true) {			$lineno++;			$line = PO::read_line($f);			if (!$line)  {				if (feof($f)) {					if ($is_final($context))						break;					elseif (!$context) // we haven't read a line and eof came						return null;					else						return false;				} else {					return false;				}			}			if ($line == "\n") continue;			$line = trim($line);			if (preg_match('/^#/', $line, $m)) {				// the comment is the start of a new entry				if ($is_final($context)) {					PO::read_line($f, 'put-back');					$lineno--;					break;				}				// comments have to be at the beginning				if ($context && $context != 'comment') {					return false;				}				// add comment				$this->add_comment_to_entry($entry, $line);			} elseif (preg_match('/^msgctxt\s+(".*")/', $line, $m)) {				if ($is_final($context)) {					PO::read_line($f, 'put-back');					$lineno--;					break;				}				if ($context && $context != 'comment') {					return false;				}				$context = 'msgctxt';				$entry->context .= PO::unpoify($m[1]);			} elseif (preg_match('/^msgid\s+(".*")/', $line, $m)) {				if ($is_final($context)) {					PO::read_line($f, 'put-back');					$lineno--;					break;				}				if ($context && $context != 'msgctxt' && $context != 'comment') {					return false;				}				$context = 'msgid';				$entry->singular .= PO::unpoify($m[1]);			} elseif (preg_match('/^msgid_plural\s+(".*")/', $line, $m)) {				if ($context != 'msgid') {					return false;				}				$context = 'msgid_plural';				$entry->is_plural = true;				$entry->plural .= PO::unpoify($m[1]);			} elseif (preg_match('/^msgstr\s+(".*")/', $line, $m)) {				if ($context != 'msgid') {					return false;				}				$context = 'msgstr';				$entry->translations = array(PO::unpoify($m[1]));			} elseif (preg_match('/^msgstr\[(\d+)\]\s+(".*")/', $line, $m)) {				if ($context != 'msgid_plural' && $context != 'msgstr_plural') {					return false;				}				$context = 'msgstr_plural';				$msgstr_index = $m[1];				$entry->translations[$m[1]] = PO::unpoify($m[2]);			} elseif (preg_match('/^".*"$/', $line)) {				$unpoified = PO::unpoify($line);				switch ($context) {					case 'msgid':						$entry->singular .= $unpoified; break;					case 'msgctxt':						$entry->context .= $unpoified; break;					case 'msgid_plural':						$entry->plural .= $unpoified; break;					case 'msgstr':						$entry->translations[0] .= $unpoified; break;					case 'msgstr_plural':						$entry->translations[$msgstr_index] .= $unpoified; break;					default:						return false;				}			} else {				return false;			}		}		if (array() == array_filter($entry->translations, create_function('$t', 'return $t || "0" === $t;'))) {			$entry->translations = array();		}		return array('entry' => $entry, 'lineno' => $lineno);	}	function read_line($f, $action = 'read') {		static $last_line = '';		static $use_last_line = false;		if ('clear' == $action) {			$last_line = '';			return true;		}		if ('put-back' == $action) {			$use_last_line = true;			return true;		}		$line = $use_last_line? $last_line : fgets($f);		$last_line = $line;		$use_last_line = false;		return $line;	}	function add_comment_to_entry(&$entry, $po_comment_line) {		$first_two = substr($po_comment_line, 0, 2);		$comment = trim(substr($po_comment_line, 2));		if ('#:' == $first_two) {			$entry->references = array_merge($entry->references, preg_split('/\s+/', $comment));		} elseif ('#.' == $first_two) {			$entry->extracted_comments = trim($entry->extracted_comments . "\n" . $comment);		} elseif ('#,' == $first_two) {			$entry->flags = array_merge($entry->flags, preg_split('/,\s*/', $comment));		} else {			$entry->translator_comments = trim($entry->translator_comments . "\n" . $comment);		}	}	function trim_quotes($s) {		if ( substr($s, 0, 1) == '"') $s = substr($s, 1);		if ( substr($s, -1, 1) == '"') $s = substr($s, 0, -1);		return $s;	}}endif;
<?php/** Sets up the WordPress Environment. */require( dirname(__FILE__) . '/wp-load.php' );add_action( 'wp_head', 'signuppageheaders' ) ;require( './wp-blog-header.php' );require_once( ABSPATH . WPINC . '/registration.php' );if ( is_array( get_site_option( 'illegal_names' )) && isset( $_GET[ 'new' ] ) && in_array( $_GET[ 'new' ], get_site_option( 'illegal_names' ) ) == true ) {	wp_redirect( network_home_url() );	die();}function do_signup_header() {	do_action("signup_header");}add_action( 'wp_head', 'do_signup_header' );function signuppageheaders() {	echo "<meta name='robots' content='noindex,nofollow' />\n";}if ( !is_multisite() ) {	wp_redirect( get_option( 'siteurl' ) . "/wp-login.php?action=register" );	die();}if ( !is_main_site() ) {	wp_redirect( network_home_url( 'wp-signup.php' ) );	die();}// Fix for page title$wp_query->is_404 = false;function wpmu_signup_stylesheet() {	?>	<style type="text/css">		.mu_register { width: 90%; margin:0 auto; }		.mu_register form { margin-top: 2em; }		.mu_register .error { font-weight:700; padding:10px; color:#333333; background:#FFEBE8; border:1px solid #CC0000; }		.mu_register input[type="submit"],			.mu_register #blog_title,			.mu_register #user_email,			.mu_register #blogname,			.mu_register #user_name { width:100%; font-size: 24px; margin:5px 0; }		.mu_register .prefix_address,			.mu_register .suffix_address {font-size: 18px;display:inline; }		.mu_register label { font-weight:700; font-size:15px; display:block; margin:10px 0; }		.mu_register label.checkbox { display:inline; }		.mu_register .mu_alert { font-weight:700; padding:10px; color:#333333; background:#ffffe0; border:1px solid #e6db55; }	</style>	<?php}add_action( 'wp_head', 'wpmu_signup_stylesheet' );get_header();do_action( 'before_signup_form' );?><div id="content" class="widecolumn"><div class="mu_register"><?phpfunction show_blog_form($blogname = '', $blog_title = '', $errors = '') {	global $current_site;	// Blog name	if ( !is_subdomain_install() )		echo '<label for="blogname">' . __('Site Name:') . '</label>';	else		echo '<label for="blogname">' . __('Site Domain:') . '</label>';	if ( $errmsg = $errors->get_error_message('blogname') ) { ?>		<p class="error"><?php echo $errmsg ?></p>	<?php }	if ( !is_subdomain_install() )		echo '<span class="prefix_address">' . $current_site->domain . $current_site->path . '</span><input name="blogname" type="text" id="blogname" value="'. esc_attr($blogname) .'" maxlength="60" /><br />';	else		echo '<input name="blogname" type="text" id="blogname" value="'.esc_attr($blogname).'" maxlength="60" /><span class="suffix_address">.' . ( $site_domain = preg_replace( '|^www\.|', '', $current_site->domain ) ) . '</span><br />';	if ( !is_user_logged_in() ) {		print '(<strong>' . __( 'Your address will be ' );		if ( !is_subdomain_install() )			print $current_site->domain . $current_site->path . __( 'sitename' );		else			print __( 'domain.' ) . $site_domain . $current_site->path;		echo '.</strong>) ' . __( 'Must be at least 4 characters, letters and numbers only. It cannot be changed, so choose carefully!' ) . '</p>';	}	// Blog Title	?>	<label for="blog_title"><?php _e('Site Title:') ?></label>	<?php if ( $errmsg = $errors->get_error_message('blog_title') ) { ?>		<p class="error"><?php echo $errmsg ?></p>	<?php }	echo '<input name="blog_title" type="text" id="blog_title" value="'.esc_attr($blog_title).'" />';	?>	<div id="privacy">        <p class="privacy-intro">            <label for="blog_public_on"><?php _e('Privacy:') ?></label>            <?php _e('Allow my site to appear in search engines like Google, Technorati, and in public listings around this network.'); ?>            <br style="clear:both" />            <label class="checkbox" for="blog_public_on">                <input type="radio" id="blog_public_on" name="blog_public" value="1" <?php if ( !isset( $_POST['blog_public'] ) || $_POST['blog_public'] == '1' ) { ?>checked="checked"<?php } ?> />                <strong><?php _e( 'Yes' ); ?></strong>            </label>            <label class="checkbox" for="blog_public_off">                <input type="radio" id="blog_public_off" name="blog_public" value="0" <?php if ( isset( $_POST['blog_public'] ) && $_POST['blog_public'] == '0' ) { ?>checked="checked"<?php } ?> />                <strong><?php _e( 'No' ); ?></strong>            </label>        </p>	</div>	<?php	do_action('signup_blogform', $errors);}function validate_blog_form() {	$user = '';	if ( is_user_logged_in() )		$user = wp_get_current_user();	return wpmu_validate_blog_signup($_POST['blogname'], $_POST['blog_title'], $user);}function show_user_form($user_name = '', $user_email = '', $errors = '') {	// User name	echo '<label for="user_name">' . __('Username:') . '</label>';	if ( $errmsg = $errors->get_error_message('user_name') ) {		echo '<p class="error">'.$errmsg.'</p>';	}	echo '<input name="user_name" type="text" id="user_name" value="'. esc_attr($user_name) .'" maxlength="60" /><br />';	_e( '(Must be at least 4 characters, letters and numbers only.)' );	?>	<label for="user_email"><?php _e( 'Email&nbsp;Address:' ) ?></label>	<?php if ( $errmsg = $errors->get_error_message('user_email') ) { ?>		<p class="error"><?php echo $errmsg ?></p>	<?php } ?>	<input name="user_email" type="text" id="user_email" value="<?php  echo esc_attr($user_email) ?>" maxlength="200" /><br /><?php _e('We send your registration email to this address. (Double-check your email address before continuing.)') ?>	<?php	if ( $errmsg = $errors->get_error_message('generic') ) {		echo '<p class="error">' . $errmsg . '</p>';	}	do_action( 'signup_extra_fields', $errors );}function validate_user_form() {	return wpmu_validate_user_signup($_POST['user_name'], $_POST['user_email']);}function signup_another_blog($blogname = '', $blog_title = '', $errors = '') {	global $current_user, $current_site;	if ( ! is_wp_error($errors) ) {		$errors = new WP_Error();	}	// allow definition of default variables	$filtered_results = apply_filters('signup_another_blog_init', array('blogname' => $blogname, 'blog_title' => $blog_title, 'errors' => $errors ));	$blogname = $filtered_results['blogname'];	$blog_title = $filtered_results['blog_title'];	$errors = $filtered_results['errors'];	echo '<h2>' . sprintf( __( 'Get <em>another</em> %s site in seconds' ), $current_site->site_name ) . '</h2>';	if ( $errors->get_error_code() ) {		echo '<p>' . __( 'There was a problem, please correct the form below and try again.' ) . '</p>';	}	?>	<p><?php printf( __( 'Welcome back, %s. By filling out the form below, you can <strong>add another site to your account</strong>. There is no limit to the number of sites you can have, so create to your heart&#8217;s content, but write responsibly!' ), $current_user->display_name ) ?></p>	<?php	$blogs = get_blogs_of_user($current_user->ID);	if ( !empty($blogs) ) { ?>			<p><?php _e( 'Sites you are already a member of:' ) ?></p>			<ul>				<?php foreach ( $blogs as $blog ) {					$home_url = get_home_url( $blog->userblog_id );					echo '<li><a href="' . esc_url( $home_url ) . '">' . $home_url . '</a></li>';				} ?>			</ul>	<?php } ?>	<p><?php _e( 'If you&#8217;re not going to use a great site domain, leave it for a new user. Now have at it!' ) ?></p>	<form id="setupform" method="post" action="wp-signup.php">		<input type="hidden" name="stage" value="gimmeanotherblog" />		<?php do_action( "signup_hidden_fields" ); ?>		<?php show_blog_form($blogname, $blog_title, $errors); ?>		<p class="submit"><input type="submit" name="submit" class="submit" value="<?php esc_attr_e( 'Create Site' ) ?>" /></p>	</form>	<?php}function validate_another_blog_signup() {	global $wpdb, $current_user, $blogname, $blog_title, $errors, $domain, $path;	$current_user = wp_get_current_user();	if ( !is_user_logged_in() )		die();	$result = validate_blog_form();	extract($result);	if ( $errors->get_error_code() ) {		signup_another_blog($blogname, $blog_title, $errors);		return false;	}	$public = (int) $_POST['blog_public'];	$meta = apply_filters( 'signup_create_blog_meta', array( 'lang_id' => 1, 'public' => $public ) ); // deprecated	$meta = apply_filters( 'add_signup_meta', $meta );	wpmu_create_blog( $domain, $path, $blog_title, $current_user->id, $meta, $wpdb->siteid );	confirm_another_blog_signup($domain, $path, $blog_title, $current_user->user_login, $current_user->user_email, $meta);	return true;}function confirm_another_blog_signup($domain, $path, $blog_title, $user_name, $user_email = '', $meta = '') {	?>	<h2><?php printf( __( 'The site %s is yours.' ), "<a href='http://{$domain}{$path}'>{$blog_title}</a>" ) ?></h2>	<p>		<?php printf( __( '<a href="http://%1$s">http://%2$s</a> is your new site.  <a href="%3$s">Log in</a> as &#8220;%4$s&#8221; using your existing password.' ), $domain.$path, $domain.$path, "http://" . $domain.$path . "wp-login.php", $user_name ) ?>	</p>	<?php	do_action( 'signup_finished' );}function signup_user($user_name = '', $user_email = '', $errors = '') {	global $current_site, $active_signup;	if ( !is_wp_error($errors) )		$errors = new WP_Error();	if ( isset( $_POST[ 'signup_for' ] ) )		$signup[ esc_html( $_POST[ 'signup_for' ] ) ] = 'checked="checked"';	else		$signup[ 'blog' ] = 'checked="checked"';	//TODO - This doesn't seem to do anything do we really need it?	$signup['user'] = isset( $signup['user'] ) ? $signup['user'] : '';	// allow definition of default variables	$filtered_results = apply_filters('signup_user_init', array('user_name' => $user_name, 'user_email' => $user_email, 'errors' => $errors ));	$user_name = $filtered_results['user_name'];	$user_email = $filtered_results['user_email'];	$errors = $filtered_results['errors'];	?>	<h2><?php printf( __( 'Get your own %s account in seconds' ), $current_site->site_name ) ?></h2>	<form id="setupform" method="post" action="wp-signup.php">		<input type="hidden" name="stage" value="validate-user-signup" />		<?php do_action( "signup_hidden_fields" ); ?>		<?php show_user_form($user_name, $user_email, $errors); ?>		<p>		<?php if ( $active_signup == 'blog' ) { ?>			<input id="signupblog" type="hidden" name="signup_for" value="blog" />		<?php } elseif ( $active_signup == 'user' ) { ?>			<input id="signupblog" type="hidden" name="signup_for" value="user" />		<?php } else { ?>			<input id="signupblog" type="radio" name="signup_for" value="blog" <?php echo $signup['blog'] ?> />			<label class="checkbox" for="signupblog"><?php _e('Gimme a site!') ?></label>			<br />			<input id="signupuser" type="radio" name="signup_for" value="user" <?php echo $signup['user'] ?> />			<label class="checkbox" for="signupuser"><?php _e('Just a username, please.') ?></label>		<?php } ?>		</p>		<p class="submit"><input type="submit" name="submit" class="submit" value="<?php esc_attr_e('Next') ?>" /></p>	</form>	<?php}function validate_user_signup() {	$result = validate_user_form();	extract($result);	if ( $errors->get_error_code() ) {		signup_user($user_name, $user_email, $errors);		return false;	}	if ( 'blog' == $_POST['signup_for'] ) {		signup_blog($user_name, $user_email);		return false;	}	wpmu_signup_user($user_name, $user_email, apply_filters( "add_signup_meta", array() ) );	confirm_user_signup($user_name, $user_email);	return true;}function confirm_user_signup($user_name, $user_email) {	?>	<h2><?php printf( __( '%s is your new username' ), $user_name) ?></h2>	<p><?php _e( 'But, before you can start using your new username, <strong>you must activate it</strong>.' ) ?></p>	<p><?php printf(__( 'Check your inbox at <strong>%1$s</strong> and click the link given.' ),  $user_email) ?></p>	<p><?php _e( 'If you do not activate your username within two days, you will have to sign up again.' ); ?></p>	<?php	do_action( 'signup_finished' );}function signup_blog($user_name = '', $user_email = '', $blogname = '', $blog_title = '', $errors = '') {	if ( !is_wp_error($errors) )		$errors = new WP_Error();	// allow definition of default variables	$filtered_results = apply_filters('signup_blog_init', array('user_name' => $user_name, 'user_email' => $user_email, 'blogname' => $blogname, 'blog_title' => $blog_title, 'errors' => $errors ));	$user_name = $filtered_results['user_name'];	$user_email = $filtered_results['user_email'];	$blogname = $filtered_results['blogname'];	$blog_title = $filtered_results['blog_title'];	$errors = $filtered_results['errors'];	if ( empty($blogname) )		$blogname = $user_name;	?>	<form id="setupform" method="post" action="wp-signup.php">		<input type="hidden" name="stage" value="validate-blog-signup" />		<input type="hidden" name="user_name" value="<?php echo esc_attr($user_name) ?>" />		<input type="hidden" name="user_email" value="<?php echo esc_attr($user_email) ?>" />		<?php do_action( "signup_hidden_fields" ); ?>		<?php show_blog_form($blogname, $blog_title, $errors); ?>		<p class="submit"><input type="submit" name="submit" class="submit" value="<?php esc_attr_e('Signup') ?>" /></p>	</form>	<?php}function validate_blog_signup() {	// Re-validate user info.	$result = wpmu_validate_user_signup($_POST['user_name'], $_POST['user_email']);	extract($result);	if ( $errors->get_error_code() ) {		signup_user($user_name, $user_email, $errors);		return false;	}	$result = wpmu_validate_blog_signup($_POST['blogname'], $_POST['blog_title']);	extract($result);	if ( $errors->get_error_code() ) {		signup_blog($user_name, $user_email, $blogname, $blog_title, $errors);		return false;	}	$public = (int) $_POST['blog_public'];	$meta = array ('lang_id' => 1, 'public' => $public);	$meta = apply_filters( "add_signup_meta", $meta );	wpmu_signup_blog($domain, $path, $blog_title, $user_name, $user_email, $meta);	confirm_blog_signup($domain, $path, $blog_title, $user_name, $user_email, $meta);	return true;}function confirm_blog_signup($domain, $path, $blog_title, $user_name = '', $user_email = '', $meta) {	?>	<h2><?php printf( __( 'Congratulations! Your new site, %s, is almost ready.' ), "<a href='http://{$domain}{$path}'>{$blog_title}</a>" ) ?></h2>	<p><?php _e( 'But, before you can start using your site, <strong>you must activate it</strong>.' ) ?></p>	<p><?php printf( __( 'Check your inbox at <strong>%s</strong> and click the link given.' ),  $user_email) ?></p>	<p><?php _e( 'If you do not activate your site within two days, you will have to sign up again.' ); ?></p>	<h2><?php _e( 'Still waiting for your email?' ); ?></h2>	<p>		<?php _e( 'If you haven&#8217;t received your email yet, there are a number of things you can do:' ) ?>		<ul id="noemail-tips">			<li><p><strong><?php _e( 'Wait a little longer. Sometimes delivery of email can be delayed by processes outside of our control.' ) ?></strong></p></li>			<li><p><?php _e( 'Check the junk or spam folder of your email client. Sometime emails wind up there by mistake.' ) ?></p></li>			<li><?php printf( __( 'Have you entered your email correctly?  You have entered %s, if it&#8217;s incorrect, you will not receive your email.' ), $user_email ) ?></li>		</ul>	</p>	<?php	do_action( 'signup_finished' );}// Main$active_signup = get_site_option( 'registration' );if ( !$active_signup )	$active_signup = 'all';$active_signup = apply_filters( 'wpmu_active_signup', $active_signup ); // return "all", "none", "blog" or "user"// Make the signup type translatable.$i18n_signup['all'] = _x('all', 'Multisite active signup type');$i18n_signup['none'] = _x('none', 'Multisite active signup type');$i18n_signup['blog'] = _x('blog', 'Multisite active signup type');$i18n_signup['user'] = _x('user', 'Multisite active signup type');if ( is_super_admin() )	echo '<div class="mu_alert">' . sprintf( __( 'Greetings Site Administrator! You are currently allowing &#8220;%s&#8221; registrations. To change or disable registration go to your <a href="%s">Options page</a>.' ), $i18n_signup[$active_signup], esc_url( network_admin_url( 'ms-options.php' ) ) ) . '</div>';$newblogname = isset($_GET['new']) ? strtolower(preg_replace('/^-|-$|[^-a-zA-Z0-9]/', '', $_GET['new'])) : null;$current_user = wp_get_current_user();if ( $active_signup == "none" ) {	_e( 'Registration has been disabled.' );} elseif ( $active_signup == 'blog' && !is_user_logged_in() ) {	if ( is_ssl() )		$proto = 'https://';	else		$proto = 'http://';	$login_url = site_url( 'wp-login.php?redirect_to=' . urlencode($proto . $_SERVER['HTTP_HOST'] . '/wp-signup.php' ));	echo sprintf( __( 'You must first <a href="%s">log in</a>, and then you can create a new site.' ), $login_url );} else {	$stage = isset( $_POST['stage'] ) ?  $_POST['stage'] : 'default';	switch ( $stage ) {		case 'validate-user-signup' :			if ( $active_signup == 'all' || $_POST[ 'signup_for' ] == 'blog' && $active_signup == 'blog' || $_POST[ 'signup_for' ] == 'user' && $active_signup == 'user' )				validate_user_signup();			else				_e( 'User registration has been disabled.' );		break;		case 'validate-blog-signup':			if ( $active_signup == 'all' || $active_signup == 'blog' )				validate_blog_signup();			else				_e( 'Site registration has been disabled.' );			break;		case 'gimmeanotherblog':			validate_another_blog_signup();			break;		case 'default':		default :			$user_email = isset( $_POST[ 'user_email' ] ) ? $_POST[ 'user_email' ] : '';			do_action( "preprocess_signup_form" ); // populate the form from invites, elsewhere?			if ( is_user_logged_in() && ( $active_signup == 'all' || $active_signup == 'blog' ) )				signup_another_blog($newblogname);			elseif ( is_user_logged_in() == false && ( $active_signup == 'all' || $active_signup == 'user' ) )				signup_user( $newblogname, $user_email );			elseif ( is_user_logged_in() == false && ( $active_signup == 'blog' ) )				_e( 'Sorry, new registrations are not allowed at this time.' );			else				_e( 'You are logged in already. No need to register again!' );			if ( $newblogname ) {				$newblog = get_blogaddress_by_name( $newblogname );				if ( $active_signup == 'blog' || $active_signup == 'all' )					printf( __( '<p><em>The site you were looking for, <strong>%s</strong> does not exist, but you can create it now!</em></p>' ), $newblog );				else					printf( __( '<p><em>The site you were looking for, <strong>%s</strong>, does not exist.</em></p>' ), $newblog );			}			break;	}}?></div></div><?php do_action( 'after_signup_form' ); ?><?php get_footer(); ?>
<?php/** * File contains all the administration image manipulation functions. * * @package WordPress * @subpackage Administration *//** The descriptions for theme files. */$wp_file_descriptions = array (	'index.php' => __( 'Main Index Template' ),	'style.css' => __( 'Stylesheet' ),	'editor-style.css' => __( 'Visual Editor Stylesheet' ),	'rtl.css' => __( 'RTL Stylesheet' ),	'comments.php' => __( 'Comments' ),	'comments-popup.php' => __( 'Popup Comments' ),	'footer.php' => __( 'Footer' ),	'header.php' => __( 'Header' ),	'sidebar.php' => __( 'Sidebar' ),	'archive.php' => __( 'Archives' ),	'author.php' => __( 'Author Template' ),	'tag.php' => __( 'Tag Template' ),	'category.php' => __( 'Category Template' ),	'page.php' => __( 'Page Template' ),	'search.php' => __( 'Search Results' ),	'searchform.php' => __( 'Search Form' ),	'single.php' => __( 'Single Post' ),	'404.php' => __( '404 Template' ),	'link.php' => __( 'Links Template' ),	'functions.php' => __( 'Theme Functions' ),	'attachment.php' => __( 'Attachment Template' ),	'image.php' => __('Image Attachment Template'),	'video.php' => __('Video Attachment Template'),	'audio.php' => __('Audio Attachment Template'),	'application.php' => __('Application Attachment Template'),	'my-hacks.php' => __( 'my-hacks.php (legacy hacks support)' ),	'.htaccess' => __( '.htaccess (for rewrite rules )' ),	// Deprecated files	'wp-layout.css' => __( 'Stylesheet' ), 'wp-comments.php' => __( 'Comments Template' ), 'wp-comments-popup.php' => __( 'Popup Comments Template' ));/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $file * @return unknown */function get_file_description( $file ) {	global $wp_file_descriptions;	if ( isset( $wp_file_descriptions[basename( $file )] ) ) {		return $wp_file_descriptions[basename( $file )];	}	elseif ( file_exists( $file ) && is_file( $file ) ) {		$template_data = implode( '', file( $file ) );		if ( preg_match( '|Template Name:(.*)$|mi', $template_data, $name ))			return _cleanup_header_comment($name[1]) . ' Page Template';	}	return basename( $file );}/** * {@internal Missing Short Description}} * * @since unknown * * @return unknown */function get_home_path() {	$home = get_option( 'home' );	$siteurl = get_option( 'siteurl' );	if ( $home != '' && $home != $siteurl ) {	        $wp_path_rel_to_home = str_replace($home, '', $siteurl); /* $siteurl - $home */	        $pos = strpos($_SERVER["SCRIPT_FILENAME"], $wp_path_rel_to_home);	        $home_path = substr($_SERVER["SCRIPT_FILENAME"], 0, $pos);		$home_path = trailingslashit( $home_path );	} else {		$home_path = ABSPATH;	}	return $home_path;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $file * @return unknown */function get_real_file_to_edit( $file ) {	if ('index.php' == $file || '.htaccess' == $file ) {		$real_file = get_home_path() . $file;	} else {		$real_file = WP_CONTENT_DIR . $file;	}	return $real_file;}/** * Returns a listing of all files in the specified folder and all subdirectories up to 100 levels deep. * The depth of the recursiveness can be controlled by the $levels param. * * @since 2.6.0 * * @param string $folder Full path to folder * @param int $levels (optional) Levels of folders to follow, Default: 100 (PHP Loop limit). * @return bool|array False on failure, Else array of files */function list_files( $folder = '', $levels = 100 ) {	if ( empty($folder) )		return false;	if ( ! $levels )		return false;	$files = array();	if ( $dir = @opendir( $folder ) ) {		while (($file = readdir( $dir ) ) !== false ) {			if ( in_array($file, array('.', '..') ) )				continue;			if ( is_dir( $folder . '/' . $file ) ) {				$files2 = list_files( $folder . '/' . $file, $levels - 1);				if ( $files2 )					$files = array_merge($files, $files2 );				else					$files[] = $folder . '/' . $file . '/';			} else {				$files[] = $folder . '/' . $file;			}		}	}	@closedir( $dir );	return $files;}/** * Determines a writable directory for temporary files. * Function's preference is to WP_CONTENT_DIR followed by the return value of <code>sys_get_temp_dir()</code>, before finally defaulting to /tmp/ * * In the event that this function does not find a writable location, It may be overridden by the <code>WP_TEMP_DIR</code> constant in your <code>wp-config.php</code> file. * * @since 2.5.0 * * @return string Writable temporary directory */function get_temp_dir() {	static $temp;	if ( defined('WP_TEMP_DIR') )		return trailingslashit(WP_TEMP_DIR);	if ( $temp )		return trailingslashit($temp);	$temp = WP_CONTENT_DIR . '/';	if ( is_dir($temp) && @is_writable($temp) )		return $temp;	if  ( function_exists('sys_get_temp_dir') ) {		$temp = sys_get_temp_dir();		if ( @is_writable($temp) )			return trailingslashit($temp);	}	$temp = ini_get('upload_tmp_dir');	if ( is_dir($temp) && @is_writable($temp) )		return trailingslashit($temp);	$temp = '/tmp/';	return $temp;}/** * Returns a filename of a Temporary unique file. * Please note that the calling function must unlink() this itself. * * The filename is based off the passed parameter or defaults to the current unix timestamp, * while the directory can either be passed as well, or by leaving  it blank, default to a writable temporary directory. * * @since 2.6.0 * * @param string $filename (optional) Filename to base the Unique file off * @param string $dir (optional) Directory to store the file in * @return string a writable filename */function wp_tempnam($filename = '', $dir = '') {	if ( empty($dir) )		$dir = get_temp_dir();	$filename = basename($filename);	if ( empty($filename) )		$filename = time();	$filename = preg_replace('|\..*$|', '.tmp', $filename);	$filename = $dir . wp_unique_filename($dir, $filename);	touch($filename);	return $filename;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $file * @param unknown_type $allowed_files * @return unknown */function validate_file_to_edit( $file, $allowed_files = '' ) {	$code = validate_file( $file, $allowed_files );	if (!$code )		return $file;	switch ( $code ) {		case 1 :			wp_die( __('Sorry, can&#8217;t edit files with &#8220;..&#8221; in the name. If you are trying to edit a file in your WordPress home directory, you can just type the name of the file in.' ));		//case 2 :		//	wp_die( __('Sorry, can&#8217;t call files with their real path.' ));		case 3 :			wp_die( __('Sorry, that file cannot be edited.' ));	}}/** * {@internal Missing Short Description}} * * @since unknown * * @param array $file Reference to a single element of $_FILES. Call the function once for each uploaded file. * @param array $overrides Optional. An associative array of names=>values to override default variables with extract( $overrides, EXTR_OVERWRITE ). * @return array On success, returns an associative array of file attributes. On failure, returns $overrides['upload_error_handler'](&$file, $message ) or array( 'error'=>$message ). */function wp_handle_upload( &$file, $overrides = false, $time = null ) {	// The default error handler.	if ( ! function_exists( 'wp_handle_upload_error' ) ) {		function wp_handle_upload_error( &$file, $message ) {			return array( 'error'=>$message );		}	}	$file = apply_filters( 'wp_handle_upload_prefilter', $file );	// You may define your own function and pass the name in $overrides['upload_error_handler']	$upload_error_handler = 'wp_handle_upload_error';	// You may have had one or more 'wp_handle_upload_prefilter' functions error out the file.  Handle that gracefully.	if ( isset( $file['error'] ) && !is_numeric( $file['error'] ) && $file['error'] )		return $upload_error_handler( $file, $file['error'] );	// You may define your own function and pass the name in $overrides['unique_filename_callback']	$unique_filename_callback = null;	// $_POST['action'] must be set and its value must equal $overrides['action'] or this:	$action = 'wp_handle_upload';	// Courtesy of php.net, the strings that describe the error indicated in $_FILES[{form field}]['error'].	$upload_error_strings = array( false,		__( "The uploaded file exceeds the <code>upload_max_filesize</code> directive in <code>php.ini</code>." ),		__( "The uploaded file exceeds the <em>MAX_FILE_SIZE</em> directive that was specified in the HTML form." ),		__( "The uploaded file was only partially uploaded." ),		__( "No file was uploaded." ),		'',		__( "Missing a temporary folder." ),		__( "Failed to write file to disk." ),		__( "File upload stopped by extension." ));	// All tests are on by default. Most can be turned off by $override[{test_name}] = false;	$test_form = true;	$test_size = true;	$test_upload = true;	// If you override this, you must provide $ext and $type!!!!	$test_type = true;	$mimes = false;	// Install user overrides. Did we mention that this voids your warranty?	if ( is_array( $overrides ) )		extract( $overrides, EXTR_OVERWRITE );	// A correct form post will pass this test.	if ( $test_form && (!isset( $_POST['action'] ) || ($_POST['action'] != $action ) ) )		return call_user_func($upload_error_handler, $file, __( 'Invalid form submission.' ));	// A successful upload will pass this test. It makes no sense to override this one.	if ( $file['error'] > 0 )		return call_user_func($upload_error_handler, $file, $upload_error_strings[$file['error']] );	// A non-empty file will pass this test.	if ( $test_size && !($file['size'] > 0 ) ) {		if ( is_multisite() )			$error_msg = __( 'File is empty. Please upload something more substantial.' );		else			$error_msg = __( 'File is empty. Please upload something more substantial. This error could also be caused by uploads being disabled in your php.ini or by post_max_size being defined as smaller than upload_max_filesize in php.ini.' );		return call_user_func($upload_error_handler, $file, $error_msg);	}	// A properly uploaded file will pass this test. There should be no reason to override this one.	if ( $test_upload && ! @ is_uploaded_file( $file['tmp_name'] ) )		return call_user_func($upload_error_handler, $file, __( 'Specified file failed upload test.' ));	// A correct MIME type will pass this test. Override $mimes or use the upload_mimes filter.	if ( $test_type ) {		$wp_filetype = wp_check_filetype_and_ext( $file['tmp_name'], $file['name'], $mimes );		extract( $wp_filetype );		// Check to see if wp_check_filetype_and_ext() determined the filename was incorrect		if ( $proper_filename )			$file['name'] = $proper_filename;		if ( ( !$type || !$ext ) && !current_user_can( 'unfiltered_upload' ) )			return call_user_func($upload_error_handler, $file, __( 'File type does not meet security guidelines. Try another.' ));		if ( !$ext )			$ext = ltrim(strrchr($file['name'], '.'), '.');		if ( !$type )			$type = $file['type'];	} else {		$type = '';	}	// A writable uploads dir will pass this test. Again, there's no point overriding this one.	if ( ! ( ( $uploads = wp_upload_dir($time) ) && false === $uploads['error'] ) )		return call_user_func($upload_error_handler, $file, $uploads['error'] );	$filename = wp_unique_filename( $uploads['path'], $file['name'], $unique_filename_callback );	// Move the file to the uploads dir	$new_file = $uploads['path'] . "/$filename";	if ( false === @ move_uploaded_file( $file['tmp_name'], $new_file ) )		return $upload_error_handler( $file, sprintf( __('The uploaded file could not be moved to %s.' ), $uploads['path'] ) );	// Set correct file permissions	$stat = stat( dirname( $new_file ));	$perms = $stat['mode'] & 0000666;	@ chmod( $new_file, $perms );	// Compute the URL	$url = $uploads['url'] . "/$filename";	if ( is_multisite() )		delete_transient( 'dirsize_cache' );	return apply_filters( 'wp_handle_upload', array( 'file' => $new_file, 'url' => $url, 'type' => $type ), 'upload' );}/** * {@internal Missing Short Description}} * * Pass this function an array similar to that of a $_FILES POST array. * * @since unknown * * @param unknown_type $file * @param unknown_type $overrides * @return unknown */function wp_handle_sideload( &$file, $overrides = false ) {	// The default error handler.	if (! function_exists( 'wp_handle_upload_error' ) ) {		function wp_handle_upload_error( &$file, $message ) {			return array( 'error'=>$message );		}	}	// You may define your own function and pass the name in $overrides['upload_error_handler']	$upload_error_handler = 'wp_handle_upload_error';	// You may define your own function and pass the name in $overrides['unique_filename_callback']	$unique_filename_callback = null;	// $_POST['action'] must be set and its value must equal $overrides['action'] or this:	$action = 'wp_handle_sideload';	// Courtesy of php.net, the strings that describe the error indicated in $_FILES[{form field}]['error'].	$upload_error_strings = array( false,		__( "The uploaded file exceeds the <code>upload_max_filesize</code> directive in <code>php.ini</code>." ),		__( "The uploaded file exceeds the <em>MAX_FILE_SIZE</em> directive that was specified in the HTML form." ),		__( "The uploaded file was only partially uploaded." ),		__( "No file was uploaded." ),		'',		__( "Missing a temporary folder." ),		__( "Failed to write file to disk." ),		__( "File upload stopped by extension." ));	// All tests are on by default. Most can be turned off by $override[{test_name}] = false;	$test_form = true;	$test_size = true;	// If you override this, you must provide $ext and $type!!!!	$test_type = true;	$mimes = false;	// Install user overrides. Did we mention that this voids your warranty?	if ( is_array( $overrides ) )		extract( $overrides, EXTR_OVERWRITE );	// A correct form post will pass this test.	if ( $test_form && (!isset( $_POST['action'] ) || ($_POST['action'] != $action ) ) )		return $upload_error_handler( $file, __( 'Invalid form submission.' ));	// A successful upload will pass this test. It makes no sense to override this one.	if ( ! empty( $file['error'] ) )		return $upload_error_handler( $file, $upload_error_strings[$file['error']] );	// A non-empty file will pass this test.	if ( $test_size && !(filesize($file['tmp_name']) > 0 ) )		return $upload_error_handler( $file, __( 'File is empty. Please upload something more substantial. This error could also be caused by uploads being disabled in your php.ini.' ));	// A properly uploaded file will pass this test. There should be no reason to override this one.	if (! @ is_file( $file['tmp_name'] ) )		return $upload_error_handler( $file, __( 'Specified file does not exist.' ));	// A correct MIME type will pass this test. Override $mimes or use the upload_mimes filter.	if ( $test_type ) {		$wp_filetype = wp_check_filetype_and_ext( $file['tmp_name'], $file['name'], $mimes );		extract( $wp_filetype );		// Check to see if wp_check_filetype_and_ext() determined the filename was incorrect		if ( $proper_filename )			$file['name'] = $proper_filename;		if ( ( !$type || !$ext ) && !current_user_can( 'unfiltered_upload' ) )			return $upload_error_handler( $file, __( 'File type does not meet security guidelines. Try another.' ));		if ( !$ext )			$ext = ltrim(strrchr($file['name'], '.'), '.');		if ( !$type )			$type = $file['type'];	}	// A writable uploads dir will pass this test. Again, there's no point overriding this one.	if ( ! ( ( $uploads = wp_upload_dir() ) && false === $uploads['error'] ) )		return $upload_error_handler( $file, $uploads['error'] );	$filename = wp_unique_filename( $uploads['path'], $file['name'], $unique_filename_callback );	// Strip the query strings.	$filename = str_replace('?','-', $filename);	$filename = str_replace('&','-', $filename);	// Move the file to the uploads dir	$new_file = $uploads['path'] . "/$filename";	if ( false === @ rename( $file['tmp_name'], $new_file ) ) {		return $upload_error_handler( $file, sprintf( __('The uploaded file could not be moved to %s.' ), $uploads['path'] ) );	}	// Set correct file permissions	$stat = stat( dirname( $new_file ));	$perms = $stat['mode'] & 0000666;	@ chmod( $new_file, $perms );	// Compute the URL	$url = $uploads['url'] . "/$filename";	$return = apply_filters( 'wp_handle_upload', array( 'file' => $new_file, 'url' => $url, 'type' => $type ), 'sideload' );	return $return;}/** * Downloads a url to a local temporary file using the WordPress HTTP Class. * Please note, That the calling function must unlink() the  file. * * @since 2.5.0 * * @param string $url the URL of the file to download * @return mixed WP_Error on failure, string Filename on success. */function download_url( $url ) {	//WARNING: The file is not automatically deleted, The script must unlink() the file.	if ( ! $url )		return new WP_Error('http_no_url', __('Invalid URL Provided.'));	$tmpfname = wp_tempnam($url);	if ( ! $tmpfname )		return new WP_Error('http_no_file', __('Could not create Temporary file.'));	$handle = @fopen($tmpfname, 'wb');	if ( ! $handle )		return new WP_Error('http_no_file', __('Could not create Temporary file.'));	$response = wp_remote_get($url, array('timeout' => 300));	if ( is_wp_error($response) ) {		fclose($handle);		unlink($tmpfname);		return $response;	}	if ( $response['response']['code'] != '200' ){		fclose($handle);		unlink($tmpfname);		return new WP_Error('http_404', trim($response['response']['message']));	}	fwrite($handle, $response['body']);	fclose($handle);	return $tmpfname;}/** * Unzip's a specified ZIP file to a location on the Filesystem via the WordPress Filesystem Abstraction. * Assumes that WP_Filesystem() has already been called and set up. Does not extract a root-level __MACOSX directory, if present. * * Attempts to increase the PHP Memory limit to 256M before uncompressing, * However, The most memory required shouldn't be much larger than the Archive itself. * * @since 2.5.0 * * @param string $file Full path and filename of zip archive * @param string $to Full path on the filesystem to extract archive to * @return mixed WP_Error on failure, True on success */function unzip_file($file, $to) {	global $wp_filesystem;	if ( ! $wp_filesystem || !is_object($wp_filesystem) )		return new WP_Error('fs_unavailable', __('Could not access filesystem.'));	// Unzip can use a lot of memory, but not this much hopefully	@ini_set('memory_limit', '256M');	$needed_dirs = array();	$to = trailingslashit($to);	// Determine any parent dir's needed (of the upgrade directory)	if ( ! $wp_filesystem->is_dir($to) ) { //Only do parents if no children exist		$path = preg_split('![/\\\]!', untrailingslashit($to));		for ( $i = count($path); $i >= 0; $i-- ) {			if ( empty($path[$i]) )				continue;			$dir = implode('/', array_slice($path, 0, $i+1) );			if ( preg_match('!^[a-z]:$!i', $dir) ) // Skip it if it looks like a Windows Drive letter.				continue;			if ( ! $wp_filesystem->is_dir($dir) )				$needed_dirs[] = $dir;			else				break; // A folder exists, therefor, we dont need the check the levels below this		}	}	if ( class_exists('ZipArchive') && apply_filters('unzip_file_use_ziparchive', true ) ) {		$result = _unzip_file_ziparchive($file, $to, $needed_dirs);		if ( true === $result ) {			return $result;		} elseif ( is_wp_error($result) ) {			if ( 'incompatible_archive' != $result->get_error_code() )				return $result;		}	}	// Fall through to PclZip if ZipArchive is not available, or encountered an error opening the file.	return _unzip_file_pclzip($file, $to, $needed_dirs);}/** * This function should not be called directly, use unzip_file instead. Attempts to unzip an archive using the ZipArchive class. * Assumes that WP_Filesystem() has already been called and set up. * * @since 3.0.0 * @see unzip_file * @access private * * @param string $file Full path and filename of zip archive * @param string $to Full path on the filesystem to extract archive to * @param array $needed_dirs A partial list of required folders needed to be created. * @return mixed WP_Error on failure, True on success */function _unzip_file_ziparchive($file, $to, $needed_dirs = array() ) {	global $wp_filesystem;	$z = new ZipArchive();	// PHP4-compat - php4 classes can't contain constants	$zopen = $z->open($file, /* ZIPARCHIVE::CHECKCONS */ 4);	if ( true !== $zopen )		return new WP_Error('incompatible_archive', __('Incompatible Archive.'));	for ( $i = 0; $i < $z->numFiles; $i++ ) {		if ( ! $info = $z->statIndex($i) )			return new WP_Error('stat_failed', __('Could not retrieve file from archive.'));		if ( '__MACOSX/' === substr($info['name'], 0, 9) ) // Skip the OS X-created __MACOSX directory			continue;		if ( '/' == substr($info['name'], -1) ) // directory			$needed_dirs[] = $to . untrailingslashit($info['name']);		else			$needed_dirs[] = $to . untrailingslashit(dirname($info['name']));	}	$needed_dirs = array_unique($needed_dirs);	foreach ( $needed_dirs as $dir ) {		// Check the parent folders of the folders all exist within the creation array.		if ( untrailingslashit($to) == $dir ) // Skip over the working directory, We know this exists (or will exist)			continue;		if ( strpos($dir, $to) === false ) // If the directory is not within the working directory, Skip it			continue;		$parent_folder = dirname($dir);		while ( !empty($parent_folder) && untrailingslashit($to) != $parent_folder && !in_array($parent_folder, $needed_dirs) ) {			$needed_dirs[] = $parent_folder;			$parent_folder = dirname($parent_folder);		}	}	asort($needed_dirs);	// Create those directories if need be:	foreach ( $needed_dirs as $_dir ) {		if ( ! $wp_filesystem->mkdir($_dir, FS_CHMOD_DIR) && ! $wp_filesystem->is_dir($_dir) ) // Only check to see if the Dir exists upon creation failure. Less I/O this way.			return new WP_Error('mkdir_failed', __('Could not create directory.'), $_dir);	}	unset($needed_dirs);	for ( $i = 0; $i < $z->numFiles; $i++ ) {		if ( ! $info = $z->statIndex($i) )			return new WP_Error('stat_failed', __('Could not retrieve file from archive.'));		if ( '/' == substr($info['name'], -1) ) // directory			continue;		if ( '__MACOSX/' === substr($info['name'], 0, 9) ) // Don't extract the OS X-created __MACOSX directory files			continue;		$contents = $z->getFromIndex($i);		if ( false === $contents )			return new WP_Error('extract_failed', __('Could not extract file from archive.'), $info['name']);		if ( ! $wp_filesystem->put_contents( $to . $info['name'], $contents, FS_CHMOD_FILE) )			return new WP_Error('copy_failed', __('Could not copy file.'), $to . $info['filename']);	}	$z->close();	return true;}/** * This function should not be called directly, use unzip_file instead. Attempts to unzip an archive using the PclZip library. * Assumes that WP_Filesystem() has already been called and set up. * * @since 3.0.0 * @see unzip_file * @access private * * @param string $file Full path and filename of zip archive * @param string $to Full path on the filesystem to extract archive to * @param array $needed_dirs A partial list of required folders needed to be created. * @return mixed WP_Error on failure, True on success */function _unzip_file_pclzip($file, $to, $needed_dirs = array()) {	global $wp_filesystem;	require_once(ABSPATH . 'wp-admin/includes/class-pclzip.php');	$archive = new PclZip($file);	// Is the archive valid?	if ( false == ($archive_files = $archive->extract(PCLZIP_OPT_EXTRACT_AS_STRING)) )		return new WP_Error('incompatible_archive', __('Incompatible Archive.'), $archive->errorInfo(true));	if ( 0 == count($archive_files) )		return new WP_Error('empty_archive', __('Empty archive.'));	// Determine any children directories needed (From within the archive)	foreach ( $archive_files as $file ) {		if ( '__MACOSX/' === substr($file['filename'], 0, 9) ) // Skip the OS X-created __MACOSX directory			continue;		$needed_dirs[] = $to . untrailingslashit( $file['folder'] ? $file['filename'] : dirname($file['filename']) );	}	$needed_dirs = array_unique($needed_dirs);	foreach ( $needed_dirs as $dir ) {		// Check the parent folders of the folders all exist within the creation array.		if ( untrailingslashit($to) == $dir ) // Skip over the working directory, We know this exists (or will exist)			continue;		if ( strpos($dir, $to) === false ) // If the directory is not within the working directory, Skip it			continue;		$parent_folder = dirname($dir);		while ( !empty($parent_folder) && untrailingslashit($to) != $parent_folder && !in_array($parent_folder, $needed_dirs) ) {			$needed_dirs[] = $parent_folder;			$parent_folder = dirname($parent_folder);		}	}	asort($needed_dirs);	// Create those directories if need be:	foreach ( $needed_dirs as $_dir ) {		if ( ! $wp_filesystem->mkdir($_dir, FS_CHMOD_DIR) && ! $wp_filesystem->is_dir($_dir) ) // Only check to see if the dir exists upon creation failure. Less I/O this way.			return new WP_Error('mkdir_failed', __('Could not create directory.'), $_dir);	}	unset($needed_dirs);	// Extract the files from the zip	foreach ( $archive_files as $file ) {		if ( $file['folder'] )			continue;		if ( '__MACOSX/' === substr($file['filename'], 0, 9) ) // Don't extract the OS X-created __MACOSX directory files			continue;		if ( ! $wp_filesystem->put_contents( $to . $file['filename'], $file['content'], FS_CHMOD_FILE) )			return new WP_Error('copy_failed', __('Could not copy file.'), $to . $file['filename']);	}	return true;}/** * Copies a directory from one location to another via the WordPress Filesystem Abstraction. * Assumes that WP_Filesystem() has already been called and setup. * * @since 2.5.0 * * @param string $from source directory * @param string $to destination directory * @return mixed WP_Error on failure, True on success. */function copy_dir($from, $to) {	global $wp_filesystem;	$dirlist = $wp_filesystem->dirlist($from);	$from = trailingslashit($from);	$to = trailingslashit($to);	foreach ( (array) $dirlist as $filename => $fileinfo ) {		if ( 'f' == $fileinfo['type'] ) {			if ( ! $wp_filesystem->copy($from . $filename, $to . $filename, true) ) {				// If copy failed, chmod file to 0644 and try again.				$wp_filesystem->chmod($to . $filename, 0644);				if ( ! $wp_filesystem->copy($from . $filename, $to . $filename, true) )					return new WP_Error('copy_failed', __('Could not copy file.'), $to . $filename);			}			$wp_filesystem->chmod($to . $filename, FS_CHMOD_FILE);		} elseif ( 'd' == $fileinfo['type'] ) {			if ( !$wp_filesystem->is_dir($to . $filename) ) {				if ( !$wp_filesystem->mkdir($to . $filename, FS_CHMOD_DIR) )					return new WP_Error('mkdir_failed', __('Could not create directory.'), $to . $filename);			}			$result = copy_dir($from . $filename, $to . $filename);			if ( is_wp_error($result) )				return $result;		}	}	return true;}/** * Initialises and connects the WordPress Filesystem Abstraction classes. * This function will include the chosen transport and attempt connecting. * * Plugins may add extra transports, And force WordPress to use them by returning the filename via the 'filesystem_method_file' filter. * * @since 2.5.0 * * @param array $args (optional) Connection args, These are passed directly to the WP_Filesystem_*() classes. * @param string $context (optional) Context for get_filesystem_method(), See function declaration for more information. * @return boolean false on failure, true on success */function WP_Filesystem( $args = false, $context = false ) {	global $wp_filesystem;	require_once(ABSPATH . 'wp-admin/includes/class-wp-filesystem-base.php');	$method = get_filesystem_method($args, $context);	if ( ! $method )		return false;	if ( ! class_exists("WP_Filesystem_$method") ) {		$abstraction_file = apply_filters('filesystem_method_file', ABSPATH . 'wp-admin/includes/class-wp-filesystem-' . $method . '.php', $method);		if ( ! file_exists($abstraction_file) )			return;		require_once($abstraction_file);	}	$method = "WP_Filesystem_$method";	$wp_filesystem = new $method($args);	//Define the timeouts for the connections. Only available after the construct is called to allow for per-transport overriding of the default.	if ( ! defined('FS_CONNECT_TIMEOUT') )		define('FS_CONNECT_TIMEOUT', 30);	if ( ! defined('FS_TIMEOUT') )		define('FS_TIMEOUT', 30);	if ( is_wp_error($wp_filesystem->errors) && $wp_filesystem->errors->get_error_code() )		return false;	if ( !$wp_filesystem->connect() )		return false; //There was an erorr connecting to the server.	// Set the permission constants if not already set.	if ( ! defined('FS_CHMOD_DIR') )		define('FS_CHMOD_DIR', 0755 );	if ( ! defined('FS_CHMOD_FILE') )		define('FS_CHMOD_FILE', 0644 );	return true;}/** * Determines which Filesystem Method to use. * The priority of the Transports are: Direct, SSH2, FTP PHP Extension, FTP Sockets (Via Sockets class, or fsoxkopen()) * * Note that the return value of this function can be overridden in 2 ways *  - By defining FS_METHOD in your <code>wp-config.php</code> file *  - By using the filesystem_method filter * Valid values for these are: 'direct', 'ssh', 'ftpext' or 'ftpsockets' * Plugins may also define a custom transport handler, See the WP_Filesystem function for more information. * * @since 2.5.0 * * @param array $args Connection details. * @param string $context Full path to the directory that is tested for being writable. * @return string The transport to use, see description for valid return values. */function get_filesystem_method($args = array(), $context = false) {	$method = defined('FS_METHOD') ? FS_METHOD : false; //Please ensure that this is either 'direct', 'ssh', 'ftpext' or 'ftpsockets'	if ( ! $method && function_exists('getmyuid') && function_exists('fileowner') ){		if ( !$context )			$context = WP_CONTENT_DIR;		$context = trailingslashit($context);		$temp_file_name = $context . 'temp-write-test-' . time();		$temp_handle = @fopen($temp_file_name, 'w');		if ( $temp_handle ) {			if ( getmyuid() == @fileowner($temp_file_name) )				$method = 'direct';			@fclose($temp_handle);			@unlink($temp_file_name);		} 	}	if ( ! $method && isset($args['connection_type']) && 'ssh' == $args['connection_type'] && extension_loaded('ssh2') && function_exists('stream_get_contents') ) $method = 'ssh2';	if ( ! $method && extension_loaded('ftp') ) $method = 'ftpext';	if ( ! $method && ( extension_loaded('sockets') || function_exists('fsockopen') ) ) $method = 'ftpsockets'; //Sockets: Socket extension; PHP Mode: FSockopen / fwrite / fread	return apply_filters('filesystem_method', $method, $args);}/** * Displays a form to the user to request for their FTP/SSH details in order to  connect to the filesystem. * All chosen/entered details are saved, Excluding the Password. * * Hostnames may be in the form of hostname:portnumber (eg: wordpress.org:2467) to specify an alternate FTP/SSH port. * * Plugins may override this form by returning true|false via the <code>request_filesystem_credentials</code> filter. * * @since 2.5.0 * * @param string $form_post the URL to post the form to * @param string $type the chosen Filesystem method in use * @param boolean $error if the current request has failed to connect * @param string $context The directory which is needed access to, The write-test will be performed on  this directory by get_filesystem_method() * @param string $extra_fields Extra POST fields which should be checked for to be included in the post. * @return boolean False on failure. True on success. */function request_filesystem_credentials($form_post, $type = '', $error = false, $context = false, $extra_fields = null) {	$req_cred = apply_filters( 'request_filesystem_credentials', '', $form_post, $type, $error, $context, $extra_fields );	if ( '' !== $req_cred )		return $req_cred;	if ( empty($type) )		$type = get_filesystem_method(array(), $context);	if ( 'direct' == $type )		return true;	if ( is_null( $extra_fields ) )		$extra_fields = array( 'version', 'locale' );	$credentials = get_option('ftp_credentials', array( 'hostname' => '', 'username' => ''));	// If defined, set it to that, Else, If POST'd, set it to that, If not, Set it to whatever it previously was(saved details in option)	$credentials['hostname'] = defined('FTP_HOST') ? FTP_HOST : (!empty($_POST['hostname']) ? stripslashes($_POST['hostname']) : $credentials['hostname']);	$credentials['username'] = defined('FTP_USER') ? FTP_USER : (!empty($_POST['username']) ? stripslashes($_POST['username']) : $credentials['username']);	$credentials['password'] = defined('FTP_PASS') ? FTP_PASS : (!empty($_POST['password']) ? stripslashes($_POST['password']) : '');	// Check to see if we are setting the public/private keys for ssh	$credentials['public_key'] = defined('FTP_PUBKEY') ? FTP_PUBKEY : (!empty($_POST['public_key']) ? stripslashes($_POST['public_key']) : '');	$credentials['private_key'] = defined('FTP_PRIKEY') ? FTP_PRIKEY : (!empty($_POST['private_key']) ? stripslashes($_POST['private_key']) : '');	//sanitize the hostname, Some people might pass in odd-data:	$credentials['hostname'] = preg_replace('|\w+://|', '', $credentials['hostname']); //Strip any schemes off	if ( strpos($credentials['hostname'], ':') ) {		list( $credentials['hostname'], $credentials['port'] ) = explode(':', $credentials['hostname'], 2);		if ( ! is_numeric($credentials['port']) )			unset($credentials['port']);	} else {		unset($credentials['port']);	}	if ( (defined('FTP_SSH') && FTP_SSH) || (defined('FS_METHOD') && 'ssh' == FS_METHOD) )		$credentials['connection_type'] = 'ssh';	else if ( (defined('FTP_SSL') && FTP_SSL) && 'ftpext' == $type ) //Only the FTP Extension understands SSL		$credentials['connection_type'] = 'ftps';	else if ( !empty($_POST['connection_type']) )		$credentials['connection_type'] = stripslashes($_POST['connection_type']);	else if ( !isset($credentials['connection_type']) ) //All else fails (And its not defaulted to something else saved), Default to FTP		$credentials['connection_type'] = 'ftp';	if ( ! $error &&			(				( !empty($credentials['password']) && !empty($credentials['username']) && !empty($credentials['hostname']) ) ||				( 'ssh' == $credentials['connection_type'] && !empty($credentials['public_key']) && !empty($credentials['private_key']) )			) ) {		$stored_credentials = $credentials;		if ( !empty($stored_credentials['port']) ) //save port as part of hostname to simplify above code.			$stored_credentials['hostname'] .= ':' . $stored_credentials['port'];		unset($stored_credentials['password'], $stored_credentials['port'], $stored_credentials['private_key'], $stored_credentials['public_key']);		update_option('ftp_credentials', $stored_credentials);		return $credentials;	}	$hostname = '';	$username = '';	$password = '';	$connection_type = '';	if ( !empty($credentials) )		extract($credentials, EXTR_OVERWRITE);	if ( $error ) {		$error_string = __('<strong>Error:</strong> There was an error connecting to the server, Please verify the settings are correct.');		if ( is_wp_error($error) )			$error_string = $error->get_error_message();		echo '<div id="message" class="error"><p>' . $error_string . '</p></div>';	}	$types = array();	if ( extension_loaded('ftp') || extension_loaded('sockets') || function_exists('fsockopen') )		$types[ 'ftp' ] = __('FTP');	if ( extension_loaded('ftp') ) //Only this supports FTPS		$types[ 'ftps' ] = __('FTPS (SSL)');	if ( extension_loaded('ssh2') && function_exists('stream_get_contents') )		$types[ 'ssh' ] = __('SSH2');	$types = apply_filters('fs_ftp_connection_types', $types, $credentials, $type, $error, $context);?><script type="text/javascript"><!--jQuery(function($){	jQuery("#ssh").click(function () {		jQuery("#ssh_keys").show();	});	jQuery("#ftp, #ftps").click(function () {		jQuery("#ssh_keys").hide();	});	jQuery('form input[value=""]:first').focus();});--></script><form action="<?php echo $form_post ?>" method="post"><div class="wrap"><?php screen_icon(); ?><h2><?php _e('Connection Information') ?></h2><p><?php	$label_user = __('Username');	$label_pass = __('Password');	_e('To perform the requested action, WordPress needs to access to your web server.');	echo ' ';	if ( ( isset( $types['ftp'] ) || isset( $types['ftps'] ) ) ) {		if ( isset( $types['ssh'] ) ) {			_e('Please enter your FTP or SSH credentials to proceed.');			$label_user = __('FTP/SSH Username');			$label_pass = __('FTP/SSH Password');		} else {			_e('Please enter your FTP credentials to proceed.');			$label_user = __('FTP Username');			$label_pass = __('FTP Password');		}		echo ' ';	}	_e('If you do not remember your credentials, you should contact your web host.');?></p><table class="form-table"><tr valign="top"><th scope="row"><label for="hostname"><?php _e('Hostname') ?></label></th><td><input name="hostname" type="text" id="hostname" value="<?php echo esc_attr($hostname); if ( !empty($port) ) echo ":$port"; ?>"<?php disabled( defined('FTP_HOST') ); ?> size="40" /></td></tr><tr valign="top"><th scope="row"><label for="username"><?php echo $label_user; ?></label></th><td><input name="username" type="text" id="username" value="<?php echo esc_attr($username) ?>"<?php disabled( defined('FTP_USER') ); ?> size="40" /></td></tr><tr valign="top"><th scope="row"><label for="password"><?php echo $label_pass; ?></label></th><td><input name="password" type="password" id="password" value="<?php if ( defined('FTP_PASS') ) echo '*****'; ?>"<?php disabled( defined('FTP_PASS') ); ?> size="40" /></td></tr><?php if ( isset($types['ssh']) ) : ?><tr id="ssh_keys" valign="top" style="<?php if ( 'ssh' != $connection_type ) echo 'display:none' ?>"><th scope="row"><?php _e('Authentication Keys') ?><div class="key-labels textright"><label for="public_key"><?php _e('Public Key:') ?></label ><br /><label for="private_key"><?php _e('Private Key:') ?></label></div></th><td><br /><input name="public_key" type="text" id="public_key" value="<?php echo esc_attr($public_key) ?>"<?php disabled( defined('FTP_PUBKEY') ); ?> size="40" /><br /><input name="private_key" type="text" id="private_key" value="<?php echo esc_attr($private_key) ?>"<?php disabled( defined('FTP_PRIKEY') ); ?> size="40" /><div><?php _e('Enter the location on the server where the keys are located. If a passphrase is needed, enter that in the password field above.') ?></div></td></tr><?php endif; ?><tr valign="top"><th scope="row"><?php _e('Connection Type') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Connection Type') ?></span></legend><?php	$disabled = disabled( (defined('FTP_SSL') && FTP_SSL) || (defined('FTP_SSH') && FTP_SSH), true, false );	foreach ( $types as $name => $text ) : ?>	<label for="<?php echo esc_attr($name) ?>">		<input type="radio" name="connection_type" id="<?php echo esc_attr($name) ?>" value="<?php echo esc_attr($name) ?>"<?php checked($name, $connection_type); echo $disabled; ?> />		<?php echo $text ?>	</label>	<?php endforeach; ?></fieldset></td></tr></table><?phpforeach ( (array) $extra_fields as $field ) {	if ( isset( $_POST[ $field ] ) )		echo '<input type="hidden" name="' . esc_attr( $field ) . '" value="' . esc_attr( stripslashes( $_POST[ $field ] ) ) . '" />';}?><p class="submit"><input id="upgrade" name="upgrade" type="submit" class="button" value="<?php esc_attr_e('Proceed'); ?>" /></p></div></form><?php	return false;}?>
<?php/** * Multisite delete site panel. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */require_once( './admin.php' );if ( !is_multisite() )	wp_die( __( 'Multisite support is not enabled.' ) );// @todo Create a delete blog cap.if ( ! current_user_can( 'manage_options' ) )	wp_die(__( 'You do not have sufficient permissions to delete this site.'));if ( isset( $_GET['h'] ) && $_GET['h'] != '' && get_option( 'delete_blog_hash' ) != false ) {	if ( get_option( 'delete_blog_hash' ) == $_GET['h'] ) {		wpmu_delete_blog( $wpdb->blogid );		wp_die( sprintf( __( 'Thank you for using %s, your site has been deleted. Happy trails to you until we meet again.' ), $current_site->site_name ) );	} else {		wp_die( __( "I'm sorry, the link you clicked is stale. Please select another option." ) );	}}$title = __( 'Delete Site' );$parent_file = 'tools.php';require_once( './admin-header.php' );echo '<div class="wrap">';screen_icon();echo '<h2>' . esc_html( $title ) . '</h2>';if ( isset( $_POST['action'] ) && $_POST['action'] == 'deleteblog' && isset( $_POST['confirmdelete'] ) && $_POST['confirmdelete'] == '1' ) {	$hash = wp_generate_password( 20, false );	update_option( 'delete_blog_hash', $hash );	$url_delete = esc_url( admin_url( 'ms-delete-site.php?h=' . $hash ) );	$content = apply_filters( 'delete_site_email_content', __( "Dear User,You recently clicked the 'Delete Site' link on your site and filled in aform on that page.If you really want to delete your site, click the link below. You will notbe asked to confirm again so only click this link if you are absolutely certain:###URL_DELETE###If you delete your site, please consider opening a new site heresome time in the future! (But remember your current site and usernameare gone forever.)Thanks for using the site,Webmaster###SITE_NAME###" ) );	$content = str_replace( '###URL_DELETE###', $url_delete, $content );	$content = str_replace( '###SITE_NAME###', $current_site->site_name, $content );	wp_mail( get_option( 'admin_email' ), "[ " . get_option( 'blogname' ) . " ] ".__( 'Delete My Site' ), $content );	?>	<p><?php _e( 'Thank you. Please check your email for a link to confirm your action. Your site will not be deleted until this link is clicked. ') ?></p><?php } else {	?>	<p><?php printf( __( 'If you do not want to use your %s site any more, you can delete it using the form below. When you click <strong>Delete My Site Permanently</strong> you will be sent an email with a link in it. Click on this link to delete your site.'), $current_site->site_name); ?></p>	<p><?php _e( 'Remember, once deleted your site cannot be restored.' ) ?></p>	<form method="post" name="deletedirect">		<input type="hidden" name="action" value="deleteblog" />		<p><input id="confirmdelete" type="checkbox" name="confirmdelete" value="1" /> <label for="confirmdelete"><strong><?php printf( __( "I'm sure I want to permanently disable my site, and I am aware I can never get it back or use %s again." ), is_subdomain_install() ? $current_blog->domain : $current_blog->domain . $current_blog->path ); ?></strong></label></p>		<p class="submit"><input type="submit" value="<?php esc_attr_e( 'Delete My Site Permanently' ) ?>" /></p>	</form>	<?php}echo '</div>';include( './admin-footer.php' );?>
<?php/** * The Template for displaying all single posts. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main"><?php if ( have_posts() ) while ( have_posts() ) : the_post(); ?>				<div id="nav-above" class="navigation">					<div class="nav-previous"><?php previous_post_link( '%link', '<span class="meta-nav">' . _x( '&larr;', 'Previous post link', 'twentyten' ) . '</span> %title' ); ?></div>					<div class="nav-next"><?php next_post_link( '%link', '%title <span class="meta-nav">' . _x( '&rarr;', 'Next post link', 'twentyten' ) . '</span>' ); ?></div>				</div><!-- #nav-above -->				<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>					<h1 class="entry-title"><?php the_title(); ?></h1>					<div class="entry-meta">						<?php twentyten_posted_on(); ?>					</div><!-- .entry-meta -->					<div class="entry-content">						<?php the_content(); ?>						<?php wp_link_pages( array( 'before' => '<div class="page-link">' . __( 'Pages:', 'twentyten' ), 'after' => '</div>' ) ); ?>					</div><!-- .entry-content --><?php if ( get_the_author_meta( 'description' ) ) : // If a user has filled out their description, show a bio on their entries  ?>					<div id="entry-author-info">						<div id="author-avatar">							<?php echo get_avatar( get_the_author_meta( 'user_email' ), apply_filters( 'twentyten_author_bio_avatar_size', 60 ) ); ?>						</div><!-- #author-avatar -->						<div id="author-description">							<h2><?php printf( esc_attr__( 'About %s', 'twentyten' ), get_the_author() ); ?></h2>							<?php the_author_meta( 'description' ); ?>							<div id="author-link">								<a href="<?php echo get_author_posts_url( get_the_author_meta( 'ID' ) ); ?>">									<?php printf( __( 'View all posts by %s <span class="meta-nav">&rarr;</span>', 'twentyten' ), get_the_author() ); ?>								</a>							</div><!-- #author-link	-->						</div><!-- #author-description -->					</div><!-- #entry-author-info --><?php endif; ?>					<div class="entry-utility">						<?php twentyten_posted_in(); ?>						<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="edit-link">', '</span>' ); ?>					</div><!-- .entry-utility -->				</div><!-- #post-## -->				<div id="nav-below" class="navigation">					<div class="nav-previous"><?php previous_post_link( '%link', '<span class="meta-nav">' . _x( '&larr;', 'Previous post link', 'twentyten' ) . '</span> %title' ); ?></div>					<div class="nav-next"><?php next_post_link( '%link', '%title <span class="meta-nav">' . _x( '&rarr;', 'Next post link', 'twentyten' ) . '</span>' ); ?></div>				</div><!-- #nav-below -->				<?php comments_template( '', true ); ?><?php endwhile; // end of the loop. ?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
<?php/** * Deprecated functions from WordPress MU and the multisite feature. You shouldn't * use these functions and look for the alternatives instead. The functions will be * removed in a later version. * * @package WordPress * @subpackage Deprecated * @since 3.0.0 *//* * Deprecated functions come here to die. *//** * @since unknown * @deprecated 3.0.0 * @deprecated Use wp_generate_password() * @see wp_generate_password() */function generate_random_password( $len = 8 ) {	_deprecated_function( __FUNCTION__, '3.0', 'wp_generate_password()' );	return wp_generate_password( $len );}/** * Determine if user is a site admin. * * Plugins should use is_multisite() instead of checking if this function exists * to determine if multisite is enabled. * * This function must reside in a file included only if is_multisite() due to * legacy function_exists() checks to determine if multisite is enabled. * * @since MU * @deprecated 3.0.0 * @deprecated Use is_super_admin() * @see is_super_admin() * @see is_multisite() * */function is_site_admin( $user_login = '' ) {	_deprecated_function( __FUNCTION__, '3.0', 'is_super_admin()' );	if ( empty( $user_login ) ) {		$user_id = get_current_user_id();		if ( !$user_id )			return false;	} else {		$user = new WP_User( null, $user_login) ;		if ( empty( $user->id ) )			return false;		$user_id = $user->id;	}	return is_super_admin( $user_id );}if ( !function_exists( 'graceful_fail' ) ) :/** * @since MU * @deprecated 3.0.0 * @deprecated Use wp_die() * @see wp_die() */function graceful_fail( $message ) {	_deprecated_function( __FUNCTION__, '3.0', 'wp_die()' );	$message = apply_filters( 'graceful_fail', $message );	$message_template = apply_filters( 'graceful_fail_template','<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head profile="http://gmpg.org/xfn/11"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Error!</title><style type="text/css">img {	border: 0;}body {line-height: 1.6em; font-family: Georgia, serif; width: 390px; margin: auto;text-align: center;}.message {	font-size: 22px;	width: 350px;	margin: auto;}</style></head><body><p class="message">%s</p></body></html>' );	die( sprintf( $message_template, $message ) );}endif;/** * @since MU * @deprecated 3.0.0 * @deprecated Use get_user_by() * @see get_user_by() */function get_user_details( $username ) {	_deprecated_function( __FUNCTION__, '3.0', 'get_user_by()' );	return get_user_by('login', $username);}/** * @since MU * @deprecated 3.0.0 * @deprecated Use clean_post_cache() * @see clean_post_cache() */function clear_global_post_cache( $post_id ) {	_deprecated_function( __FUNCTION__, '3.0', 'clean_post_cache()' );}/** * @since MU * @deprecated 3.0.0 * @deprecated Use is_main_site() * @see is_main_site() */function is_main_blog() {	_deprecated_function( __FUNCTION__, '3.0', 'is_main_site()' );	return is_main_site();}/** * @since MU * @deprecated 3.0.0 * @deprecated Use is_email() * @see is_email() */function validate_email( $email, $check_domain = true) {	_deprecated_function( __FUNCTION__, '3.0', 'is_email()' );	return is_email( $email, $check_domain );}/** * @since MU * @deprecated 3.0.0 * @deprecated Don't use this, really. */function get_blog_list( $start = 0, $num = 10, $deprecated = '' ) {	_deprecated_function( __FUNCTION__, '3.0', "Don't use this, really." );	global $wpdb;	$blogs = $wpdb->get_results( $wpdb->prepare("SELECT blog_id, domain, path FROM $wpdb->blogs WHERE site_id = %d AND public = '1' AND archived = '0' AND mature = '0' AND spam = '0' AND deleted = '0' ORDER BY registered DESC", $wpdb->siteid), ARRAY_A );	foreach ( (array) $blogs as $details ) {		$blog_list[ $details['blog_id'] ] = $details;		$blog_list[ $details['blog_id'] ]['postcount'] = $wpdb->get_var( "SELECT COUNT(ID) FROM " . $wpdb->get_blog_prefix( $details['blog_id'] ). "posts WHERE post_status='publish' AND post_type='post'" );	}	unset( $blogs );	$blogs = $blog_list;	if ( false == is_array( $blogs ) )		return array();	if ( $num == 'all' )		return array_slice( $blogs, $start, count( $blogs ) );	else		return array_slice( $blogs, $start, $num );}/** * @since MU * @deprecated 3.0.0 * @deprecated Don't use this, really. */function get_most_active_blogs( $num = 10, $display = true ) {	_deprecated_function( __FUNCTION__, '3.0', "Don't use this, really." );	$blogs = get_blog_list( 0, 'all', false ); // $blog_id -> $details	if ( is_array( $blogs ) ) {		reset( $blogs );		foreach ( (array) $blogs as $key => $details ) {			$most_active[ $details['blog_id'] ] = $details['postcount'];			$blog_list[ $details['blog_id'] ] = $details; // array_slice() removes keys!!		}		arsort( $most_active );		reset( $most_active );		foreach ( (array) $most_active as $key => $details )			$t[ $key ] = $blog_list[ $key ];		unset( $most_active );		$most_active = $t;	}	if ( $display == true ) {		if ( is_array( $most_active ) ) {			reset( $most_active );			foreach ( (array) $most_active as $key => $details ) {				$url = esc_url('http://' . $details['domain'] . $details['path']);				echo '<li>' . $details['postcount'] . " <a href='$url'>$url</a></li>";			}		}	}	return array_slice( $most_active, 0, $num );}?>
<?php/** * Simple and uniform HTTP request API. * * Will eventually replace and standardize the WordPress HTTP requests made. * * @link http://trac.wordpress.org/ticket/4779 HTTP API Proposal * * @package WordPress * @subpackage HTTP * @since 2.7.0 *//** * Returns the initialized WP_Http Object * * @since 2.7.0 * @access private * * @return WP_Http HTTP Transport object. */function &_wp_http_get_object() {	static $http;	if ( is_null($http) )		$http = new WP_Http();	return $http;}/** * Retrieve the raw response from the HTTP request. * * The array structure is a little complex. * * <code> * $res = array( 'headers' => array(), 'response' => array('code' => int, 'message' => string) ); * </code> * * All of the headers in $res['headers'] are with the name as the key and the * value as the value. So to get the User-Agent, you would do the following. * * <code> * $user_agent = $res['headers']['user-agent']; * </code> * * The body is the raw response content and can be retrieved from $res['body']. * * This function is called first to make the request and there are other API * functions to abstract out the above convoluted setup. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_request($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->request($url, $args);}/** * Retrieve the raw response from the HTTP request using the GET method. * * @see wp_remote_request() For more information on the response array format. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_get($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->get($url, $args);}/** * Retrieve the raw response from the HTTP request using the POST method. * * @see wp_remote_request() For more information on the response array format. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_post($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->post($url, $args);}/** * Retrieve the raw response from the HTTP request using the HEAD method. * * @see wp_remote_request() For more information on the response array format. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_head($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->head($url, $args);}/** * Retrieve only the headers from the raw response. * * @since 2.7.0 * * @param array $response HTTP response. * @return array The headers of the response. Empty array if incorrect parameter given. */function wp_remote_retrieve_headers(&$response) {	if ( is_wp_error($response) || ! isset($response['headers']) || ! is_array($response['headers']))		return array();	return $response['headers'];}/** * Retrieve a single header by name from the raw response. * * @since 2.7.0 * * @param array $response * @param string $header Header name to retrieve value from. * @return string The header value. Empty string on if incorrect parameter given, or if the header doesnt exist. */function wp_remote_retrieve_header(&$response, $header) {	if ( is_wp_error($response) || ! isset($response['headers']) || ! is_array($response['headers']))		return '';	if ( array_key_exists($header, $response['headers']) )		return $response['headers'][$header];	return '';}/** * Retrieve only the response code from the raw response. * * Will return an empty array if incorrect parameter value is given. * * @since 2.7.0 * * @param array $response HTTP response. * @return string the response code. Empty string on incorrect parameter given. */function wp_remote_retrieve_response_code(&$response) {	if ( is_wp_error($response) || ! isset($response['response']) || ! is_array($response['response']))		return '';	return $response['response']['code'];}/** * Retrieve only the response message from the raw response. * * Will return an empty array if incorrect parameter value is given. * * @since 2.7.0 * * @param array $response HTTP response. * @return string The response message. Empty string on incorrect parameter given. */function wp_remote_retrieve_response_message(&$response) {	if ( is_wp_error($response) || ! isset($response['response']) || ! is_array($response['response']))		return '';	return $response['response']['message'];}/** * Retrieve only the body from the raw response. * * @since 2.7.0 * * @param array $response HTTP response. * @return string The body of the response. Empty string if no body or incorrect parameter given. */function wp_remote_retrieve_body(&$response) {	if ( is_wp_error($response) || ! isset($response['body']) )		return '';	return $response['body'];}?>
<?php/** * Theme editor administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( !current_user_can('edit_themes') )	wp_die('<p>'.__('You do not have sufficient permissions to edit templates for this site.').'</p>');$title = __("Edit Themes");$parent_file = 'themes.php';$help = '<p>' . __('You can use the Theme Editor to edit the individual CSS and PHP files which make up your theme.') . '</p>';$help .= '<p>' . __('Begin by choosing a theme to edit from the dropdown menu and clicking Select. A list then appears of all the template files. Clicking once on any file name causes the file to appear in the large Editor box.') . '</p>';$help .= '<p>' . __('For PHP files, you can use the Documentation dropdown to select from functions recognized in that file. Lookup takes you to a web page with reference material about that particular function.') . '</p>';$help .= '<p>' . __('After typing in your edits, click Update File.') . '</p>';$help .= '<p>' . __('<strong>Advice:</strong> think very carefully about your site crashing if you are live-editing the theme currently in use.') . '</p>';$help .= '<p>' . __('Upgrading to a newer version of the same theme will override changes made here. To avoid this, consider creating a <a href="http://codex.wordpress.org/Child_Themes" target="_blank">child theme</a> instead.') . '</p>';$help .= '<p><strong>' . __('For more information:') . '</strong></p>';$help .= '<p>' . __('<a href="http://codex.wordpress.org/Theme_Development" target="_blank">Documentation on Theme Development</a>') . '</p>';$help .= '<p>' . __('<a href="http://codex.wordpress.org/Using_Themes" target="_blank">Documentation on Using Themes</a>') . '</p>';$help .= '<p>' . __('<a href="http://codex.wordpress.org/Editing_Files" target="_blank">Documentation on Editing Files</a>') . '</p>';$help .= '<p>' . __('<a href="http://codex.wordpress.org/Template_Tags" target="_blank">Documentation on Template Tags</a>') . '</p>';$help .= '<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>';add_contextual_help($current_screen, $help);wp_reset_vars(array('action', 'redirect', 'profile', 'error', 'warning', 'a', 'file', 'theme', 'dir'));wp_admin_css( 'theme-editor' );$themes = get_themes();if (empty($theme)) {	$theme = get_current_theme();} else {	$theme = stripslashes($theme);}if ( ! isset($themes[$theme]) )	wp_die(__('The requested theme does not exist.'));$allowed_files = array_merge($themes[$theme]['Stylesheet Files'], $themes[$theme]['Template Files']);if (empty($file)) {	$file = $allowed_files[0];} else {	$file = stripslashes($file);	if ( 'theme' == $dir ) {		$file = dirname(dirname($themes[$theme]['Template Dir'])) . $file ;	} else if ( 'style' == $dir) {		$file = dirname(dirname($themes[$theme]['Stylesheet Dir'])) . $file ;	}}validate_file_to_edit($file, $allowed_files);$scrollto = isset($_REQUEST['scrollto']) ? (int) $_REQUEST['scrollto'] : 0;$file_show = basename( $file );switch($action) {case 'update':	check_admin_referer('edit-theme_' . $file . $theme);	$newcontent = stripslashes($_POST['newcontent']);	$theme = urlencode($theme);	if (is_writeable($file)) {		//is_writable() not always reliable, check return value. see comments @ http://uk.php.net/is_writable		$f = fopen($file, 'w+');		if ($f !== FALSE) {			fwrite($f, $newcontent);			fclose($f);			$location = "theme-editor.php?file=$file&theme=$theme&a=te&scrollto=$scrollto";		} else {			$location = "theme-editor.php?file=$file&theme=$theme&scrollto=$scrollto";		}	} else {		$location = "theme-editor.php?file=$file&theme=$theme&scrollto=$scrollto";	}	$location = wp_kses_no_null($location);	$strip = array('%0d', '%0a', '%0D', '%0A');	$location = _deep_replace($strip, $location);	header("Location: $location");	exit();break;default:	require_once('./admin-header.php');	update_recently_edited($file);	if ( !is_file($file) )		$error = 1;	if ( !$error && filesize($file) > 0 ) {		$f = fopen($file, 'r');		$content = fread($f, filesize($file));		if ( '.php' == substr( $file, strrpos( $file, '.' ) ) ) {			$functions = wp_doc_link_parse( $content );			$docs_select = '<select name="docs-list" id="docs-list">';			$docs_select .= '<option value="">' . esc_attr__( 'Function Name...' ) . '</option>';			foreach ( $functions as $function ) {				$docs_select .= '<option value="' . esc_attr( urlencode( $function ) ) . '">' . htmlspecialchars( $function ) . '()</option>';			}			$docs_select .= '</select>';		}		$content = htmlspecialchars( $content );	}	?><?php if (isset($_GET['a'])) : ?> <div id="message" class="updated"><p><?php _e('File edited successfully.') ?></p></div><?php endif;$description = get_file_description($file);$desc_header = ( $description != $file_show ) ? "<strong>$description</strong> (%s)" : "%s";?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><div class="fileedit-sub"><div class="alignleft"><big><?php echo sprintf($desc_header, $file_show); ?></big></div><div class="alignright">	<form action="theme-editor.php" method="post">		<strong><label for="theme"><?php _e('Select theme to edit:'); ?> </label></strong>		<select name="theme" id="theme"><?php	foreach ($themes as $a_theme) {	$theme_name = $a_theme['Name'];	if ($theme_name == $theme) $selected = " selected='selected'";	else $selected = '';	$theme_name = esc_attr($theme_name);	echo "\n\t<option value=\"$theme_name\" $selected>$theme_name</option>";}?>		</select>		<input type="submit" name="Submit" value="<?php esc_attr_e('Select') ?>" class="button" />	</form></div><br class="clear" /></div>	<div id="templateside"><?phpif ($allowed_files) :?>	<h3><?php _e('Templates'); ?></h3>	<ul><?php	$template_mapping = array();	$template_dir = $themes[$theme]['Template Dir'];	foreach ( $themes[$theme]['Template Files'] as $template_file ) {		$description = trim( get_file_description($template_file) );		$template_show = basename($template_file);		$filedesc = ( $description != $template_file ) ? "$description<br /><span class='nonessential'>($template_show)</span>" : "$description";		$filedesc = ( $template_file == $file ) ? "<span class='highlight'>$description<br /><span class='nonessential'>($template_show)</span></span>" : $filedesc;		// If we have two files of the same name prefer the one in the Template Directory		// This means that we display the correct files for child themes which overload Templates as well as Styles		if ( array_key_exists($description, $template_mapping ) ) {			if ( false !== strpos( $template_file, $template_dir ) )  {				$template_mapping[ $description ] = array( _get_template_edit_filename($template_file, $template_dir), $filedesc );			}		} else {			$template_mapping[ $description ] = array( _get_template_edit_filename($template_file, $template_dir), $filedesc );		}	}	ksort( $template_mapping );	while ( list( $template_sorted_key, list( $template_file, $filedesc ) ) = each( $template_mapping ) ) :	?>		<li><a href="theme-editor.php?file=<?php echo "$template_file"; ?>&amp;theme=<?php echo urlencode($theme) ?>&amp;dir=theme"><?php echo $filedesc ?></a></li><?php endwhile; ?>	</ul>	<h3><?php /* translators: Theme stylesheets in theme editor */ _ex('Styles', 'Theme stylesheets in theme editor'); ?></h3>	<ul><?php	$template_mapping = array();	$stylesheet_dir = $themes[$theme]['Stylesheet Dir'];	foreach ( $themes[$theme]['Stylesheet Files'] as $style_file ) {		$description = trim( get_file_description($style_file) );		$style_show = basename($style_file);		$filedesc = ( $description != $style_file ) ? "$description<br /><span class='nonessential'>($style_show)</span>" : "$description";		$filedesc = ( $style_file == $file ) ? "<span class='highlight'>$description<br /><span class='nonessential'>($style_show)</span></span>" : $filedesc;		$template_mapping[ $description ] = array( _get_template_edit_filename($style_file, $stylesheet_dir), $filedesc );	}	ksort( $template_mapping );	while ( list( $template_sorted_key, list( $style_file, $filedesc ) ) = each( $template_mapping ) ) :		?>		<li><a href="theme-editor.php?file=<?php echo "$style_file"; ?>&amp;theme=<?php echo urlencode($theme) ?>&amp;dir=style"><?php echo $filedesc ?></a></li><?php endwhile; ?>	</ul><?php endif; ?></div><?php if (!$error) { ?>	<form name="template" id="template" action="theme-editor.php" method="post">	<?php wp_nonce_field('edit-theme_' . $file . $theme) ?>		 <div><textarea cols="70" rows="25" name="newcontent" id="newcontent" tabindex="1"><?php echo $content ?></textarea>		 <input type="hidden" name="action" value="update" />		 <input type="hidden" name="file" value="<?php echo esc_attr($file) ?>" />		 <input type="hidden" name="theme" value="<?php echo esc_attr($theme) ?>" />		 <input type="hidden" name="scrollto" id="scrollto" value="<?php echo $scrollto; ?>" />		 </div>	<?php if ( isset($functions ) && count($functions) ) { ?>		<div id="documentation" class="hide-if-no-js">		<label for="docs-list"><?php _e('Documentation:') ?></label>		<?php echo $docs_select; ?>		<input type="button" class="button" value=" <?php esc_attr_e( 'Lookup' ); ?> " onclick="if ( '' != jQuery('#docs-list').val() ) { window.open( 'http://api.wordpress.org/core/handbook/1.0/?function=' + escape( jQuery( '#docs-list' ).val() ) + '&amp;locale=<?php echo urlencode( get_locale() ) ?>&amp;version=<?php echo urlencode( $wp_version ) ?>&amp;redirect=true'); }" />		</div>	<?php } ?>		<div><?php if ( is_writeable($file) ) : ?>			<p class="submit"><?php	echo "<input type='submit' name='submit' class='button-primary' value='" . esc_attr__('Update File') . "' tabindex='2' />";?></p><?php else : ?><p><em><?php _e('You need to make this file writable before you can save your changes. See <a href="http://codex.wordpress.org/Changing_File_Permissions">the Codex</a> for more information.'); ?></em></p><?php endif; ?>		</div>	</form><?php	} else {		echo '<div class="error"><p>' . __('Oops, no such file exists! Double check the name and try again, merci.') . '</p></div>';	}?><br class="clear" /></div><script type="text/javascript">/* <![CDATA[ */jQuery(document).ready(function($){	$('#template').submit(function(){ $('#scrollto').val( $('#newcontent').scrollTop() ); });	$('#newcontent').scrollTop( $('#scrollto').val() );});/* ]]> */</script><?phpbreak;}include("./admin-footer.php");
<?php/** * Creates common globals for the rest of WordPress * * Sets $pagenow global which is the current page. Checks * for the browser to set which one is currently being used. * * Detects which user environment WordPress is being used on. * Only attempts to check for Apache and IIS. Two web servers * with known permalink capability. * * @package WordPress */// On which page are we ?if ( is_admin() ) {	// wp-admin pages are checked more carefully	preg_match('#/wp-admin/?(.*?)$#i', $PHP_SELF, $self_matches);	$pagenow = $self_matches[1];	$pagenow = trim($pagenow, '/');	$pagenow = preg_replace('#\?.*?$#', '', $pagenow);	if ( '' === $pagenow || 'index' === $pagenow || 'index.php' === $pagenow ) {		$pagenow = 'index.php';	} else {		preg_match('#(.*?)(/|$)#', $pagenow, $self_matches);		$pagenow = strtolower($self_matches[1]);		if ( '.php' !== substr($pagenow, -4, 4) )			$pagenow .= '.php'; // for Options +Multiviews: /wp-admin/themes/index.php (themes.php is queried)	}} else {	if ( preg_match('#([^/]+\.php)([?/].*?)?$#i', $PHP_SELF, $self_matches) )		$pagenow = strtolower($self_matches[1]);	else		$pagenow = 'index.php';}// Simple browser detection$is_lynx = $is_gecko = $is_winIE = $is_macIE = $is_opera = $is_NS4 = $is_safari = $is_chrome = $is_iphone = false;if ( isset($_SERVER['HTTP_USER_AGENT']) ) {	if ( strpos($_SERVER['HTTP_USER_AGENT'], 'Lynx') !== false ) {		$is_lynx = true;	} elseif ( stripos($_SERVER['HTTP_USER_AGENT'], 'chrome') !== false ) {		$is_chrome = true;	} elseif ( stripos($_SERVER['HTTP_USER_AGENT'], 'safari') !== false ) {		$is_safari = true;	} elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'Gecko') !== false ) {		$is_gecko = true;	} elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== false && strpos($_SERVER['HTTP_USER_AGENT'], 'Win') !== false ) {		$is_winIE = true;	} elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== false && strpos($_SERVER['HTTP_USER_AGENT'], 'Mac') !== false ) {		$is_macIE = true;	} elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'Opera') !== false ) {		$is_opera = true;	} elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'Nav') !== false && strpos($_SERVER['HTTP_USER_AGENT'], 'Mozilla/4.') !== false ) {		$is_NS4 = true;	}}if ( $is_safari && stripos($_SERVER['HTTP_USER_AGENT'], 'mobile') !== false )	$is_iphone = true;$is_IE = ( $is_macIE || $is_winIE );// Server detection/** * Whether the server software is Apache or something else * @global bool $is_apache */$is_apache = (strpos($_SERVER['SERVER_SOFTWARE'], 'Apache') !== false || strpos($_SERVER['SERVER_SOFTWARE'], 'LiteSpeed') !== false);/** * Whether the server software is IIS or something else * @global bool $is_IIS */$is_IIS = (strpos($_SERVER['SERVER_SOFTWARE'], 'Microsoft-IIS') !== false || strpos($_SERVER['SERVER_SOFTWARE'], 'ExpressionDevServer') !== false);/** * Whether the server software is IIS 7.X * @global bool $is_iis7 */$is_iis7 = (strpos($_SERVER['SERVER_SOFTWARE'], 'Microsoft-IIS/7.') !== false);?>
<?php/** * BackPress Styles enqueue. * * These classes were refactored from the WordPress WP_Scripts and WordPress * script enqueue API. * * @package BackPress * @since r74 *//** * BackPress Styles enqueue class. * * @package BackPress * @uses WP_Dependencies * @since r74 */class WP_Styles extends WP_Dependencies {	var $base_url;	var $content_url;	var $default_version;	var $text_direction = 'ltr';	var $concat = '';	var $concat_version = '';	var $do_concat = false;	var $print_html = '';	var $default_dirs;	function __construct() {		do_action_ref_array( 'wp_default_styles', array(&$this) );	}	function do_item( $handle ) {		if ( !parent::do_item($handle) )			return false;		if ( null === $this->registered[$handle]->ver )			$ver = '';		else			$ver = $this->registered[$handle]->ver ? $this->registered[$handle]->ver : $this->default_version;		if ( isset($this->args[$handle]) )			$ver = $ver ? $ver . '&amp;' . $this->args[$handle] : $this->args[$handle];		if ( $this->do_concat ) {			if ( $this->in_default_dir($this->registered[$handle]->src) && !isset($this->registered[$handle]->extra['conditional']) && !isset($this->registered[$handle]->extra['alt']) ) {				$this->concat .= "$handle,";				$this->concat_version .= "$handle$ver";				return true;			}		}		if ( isset($this->registered[$handle]->args) )			$media = esc_attr( $this->registered[$handle]->args );		else			$media = 'all';		$href = $this->_css_href( $this->registered[$handle]->src, $ver, $handle );		$rel = isset($this->registered[$handle]->extra['alt']) && $this->registered[$handle]->extra['alt'] ? 'alternate stylesheet' : 'stylesheet';		$title = isset($this->registered[$handle]->extra['title']) ? "title='" . esc_attr( $this->registered[$handle]->extra['title'] ) . "'" : '';		$end_cond = $tag = '';		if ( isset($this->registered[$handle]->extra['conditional']) && $this->registered[$handle]->extra['conditional'] ) {			$tag .= "<!--[if {$this->registered[$handle]->extra['conditional']}]>\n";			$end_cond = "<![endif]-->\n";		}		$tag .= apply_filters( 'style_loader_tag', "<link rel='$rel' id='$handle-css' $title href='$href' type='text/css' media='$media' />\n", $handle );		if ( 'rtl' === $this->text_direction && isset($this->registered[$handle]->extra['rtl']) && $this->registered[$handle]->extra['rtl'] ) {			if ( is_bool( $this->registered[$handle]->extra['rtl'] ) ) {				$suffix = isset( $this->registered[$handle]->extra['suffix'] ) ? $this->registered[$handle]->extra['suffix'] : '';				$rtl_href = str_replace( "{$suffix}.css", "-rtl{$suffix}.css", $this->_css_href( $this->registered[$handle]->src , $ver, "$handle-rtl" ));			} else {				$rtl_href = $this->_css_href( $this->registered[$handle]->extra['rtl'], $ver, "$handle-rtl" );			}			$tag .= apply_filters( 'style_loader_tag', "<link rel='$rel' id='$handle-rtl-css' $title href='$rtl_href' type='text/css' media='$media' />\n", $handle );		}		$tag .= $end_cond;		if ( $this->do_concat )			$this->print_html .= $tag;		else			echo $tag;		// Could do something with $this->registered[$handle]->extra here to print out extra CSS rules//		echo "<style type='text/css'>\n";//		echo "/* <![CDATA[ */\n";//		echo "/* ]]> */\n";//		echo "</style>\n";		return true;	}	function all_deps( $handles, $recursion = false, $group = false ) {		$r = parent::all_deps( $handles, $recursion );		if ( !$recursion )			$this->to_do = apply_filters( 'print_styles_array', $this->to_do );		return $r;	}	function _css_href( $src, $ver, $handle ) {		if ( !is_bool($src) && !preg_match('|^https?://|', $src) && ! ( $this->content_url && 0 === strpos($src, $this->content_url) ) ) {			$src = $this->base_url . $src;		}		if ( !empty($ver) )			$src = add_query_arg('ver', $ver, $src);		$src = apply_filters( 'style_loader_src', $src, $handle );		return esc_url( $src );	}	function in_default_dir($src) {		if ( ! $this->default_dirs )			return true;		foreach ( (array) $this->default_dirs as $test ) {			if ( 0 === strpos($src, $test) )				return true;		}		return false;	}}
<?php/** * The main template file. * * This is the most generic template file in a WordPress theme * and one of the two required files for a theme (the other being style.css). * It is used to display a page when nothing more specific matches a query.  * E.g., it puts together the home page when no home.php file exists. * Learn more: http://codex.wordpress.org/Template_Hierarchy * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main">			<?php			/* Run the loop to output the posts.			 * If you want to overload this in a child theme then include a file			 * called loop-index.php and that will be used instead.			 */			 get_template_part( 'loop', 'index' );			?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
