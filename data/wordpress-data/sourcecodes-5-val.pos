<?php/** * RSS 0.92 Feed Template for displaying RSS 0.92 Posts feed. * * @package WordPress */header('Content-Type: ' . feed_content_type('rss-http') . '; charset=' . get_option('blog_charset'), true);$more = 1;echo '<?xml version="1.0" encoding="'.get_option('blog_charset').'"?'.'>'; ?><rss version="0.92"><channel>	<title><?php bloginfo_rss('name'); wp_title_rss(); ?></title>	<link><?php bloginfo_rss('url') ?></link>	<description><?php bloginfo_rss('description') ?></description>	<lastBuildDate><?php echo mysql2date('D, d M Y H:i:s +0000', get_lastpostmodified('GMT'), false); ?></lastBuildDate>	<docs>http://backend.userland.com/rss092</docs>	<language><?php echo get_option('rss_language'); ?></language>	<?php do_action('rss_head'); ?><?php while (have_posts()) : the_post(); ?>	<item>		<title><?php the_title_rss() ?></title>		<description><![CDATA[<?php the_excerpt_rss() ?>]]></description>		<link><?php the_permalink_rss() ?></link>		<?php do_action('rss_item'); ?>	</item><?php endwhile; ?></channel></rss>
<?php/** * Simple and uniform HTTP request API. * * Standardizes the HTTP requests for WordPress. Handles cookies, gzip encoding and decoding, chunk * decoding, if HTTP 1.1 and various other difficult HTTP protocol implementations. * * @link http://trac.wordpress.org/ticket/4779 HTTP API Proposal * * @package WordPress * @subpackage HTTP * @since 2.7.0 *//** * WordPress HTTP Class for managing HTTP Transports and making HTTP requests. * * This class is called for the functionality of making HTTP requests and replaces Snoopy * functionality. There is no available functionality to add HTTP transport implementations, since * most of the HTTP transports are added and available for use. * * There are no properties, because none are needed and for performance reasons. Some of the * functions are static and while they do have some overhead over functions in PHP4, the purpose is * maintainability. When PHP5 is finally the requirement, it will be easy to add the static keyword * to the code. It is not as easy to convert a function to a method after enough code uses the old * way. * * Debugging includes several actions, which pass different variables for debugging the HTTP API. * * <strong>http_transport_get_debug</strong> - gives working, nonblocking, and blocking transports. * * <strong>http_transport_post_debug</strong> - gives working, nonblocking, and blocking transports. * * @package WordPress * @subpackage HTTP * @since 2.7.0 */class WP_Http {	/**	 * PHP4 style Constructor - Calls PHP5 Style Constructor	 *	 * @since 2.7.0	 * @return WP_Http	 */	function WP_Http() {		$this->__construct();	}	/**	 * PHP5 style Constructor - Set up available transport if not available.	 *	 * PHP4 does not have the 'self' keyword and since WordPress supports PHP4, the class needs to	 * be used for the static call. The transport are set up to save time and will only be created	 * once. This class can be created many times without having to go through the step of finding	 * which transports are available.	 *	 * @since 2.7.0	 * @return WP_Http	 */	function __construct() {		WP_Http::_getTransport();		WP_Http::_postTransport();	}	/**	 * Tests the WordPress HTTP objects for an object to use and returns it.	 *	 * Tests all of the objects and returns the object that passes. Also caches that object to be	 * used later.	 *	 * The order for the GET/HEAD requests are HTTP Extension, cURL, Streams, Fopen, and finally	 * Fsockopen. fsockopen() is used last, because it has the most overhead in its implementation.	 * There isn't any real way around it, since redirects have to be supported, much the same way	 * the other transports also handle redirects.	 *	 * There are currently issues with "localhost" not resolving correctly with DNS. This may cause	 * an error "failed to open stream: A connection attempt failed because the connected party did	 * not properly respond after a period of time, or established connection failed because [the]	 * connected host has failed to respond."	 *	 * @since 2.7.0	 * @access private	 *	 * @param array $args Request args, default us an empty array	 * @return object|null Null if no transports are available, HTTP transport object.	 */	function &_getTransport( $args = array() ) {		static $working_transport, $blocking_transport, $nonblocking_transport;		if ( is_null($working_transport) ) {			if ( true === WP_Http_ExtHttp::test($args) ) {				$working_transport['exthttp'] = new WP_Http_ExtHttp();				$blocking_transport[] = &$working_transport['exthttp'];			} else if ( true === WP_Http_Curl::test($args) ) {				$working_transport['curl'] = new WP_Http_Curl();				$blocking_transport[] = &$working_transport['curl'];			} else if ( true === WP_Http_Streams::test($args) ) {				$working_transport['streams'] = new WP_Http_Streams();				$blocking_transport[] = &$working_transport['streams'];			} else if ( true === WP_Http_Fopen::test($args) ) {				$working_transport['fopen'] = new WP_Http_Fopen();				$blocking_transport[] = &$working_transport['fopen'];			} else if ( true === WP_Http_Fsockopen::test($args) ) {				$working_transport['fsockopen'] = new WP_Http_Fsockopen();				$blocking_transport[] = &$working_transport['fsockopen'];			}			foreach ( array('curl', 'streams', 'fopen', 'fsockopen', 'exthttp') as $transport ) {				if ( isset($working_transport[$transport]) )					$nonblocking_transport[] = &$working_transport[$transport];			}		}		do_action( 'http_transport_get_debug', $working_transport, $blocking_transport, $nonblocking_transport );		if ( isset($args['blocking']) && !$args['blocking'] )			return $nonblocking_transport;		else			return $blocking_transport;	}	/**	 * Tests the WordPress HTTP objects for an object to use and returns it.	 *	 * Tests all of the objects and returns the object that passes. Also caches	 * that object to be used later. This is for posting content to a URL and	 * is used when there is a body. The plain Fopen Transport can not be used	 * to send content, but the streams transport can. This is a limitation that	 * is addressed here, by just not including that transport.	 *	 * @since 2.7.0	 * @access private	 *	 * @param array $args Request args, default us an empty array	 * @return object|null Null if no transports are available, HTTP transport object.	 */	function &_postTransport( $args = array() ) {		static $working_transport, $blocking_transport, $nonblocking_transport;		if ( is_null($working_transport) ) {			if ( true === WP_Http_ExtHttp::test($args) ) {				$working_transport['exthttp'] = new WP_Http_ExtHttp();				$blocking_transport[] = &$working_transport['exthttp'];			} else if ( true === WP_Http_Curl::test($args) ) {				$working_transport['curl'] = new WP_Http_Curl();				$blocking_transport[] = &$working_transport['curl'];			} else if ( true === WP_Http_Streams::test($args) ) {				$working_transport['streams'] = new WP_Http_Streams();				$blocking_transport[] = &$working_transport['streams'];			} else if ( true === WP_Http_Fsockopen::test($args) ) {				$working_transport['fsockopen'] = new WP_Http_Fsockopen();				$blocking_transport[] = &$working_transport['fsockopen'];			}			foreach ( array('curl', 'streams', 'fsockopen', 'exthttp') as $transport ) {				if ( isset($working_transport[$transport]) )					$nonblocking_transport[] = &$working_transport[$transport];			}		}		do_action( 'http_transport_post_debug', $working_transport, $blocking_transport, $nonblocking_transport );		if ( isset($args['blocking']) && !$args['blocking'] )			return $nonblocking_transport;		else			return $blocking_transport;	}	/**	 * Send a HTTP request to a URI.	 *	 * The body and headers are part of the arguments. The 'body' argument is for the body and will	 * accept either a string or an array. The 'headers' argument should be an array, but a string	 * is acceptable. If the 'body' argument is an array, then it will automatically be escaped	 * using http_build_query().	 *	 * The only URI that are supported in the HTTP Transport implementation are the HTTP and HTTPS	 * protocols. HTTP and HTTPS are assumed so the server might not know how to handle the send	 * headers. Other protocols are unsupported and most likely will fail.	 *	 * The defaults are 'method', 'timeout', 'redirection', 'httpversion', 'blocking' and	 * 'user-agent'.	 *	 * Accepted 'method' values are 'GET', 'POST', and 'HEAD', some transports technically allow	 * others, but should not be assumed. The 'timeout' is used to sent how long the connection	 * should stay open before failing when no response. 'redirection' is used to track how many	 * redirects were taken and used to sent the amount for other transports, but not all transports	 * accept setting that value.	 *	 * The 'httpversion' option is used to sent the HTTP version and accepted values are '1.0', and	 * '1.1' and should be a string. Version 1.1 is not supported, because of chunk response. The	 * 'user-agent' option is the user-agent and is used to replace the default user-agent, which is	 * 'WordPress/WP_Version', where WP_Version is the value from $wp_version.	 *	 * 'blocking' is the default, which is used to tell the transport, whether it should halt PHP	 * while it performs the request or continue regardless. Actually, that isn't entirely correct.	 * Blocking mode really just means whether the fread should just pull what it can whenever it	 * gets bytes or if it should wait until it has enough in the buffer to read or finishes reading	 * the entire content. It doesn't actually always mean that PHP will continue going after making	 * the request.	 *	 * @access public	 * @since 2.7.0	 * @todo Refactor this code. The code in this method extends the scope of its original purpose	 *		and should be refactored to allow for cleaner abstraction and reduce duplication of the	 *		code. One suggestion is to create a class specifically for the arguments, however	 *		preliminary refactoring to this affect has affect more than just the scope of the	 *		arguments. Something to ponder at least.	 *	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return array containing 'headers', 'body', 'response', 'cookies'	 */	function request( $url, $args = array() ) {		global $wp_version;		$defaults = array(			'method' => 'GET',			'timeout' => apply_filters( 'http_request_timeout', 5),			'redirection' => apply_filters( 'http_request_redirection_count', 5),			'httpversion' => apply_filters( 'http_request_version', '1.0'),			'user-agent' => apply_filters( 'http_headers_useragent', 'WordPress/' . $wp_version . '; ' . get_bloginfo( 'url' )  ),			'blocking' => true,			'headers' => array(),			'cookies' => array(),			'body' => null,			'compress' => false,			'decompress' => true,			'sslverify' => true		);		$r = wp_parse_args( $args, $defaults );		$r = apply_filters( 'http_request_args', $r, $url );		// Allow plugins to short-circuit the request		$pre = apply_filters( 'pre_http_request', false, $r, $url );		if ( false !== $pre )			return $pre;		$arrURL = parse_url($url);		if ( empty( $url ) || empty($url['scheme'] ) )			return new WP_Error('http_request_failed', __('A valid URL was not provided.'));		if ( $this->block_request( $url ) )			return new WP_Error('http_request_failed', __('User has blocked requests through HTTP.'));		// Determine if this is a https call and pass that on to the transport functions		// so that we can blacklist the transports that do not support ssl verification		$r['ssl'] = $arrURL['scheme'] == 'https' || $arrURL['scheme'] == 'ssl';		// Determine if this request is to OUR install of WordPress		$homeURL = parse_url( get_bloginfo('url') );		$r['local'] = $homeURL['host'] == $arrURL['host'] || 'localhost' == $arrURL['host'];		unset($homeURL);		if ( is_null( $r['headers'] ) )			$r['headers'] = array();		if ( ! is_array($r['headers']) ) {			$processedHeaders = WP_Http::processHeaders($r['headers']);			$r['headers'] = $processedHeaders['headers'];		}		if ( isset($r['headers']['User-Agent']) ) {			$r['user-agent'] = $r['headers']['User-Agent'];			unset($r['headers']['User-Agent']);		}		if ( isset($r['headers']['user-agent']) ) {			$r['user-agent'] = $r['headers']['user-agent'];			unset($r['headers']['user-agent']);		}		// Construct Cookie: header if any cookies are set		WP_Http::buildCookieHeader( $r );		if ( WP_Http_Encoding::is_available() )			$r['headers']['Accept-Encoding'] = WP_Http_Encoding::accept_encoding();		if ( empty($r['body']) ) {			// Some servers fail when sending content without the content-length header being set.			// Also, to fix another bug, we only send when doing POST and PUT and the content-length			// header isn't already set.			if( ($r['method'] == 'POST' || $r['method'] == 'PUT') && ! isset($r['headers']['Content-Length']) )				$r['headers']['Content-Length'] = 0;			// The method is ambiguous, because we aren't talking about HTTP methods, the "get" in			// this case is simply that we aren't sending any bodies and to get the transports that			// don't support sending bodies along with those which do.			$transports = WP_Http::_getTransport($r);		} else {			if ( is_array( $r['body'] ) || is_object( $r['body'] ) ) {				if ( ! version_compare(phpversion(), '5.1.2', '>=') )					$r['body'] = _http_build_query($r['body'], null, '&');				else					$r['body'] = http_build_query($r['body'], null, '&');				$r['headers']['Content-Type'] = 'application/x-www-form-urlencoded; charset=' . get_option('blog_charset');				$r['headers']['Content-Length'] = strlen($r['body']);			}			if ( ! isset( $r['headers']['Content-Length'] ) && ! isset( $r['headers']['content-length'] ) )				$r['headers']['Content-Length'] = strlen($r['body']);			// The method is ambiguous, because we aren't talking about HTTP methods, the "post" in			// this case is simply that we are sending HTTP body and to get the transports that do			// support sending the body. Not all do, depending on the limitations of the PHP core			// limitations.			$transports = WP_Http::_postTransport($r);		}		do_action( 'http_api_debug', $transports, 'transports_list' );		$response = array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		foreach ( (array) $transports as $transport ) {			$response = $transport->request($url, $r);			do_action( 'http_api_debug', $response, 'response', get_class($transport) );			if ( ! is_wp_error($response) )				return apply_filters( 'http_response', $response, $r, $url );		}		return $response;	}	/**	 * Uses the POST HTTP method.	 *	 * Used for sending data that is expected to be in the body.	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return boolean	 */	function post($url, $args = array()) {		$defaults = array('method' => 'POST');		$r = wp_parse_args( $args, $defaults );		return $this->request($url, $r);	}	/**	 * Uses the GET HTTP method.	 *	 * Used for sending data that is expected to be in the body.	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return boolean	 */	function get($url, $args = array()) {		$defaults = array('method' => 'GET');		$r = wp_parse_args( $args, $defaults );		return $this->request($url, $r);	}	/**	 * Uses the HEAD HTTP method.	 *	 * Used for sending data that is expected to be in the body.	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return boolean	 */	function head($url, $args = array()) {		$defaults = array('method' => 'HEAD');		$r = wp_parse_args( $args, $defaults );		return $this->request($url, $r);	}	/**	 * Parses the responses and splits the parts into headers and body.	 *	 * @access public	 * @static	 * @since 2.7.0	 *	 * @param string $strResponse The full response string	 * @return array Array with 'headers' and 'body' keys.	 */	function processResponse($strResponse) {		$res = explode("\r\n\r\n", $strResponse, 2);		return array('headers' => isset($res[0]) ? $res[0] : array(), 'body' => isset($res[1]) ? $res[1] : '');	}	/**	 * Transform header string into an array.	 *	 * If an array is given then it is assumed to be raw header data with numeric keys with the	 * headers as the values. No headers must be passed that were already processed.	 *	 * @access public	 * @static	 * @since 2.7.0	 *	 * @param string|array $headers	 * @return array Processed string headers. If duplicate headers are encountered,	 * 					Then a numbered array is returned as the value of that header-key.	 */	function processHeaders($headers) {		// split headers, one per array element		if ( is_string($headers) ) {			// tolerate line terminator: CRLF = LF (RFC 2616 19.3)			$headers = str_replace("\r\n", "\n", $headers);			// unfold folded header fields. LWS = [CRLF] 1*( SP | HT ) <US-ASCII SP, space (32)>, <US-ASCII HT, horizontal-tab (9)> (RFC 2616 2.2)			$headers = preg_replace('/\n[ \t]/', ' ', $headers);			// create the headers array			$headers = explode("\n", $headers);		}		$response = array('code' => 0, 'message' => '');		// If a redirection has taken place, The headers for each page request may have been passed.		// In this case, determine the final HTTP header and parse from there.		for ( $i = count($headers)-1; $i >= 0; $i-- ) {			if ( !empty($headers[$i]) && false === strpos($headers[$i], ':') ) {				$headers = array_splice($headers, $i);				break;			}		}		$cookies = array();		$newheaders = array();		foreach ( $headers as $tempheader ) {			if ( empty($tempheader) )				continue;			if ( false === strpos($tempheader, ':') ) {				list( , $response['code'], $response['message']) = explode(' ', $tempheader, 3);				continue;			}			list($key, $value) = explode(':', $tempheader, 2);			if ( !empty( $value ) ) {				$key = strtolower( $key );				if ( isset( $newheaders[$key] ) ) {					if ( !is_array($newheaders[$key]) )						$newheaders[$key] = array($newheaders[$key]);					$newheaders[$key][] = trim( $value );				} else {					$newheaders[$key] = trim( $value );				}				if ( 'set-cookie' == strtolower( $key ) )					$cookies[] = new WP_Http_Cookie( $value );			}		}		return array('response' => $response, 'headers' => $newheaders, 'cookies' => $cookies);	}	/**	 * Takes the arguments for a ::request() and checks for the cookie array.	 *	 * If it's found, then it's assumed to contain WP_Http_Cookie objects, which are each parsed	 * into strings and added to the Cookie: header (within the arguments array). Edits the array by	 * reference.	 *	 * @access public	 * @version 2.8.0	 * @static	 *	 * @param array $r Full array of args passed into ::request()	 */	function buildCookieHeader( &$r ) {		if ( ! empty($r['cookies']) ) {			$cookies_header = '';			foreach ( (array) $r['cookies'] as $cookie ) {				$cookies_header .= $cookie->getHeaderValue() . '; ';			}			$cookies_header = substr( $cookies_header, 0, -2 );			$r['headers']['cookie'] = $cookies_header;		}	}	/**	 * Decodes chunk transfer-encoding, based off the HTTP 1.1 specification.	 *	 * Based off the HTTP http_encoding_dechunk function. Does not support UTF-8. Does not support	 * returning footer headers. Shouldn't be too difficult to support it though.	 *	 * @todo Add support for footer chunked headers.	 * @access public	 * @since 2.7.0	 * @static	 *	 * @param string $body Body content	 * @return string Chunked decoded body on success or raw body on failure.	 */	function chunkTransferDecode($body) {		$body = str_replace(array("\r\n", "\r"), "\n", $body);		// The body is not chunked encoding or is malformed.		if ( ! preg_match( '/^[0-9a-f]+(\s|\n)+/mi', trim($body) ) )			return $body;		$parsedBody = '';		//$parsedHeaders = array(); Unsupported		while ( true ) {			$hasChunk = (bool) preg_match( '/^([0-9a-f]+)(\s|\n)+/mi', $body, $match );			if ( $hasChunk ) {				if ( empty( $match[1] ) )					return $body;				$length = hexdec( $match[1] );				$chunkLength = strlen( $match[0] );				$strBody = substr($body, $chunkLength, $length);				$parsedBody .= $strBody;				$body = ltrim(str_replace(array($match[0], $strBody), '', $body), "\n");				if ( "0" == trim($body) )					return $parsedBody; // Ignore footer headers.			} else {				return $body;			}		}	}	/**	 * Block requests through the proxy.	 *	 * Those who are behind a proxy and want to prevent access to certain hosts may do so. This will	 * prevent plugins from working and core functionality, if you don't include api.wordpress.org.	 *	 * You block external URL requests by defining WP_HTTP_BLOCK_EXTERNAL as true in your wp-config.php	 * file and this will only allow localhost and your blog to make requests. The constant	 * WP_ACCESSIBLE_HOSTS will allow additional hosts to go through for requests. The format of the	 * WP_ACCESSIBLE_HOSTS constant is a comma separated list of hostnames to allow.	 *	 * @since 2.8.0	 * @link http://core.trac.wordpress.org/ticket/8927 Allow preventing external requests.	 *	 * @param string $uri URI of url.	 * @return bool True to block, false to allow.	 */	function block_request($uri) {		// We don't need to block requests, because nothing is blocked.		if ( ! defined( 'WP_HTTP_BLOCK_EXTERNAL' ) || ! WP_HTTP_BLOCK_EXTERNAL )			return false;		// parse_url() only handles http, https type URLs, and will emit E_WARNING on failure.		// This will be displayed on blogs, which is not reasonable.		$check = @parse_url($uri);		/* Malformed URL, can not process, but this could mean ssl, so let through anyway.		 *		 * This isn't very security sound. There are instances where a hacker might attempt		 * to bypass the proxy and this check. However, the reason for this behavior is that		 * WordPress does not do any checking currently for non-proxy requests, so it is keeps with		 * the default unsecure nature of the HTTP request.		 */		if ( $check === false )			return false;		$home = parse_url( get_option('siteurl') );		// Don't block requests back to ourselves by default		if ( $check['host'] == 'localhost' || $check['host'] == $home['host'] )			return apply_filters('block_local_requests', false);		if ( !defined('WP_ACCESSIBLE_HOSTS') )			return true;		static $accessible_hosts;		if ( null == $accessible_hosts )			$accessible_hosts = preg_split('|,\s*|', WP_ACCESSIBLE_HOSTS);		return !in_array( $check['host'], $accessible_hosts ); //Inverse logic, If its in the array, then we can't access it.	}}/** * HTTP request method uses fsockopen function to retrieve the url. * * This would be the preferred method, but the fsockopen implementation has the most overhead of all * the HTTP transport implementations. * * @package WordPress * @subpackage HTTP * @since 2.7.0 */class WP_Http_Fsockopen {	/**	 * Send a HTTP request to a URI using fsockopen().	 *	 * Does not support non-blocking mode.	 *	 * @see WP_Http::request For default options descriptions.	 *	 * @since 2.7	 * @access public	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return array 'headers', 'body', 'cookies' and 'response' keys.	 */	function request($url, $args = array()) {		$defaults = array(			'method' => 'GET', 'timeout' => 5,			'redirection' => 5, 'httpversion' => '1.0',			'blocking' => true,			'headers' => array(), 'body' => null, 'cookies' => array()		);		$r = wp_parse_args( $args, $defaults );		if ( isset($r['headers']['User-Agent']) ) {			$r['user-agent'] = $r['headers']['User-Agent'];			unset($r['headers']['User-Agent']);		} else if( isset($r['headers']['user-agent']) ) {			$r['user-agent'] = $r['headers']['user-agent'];			unset($r['headers']['user-agent']);		}		// Construct Cookie: header if any cookies are set		WP_Http::buildCookieHeader( $r );		$iError = null; // Store error number		$strError = null; // Store error string		$arrURL = parse_url($url);		$fsockopen_host = $arrURL['host'];		$secure_transport = false;		if ( ! isset( $arrURL['port'] ) ) {			if ( ( $arrURL['scheme'] == 'ssl' || $arrURL['scheme'] == 'https' ) && extension_loaded('openssl') ) {				$fsockopen_host = "ssl://$fsockopen_host";				$arrURL['port'] = 443;				$secure_transport = true;			} else {				$arrURL['port'] = 80;			}		}		//fsockopen has issues with 'localhost' with IPv6 with certain versions of PHP, It attempts to connect to ::1,		// which fails when the server is not set up for it. For compatibility, always connect to the IPv4 address.		if ( 'localhost' == strtolower($fsockopen_host) )			$fsockopen_host = '127.0.0.1';		// There are issues with the HTTPS and SSL protocols that cause errors that can be safely		// ignored and should be ignored.		if ( true === $secure_transport )			$error_reporting = error_reporting(0);		$startDelay = time();		$proxy = new WP_HTTP_Proxy();		if ( !WP_DEBUG ) {			if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) )				$handle = @fsockopen( $proxy->host(), $proxy->port(), $iError, $strError, $r['timeout'] );			else				$handle = @fsockopen( $fsockopen_host, $arrURL['port'], $iError, $strError, $r['timeout'] );		} else {			if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) )				$handle = fsockopen( $proxy->host(), $proxy->port(), $iError, $strError, $r['timeout'] );			else				$handle = fsockopen( $fsockopen_host, $arrURL['port'], $iError, $strError, $r['timeout'] );		}		$endDelay = time();		// If the delay is greater than the timeout then fsockopen should't be used, because it will		// cause a long delay.		$elapseDelay = ($endDelay-$startDelay) > $r['timeout'];		if ( true === $elapseDelay )			add_option( 'disable_fsockopen', $endDelay, null, true );		if ( false === $handle )			return new WP_Error('http_request_failed', $iError . ': ' . $strError);		$timeout = (int) floor( $r['timeout'] );		$utimeout = $timeout == $r['timeout'] ? 0 : 1000000 * $r['timeout'] % 1000000;		stream_set_timeout( $handle, $timeout, $utimeout );		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) //Some proxies require full URL in this field.			$requestPath = $url;		else			$requestPath = $arrURL['path'] . ( isset($arrURL['query']) ? '?' . $arrURL['query'] : '' );		if ( empty($requestPath) )			$requestPath .= '/';		$strHeaders = strtoupper($r['method']) . ' ' . $requestPath . ' HTTP/' . $r['httpversion'] . "\r\n";		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) )			$strHeaders .= 'Host: ' . $arrURL['host'] . ':' . $arrURL['port'] . "\r\n";		else			$strHeaders .= 'Host: ' . $arrURL['host'] . "\r\n";		if ( isset($r['user-agent']) )			$strHeaders .= 'User-agent: ' . $r['user-agent'] . "\r\n";		if ( is_array($r['headers']) ) {			foreach ( (array) $r['headers'] as $header => $headerValue )				$strHeaders .= $header . ': ' . $headerValue . "\r\n";		} else {			$strHeaders .= $r['headers'];		}		if ( $proxy->use_authentication() )			$strHeaders .= $proxy->authentication_header() . "\r\n";		$strHeaders .= "\r\n";		if ( ! is_null($r['body']) )			$strHeaders .= $r['body'];		fwrite($handle, $strHeaders);		if ( ! $r['blocking'] ) {			fclose($handle);			return array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		}		$strResponse = '';		while ( ! feof($handle) )			$strResponse .= fread($handle, 4096);		fclose($handle);		if ( true === $secure_transport )			error_reporting($error_reporting);		$process = WP_Http::processResponse($strResponse);		$arrHeaders = WP_Http::processHeaders($process['headers']);		// Is the response code within the 400 range?		if ( (int) $arrHeaders['response']['code'] >= 400 && (int) $arrHeaders['response']['code'] < 500 )			return new WP_Error('http_request_failed', $arrHeaders['response']['code'] . ': ' . $arrHeaders['response']['message']);		// If location is found, then assume redirect and redirect to location.		if ( 'HEAD' != $r['method'] && isset($arrHeaders['headers']['location']) ) {			if ( $r['redirection']-- > 0 ) {				return $this->request($arrHeaders['headers']['location'], $r);			} else {				return new WP_Error('http_request_failed', __('Too many redirects.'));			}		}		// If the body was chunk encoded, then decode it.		if ( ! empty( $process['body'] ) && isset( $arrHeaders['headers']['transfer-encoding'] ) && 'chunked' == $arrHeaders['headers']['transfer-encoding'] )			$process['body'] = WP_Http::chunkTransferDecode($process['body']);		if ( true === $r['decompress'] && true === WP_Http_Encoding::should_decode($arrHeaders['headers']) )			$process['body'] = WP_Http_Encoding::decompress( $process['body'] );		return array('headers' => $arrHeaders['headers'], 'body' => $process['body'], 'response' => $arrHeaders['response'], 'cookies' => $arrHeaders['cookies']);	}	/**	 * Whether this class can be used for retrieving an URL.	 *	 * @since 2.7.0	 * @static	 * @return boolean False means this class can not be used, true means it can.	 */	function test( $args = array() ) {		if ( false !== ($option = get_option( 'disable_fsockopen' )) && time()-$option < 43200 ) // 12 hours			return false;		$is_ssl = isset($args['ssl']) && $args['ssl'];		if ( ! $is_ssl && function_exists( 'fsockopen' ) )			$use = true;		elseif ( $is_ssl && extension_loaded('openssl') && function_exists( 'fsockopen' ) )			$use = true;		else			$use = false;		return apply_filters('use_fsockopen_transport', $use, $args);	}}/** * HTTP request method uses fopen function to retrieve the url. * * Requires PHP version greater than 4.3.0 for stream support. Does not allow for $context support, * but should still be okay, to write the headers, before getting the response. Also requires that * 'allow_url_fopen' to be enabled. * * @package WordPress * @subpackage HTTP * @since 2.7.0 */class WP_Http_Fopen {	/**	 * Send a HTTP request to a URI using fopen().	 *	 * This transport does not support sending of headers and body, therefore should not be used in	 * the instances, where there is a body and headers.	 *	 * Notes: Does not support non-blocking mode. Ignores 'redirection' option.	 *	 * @see WP_Http::retrieve For default options descriptions.	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return array 'headers', 'body', 'cookies' and 'response' keys.	 */	function request($url, $args = array()) {		$defaults = array(			'method' => 'GET', 'timeout' => 5,			'redirection' => 5, 'httpversion' => '1.0',			'blocking' => true,			'headers' => array(), 'body' => null, 'cookies' => array()		);		$r = wp_parse_args( $args, $defaults );		$arrURL = parse_url($url);		if ( false === $arrURL )			return new WP_Error('http_request_failed', sprintf(__('Malformed URL: %s'), $url));		if ( 'http' != $arrURL['scheme'] && 'https' != $arrURL['scheme'] )			$url = str_replace($arrURL['scheme'], 'http', $url);		if ( is_null( $r['headers'] ) )			$r['headers'] = array();		if ( is_string($r['headers']) ) {			$processedHeaders = WP_Http::processHeaders($r['headers']);			$r['headers'] = $processedHeaders['headers'];		}		$initial_user_agent = ini_get('user_agent');		if ( !empty($r['headers']) && is_array($r['headers']) ) {			$user_agent_extra_headers = '';			foreach ( $r['headers'] as $header => $value )				$user_agent_extra_headers .= "\r\n$header: $value";			@ini_set('user_agent', $r['user-agent'] . $user_agent_extra_headers);		} else {			@ini_set('user_agent', $r['user-agent']);		}		if ( !WP_DEBUG )			$handle = @fopen($url, 'r');		else			$handle = fopen($url, 'r');		if (! $handle)			return new WP_Error('http_request_failed', sprintf(__('Could not open handle for fopen() to %s'), $url));		$timeout = (int) floor( $r['timeout'] );		$utimeout = $timeout == $r['timeout'] ? 0 : 1000000 * $r['timeout'] % 1000000;		stream_set_timeout( $handle, $timeout, $utimeout );		if ( ! $r['blocking'] ) {			fclose($handle);			@ini_set('user_agent', $initial_user_agent); //Clean up any extra headers added			return array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		}		$strResponse = '';		while ( ! feof($handle) )			$strResponse .= fread($handle, 4096);		if ( function_exists('stream_get_meta_data') ) {			$meta = stream_get_meta_data($handle);			$theHeaders = $meta['wrapper_data'];			if ( isset( $meta['wrapper_data']['headers'] ) )				$theHeaders = $meta['wrapper_data']['headers'];		} else {			//$http_response_header is a PHP reserved variable which is set in the current-scope when using the HTTP Wrapper			//see http://php.oregonstate.edu/manual/en/reserved.variables.httpresponseheader.php			$theHeaders = $http_response_header;		}		fclose($handle);		@ini_set('user_agent', $initial_user_agent); //Clean up any extra headers added		$processedHeaders = WP_Http::processHeaders($theHeaders);		if ( ! empty( $strResponse ) && isset( $processedHeaders['headers']['transfer-encoding'] ) && 'chunked' == $processedHeaders['headers']['transfer-encoding'] )			$strResponse = WP_Http::chunkTransferDecode($strResponse);		if ( true === $r['decompress'] && true === WP_Http_Encoding::should_decode($processedHeaders['headers']) )			$strResponse = WP_Http_Encoding::decompress( $strResponse );		return array('headers' => $processedHeaders['headers'], 'body' => $strResponse, 'response' => $processedHeaders['response'], 'cookies' => $processedHeaders['cookies']);	}	/**	 * Whether this class can be used for retrieving an URL.	 *	 * @since 2.7.0	 * @static	 * @return boolean False means this class can not be used, true means it can.	 */	function test($args = array()) {		if ( ! function_exists('fopen') || (function_exists('ini_get') && true != ini_get('allow_url_fopen')) )			return false;		if ( isset($args['method']) && 'HEAD' == $args['method'] ) //This transport cannot make a HEAD request			return false;		$use = true;		//PHP does not verify SSL certs, We can only make a request via this transports if SSL Verification is turned off.		$is_ssl = isset($args['ssl']) && $args['ssl'];		if ( $is_ssl ) {			$is_local = isset($args['local']) && $args['local'];			$ssl_verify = isset($args['sslverify']) && $args['sslverify'];			if ( $is_local && true != apply_filters('https_local_ssl_verify', true) )				$use = true;			elseif ( !$is_local && true != apply_filters('https_ssl_verify', true) )				$use = true;			elseif ( !$ssl_verify )				$use = true;			else				$use = false;		}		return apply_filters('use_fopen_transport', $use, $args);	}}/** * HTTP request method uses Streams to retrieve the url. * * Requires PHP 5.0+ and uses fopen with stream context. Requires that 'allow_url_fopen' PHP setting * to be enabled. * * Second preferred method for getting the URL, for PHP 5. * * @package WordPress * @subpackage HTTP * @since 2.7.0 */class WP_Http_Streams {	/**	 * Send a HTTP request to a URI using streams with fopen().	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url	 * @param str|array $args Optional. Override the defaults.	 * @return array 'headers', 'body', 'cookies' and 'response' keys.	 */	function request($url, $args = array()) {		$defaults = array(			'method' => 'GET', 'timeout' => 5,			'redirection' => 5, 'httpversion' => '1.0',			'blocking' => true,			'headers' => array(), 'body' => null, 'cookies' => array()		);		$r = wp_parse_args( $args, $defaults );		if ( isset($r['headers']['User-Agent']) ) {			$r['user-agent'] = $r['headers']['User-Agent'];			unset($r['headers']['User-Agent']);		} else if( isset($r['headers']['user-agent']) ) {			$r['user-agent'] = $r['headers']['user-agent'];			unset($r['headers']['user-agent']);		}		// Construct Cookie: header if any cookies are set		WP_Http::buildCookieHeader( $r );		$arrURL = parse_url($url);		if ( false === $arrURL )			return new WP_Error('http_request_failed', sprintf(__('Malformed URL: %s'), $url));		if ( 'http' != $arrURL['scheme'] && 'https' != $arrURL['scheme'] )			$url = preg_replace('|^' . preg_quote($arrURL['scheme'], '|') . '|', 'http', $url);		// Convert Header array to string.		$strHeaders = '';		if ( is_array( $r['headers'] ) )			foreach ( $r['headers'] as $name => $value )				$strHeaders .= "{$name}: $value\r\n";		else if ( is_string( $r['headers'] ) )			$strHeaders = $r['headers'];		$is_local = isset($args['local']) && $args['local'];		$ssl_verify = isset($args['sslverify']) && $args['sslverify'];		if ( $is_local )			$ssl_verify = apply_filters('https_local_ssl_verify', $ssl_verify);		elseif ( ! $is_local )			$ssl_verify = apply_filters('https_ssl_verify', $ssl_verify);		$arrContext = array('http' =>			array(				'method' => strtoupper($r['method']),				'user_agent' => $r['user-agent'],				'max_redirects' => $r['redirection'] + 1, // See #11557				'protocol_version' => (float) $r['httpversion'],				'header' => $strHeaders,				'ignore_errors' => true, // Return non-200 requests.				'timeout' => $r['timeout'],				'ssl' => array(						'verify_peer' => $ssl_verify,						'verify_host' => $ssl_verify				)			)		);		$proxy = new WP_HTTP_Proxy();		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) {			$arrContext['http']['proxy'] = 'tcp://' . $proxy->host() . ':' . $proxy->port();			$arrContext['http']['request_fulluri'] = true;			// We only support Basic authentication so this will only work if that is what your proxy supports.			if ( $proxy->use_authentication() )				$arrContext['http']['header'] .= $proxy->authentication_header() . "\r\n";		}		if ( 'HEAD' == $r['method'] ) // Disable redirects for HEAD requests			$arrContext['http']['max_redirects'] = 1;		if ( ! empty($r['body'] ) )			$arrContext['http']['content'] = $r['body'];		$context = stream_context_create($arrContext);		if ( !WP_DEBUG )			$handle = @fopen($url, 'r', false, $context);		else			$handle = fopen($url, 'r', false, $context);		if ( ! $handle )			return new WP_Error('http_request_failed', sprintf(__('Could not open handle for fopen() to %s'), $url));		$timeout = (int) floor( $r['timeout'] );		$utimeout = $timeout == $r['timeout'] ? 0 : 1000000 * $r['timeout'] % 1000000;		stream_set_timeout( $handle, $timeout, $utimeout );		if ( ! $r['blocking'] ) {			stream_set_blocking($handle, 0);			fclose($handle);			return array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		}		$strResponse = stream_get_contents($handle);		$meta = stream_get_meta_data($handle);		fclose($handle);		$processedHeaders = array();		if ( isset( $meta['wrapper_data']['headers'] ) )			$processedHeaders = WP_Http::processHeaders($meta['wrapper_data']['headers']);		else			$processedHeaders = WP_Http::processHeaders($meta['wrapper_data']);		if ( ! empty( $strResponse ) && isset( $processedHeaders['headers']['transfer-encoding'] ) && 'chunked' == $processedHeaders['headers']['transfer-encoding'] )			$strResponse = WP_Http::chunkTransferDecode($strResponse);		if ( true === $r['decompress'] && true === WP_Http_Encoding::should_decode($processedHeaders['headers']) )			$strResponse = WP_Http_Encoding::decompress( $strResponse );		return array('headers' => $processedHeaders['headers'], 'body' => $strResponse, 'response' => $processedHeaders['response'], 'cookies' => $processedHeaders['cookies']);	}	/**	 * Whether this class can be used for retrieving an URL.	 *	 * @static	 * @access public	 * @since 2.7.0	 *	 * @return boolean False means this class can not be used, true means it can.	 */	function test($args = array()) {		if ( ! function_exists('fopen') || (function_exists('ini_get') && true != ini_get('allow_url_fopen')) )			return false;		if ( version_compare(PHP_VERSION, '5.0', '<') )			return false;		//HTTPS via Proxy was added in 5.1.0		$is_ssl = isset($args['ssl']) && $args['ssl'];		if ( $is_ssl && version_compare(PHP_VERSION, '5.1.0', '<') ) {			$proxy = new WP_HTTP_Proxy();			/**			 * No URL check, as its not currently passed to the ::test() function			 * In the case where a Proxy is in use, Just bypass this transport for HTTPS.			 */			if ( $proxy->is_enabled() )				return false;		}		return apply_filters('use_streams_transport', true, $args);	}}/** * HTTP request method uses HTTP extension to retrieve the url. * * Requires the HTTP extension to be installed. This would be the preferred transport since it can * handle a lot of the problems that forces the others to use the HTTP version 1.0. Even if PHP 5.2+ * is being used, it doesn't mean that the HTTP extension will be enabled. * * @package WordPress * @subpackage HTTP * @since 2.7.0 */class WP_Http_ExtHTTP {	/**	 * Send a HTTP request to a URI using HTTP extension.	 *	 * Does not support non-blocking.	 *	 * @access public	 * @since 2.7	 *	 * @param string $url	 * @param str|array $args Optional. Override the defaults.	 * @return array 'headers', 'body', 'cookies' and 'response' keys.	 */	function request($url, $args = array()) {		$defaults = array(			'method' => 'GET', 'timeout' => 5,			'redirection' => 5, 'httpversion' => '1.0',			'blocking' => true,			'headers' => array(), 'body' => null, 'cookies' => array()		);		$r = wp_parse_args( $args, $defaults );		if ( isset($r['headers']['User-Agent']) ) {			$r['user-agent'] = $r['headers']['User-Agent'];			unset($r['headers']['User-Agent']);		} else if( isset($r['headers']['user-agent']) ) {			$r['user-agent'] = $r['headers']['user-agent'];			unset($r['headers']['user-agent']);		}		// Construct Cookie: header if any cookies are set		WP_Http::buildCookieHeader( $r );		switch ( $r['method'] ) {			case 'POST':				$r['method'] = HTTP_METH_POST;				break;			case 'HEAD':				$r['method'] = HTTP_METH_HEAD;				break;			case 'PUT':				$r['method'] =  HTTP_METH_PUT;				break;			case 'GET':			default:				$r['method'] = HTTP_METH_GET;		}		$arrURL = parse_url($url);		if ( 'http' != $arrURL['scheme'] && 'https' != $arrURL['scheme'] )			$url = preg_replace('|^' . preg_quote($arrURL['scheme'], '|') . '|', 'http', $url);		$is_local = isset($args['local']) && $args['local'];		$ssl_verify = isset($args['sslverify']) && $args['sslverify'];		if ( $is_local )			$ssl_verify = apply_filters('https_local_ssl_verify', $ssl_verify);		elseif ( ! $is_local )			$ssl_verify = apply_filters('https_ssl_verify', $ssl_verify);		$r['timeout'] = (int) ceil( $r['timeout'] );		$options = array(			'timeout' => $r['timeout'],			'connecttimeout' => $r['timeout'],			'redirect' => $r['redirection'],			'useragent' => $r['user-agent'],			'headers' => $r['headers'],			'ssl' => array(				'verifypeer' => $ssl_verify,				'verifyhost' => $ssl_verify			)		);		if ( HTTP_METH_HEAD == $r['method'] )			$options['redirect'] = 0; // Assumption: Docs seem to suggest that this means do not follow. Untested.		// The HTTP extensions offers really easy proxy support.		$proxy = new WP_HTTP_Proxy();		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) {			$options['proxyhost'] = $proxy->host();			$options['proxyport'] = $proxy->port();			$options['proxytype'] = HTTP_PROXY_HTTP;			if ( $proxy->use_authentication() ) {				$options['proxyauth'] = $proxy->authentication();				$options['proxyauthtype'] = HTTP_AUTH_ANY;			}		}		if ( !WP_DEBUG ) //Emits warning level notices for max redirects and timeouts			$strResponse = @http_request($r['method'], $url, $r['body'], $options, $info);		else			$strResponse = http_request($r['method'], $url, $r['body'], $options, $info); //Emits warning level notices for max redirects and timeouts		// Error may still be set, Response may return headers or partial document, and error		// contains a reason the request was aborted, eg, timeout expired or max-redirects reached.		if ( false === $strResponse || ! empty($info['error']) )			return new WP_Error('http_request_failed', $info['response_code'] . ': ' . $info['error']);		if ( ! $r['blocking'] )			return array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		$headers_body = WP_HTTP::processResponse($strResponse);		$theHeaders = $headers_body['headers'];		$theBody = $headers_body['body'];		unset($headers_body);		$theHeaders = WP_Http::processHeaders($theHeaders);		if ( ! empty( $theBody ) && isset( $theHeaders['headers']['transfer-encoding'] ) && 'chunked' == $theHeaders['headers']['transfer-encoding'] ) {			if ( !WP_DEBUG )				$theBody = @http_chunked_decode($theBody);			else				$theBody = http_chunked_decode($theBody);		}		if ( true === $r['decompress'] && true === WP_Http_Encoding::should_decode($theHeaders['headers']) )			$theBody = http_inflate( $theBody );		$theResponse = array();		$theResponse['code'] = $info['response_code'];		$theResponse['message'] = get_status_header_desc($info['response_code']);		return array('headers' => $theHeaders['headers'], 'body' => $theBody, 'response' => $theResponse, 'cookies' => $theHeaders['cookies']);	}	/**	 * Whether this class can be used for retrieving an URL.	 *	 * @static	 * @since 2.7.0	 *	 * @return boolean False means this class can not be used, true means it can.	 */	function test($args = array()) {		return apply_filters('use_http_extension_transport', function_exists('http_request'), $args );	}}/** * HTTP request method uses Curl extension to retrieve the url. * * Requires the Curl extension to be installed. * * @package WordPress * @subpackage HTTP * @since 2.7 */class WP_Http_Curl {	/**	 * Send a HTTP request to a URI using cURL extension.	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url	 * @param str|array $args Optional. Override the defaults.	 * @return array 'headers', 'body', 'cookies' and 'response' keys.	 */	function request($url, $args = array()) {		$defaults = array(			'method' => 'GET', 'timeout' => 5,			'redirection' => 5, 'httpversion' => '1.0',			'blocking' => true,			'headers' => array(), 'body' => null, 'cookies' => array()		);		$r = wp_parse_args( $args, $defaults );		if ( isset($r['headers']['User-Agent']) ) {			$r['user-agent'] = $r['headers']['User-Agent'];			unset($r['headers']['User-Agent']);		} else if( isset($r['headers']['user-agent']) ) {			$r['user-agent'] = $r['headers']['user-agent'];			unset($r['headers']['user-agent']);		}		// Construct Cookie: header if any cookies are set.		WP_Http::buildCookieHeader( $r );		$handle = curl_init();		// cURL offers really easy proxy support.		$proxy = new WP_HTTP_Proxy();		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) {			$isPHP5 = version_compare(PHP_VERSION, '5.0.0', '>=');			if ( $isPHP5 ) {				curl_setopt( $handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP );				curl_setopt( $handle, CURLOPT_PROXY, $proxy->host() );				curl_setopt( $handle, CURLOPT_PROXYPORT, $proxy->port() );			} else {				curl_setopt( $handle, CURLOPT_PROXY, $proxy->host() .':'. $proxy->port() );			}			if ( $proxy->use_authentication() ) {				if ( $isPHP5 )					curl_setopt( $handle, CURLOPT_PROXYAUTH, CURLAUTH_ANY );				curl_setopt( $handle, CURLOPT_PROXYUSERPWD, $proxy->authentication() );			}		}		$is_local = isset($args['local']) && $args['local'];		$ssl_verify = isset($args['sslverify']) && $args['sslverify'];		if ( $is_local )			$ssl_verify = apply_filters('https_local_ssl_verify', $ssl_verify);		elseif ( ! $is_local )			$ssl_verify = apply_filters('https_ssl_verify', $ssl_verify);		// CURLOPT_TIMEOUT and CURLOPT_CONNECTTIMEOUT expect integers.  Have to use ceil since		// a value of 0 will allow an ulimited timeout.		$timeout = (int) ceil( $r['timeout'] );		curl_setopt( $handle, CURLOPT_CONNECTTIMEOUT, $timeout );		curl_setopt( $handle, CURLOPT_TIMEOUT, $timeout );		curl_setopt( $handle, CURLOPT_URL, $url);		curl_setopt( $handle, CURLOPT_RETURNTRANSFER, true );		curl_setopt( $handle, CURLOPT_SSL_VERIFYHOST, $ssl_verify );		curl_setopt( $handle, CURLOPT_SSL_VERIFYPEER, $ssl_verify );		curl_setopt( $handle, CURLOPT_USERAGENT, $r['user-agent'] );		curl_setopt( $handle, CURLOPT_MAXREDIRS, $r['redirection'] );		switch ( $r['method'] ) {			case 'HEAD':				curl_setopt( $handle, CURLOPT_NOBODY, true );				break;			case 'POST':				curl_setopt( $handle, CURLOPT_POST, true );				curl_setopt( $handle, CURLOPT_POSTFIELDS, $r['body'] );				break;			case 'PUT':				curl_setopt( $handle, CURLOPT_CUSTOMREQUEST, 'PUT' );				curl_setopt( $handle, CURLOPT_POSTFIELDS, $r['body'] );				break;		}		if ( true === $r['blocking'] )			curl_setopt( $handle, CURLOPT_HEADER, true );		else			curl_setopt( $handle, CURLOPT_HEADER, false );		// The option doesn't work with safe mode or when open_basedir is set.		// Disable HEAD when making HEAD requests.		if ( !ini_get('safe_mode') && !ini_get('open_basedir') && 'HEAD' != $r['method'] )			curl_setopt( $handle, CURLOPT_FOLLOWLOCATION, true );		if ( !empty( $r['headers'] ) ) {			// cURL expects full header strings in each element			$headers = array();			foreach ( $r['headers'] as $name => $value ) {				$headers[] = "{$name}: $value";			}			curl_setopt( $handle, CURLOPT_HTTPHEADER, $headers );		}		if ( $r['httpversion'] == '1.0' )			curl_setopt( $handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0 );		else			curl_setopt( $handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1 );		// Cookies are not handled by the HTTP API currently. Allow for plugin authors to handle it		// themselves... Although, it is somewhat pointless without some reference.		do_action_ref_array( 'http_api_curl', array(&$handle) );		// We don't need to return the body, so don't. Just execute request and return.		if ( ! $r['blocking'] ) {			curl_exec( $handle );			curl_close( $handle );			return array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		}		$theResponse = curl_exec( $handle );		if ( !empty($theResponse) ) {			$headerLength = curl_getinfo($handle, CURLINFO_HEADER_SIZE);			$theHeaders = trim( substr($theResponse, 0, $headerLength) );			if ( strlen($theResponse) > $headerLength )				$theBody = substr( $theResponse, $headerLength );			else				$theBody = '';			if ( false !== strrpos($theHeaders, "\r\n\r\n") ) {				$headerParts = explode("\r\n\r\n", $theHeaders);				$theHeaders = $headerParts[ count($headerParts) -1 ];			}			$theHeaders = WP_Http::processHeaders($theHeaders);		} else {			if ( $curl_error = curl_error($handle) )				return new WP_Error('http_request_failed', $curl_error);			if ( in_array( curl_getinfo( $handle, CURLINFO_HTTP_CODE ), array(301, 302) ) )				return new WP_Error('http_request_failed', __('Too many redirects.'));			$theHeaders = array( 'headers' => array(), 'cookies' => array() );			$theBody = '';		}		$response = array();		$response['code'] = curl_getinfo( $handle, CURLINFO_HTTP_CODE );		$response['message'] = get_status_header_desc($response['code']);		curl_close( $handle );		// See #11305 - When running under safe mode, redirection is disabled above. Handle it manually.		if ( !empty($theHeaders['headers']['location']) && (ini_get('safe_mode') || ini_get('open_basedir')) ) {			if ( $r['redirection']-- > 0 ) {				return $this->request($theHeaders['headers']['location'], $r);			} else {				return new WP_Error('http_request_failed', __('Too many redirects.'));			}		}		if ( true === $r['decompress'] && true === WP_Http_Encoding::should_decode($theHeaders['headers']) )			$theBody = WP_Http_Encoding::decompress( $theBody );		return array('headers' => $theHeaders['headers'], 'body' => $theBody, 'response' => $response, 'cookies' => $theHeaders['cookies']);	}	/**	 * Whether this class can be used for retrieving an URL.	 *	 * @static	 * @since 2.7.0	 *	 * @return boolean False means this class can not be used, true means it can.	 */	function test($args = array()) {		if ( function_exists('curl_init') && function_exists('curl_exec') )			return apply_filters('use_curl_transport', true, $args);		return false;	}}/** * Adds Proxy support to the WordPress HTTP API. * * There are caveats to proxy support. It requires that defines be made in the wp-config.php file to * enable proxy support. There are also a few filters that plugins can hook into for some of the * constants. * * Please note that only BASIC authentication is supported by most transports. * cURL and the PHP HTTP Extension MAY support more methods (such as NTLM authentication) depending on your environment. * * The constants are as follows: * <ol> * <li>WP_PROXY_HOST - Enable proxy support and host for connecting.</li> * <li>WP_PROXY_PORT - Proxy port for connection. No default, must be defined.</li> * <li>WP_PROXY_USERNAME - Proxy username, if it requires authentication.</li> * <li>WP_PROXY_PASSWORD - Proxy password, if it requires authentication.</li> * <li>WP_PROXY_BYPASS_HOSTS - Will prevent the hosts in this list from going through the proxy. * You do not need to have localhost and the blog host in this list, because they will not be passed * through the proxy. The list should be presented in a comma separated list</li> * </ol> * * An example can be as seen below. * <code> * define('WP_PROXY_HOST', '192.168.84.101'); * define('WP_PROXY_PORT', '8080'); * define('WP_PROXY_BYPASS_HOSTS', 'localhost, www.example.com'); * </code> * * @link http://core.trac.wordpress.org/ticket/4011 Proxy support ticket in WordPress. * @since 2.8 */class WP_HTTP_Proxy {	/**	 * Whether proxy connection should be used.	 *	 * @since 2.8	 * @use WP_PROXY_HOST	 * @use WP_PROXY_PORT	 *	 * @return bool	 */	function is_enabled() {		return defined('WP_PROXY_HOST') && defined('WP_PROXY_PORT');	}	/**	 * Whether authentication should be used.	 *	 * @since 2.8	 * @use WP_PROXY_USERNAME	 * @use WP_PROXY_PASSWORD	 *	 * @return bool	 */	function use_authentication() {		return defined('WP_PROXY_USERNAME') && defined('WP_PROXY_PASSWORD');	}	/**	 * Retrieve the host for the proxy server.	 *	 * @since 2.8	 *	 * @return string	 */	function host() {		if ( defined('WP_PROXY_HOST') )			return WP_PROXY_HOST;		return '';	}	/**	 * Retrieve the port for the proxy server.	 *	 * @since 2.8	 *	 * @return string	 */	function port() {		if ( defined('WP_PROXY_PORT') )			return WP_PROXY_PORT;		return '';	}	/**	 * Retrieve the username for proxy authentication.	 *	 * @since 2.8	 *	 * @return string	 */	function username() {		if ( defined('WP_PROXY_USERNAME') )			return WP_PROXY_USERNAME;		return '';	}	/**	 * Retrieve the password for proxy authentication.	 *	 * @since 2.8	 *	 * @return string	 */	function password() {		if ( defined('WP_PROXY_PASSWORD') )			return WP_PROXY_PASSWORD;		return '';	}	/**	 * Retrieve authentication string for proxy authentication.	 *	 * @since 2.8	 *	 * @return string	 */	function authentication() {		return $this->username() . ':' . $this->password();	}	/**	 * Retrieve header string for proxy authentication.	 *	 * @since 2.8	 *	 * @return string	 */	function authentication_header() {		return 'Proxy-Authorization: Basic ' . base64_encode( $this->authentication() );	}	/**	 * Whether URL should be sent through the proxy server.	 *	 * We want to keep localhost and the blog URL from being sent through the proxy server, because	 * some proxies can not handle this. We also have the constant available for defining other	 * hosts that won't be sent through the proxy.	 *	 * @uses WP_PROXY_BYPASS_HOSTS	 * @since unknown	 *	 * @param string $uri URI to check.	 * @return bool True, to send through the proxy and false if, the proxy should not be used.	 */	function send_through_proxy( $uri ) {		// parse_url() only handles http, https type URLs, and will emit E_WARNING on failure.		// This will be displayed on blogs, which is not reasonable.		$check = @parse_url($uri);		// Malformed URL, can not process, but this could mean ssl, so let through anyway.		if ( $check === false )			return true;		$home = parse_url( get_option('siteurl') );		if ( $check['host'] == 'localhost' || $check['host'] == $home['host'] )			return false;		if ( !defined('WP_PROXY_BYPASS_HOSTS') )			return true;		static $bypass_hosts;		if ( null == $bypass_hosts )			$bypass_hosts = preg_split('|,\s*|', WP_PROXY_BYPASS_HOSTS);		return !in_array( $check['host'], $bypass_hosts );	}}/** * Internal representation of a single cookie. * * Returned cookies are represented using this class, and when cookies are set, if they are not * already a WP_Http_Cookie() object, then they are turned into one. * * @todo The WordPress convention is to use underscores instead of camelCase for function and method * names. Need to switch to use underscores instead for the methods. * * @package WordPress * @subpackage HTTP * @since 2.8.0 */class WP_Http_Cookie {	/**	 * Cookie name.	 *	 * @since 2.8.0	 * @var string	 */	var $name;	/**	 * Cookie value.	 *	 * @since 2.8.0	 * @var string	 */	var $value;	/**	 * When the cookie expires.	 *	 * @since 2.8.0	 * @var string	 */	var $expires;	/**	 * Cookie URL path.	 *	 * @since 2.8.0	 * @var string	 */	var $path;	/**	 * Cookie Domain.	 *	 * @since 2.8.0	 * @var string	 */	var $domain;	/**	 * PHP4 style Constructor - Calls PHP5 Style Constructor.	 *	 * @access public	 * @since 2.8.0	 * @param string|array $data Raw cookie data.	 */	function WP_Http_Cookie( $data ) {		$this->__construct( $data );	}	/**	 * Sets up this cookie object.	 *	 * The parameter $data should be either an associative array containing the indices names below	 * or a header string detailing it.	 *	 * If it's an array, it should include the following elements:	 * <ol>	 * <li>Name</li>	 * <li>Value - should NOT be urlencoded already.</li>	 * <li>Expires - (optional) String or int (UNIX timestamp).</li>	 * <li>Path (optional)</li>	 * <li>Domain (optional)</li>	 * </ol>	 *	 * @access public	 * @since 2.8.0	 *	 * @param string|array $data Raw cookie data.	 */	function __construct( $data ) {		if ( is_string( $data ) ) {			// Assume it's a header string direct from a previous request			$pairs = explode( ';', $data );			// Special handling for first pair; name=value. Also be careful of "=" in value			$name  = trim( substr( $pairs[0], 0, strpos( $pairs[0], '=' ) ) );			$value = substr( $pairs[0], strpos( $pairs[0], '=' ) + 1 );			$this->name  = $name;			$this->value = urldecode( $value );			array_shift( $pairs ); //Removes name=value from items.			// Set everything else as a property			foreach ( $pairs as $pair ) {				$pair = rtrim($pair);				if ( empty($pair) ) //Handles the cookie ending in ; which results in a empty final pair					continue;				list( $key, $val ) = strpos( $pair, '=' ) ? explode( '=', $pair ) : array( $pair, '' );				$key = strtolower( trim( $key ) );				if ( 'expires' == $key )					$val = strtotime( $val );				$this->$key = $val;			}		} else {			if ( !isset( $data['name'] ) )				return false;			// Set properties based directly on parameters			$this->name   = $data['name'];			$this->value  = isset( $data['value'] ) ? $data['value'] : '';			$this->path   = isset( $data['path'] ) ? $data['path'] : '';			$this->domain = isset( $data['domain'] ) ? $data['domain'] : '';			if ( isset( $data['expires'] ) )				$this->expires = is_int( $data['expires'] ) ? $data['expires'] : strtotime( $data['expires'] );			else				$this->expires = null;		}	}	/**	 * Confirms that it's OK to send this cookie to the URL checked against.	 *	 * Decision is based on RFC 2109/2965, so look there for details on validity.	 *	 * @access public	 * @since 2.8.0	 *	 * @param string $url URL you intend to send this cookie to	 * @return boolean TRUE if allowed, FALSE otherwise.	 */	function test( $url ) {		// Expires - if expired then nothing else matters		if ( time() > $this->expires )			return false;		// Get details on the URL we're thinking about sending to		$url = parse_url( $url );		$url['port'] = isset( $url['port'] ) ? $url['port'] : 80;		$url['path'] = isset( $url['path'] ) ? $url['path'] : '/';		// Values to use for comparison against the URL		$path   = isset( $this->path )   ? $this->path   : '/';		$port   = isset( $this->port )   ? $this->port   : 80;		$domain = isset( $this->domain ) ? strtolower( $this->domain ) : strtolower( $url['host'] );		if ( false === stripos( $domain, '.' ) )			$domain .= '.local';		// Host - very basic check that the request URL ends with the domain restriction (minus leading dot)		$domain = substr( $domain, 0, 1 ) == '.' ? substr( $domain, 1 ) : $domain;		if ( substr( $url['host'], -strlen( $domain ) ) != $domain )			return false;		// Port - supports "port-lists" in the format: "80,8000,8080"		if ( !in_array( $url['port'], explode( ',', $port) ) )			return false;		// Path - request path must start with path restriction		if ( substr( $url['path'], 0, strlen( $path ) ) != $path )			return false;		return true;	}	/**	 * Convert cookie name and value back to header string.	 *	 * @access public	 * @since 2.8.0	 *	 * @return string Header encoded cookie name and value.	 */	function getHeaderValue() {		if ( empty( $this->name ) || empty( $this->value ) )			return '';		return $this->name . '=' . urlencode( $this->value );	}	/**	 * Retrieve cookie header for usage in the rest of the WordPress HTTP API.	 *	 * @access public	 * @since 2.8.0	 *	 * @return string	 */	function getFullHeader() {		return 'Cookie: ' . $this->getHeaderValue();	}}/** * Implementation for deflate and gzip transfer encodings. * * Includes RFC 1950, RFC 1951, and RFC 1952. * * @since 2.8 * @package WordPress * @subpackage HTTP */class WP_Http_Encoding {	/**	 * Compress raw string using the deflate format.	 *	 * Supports the RFC 1951 standard.	 *	 * @since 2.8	 *	 * @param string $raw String to compress.	 * @param int $level Optional, default is 9. Compression level, 9 is highest.	 * @param string $supports Optional, not used. When implemented it will choose the right compression based on what the server supports.	 * @return string|bool False on failure.	 */	function compress( $raw, $level = 9, $supports = null ) {		return gzdeflate( $raw, $level );	}	/**	 * Decompression of deflated string.	 *	 * Will attempt to decompress using the RFC 1950 standard, and if that fails	 * then the RFC 1951 standard deflate will be attempted. Finally, the RFC	 * 1952 standard gzip decode will be attempted. If all fail, then the	 * original compressed string will be returned.	 *	 * @since 2.8	 *	 * @param string $compressed String to decompress.	 * @param int $length The optional length of the compressed data.	 * @return string|bool False on failure.	 */	function decompress( $compressed, $length = null ) {		if ( empty($compressed) )			return $compressed;		if ( false !== ( $decompressed = @gzinflate( $compressed ) ) )			return $decompressed;		if ( false !== ( $decompressed = WP_Http_Encoding::compatible_gzinflate( $compressed ) ) )			return $decompressed;		if ( false !== ( $decompressed = @gzuncompress( $compressed ) ) )			return $decompressed;		if ( function_exists('gzdecode') ) {			$decompressed = @gzdecode( $compressed );			if ( false !== $decompressed )				return $decompressed;		}		return $compressed;	}	/**	 * Decompression of deflated string while staying compatible with the majority of servers.	 *	 * Certain Servers will return deflated data with headers which PHP's gziniflate()	 * function cannot handle out of the box. The following function lifted from	 * http://au2.php.net/manual/en/function.gzinflate.php#77336 will attempt to deflate	 * the various return forms used.	 *	 * @since 2.8.1	 * @link http://au2.php.net/manual/en/function.gzinflate.php#77336	 *	 * @param string $gzData String to decompress.	 * @return string|bool False on failure.	 */	function compatible_gzinflate($gzData) {		if ( substr($gzData, 0, 3) == "\x1f\x8b\x08" ) {			$i = 10;			$flg = ord( substr($gzData, 3, 1) );			if ( $flg > 0 ) {				if ( $flg & 4 ) {					list($xlen) = unpack('v', substr($gzData, $i, 2) );					$i = $i + 2 + $xlen;				}				if ( $flg & 8 )					$i = strpos($gzData, "\0", $i) + 1;				if ( $flg & 16 )					$i = strpos($gzData, "\0", $i) + 1;				if ( $flg & 2 )					$i = $i + 2;			}			return gzinflate( substr($gzData, $i, -8) );		} else {			return false;		}	}	/**	 * What encoding types to accept and their priority values.	 *	 * @since 2.8	 *	 * @return string Types of encoding to accept.	 */	function accept_encoding() {		$type = array();		if ( function_exists( 'gzinflate' ) )			$type[] = 'deflate;q=1.0';		if ( function_exists( 'gzuncompress' ) )			$type[] = 'compress;q=0.5';		if ( function_exists( 'gzdecode' ) )			$type[] = 'gzip;q=0.5';		return implode(', ', $type);	}	/**	 * What enconding the content used when it was compressed to send in the headers.	 *	 * @since 2.8	 *	 * @return string Content-Encoding string to send in the header.	 */	function content_encoding() {		return 'deflate';	}	/**	 * Whether the content be decoded based on the headers.	 *	 * @since 2.8	 *	 * @param array|string $headers All of the available headers.	 * @return bool	 */	function should_decode($headers) {		if ( is_array( $headers ) ) {			if ( array_key_exists('content-encoding', $headers) && ! empty( $headers['content-encoding'] ) )				return true;		} else if ( is_string( $headers ) ) {			return ( stripos($headers, 'content-encoding:') !== false );		}		return false;	}	/**	 * Whether decompression and compression are supported by the PHP version.	 *	 * Each function is tested instead of checking for the zlib extension, to	 * ensure that the functions all exist in the PHP version and aren't	 * disabled.	 *	 * @since 2.8	 *	 * @return bool	 */	function is_available() {		return ( function_exists('gzuncompress') || function_exists('gzdeflate') || function_exists('gzinflate') );	}}
<?php/** * WordPress Upgrade Functions. Old file, must not be used. Include * wp-admin/includes/upgrade.php instead. * * @deprecated 2.5 * @package WordPress * @subpackage Administration */_deprecated_file( basename(__FILE__), '2.5', 'wp-admin/includes/upgrade.php' );require_once(ABSPATH . 'wp-admin/includes/upgrade.php');?>
<?php/** * The Template for displaying all single posts. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main"><?php if ( have_posts() ) while ( have_posts() ) : the_post(); ?>				<div id="nav-above" class="navigation">					<div class="nav-previous"><?php previous_post_link( '%link', '<span class="meta-nav">' . _x( '&larr;', 'Previous post link', 'twentyten' ) . '</span> %title' ); ?></div>					<div class="nav-next"><?php next_post_link( '%link', '%title <span class="meta-nav">' . _x( '&rarr;', 'Next post link', 'twentyten' ) . '</span>' ); ?></div>				</div><!-- #nav-above -->				<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>					<h1 class="entry-title"><?php the_title(); ?></h1>					<div class="entry-meta">						<?php twentyten_posted_on(); ?>					</div><!-- .entry-meta -->					<div class="entry-content">						<?php the_content(); ?>						<?php wp_link_pages( array( 'before' => '<div class="page-link">' . __( 'Pages:', 'twentyten' ), 'after' => '</div>' ) ); ?>					</div><!-- .entry-content --><?php if ( get_the_author_meta( 'description' ) ) : // If a user has filled out their description, show a bio on their entries  ?>					<div id="entry-author-info">						<div id="author-avatar">							<?php echo get_avatar( get_the_author_meta( 'user_email' ), apply_filters( 'twentyten_author_bio_avatar_size', 60 ) ); ?>						</div><!-- #author-avatar -->						<div id="author-description">							<h2><?php printf( esc_attr__( 'About %s', 'twentyten' ), get_the_author() ); ?></h2>							<?php the_author_meta( 'description' ); ?>							<div id="author-link">								<a href="<?php echo get_author_posts_url( get_the_author_meta( 'ID' ) ); ?>">									<?php printf( __( 'View all posts by %s <span class="meta-nav">&rarr;</span>', 'twentyten' ), get_the_author() ); ?>								</a>							</div><!-- #author-link	-->						</div><!-- #author-description -->					</div><!-- #entry-author-info --><?php endif; ?>					<div class="entry-utility">						<?php twentyten_posted_in(); ?>						<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="edit-link">', '</span>' ); ?>					</div><!-- .entry-utility -->				</div><!-- #post-## -->				<div id="nav-below" class="navigation">					<div class="nav-previous"><?php previous_post_link( '%link', '<span class="meta-nav">' . _x( '&larr;', 'Previous post link', 'twentyten' ) . '</span> %title' ); ?></div>					<div class="nav-next"><?php next_post_link( '%link', '%title <span class="meta-nav">' . _x( '&rarr;', 'Next post link', 'twentyten' ) . '</span>' ); ?></div>				</div><!-- #nav-below -->				<?php comments_template( '', true ); ?><?php endwhile; // end of the loop. ?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
<?php/** * WordPress Direct Filesystem. * * @package WordPress * @subpackage Filesystem *//** * WordPress Filesystem Class for direct PHP file and folder manipulation. * * @since 2.5 * @package WordPress * @subpackage Filesystem * @uses WP_Filesystem_Base Extends class */class WP_Filesystem_Direct extends WP_Filesystem_Base {	var $errors = null;	/**	 * constructor	 *	 * @param $arg mixed ingored argument	 */	function WP_Filesystem_Direct($arg) {		$this->method = 'direct';		$this->errors = new WP_Error();	}	/**	 * connect filesystem.	 *	 * @return bool Returns true on success or false on failure (always true for WP_Filesystem_Direct).	 */	function connect() {		return true;	}	/**	 * Reads entire file into a string	 *	 * @param $file string Name of the file to read.	 * @return string|bool The function returns the read data or false on failure.	 */	function get_contents($file) {		return @file_get_contents($file);	}	/**	 * Reads entire file into an array	 *	 * @param $file string Path to the file.	 * @return array|bool the file contents in an array or false on failure.	 */	function get_contents_array($file) {		return @file($file);	}	/**	 * Write a string to a file	 *	 * @param $file string Remote path to the file where to write the data.	 * @param $contents string The data to write.	 * @param $mode int (optional) The file permissions as octal number, usually 0644.	 * @return bool False upon failure.	 */	function put_contents($file, $contents, $mode = false ) {		if ( ! ($fp = @fopen($file, 'w')) )			return false;		@fwrite($fp, $contents);		@fclose($fp);		$this->chmod($file, $mode);		return true;	}	/**	 * Gets the current working directory	 *	 * @return string|bool the current working directory on success, or false on failure.	 */	function cwd() {		return @getcwd();	}	/**	 * Change directory	 *	 * @param $dir string The new current directory.	 * @return bool Returns true on success or false on failure.	 */	function chdir($dir) {		return @chdir($dir);	}	/**	 * Changes file group	 *	 * @param $file string Path to the file.	 * @param $group mixed A group name or number.	 * @param $recursive bool (optional) If set True changes file group recursivly. Defaults to False.	 * @return bool Returns true on success or false on failure.	 */	function chgrp($file, $group, $recursive = false) {		if ( ! $this->exists($file) )			return false;		if ( ! $recursive )			return @chgrp($file, $group);		if ( ! $this->is_dir($file) )			return @chgrp($file, $group);		//Is a directory, and we want recursive		$file = trailingslashit($file);		$filelist = $this->dirlist($file);		foreach ($filelist as $filename)			$this->chgrp($file . $filename, $group, $recursive);		return true;	}	/**	 * Changes filesystem permissions	 *	 * @param $file string Path to the file.	 * @param $mode int (optional) The permissions as octal number, usually 0644 for files, 0755 for dirs.	 * @param $recursive bool (optional) If set True changes file group recursivly. Defaults to False.	 * @return bool Returns true on success or false on failure.	 */	function chmod($file, $mode = false, $recursive = false) {		if ( ! $mode ) {			if ( $this->is_file($file) )				$mode = FS_CHMOD_FILE;			elseif ( $this->is_dir($file) )				$mode = FS_CHMOD_DIR;			else				return false;		}		if ( ! $recursive || ! $this->is_dir($file) )			return @chmod($file, $mode);		//Is a directory, and we want recursive		$file = trailingslashit($file);		$filelist = $this->dirlist($file);		foreach ( (array)$filelist as $filename => $filemeta)			$this->chmod($file . $filename, $mode, $recursive);		return true;	}	/**	 * Changes file owner	 *	 * @param $file string Path to the file.	 * @param $owner mixed A user name or number.	 * @param $recursive bool (optional) If set True changes file owner recursivly. Defaults to False.	 * @return bool Returns true on success or false on failure.	 */	function chown($file, $owner, $recursive = false) {		if ( ! $this->exists($file) )			return false;		if ( ! $recursive )			return @chown($file, $owner);		if ( ! $this->is_dir($file) )			return @chown($file, $owner);		//Is a directory, and we want recursive		$filelist = $this->dirlist($file);		foreach ($filelist as $filename) {			$this->chown($file . '/' . $filename, $owner, $recursive);		}		return true;	}	/**	 * Gets file owner	 *	 * @param $file string Path to the file.	 * @return string Username of the user.	 */	function owner($file) {		$owneruid = @fileowner($file);		if ( ! $owneruid )			return false;		if ( ! function_exists('posix_getpwuid') )			return $owneruid;		$ownerarray = posix_getpwuid($owneruid);		return $ownerarray['name'];	}	/**	 * Gets file permissions	 *	 * FIXME does not handle errors in fileperms()	 *	 * @param $file string Path to the file.	 * @return string Mode of the file (last 4 digits).	 */	function getchmod($file) {		return substr(decoct(@fileperms($file)),3);	}	function group($file) {		$gid = @filegroup($file);		if ( ! $gid )			return false;		if ( ! function_exists('posix_getgrgid') )			return $gid;		$grouparray = posix_getgrgid($gid);		return $grouparray['name'];	}	function copy($source, $destination, $overwrite = false) {		if ( ! $overwrite && $this->exists($destination) )			return false;		return copy($source, $destination);	}	function move($source, $destination, $overwrite = false) {		if ( ! $overwrite && $this->exists($destination) )			return false;		// try using rename first.  if that fails (for example, source is read only) try copy		if ( @rename($source, $destination) )			return true;		if ( $this->copy($source, $destination, $overwrite) && $this->exists($destination) ) {			$this->delete($source);			return true;		} else {			return false;		}	}	function delete($file, $recursive = false) {		if ( empty($file) ) //Some filesystems report this as /, which can cause non-expected recursive deletion of all files in the filesystem.			return false;		$file = str_replace('\\', '/', $file); //for win32, occasional problems deleteing files otherwise		if ( $this->is_file($file) )			return @unlink($file);		if ( ! $recursive && $this->is_dir($file) )			return @rmdir($file);		//At this point its a folder, and we're in recursive mode		$file = trailingslashit($file);		$filelist = $this->dirlist($file, true);		$retval = true;		if ( is_array($filelist) ) //false if no files, So check first.			foreach ($filelist as $filename => $fileinfo)				if ( ! $this->delete($file . $filename, $recursive) )					$retval = false;		if ( file_exists($file) && ! @rmdir($file) )			$retval = false;		return $retval;	}	function exists($file) {		return @file_exists($file);	}	function is_file($file) {		return @is_file($file);	}	function is_dir($path) {		return @is_dir($path);	}	function is_readable($file) {		return @is_readable($file);	}	function is_writable($file) {		return @is_writable($file);	}	function atime($file) {		return @fileatime($file);	}	function mtime($file) {		return @filemtime($file);	}	function size($file) {		return @filesize($file);	}	function touch($file, $time = 0, $atime = 0) {		if ($time == 0)			$time = time();		if ($atime == 0)			$atime = time();		return @touch($file, $time, $atime);	}	function mkdir($path, $chmod = false, $chown = false, $chgrp = false) {		// safe mode fails with a trailing slash under certain PHP versions.		$path = untrailingslashit($path);		if ( empty($path) )			$path = '/';		if ( ! $chmod )			$chmod = FS_CHMOD_DIR;		if ( ! @mkdir($path) )			return false;		$this->chmod($path, $chmod);		if ( $chown )			$this->chown($path, $chown);		if ( $chgrp )			$this->chgrp($path, $chgrp);		return true;	}	function rmdir($path, $recursive = false) {		return $this->delete($path, $recursive);	}	function dirlist($path, $include_hidden = true, $recursive = false) {		if ( $this->is_file($path) ) {			$limit_file = basename($path);			$path = dirname($path);		} else {			$limit_file = false;		}		if ( ! $this->is_dir($path) )			return false;		$dir = @dir($path);		if ( ! $dir )			return false;		$ret = array();		while (false !== ($entry = $dir->read()) ) {			$struc = array();			$struc['name'] = $entry;			if ( '.' == $struc['name'] || '..' == $struc['name'] )				continue;			if ( ! $include_hidden && '.' == $struc['name'][0] )				continue;			if ( $limit_file && $struc['name'] != $limit_file)				continue;			$struc['perms'] 	= $this->gethchmod($path.'/'.$entry);			$struc['permsn']	= $this->getnumchmodfromh($struc['perms']);			$struc['number'] 	= false;			$struc['owner']    	= $this->owner($path.'/'.$entry);			$struc['group']    	= $this->group($path.'/'.$entry);			$struc['size']    	= $this->size($path.'/'.$entry);			$struc['lastmodunix']= $this->mtime($path.'/'.$entry);			$struc['lastmod']   = date('M j',$struc['lastmodunix']);			$struc['time']    	= date('h:i:s',$struc['lastmodunix']);			$struc['type']		= $this->is_dir($path.'/'.$entry) ? 'd' : 'f';			if ( 'd' == $struc['type'] ) {				if ( $recursive )					$struc['files'] = $this->dirlist($path . '/' . $struc['name'], $include_hidden, $recursive);				else					$struc['files'] = array();			}			$ret[ $struc['name'] ] = $struc;		}		$dir->close();		unset($dir);		return $ret;	}}?>
<?php/** * Class used internally by Text_Diff to actually compute the diffs. * * This class is implemented using native PHP code. * * The algorithm used here is mostly lifted from the perl module * Algorithm::Diff (version 1.06) by Ned Konz, which is available at: * http://www.perl.com/CPAN/authors/id/N/NE/NEDKONZ/Algorithm-Diff-1.06.zip * * More ideas are taken from: http://www.ics.uci.edu/~eppstein/161/960229.html * * Some ideas (and a bit of code) are taken from analyze.c, of GNU * diffutils-2.7, which can be found at: * ftp://gnudist.gnu.org/pub/gnu/diffutils/diffutils-2.7.tar.gz * * Some ideas (subdivision by NCHUNKS > 2, and some optimizations) are from * Geoffrey T. Dairiki <dairiki@dairiki.org>. The original PHP version of this * code was written by him, and is used/adapted with his permission. * * Copyright 2004-2010 The Horde Project (http://www.horde.org/) * * See the enclosed file COPYING for license information (LGPL). If you did * not receive this file, see http://opensource.org/licenses/lgpl-license.php. * * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * @package Text_Diff */class Text_Diff_Engine_native {    function diff($from_lines, $to_lines)    {        array_walk($from_lines, array('Text_Diff', 'trimNewlines'));        array_walk($to_lines, array('Text_Diff', 'trimNewlines'));        $n_from = count($from_lines);        $n_to = count($to_lines);        $this->xchanged = $this->ychanged = array();        $this->xv = $this->yv = array();        $this->xind = $this->yind = array();        unset($this->seq);        unset($this->in_seq);        unset($this->lcs);        // Skip leading common lines.        for ($skip = 0; $skip < $n_from && $skip < $n_to; $skip++) {            if ($from_lines[$skip] !== $to_lines[$skip]) {                break;            }            $this->xchanged[$skip] = $this->ychanged[$skip] = false;        }        // Skip trailing common lines.        $xi = $n_from; $yi = $n_to;        for ($endskip = 0; --$xi > $skip && --$yi > $skip; $endskip++) {            if ($from_lines[$xi] !== $to_lines[$yi]) {                break;            }            $this->xchanged[$xi] = $this->ychanged[$yi] = false;        }        // Ignore lines which do not exist in both files.        for ($xi = $skip; $xi < $n_from - $endskip; $xi++) {            $xhash[$from_lines[$xi]] = 1;        }        for ($yi = $skip; $yi < $n_to - $endskip; $yi++) {            $line = $to_lines[$yi];            if (($this->ychanged[$yi] = empty($xhash[$line]))) {                continue;            }            $yhash[$line] = 1;            $this->yv[] = $line;            $this->yind[] = $yi;        }        for ($xi = $skip; $xi < $n_from - $endskip; $xi++) {            $line = $from_lines[$xi];            if (($this->xchanged[$xi] = empty($yhash[$line]))) {                continue;            }            $this->xv[] = $line;            $this->xind[] = $xi;        }        // Find the LCS.        $this->_compareseq(0, count($this->xv), 0, count($this->yv));        // Merge edits when possible.        $this->_shiftBoundaries($from_lines, $this->xchanged, $this->ychanged);        $this->_shiftBoundaries($to_lines, $this->ychanged, $this->xchanged);        // Compute the edit operations.        $edits = array();        $xi = $yi = 0;        while ($xi < $n_from || $yi < $n_to) {            assert($yi < $n_to || $this->xchanged[$xi]);            assert($xi < $n_from || $this->ychanged[$yi]);            // Skip matching "snake".            $copy = array();            while ($xi < $n_from && $yi < $n_to                   && !$this->xchanged[$xi] && !$this->ychanged[$yi]) {                $copy[] = $from_lines[$xi++];                ++$yi;            }            if ($copy) {                $edits[] = &new Text_Diff_Op_copy($copy);            }            // Find deletes & adds.            $delete = array();            while ($xi < $n_from && $this->xchanged[$xi]) {                $delete[] = $from_lines[$xi++];            }            $add = array();            while ($yi < $n_to && $this->ychanged[$yi]) {                $add[] = $to_lines[$yi++];            }            if ($delete && $add) {                $edits[] = &new Text_Diff_Op_change($delete, $add);            } elseif ($delete) {                $edits[] = &new Text_Diff_Op_delete($delete);            } elseif ($add) {                $edits[] = &new Text_Diff_Op_add($add);            }        }        return $edits;    }    /**     * Divides the Largest Common Subsequence (LCS) of the sequences (XOFF,     * XLIM) and (YOFF, YLIM) into NCHUNKS approximately equally sized     * segments.     *     * Returns (LCS, PTS).  LCS is the length of the LCS. PTS is an array of     * NCHUNKS+1 (X, Y) indexes giving the diving points between sub     * sequences.  The first sub-sequence is contained in (X0, X1), (Y0, Y1),     * the second in (X1, X2), (Y1, Y2) and so on.  Note that (X0, Y0) ==     * (XOFF, YOFF) and (X[NCHUNKS], Y[NCHUNKS]) == (XLIM, YLIM).     *     * This function assumes that the first lines of the specified portions of     * the two files do not match, and likewise that the last lines do not     * match.  The caller must trim matching lines from the beginning and end     * of the portions it is going to specify.     */    function _diag ($xoff, $xlim, $yoff, $ylim, $nchunks)    {        $flip = false;        if ($xlim - $xoff > $ylim - $yoff) {            /* Things seems faster (I'm not sure I understand why) when the             * shortest sequence is in X. */            $flip = true;            list ($xoff, $xlim, $yoff, $ylim)                = array($yoff, $ylim, $xoff, $xlim);        }        if ($flip) {            for ($i = $ylim - 1; $i >= $yoff; $i--) {                $ymatches[$this->xv[$i]][] = $i;            }        } else {            for ($i = $ylim - 1; $i >= $yoff; $i--) {                $ymatches[$this->yv[$i]][] = $i;            }        }        $this->lcs = 0;        $this->seq[0]= $yoff - 1;        $this->in_seq = array();        $ymids[0] = array();        $numer = $xlim - $xoff + $nchunks - 1;        $x = $xoff;        for ($chunk = 0; $chunk < $nchunks; $chunk++) {            if ($chunk > 0) {                for ($i = 0; $i <= $this->lcs; $i++) {                    $ymids[$i][$chunk - 1] = $this->seq[$i];                }            }            $x1 = $xoff + (int)(($numer + ($xlim - $xoff) * $chunk) / $nchunks);            for (; $x < $x1; $x++) {                $line = $flip ? $this->yv[$x] : $this->xv[$x];                if (empty($ymatches[$line])) {                    continue;                }                $matches = $ymatches[$line];                reset($matches);                while (list(, $y) = each($matches)) {                    if (empty($this->in_seq[$y])) {                        $k = $this->_lcsPos($y);                        assert($k > 0);                        $ymids[$k] = $ymids[$k - 1];                        break;                    }                }                while (list(, $y) = each($matches)) {                    if ($y > $this->seq[$k - 1]) {                        assert($y <= $this->seq[$k]);                        /* Optimization: this is a common case: next match is                         * just replacing previous match. */                        $this->in_seq[$this->seq[$k]] = false;                        $this->seq[$k] = $y;                        $this->in_seq[$y] = 1;                    } elseif (empty($this->in_seq[$y])) {                        $k = $this->_lcsPos($y);                        assert($k > 0);                        $ymids[$k] = $ymids[$k - 1];                    }                }            }        }        $seps[] = $flip ? array($yoff, $xoff) : array($xoff, $yoff);        $ymid = $ymids[$this->lcs];        for ($n = 0; $n < $nchunks - 1; $n++) {            $x1 = $xoff + (int)(($numer + ($xlim - $xoff) * $n) / $nchunks);            $y1 = $ymid[$n] + 1;            $seps[] = $flip ? array($y1, $x1) : array($x1, $y1);        }        $seps[] = $flip ? array($ylim, $xlim) : array($xlim, $ylim);        return array($this->lcs, $seps);    }    function _lcsPos($ypos)    {        $end = $this->lcs;        if ($end == 0 || $ypos > $this->seq[$end]) {            $this->seq[++$this->lcs] = $ypos;            $this->in_seq[$ypos] = 1;            return $this->lcs;        }        $beg = 1;        while ($beg < $end) {            $mid = (int)(($beg + $end) / 2);            if ($ypos > $this->seq[$mid]) {                $beg = $mid + 1;            } else {                $end = $mid;            }        }        assert($ypos != $this->seq[$end]);        $this->in_seq[$this->seq[$end]] = false;        $this->seq[$end] = $ypos;        $this->in_seq[$ypos] = 1;        return $end;    }    /**     * Finds LCS of two sequences.     *     * The results are recorded in the vectors $this->{x,y}changed[], by     * storing a 1 in the element for each line that is an insertion or     * deletion (ie. is not in the LCS).     *     * The subsequence of file 0 is (XOFF, XLIM) and likewise for file 1.     *     * Note that XLIM, YLIM are exclusive bounds.  All line numbers are     * origin-0 and discarded lines are not counted.     */    function _compareseq ($xoff, $xlim, $yoff, $ylim)    {        /* Slide down the bottom initial diagonal. */        while ($xoff < $xlim && $yoff < $ylim               && $this->xv[$xoff] == $this->yv[$yoff]) {            ++$xoff;            ++$yoff;        }        /* Slide up the top initial diagonal. */        while ($xlim > $xoff && $ylim > $yoff               && $this->xv[$xlim - 1] == $this->yv[$ylim - 1]) {            --$xlim;            --$ylim;        }        if ($xoff == $xlim || $yoff == $ylim) {            $lcs = 0;        } else {            /* This is ad hoc but seems to work well.  $nchunks =             * sqrt(min($xlim - $xoff, $ylim - $yoff) / 2.5); $nchunks =             * max(2,min(8,(int)$nchunks)); */            $nchunks = min(7, $xlim - $xoff, $ylim - $yoff) + 1;            list($lcs, $seps)                = $this->_diag($xoff, $xlim, $yoff, $ylim, $nchunks);        }        if ($lcs == 0) {            /* X and Y sequences have no common subsequence: mark all             * changed. */            while ($yoff < $ylim) {                $this->ychanged[$this->yind[$yoff++]] = 1;            }            while ($xoff < $xlim) {                $this->xchanged[$this->xind[$xoff++]] = 1;            }        } else {            /* Use the partitions to split this problem into subproblems. */            reset($seps);            $pt1 = $seps[0];            while ($pt2 = next($seps)) {                $this->_compareseq ($pt1[0], $pt2[0], $pt1[1], $pt2[1]);                $pt1 = $pt2;            }        }    }    /**     * Adjusts inserts/deletes of identical lines to join changes as much as     * possible.     *     * We do something when a run of changed lines include a line at one end     * and has an excluded, identical line at the other.  We are free to     * choose which identical line is included.  `compareseq' usually chooses     * the one at the beginning, but usually it is cleaner to consider the     * following identical line to be the "change".     *     * This is extracted verbatim from analyze.c (GNU diffutils-2.7).     */    function _shiftBoundaries($lines, &$changed, $other_changed)    {        $i = 0;        $j = 0;        assert('count($lines) == count($changed)');        $len = count($lines);        $other_len = count($other_changed);        while (1) {            /* Scan forward to find the beginning of another run of             * changes. Also keep track of the corresponding point in the             * other file.             *             * Throughout this code, $i and $j are adjusted together so that             * the first $i elements of $changed and the first $j elements of             * $other_changed both contain the same number of zeros (unchanged             * lines).             *             * Furthermore, $j is always kept so that $j == $other_len or             * $other_changed[$j] == false. */            while ($j < $other_len && $other_changed[$j]) {                $j++;            }            while ($i < $len && ! $changed[$i]) {                assert('$j < $other_len && ! $other_changed[$j]');                $i++; $j++;                while ($j < $other_len && $other_changed[$j]) {                    $j++;                }            }            if ($i == $len) {                break;            }            $start = $i;            /* Find the end of this run of changes. */            while (++$i < $len && $changed[$i]) {                continue;            }            do {                /* Record the length of this run of changes, so that we can                 * later determine whether the run has grown. */                $runlength = $i - $start;                /* Move the changed region back, so long as the previous                 * unchanged line matches the last changed one.  This merges                 * with previous changed regions. */                while ($start > 0 && $lines[$start - 1] == $lines[$i - 1]) {                    $changed[--$start] = 1;                    $changed[--$i] = false;                    while ($start > 0 && $changed[$start - 1]) {                        $start--;                    }                    assert('$j > 0');                    while ($other_changed[--$j]) {                        continue;                    }                    assert('$j >= 0 && !$other_changed[$j]');                }                /* Set CORRESPONDING to the end of the changed run, at the                 * last point where it corresponds to a changed run in the                 * other file. CORRESPONDING == LEN means no such point has                 * been found. */                $corresponding = $j < $other_len ? $i : $len;                /* Move the changed region forward, so long as the first                 * changed line matches the following unchanged one.  This                 * merges with following changed regions.  Do this second, so                 * that if there are no merges, the changed region is moved                 * forward as far as possible. */                while ($i < $len && $lines[$start] == $lines[$i]) {                    $changed[$start++] = false;                    $changed[$i++] = 1;                    while ($i < $len && $changed[$i]) {                        $i++;                    }                    assert('$j < $other_len && ! $other_changed[$j]');                    $j++;                    if ($j < $other_len && $other_changed[$j]) {                        $corresponding = $i;                        while ($j < $other_len && $other_changed[$j]) {                            $j++;                        }                    }                }            } while ($runlength != $i - $start);            /* If possible, move the fully-merged run of changes back to a             * corresponding run in the other file. */            while ($corresponding < $i) {                $changed[--$start] = 1;                $changed[--$i] = 0;                assert('$j > 0');                while ($other_changed[--$j]) {                    continue;                }                assert('$j >= 0 && !$other_changed[$j]');            }        }    }}
<?php/** * The template for displaying Category Archive pages. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main">				<h1 class="page-title"><?php					printf( __( 'Category Archives: %s', 'twentyten' ), '<span>' . single_cat_title( '', false ) . '</span>' );				?></h1>				<?php					$category_description = category_description();					if ( ! empty( $category_description ) )						echo '<div class="archive-meta">' . $category_description . '</div>';				/* Run the loop for the category page to output the posts.				 * If you want to overload this in a child theme then include a file				 * called loop-category.php and that will be used instead.				 */				get_template_part( 'loop', 'category' );				?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
<?php/** * Navigation Menu template functions * * @package WordPress * @subpackage Nav_Menus * @since 3.0.0 *//** * Create HTML list of nav menu items. * * @package WordPress * @since 3.0.0 * @uses Walker */class Walker_Nav_Menu extends Walker {	/**	 * @see Walker::$tree_type	 * @since 3.0.0	 * @var string	 */	var $tree_type = array( 'post_type', 'taxonomy', 'custom' );	/**	 * @see Walker::$db_fields	 * @since 3.0.0	 * @todo Decouple this.	 * @var array	 */	var $db_fields = array( 'parent' => 'menu_item_parent', 'id' => 'db_id' );	/**	 * @see Walker::start_lvl()	 * @since 3.0.0	 *	 * @param string $output Passed by reference. Used to append additional content.	 * @param int $depth Depth of page. Used for padding.	 */	function start_lvl(&$output, $depth) {		$indent = str_repeat("\t", $depth);		$output .= "\n$indent<ul class=\"sub-menu\">\n";	}	/**	 * @see Walker::end_lvl()	 * @since 3.0.0	 *	 * @param string $output Passed by reference. Used to append additional content.	 * @param int $depth Depth of page. Used for padding.	 */	function end_lvl(&$output, $depth) {		$indent = str_repeat("\t", $depth);		$output .= "$indent</ul>\n";	}	/**	 * @see Walker::start_el()	 * @since 3.0.0	 *	 * @param string $output Passed by reference. Used to append additional content.	 * @param object $item Menu item data object.	 * @param int $depth Depth of menu item. Used for padding.	 * @param int $current_page Menu item ID.	 * @param object $args	 */	function start_el(&$output, $item, $depth, $args) {		global $wp_query;		$indent = ( $depth ) ? str_repeat( "\t", $depth ) : '';		$class_names = $value = '';		$classes = empty( $item->classes ) ? array() : (array) $item->classes;		$class_names = join( ' ', apply_filters( 'nav_menu_css_class', array_filter( $classes ), $item ) );		$class_names = ' class="' . esc_attr( $class_names ) . '"';		$output .= $indent . '<li id="menu-item-'. $item->ID . '"' . $value . $class_names .'>';		$attributes  = ! empty( $item->attr_title ) ? ' title="'  . esc_attr( $item->attr_title ) .'"' : '';		$attributes .= ! empty( $item->target )     ? ' target="' . esc_attr( $item->target     ) .'"' : '';		$attributes .= ! empty( $item->xfn )        ? ' rel="'    . esc_attr( $item->xfn        ) .'"' : '';		$attributes .= ! empty( $item->url )        ? ' href="'   . esc_attr( $item->url        ) .'"' : '';		$item_output = $args->before;		$item_output .= '<a'. $attributes .'>';		$item_output .= $args->link_before . apply_filters( 'the_title', $item->title, $item->ID ) . $args->link_after;		$item_output .= '</a>';		$item_output .= $args->after;		$output .= apply_filters( 'walker_nav_menu_start_el', $item_output, $item, $depth, $args );	}	/**	 * @see Walker::end_el()	 * @since 3.0.0	 *	 * @param string $output Passed by reference. Used to append additional content.	 * @param object $item Page data object. Not used.	 * @param int $depth Depth of page. Not Used.	 */	function end_el(&$output, $item, $depth) {		$output .= "</li>\n";	}}/** * Displays a navigation menu. * * Optional $args contents: * * menu - The menu that is desired.  Accepts (matching in order) id, slug, name. Defaults to blank. * menu_class - CSS class to use for the ul element which forms the menu. Defaults to 'menu'. * menu_id - The ID that is applied to the ul element which forms the menu. Defaults to the menu slug, incremented. * container - Whether to wrap the ul, and what to wrap it with. Defaults to 'div'. * container_class - the class that is applied to the container. Defaults to 'menu-{menu slug}-container'. * container_id - The ID that is applied to the container. Defaults to blank. * fallback_cb - If the menu doesn't exists, a callback function will fire. Defaults to 'wp_page_menu'. * before - Text before the link text. * after - Text after the link text. * link_before - Text before the link. * link_after - Text after the link. * echo - Whether to echo the menu or return it. Defaults to echo. * depth - how many levels of the hierarchy are to be included.  0 means all.  Defaults to 0. * walker - allows a custom walker to be specified. * theme_location - the location in the theme to be used.  Must be registered with register_nav_menu() in order to be selectable by the user. * * @since 3.0.0 * * @param array $args Arguments */function wp_nav_menu( $args = array() ) {	static $menu_id_slugs = array();	$defaults = array( 'menu' => '', 'container' => 'div', 'container_class' => '', 'container_id' => '', 'menu_class' => 'menu', 'menu_id' => '',	'echo' => true, 'fallback_cb' => 'wp_page_menu', 'before' => '', 'after' => '', 'link_before' => '', 'link_after' => '',	'depth' => 0, 'walker' => '', 'theme_location' => '' );	$args = wp_parse_args( $args, $defaults );	$args = apply_filters( 'wp_nav_menu_args', $args );	$args = (object) $args;	// Get the nav menu based on the requested menu	$menu = wp_get_nav_menu_object( $args->menu );	// Get the nav menu based on the theme_location	if ( ! $menu && $args->theme_location && ( $locations = get_nav_menu_locations() ) && isset( $locations[ $args->theme_location ] ) )		$menu = wp_get_nav_menu_object( $locations[ $args->theme_location ] );	// get the first menu that has items if we still can't find a menu	if ( ! $menu && !$args->theme_location ) {		$menus = wp_get_nav_menus();		foreach ( $menus as $menu_maybe ) {			if ( $menu_items = wp_get_nav_menu_items($menu_maybe->term_id) ) {				$menu = $menu_maybe;				break;			}		}	}	// If the menu exists, get its items.	if ( $menu && ! is_wp_error($menu) && !isset($menu_items) )		$menu_items = wp_get_nav_menu_items( $menu->term_id );	// If no menu was found or if the menu has no items and no location was requested, call the fallback_cb if it exists	if ( ( !$menu || is_wp_error($menu) || ( isset($menu_items) && empty($menu_items) && !$args->theme_location ) )		&& ( function_exists($args->fallback_cb) || is_callable( $args->fallback_cb ) ) )			return call_user_func( $args->fallback_cb, (array) $args );	// If no fallback function was specified and the menu doesn't exists, bail.	if ( !$menu || is_wp_error($menu) )		return false;	$nav_menu = $items = '';	$show_container = false;	if ( $args->container ) {		$allowed_tags = apply_filters( 'wp_nav_menu_container_allowedtags', array( 'div', 'nav' ) );		if ( in_array( $args->container, $allowed_tags ) ) {			$show_container = true;			$class = $args->container_class ? ' class="' . esc_attr( $args->container_class ) . '"' : ' class="menu-'. $menu->slug .'-container"';			$id = $args->container_id ? ' id="' . esc_attr( $args->container_id ) . '"' : '';			$nav_menu .= '<'. $args->container . $id . $class . '>';		}	}	// Set up the $menu_item variables	_wp_menu_item_classes_by_context( $menu_items );	$sorted_menu_items = array();	foreach ( (array) $menu_items as $key => $menu_item )		$sorted_menu_items[$menu_item->menu_order] = $menu_item;	unset($menu_items);	$items .= walk_nav_menu_tree( $sorted_menu_items, $args->depth, $args );	unset($sorted_menu_items);	// Attributes	if ( ! empty( $args->menu_id ) ) {		$slug = $args->menu_id;	} else {		$slug = 'menu-' . $menu->slug;		while ( in_array( $slug, $menu_id_slugs ) ) {			if ( preg_match( '#-(\d+)$#', $slug, $matches ) )				$slug = preg_replace('#-(\d+)$#', '-' . ++$matches[1], $slug);			else				$slug = $slug . '-1';		}	}	$menu_id_slugs[] = $slug;	$attributes = ' id="' . $slug . '"';	$attributes .= $args->menu_class ? ' class="'. $args->menu_class .'"' : '';	$nav_menu .= '<ul'. $attributes .'>';	// Allow plugins to hook into the menu to add their own <li>'s	$items = apply_filters( 'wp_nav_menu_items', $items, $args );	$items = apply_filters( "wp_nav_menu_{$menu->slug}_items", $items, $args );	$nav_menu .= $items;	unset($items);	$nav_menu .= '</ul>';	if ( $show_container )		$nav_menu .= '</' . $args->container . '>';	$nav_menu = apply_filters( 'wp_nav_menu', $nav_menu, $args );	if ( $args->echo )		echo $nav_menu;	else		return $nav_menu;}/** * Add the class property classes for the current context, if applicable. * * @access private * @since 3.0 * * @param array $menu_items The current menu item objects to which to add the class property information. */function _wp_menu_item_classes_by_context( &$menu_items ) {	global $wp_query;	$queried_object = $wp_query->get_queried_object();	$queried_object_id = (int) $wp_query->queried_object_id;	$active_object = '';	$active_ancestor_item_ids = array();	$active_parent_item_ids = array();	$active_parent_object_ids = array();	$possible_taxonomy_ancestors = array();	$possible_object_parents = array();	$home_page_id = (int) get_option( 'page_for_posts' );	if ( $wp_query->is_singular && ! empty( $queried_object->post_type ) && ! is_post_type_hierarchical( $queried_object->post_type ) ) {		foreach ( (array) get_object_taxonomies( $queried_object->post_type ) as $taxonomy ) {			if ( is_taxonomy_hierarchical( $taxonomy ) ) {				$term_hierarchy = _get_term_hierarchy( $taxonomy );				$terms = wp_get_object_terms( $queried_object_id, $taxonomy, array( 'fields' => 'ids' ) );				if ( is_array( $terms ) ) {					$possible_object_parents = array_merge( $possible_object_parents, $terms );					$term_to_ancestor = array();					foreach ( (array) $term_hierarchy as $anc => $descs ) {						foreach ( (array) $descs as $desc )							$term_to_ancestor[ $desc ] = $anc;					}					foreach ( $terms as $desc ) {						do {							$possible_taxonomy_ancestors[ $taxonomy ][] = $desc;							if ( isset( $term_to_ancestor[ $desc ] ) ) {								$_desc = $term_to_ancestor[ $desc ];								unset( $term_to_ancestor[ $desc ] );								$desc = $_desc;							} else {								$desc = 0;							}						} while ( ! empty( $desc ) );					}				}			}		}	} elseif ( ! empty( $queried_object->post_type ) && is_post_type_hierarchical( $queried_object->post_type ) ) {		_get_post_ancestors( $queried_object );	} elseif ( ! empty( $queried_object->taxonomy ) && is_taxonomy_hierarchical( $queried_object->taxonomy ) ) {		$term_hierarchy = _get_term_hierarchy( $queried_object->taxonomy );		$term_to_ancestor = array();		foreach ( (array) $term_hierarchy as $anc => $descs ) {			foreach ( (array) $descs as $desc )				$term_to_ancestor[ $desc ] = $anc;		}		$desc = $queried_object->term_id;		do {			$possible_taxonomy_ancestors[ $queried_object->taxonomy ][] = $desc;			if ( isset( $term_to_ancestor[ $desc ] ) ) {				$_desc = $term_to_ancestor[ $desc ];				unset( $term_to_ancestor[ $desc ] );				$desc = $_desc;			} else {				$desc = 0;			}		} while ( ! empty( $desc ) );	}	$possible_object_parents = array_filter( $possible_object_parents );	foreach ( (array) $menu_items as $key => $menu_item ) {		$classes = (array) $menu_item->classes;		$classes[] = 'menu-item';		$classes[] = 'menu-item-type-' . $menu_item->type;		// if the menu item corresponds to a taxonomy term for the currently-queried non-hierarchical post object		if ( $wp_query->is_singular && 'taxonomy' == $menu_item->type && in_array( $menu_item->object_id, $possible_object_parents ) ) {			$active_parent_object_ids[] = (int) $menu_item->object_id;			$active_parent_item_ids[] = (int) $menu_item->db_id;			$active_object = $queried_object->post_type;		// if the menu item corresponds to the currently-queried post or taxonomy object		} elseif (			$menu_item->object_id == $queried_object_id &&			(				( ! empty( $home_page_id ) && 'post_type' == $menu_item->type && $wp_query->is_home && $home_page_id == $menu_item->object_id ) ||				( 'post_type' == $menu_item->type && $wp_query->is_singular ) ||				( 'taxonomy' == $menu_item->type && ( $wp_query->is_category || $wp_query->is_tag || $wp_query->is_tax ) )			)		) {			$classes[] = 'current-menu-item';			$_anc_id = (int) $menu_item->db_id;			while(				( $_anc_id = get_post_meta( $_anc_id, '_menu_item_menu_item_parent', true ) ) &&				! in_array( $_anc_id, $active_ancestor_item_ids )			) {				$active_ancestor_item_ids[] = $_anc_id;			}			if ( 'post_type' == $menu_item->type && 'page' == $menu_item->object ) {				// Back compat classes for pages to match wp_page_menu()				$classes[] = 'page_item';				$classes[] = 'page-item-' . $menu_item->object_id;				$classes[] = 'current_page_item';			}			$active_parent_item_ids[] = (int) $menu_item->menu_item_parent;			$active_parent_object_ids[] = (int) $menu_item->post_parent;			$active_object = $menu_item->object;		// if the menu item corresponds to the currently-requested URL		} elseif ( 'custom' == $menu_item->object ) {			$current_url = ( is_ssl() ? 'https://' : 'http://' ) . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];			$item_url = strpos( $menu_item->url, '#' ) ? substr( $menu_item->url, 0, strpos( $menu_item->url, '#' ) ) : $menu_item->url;			if ( $item_url == $current_url ) {				$classes[] = 'current-menu-item';				$_anc_id = (int) $menu_item->db_id;				while(					( $_anc_id = get_post_meta( $_anc_id, '_menu_item_menu_item_parent', true ) ) &&					! in_array( $_anc_id, $active_ancestor_item_ids )				) {					$active_ancestor_item_ids[] = $_anc_id;				}				if ( untrailingslashit($current_url) == home_url() ) {					$classes[] = 'menu-item-home';					// Back compat for home limk to match wp_page_menu()					$classes[] = 'current_page_item';				}				$active_parent_item_ids[] = (int) $menu_item->menu_item_parent;				$active_parent_object_ids[] = (int) $menu_item->post_parent;				$active_object = $menu_item->object;			}		}		// back-compat with wp_page_menu: add "current_page_parent" to static home page link for any non-page query		if ( ! empty( $home_page_id ) && 'post_type' == $menu_item->type && empty( $wp_query->is_page ) && $home_page_id == $menu_item->object_id )			$classes[] = 'current_page_parent';		$menu_items[$key]->classes = array_unique( $classes );	}	$active_ancestor_item_ids = array_filter( array_unique( $active_ancestor_item_ids ) );	$active_parent_item_ids = array_filter( array_unique( $active_parent_item_ids ) );	$active_parent_object_ids = array_filter( array_unique( $active_parent_object_ids ) );	// set parent's class	foreach ( (array) $menu_items as $key => $parent_item ) {		$classes = (array) $parent_item->classes;		if (			isset( $parent_item->type ) &&			(				// ancestral post object				(					'post_type' == $parent_item->type &&					! empty( $queried_object->post_type ) &&					is_post_type_hierarchical( $queried_object->post_type ) &&					in_array( $parent_item->object_id, $queried_object->ancestors )				) ||				// ancestral term				(					'taxonomy' == $parent_item->type &&					isset( $possible_taxonomy_ancestors[ $parent_item->object ] ) &&					in_array( $parent_item->object_id, $possible_taxonomy_ancestors[ $parent_item->object ] )				)			)		) {			$classes[] = empty( $queried_object->taxonomy ) ? 'current-' . $queried_object->post_type . '-ancestor' : 'current-' . $queried_object->taxonomy . '-ancestor';		}		if ( in_array(  intval( $parent_item->db_id ), $active_ancestor_item_ids ) ) {			$classes[] = 'current-menu-ancestor';		}		if ( in_array( $parent_item->db_id, $active_parent_item_ids ) )			$classes[] = 'current-menu-parent';		if ( in_array( $parent_item->object_id, $active_parent_object_ids ) )			$classes[] = 'current-' . $active_object . '-parent';		if ( 'post_type' == $parent_item->type && 'page' == $parent_item->object ) {			// Back compat classes for pages to match wp_page_menu()			if ( in_array('current-menu-parent', $classes) )				$classes[] = 'current_page_parent';			if ( in_array('current-menu-ancestor', $classes) )				$classes[] = 'current_page_ancestor';		}		$menu_items[$key]->classes = array_unique( $classes );	}}/** * Retrieve the HTML list content for nav menu items. * * @uses Walker_Nav_Menu to create HTML list content. * @since 2.1.0 * @see Walker::walk() for parameters and return description. */function walk_nav_menu_tree( $items, $depth, $r ) {	$walker = ( empty($r->walker) ) ? new Walker_Nav_Menu : $r->walker;	$args = array( $items, $depth, $r );	return call_user_func_array( array(&$walker, 'walk'), $args );}?>
<?php/** * The template for displaying attachments. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main"><?php if ( have_posts() ) while ( have_posts() ) : the_post(); ?>				<p class="page-title"><a href="<?php echo get_permalink( $post->post_parent ); ?>" title="<?php esc_attr( printf( __( 'Return to %s', 'twentyten' ), get_the_title( $post->post_parent ) ) ); ?>" rel="gallery"><?php					/* translators: %s - title of parent post */					printf( __( '<span class="meta-nav">&larr;</span> %s', 'twentyten' ), get_the_title( $post->post_parent ) );				?></a></p>				<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>					<h2 class="entry-title"><?php the_title(); ?></h2>					<div class="entry-meta">						<?php							printf(__('<span class="%1$s">By</span> %2$s', 'twentyten'),								'meta-prep meta-prep-author',								sprintf( '<span class="author vcard"><a class="url fn n" href="%1$s" title="%2$s">%3$s</a></span>',									get_author_posts_url( get_the_author_meta( 'ID' ) ),									sprintf( esc_attr__( 'View all posts by %s', 'twentyten' ), get_the_author() ),									get_the_author()								)							);						?>						<span class="meta-sep">|</span>						<?php							printf( __('<span class="%1$s">Published</span> %2$s', 'twentyten'),								'meta-prep meta-prep-entry-date',								sprintf( '<span class="entry-date"><abbr class="published" title="%1$s">%2$s</abbr></span>',									esc_attr( get_the_time() ),									get_the_date()								)							);							if ( wp_attachment_is_image() ) {								echo ' <span class="meta-sep">|</span> ';								$metadata = wp_get_attachment_metadata();								printf( __( 'Full size is %s pixels', 'twentyten'),									sprintf( '<a href="%1$s" title="%2$s">%3$s &times; %4$s</a>',										wp_get_attachment_url(),										esc_attr( __('Link to full-size image', 'twentyten') ),										$metadata['width'],										$metadata['height']									)								);							}						?>						<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="meta-sep">|</span> <span class="edit-link">', '</span>' ); ?>					</div><!-- .entry-meta -->					<div class="entry-content">						<div class="entry-attachment"><?php if ( wp_attachment_is_image() ) :	$attachments = array_values( get_children( array( 'post_parent' => $post->post_parent, 'post_status' => 'inherit', 'post_type' => 'attachment', 'post_mime_type' => 'image', 'order' => 'ASC', 'orderby' => 'menu_order ID' ) ) );	foreach ( $attachments as $k => $attachment ) {		if ( $attachment->ID == $post->ID )			break;	}	$k++;	// If there is more than 1 image attachment in a gallery	if ( count( $attachments ) > 1 ) {		if ( isset( $attachments[ $k ] ) )			// get the URL of the next image attachment			$next_attachment_url = get_attachment_link( $attachments[ $k ]->ID );		else			// or get the URL of the first image attachment			$next_attachment_url = get_attachment_link( $attachments[ 0 ]->ID );	} else {		// or, if there's only 1 image attachment, get the URL of the image		$next_attachment_url = wp_get_attachment_url();	}?>						<p class="attachment"><a href="<?php echo $next_attachment_url; ?>" title="<?php echo esc_attr( get_the_title() ); ?>" rel="attachment"><?php							$attachment_size = apply_filters( 'twentyten_attachment_size', 900 );							echo wp_get_attachment_image( $post->ID, array( $attachment_size, 9999 ) ); // filterable image width with, essentially, no limit for image height.						?></a></p>						<div id="nav-below" class="navigation">							<div class="nav-previous"><?php previous_image_link( false ); ?></div>							<div class="nav-next"><?php next_image_link( false ); ?></div>						</div><!-- #nav-below --><?php else : ?>						<a href="<?php echo wp_get_attachment_url(); ?>" title="<?php echo esc_attr( get_the_title() ); ?>" rel="attachment"><?php echo basename( get_permalink() ); ?></a><?php endif; ?>						</div><!-- .entry-attachment -->						<div class="entry-caption"><?php if ( !empty( $post->post_excerpt ) ) the_excerpt(); ?></div><?php the_content( __( 'Continue reading <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?><?php wp_link_pages( array( 'before' => '<div class="page-link">' . __( 'Pages:', 'twentyten' ), 'after' => '</div>' ) ); ?>					</div><!-- .entry-content -->					<div class="entry-utility">						<?php twentyten_posted_in(); ?>						<?php edit_post_link( __( 'Edit', 'twentyten' ), ' <span class="edit-link">', '</span>' ); ?>					</div><!-- .entry-utility -->				</div><!-- #post-## --><?php comments_template(); ?><?php endwhile; ?>			</div><!-- #content -->		</div><!-- #container --><?php get_footer(); ?>
<?php/** * Comment Management Panel * * @package WordPress * @subpackage Administration *//** Load WordPress Bootstrap */require_once('./admin.php');$parent_file = 'edit-comments.php';$submenu_file = 'edit-comments.php';wp_reset_vars( array('action') );if ( isset( $_POST['deletecomment'] ) )	$action = 'deletecomment';if ( 'cdc' == $action )	$action = 'delete';elseif ( 'mac' == $action )	$action = 'approve';if ( isset( $_GET['dt'] ) ) {	if ( 'spam' == $_GET['dt'] )		$action = 'spam';	elseif ( 'trash' == $_GET['dt'] )		$action = 'trash';}/** * Display error message at bottom of comments. * * @param string $msg Error Message. Assumed to contain HTML and be sanitized. */function comment_footer_die( $msg ) {	echo "<div class='wrap'><p>$msg</p></div>";	include('./admin-footer.php');	die;}switch( $action ) {case 'editcomment' :	$title = __('Edit Comment');	add_contextual_help( $current_screen, '<p>' . __( 'You can edit the information left in a comment if needed. This is often useful when you notice that a commenter has made a typographical error.' ) . '</p>' .	'<p>' . __( 'You can also moderate the comment from this screen using the Status box, where you can also change the timestamp of the comment.' ) . '</p>' .	'<p><strong>' . __( 'For more information:' ) . '</strong></p>' .	'<p>' . __( '<a href="http://codex.wordpress.org/Administration_Panels#Comments" target="_blank">Comments Documentation</a>' ) . '</p>' .	'<p>' . __( '<a href="http://wordpress.org/support/" target="_blank" >Support Forums</a>' ) . '</p>'	);	wp_enqueue_script('comment');	require_once('./admin-header.php');	$comment_id = absint( $_GET['c'] );	if ( !$comment = get_comment( $comment_id ) )		comment_footer_die( __('Oops, no comment with this ID.') . sprintf(' <a href="%s">'.__('Go back').'</a>!', 'javascript:history.go(-1)') );	if ( !current_user_can('edit_post', $comment->comment_post_ID) )		comment_footer_die( __('You are not allowed to edit comments on this post.') );	if ( 'trash' == $comment->comment_approved )		comment_footer_die( __('This comment is in the Trash. Please move it out of the Trash if you want to edit it.') );	$comment = get_comment_to_edit( $comment_id );	include('./edit-form-comment.php');	break;case 'delete'  :case 'approve' :case 'trash'   :case 'spam'    :	$comment_id = absint( $_GET['c'] );	if ( !$comment = get_comment_to_edit( $comment_id ) ) {		wp_redirect( admin_url('edit-comments.php?error=1') );		die();	}	if ( !current_user_can( 'edit_post', $comment->comment_post_ID ) ) {		wp_redirect( admin_url('edit-comments.php?error=2') );		die();	}	// No need to re-approve/re-trash/re-spam a comment.	if ( $action == str_replace( '1', 'approve', $comment->comment_approved ) ) {		wp_redirect( admin_url( 'edit-comments.php?same=' . $comment_id ) );		die(); 	}	require_once('./admin-header.php');	$formaction    = $action . 'comment';	$nonce_action  = 'approve' == $action ? 'approve-comment_' : 'delete-comment_';	$nonce_action .= $comment_id;?><div class='wrap'><div class="narrow"><?php screen_icon(); ?><h2><?php esc_html_e( 'Moderate Comment' ); ?></h2><?phpswitch ( $action ) {	case 'spam' :		$caution_msg = __('You are about to mark the following comment as spam:');		$button      = __('Spam Comment');		break;	case 'trash' :		$caution_msg = __('You are about to move the following comment to the Trash:');		$button      = __('Trash Comment');		break;	case 'delete' :		$caution_msg = __('You are about to delete the following comment:');		$button      = __('Permanently Delete Comment');		break;	default :		$caution_msg = __('You are about to approve the following comment:');		$button      = __('Approve Comment');		break;}if ( $comment->comment_approved != '0' ) { // if not unapproved	$message = '';	switch ( $comment->comment_approved ) {		case '1' :			$message = __('This comment is currently approved.');			break;		case 'spam' :			$message  = __('This comment is currently marked as spam.');			break;		case 'trash' :			$message  = __('This comment is currently in the Trash.');			break;	}	if ( $message )		echo '<div class="updated"><p>' . $message . '</p></div>';}?><p><strong><?php _e('Caution:'); ?></strong> <?php echo $caution_msg; ?></p><table class="form-table comment-ays"><tr class="alt"><th scope="row"><?php _e('Author'); ?></th><td><?php echo $comment->comment_author; ?></td></tr><?php if ( $comment->comment_author_email ) { ?><tr><th scope="row"><?php _e('E-mail'); ?></th><td><?php echo $comment->comment_author_email; ?></td></tr><?php } ?><?php if ( $comment->comment_author_url ) { ?><tr><th scope="row"><?php _e('URL'); ?></th><td><a href="<?php echo $comment->comment_author_url; ?>"><?php echo $comment->comment_author_url; ?></a></td></tr><?php } ?><tr><th scope="row" valign="top"><?php /* translators: field name in comment form */ _ex('Comment', 'noun'); ?></th><td><?php echo $comment->comment_content; ?></td></tr></table><p><?php _e('Are you sure you want to do this?'); ?></p><form action='comment.php' method='get'><table width="100%"><tr><td><a class="button" href="<?php echo admin_url('edit-comments.php'); ?>"><?php esc_attr_e('No'); ?></a></td><td class="textright"><input type='submit' class="button" value='<?php echo esc_attr($button); ?>' /></td></tr></table><?php wp_nonce_field( $nonce_action ); ?><input type='hidden' name='action' value='<?php echo esc_attr($formaction); ?>' /><input type='hidden' name='p' value='<?php echo esc_attr($comment->comment_post_ID); ?>' /><input type='hidden' name='c' value='<?php echo esc_attr($comment->comment_ID); ?>' /><input type='hidden' name='noredir' value='1' /></form></div></div><?php	break;case 'deletecomment'    :case 'trashcomment'     :case 'untrashcomment'   :case 'spamcomment'      :case 'unspamcomment'    :case 'approvecomment'   :case 'unapprovecomment' :	$comment_id = absint( $_REQUEST['c'] );	if ( in_array( $action, array( 'approvecomment', 'unapprovecomment' ) ) )		check_admin_referer( 'approve-comment_' . $comment_id );	else		check_admin_referer( 'delete-comment_' . $comment_id );	$noredir = isset($_REQUEST['noredir']);	if ( !$comment = get_comment($comment_id) )		comment_footer_die( __('Oops, no comment with this ID.') . sprintf(' <a href="%s">'.__('Go back').'</a>!', 'edit-comments.php') );	if ( !current_user_can('edit_post', $comment->comment_post_ID ) )		comment_footer_die( __('You are not allowed to edit comments on this post.') );	if ( '' != wp_get_referer() && ! $noredir && false === strpos(wp_get_referer(), 'comment.php') )		$redir = wp_get_referer();	elseif ( '' != wp_get_original_referer() && ! $noredir )		$redir = wp_get_original_referer();	elseif ( in_array( $action, array( 'approvecomment', 'unapprovecomment' ) ) )		$redir = admin_url('edit-comments.php?p=' . absint( $comment->comment_post_ID ) );	else		$redir = admin_url('edit-comments.php');	$redir = remove_query_arg( array('spammed', 'unspammed', 'trashed', 'untrashed', 'deleted', 'ids', 'approved', 'unapproved'), $redir );	switch ( $action ) {		case 'deletecomment' :			wp_delete_comment( $comment_id );			$redir = add_query_arg( array('deleted' => '1'), $redir );			break;		case 'trashcomment' :			wp_trash_comment($comment_id);			$redir = add_query_arg( array('trashed' => '1', 'ids' => $comment_id), $redir );			break;		case 'untrashcomment' :			wp_untrash_comment($comment_id);			$redir = add_query_arg( array('untrashed' => '1'), $redir );			break;		case 'spamcomment' :			wp_spam_comment($comment_id);			$redir = add_query_arg( array('spammed' => '1', 'ids' => $comment_id), $redir );			break;		case 'unspamcomment' :			wp_unspam_comment($comment_id);			$redir = add_query_arg( array('unspammed' => '1'), $redir );			break;		case 'approvecomment' :			wp_set_comment_status( $comment_id, 'approve' );			$redir = add_query_arg( array( 'approved' => 1 ), $redir );			break;		case 'unapprovecomment' :			wp_set_comment_status( $comment_id, 'hold' );			$redir = add_query_arg( array( 'unapproved' => 1 ), $redir );			break;	}	wp_redirect( $redir );	die;	break;case 'editedcomment' :	$comment_id = absint( $_POST['comment_ID'] );	$comment_post_id = absint( $_POST['comment_post_ID'] );	check_admin_referer( 'update-comment_' . $comment_id );	edit_comment();	$location = ( empty( $_POST['referredby'] ) ? "edit-comments.php?p=$comment_post_id" : $_POST['referredby'] ) . '#comment-' . $comment_id;	$location = apply_filters( 'comment_edit_redirect', $location, $comment_id );	wp_redirect( $location );	exit();	break;default:	wp_die( __('Unknown action.') );	break;} // end switchinclude('./admin-footer.php');?>
<?php/** * Default Embed Handlers * * @package WordPress * @subpackage Embeds *//** * The Google Video embed handler callback. Google Video does not support oEmbed. * * @see WP_Embed::register_handler() * @see WP_Embed::shortcode() * * @param array $matches The regex matches from the provided regex when calling {@link wp_embed_register_handler()}. * @param array $attr Embed attributes. * @param string $url The original URL that was matched by the regex. * @param array $rawattr The original unmodified attributes. * @return string The embed HTML. */function wp_embed_handler_googlevideo( $matches, $attr, $url, $rawattr ) {	// If the user supplied a fixed width AND height, use it	if ( !empty($rawattr['width']) && !empty($rawattr['height']) ) {		$width  = (int) $rawattr['width'];		$height = (int) $rawattr['height'];	} else {		list( $width, $height ) = wp_expand_dimensions( 425, 344, $attr['width'], $attr['height'] );	}	return apply_filters( 'embed_googlevideo', '<embed type="application/x-shockwave-flash" src="http://video.google.com/googleplayer.swf?docid=' . esc_attr($matches[2]) . '&amp;hl=en&amp;fs=true" style="width:' . esc_attr($width) . 'px;height:' . esc_attr($height) . 'px" allowFullScreen="true" allowScriptAccess="always"></embed>', $matches, $attr, $url, $rawattr );}wp_embed_register_handler( 'googlevideo', '#http://video\.google\.([A-Za-z.]{2,5})/videoplay\?docid=([\d-]+)(.*?)#i', 'wp_embed_handler_googlevideo' );?>
<?php/** * The Sidebar containing the primary and secondary widget areas. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */?>		<div id="primary" class="widget-area" role="complementary">			<ul class="xoxo"><?php	/* When we call the dynamic_sidebar() function, it'll spit out	 * the widgets for that widget area. If it instead returns false,	 * then the sidebar simply doesn't exist, so we'll hard-code in	 * some default sidebar stuff just in case.	 */	if ( ! dynamic_sidebar( 'primary-widget-area' ) ) : ?>				<li id="search" class="widget-container widget_search">				<?php get_search_form(); ?>			</li>			<li id="archives" class="widget-container">				<h3 class="widget-title"><?php _e( 'Archives', 'twentyten' ); ?></h3>				<ul>					<?php wp_get_archives( 'type=monthly' ); ?>				</ul>			</li>			<li id="meta" class="widget-container">				<h3 class="widget-title"><?php _e( 'Meta', 'twentyten' ); ?></h3>				<ul>					<?php wp_register(); ?>					<li><?php wp_loginout(); ?></li>					<?php wp_meta(); ?>				</ul>			</li>		<?php endif; // end primary widget area ?>			</ul>		</div><!-- #primary .widget-area --><?php	// A second sidebar for widgets, just because.	if ( is_active_sidebar( 'secondary-widget-area' ) ) : ?>		<div id="secondary" class="widget-area" role="complementary">			<ul class="xoxo">				<?php dynamic_sidebar( 'secondary-widget-area' ); ?>			</ul>		</div><!-- #secondary .widget-area --><?php endif; ?>
<?php/** * WordPress Options Header. * * Resets variables: 'action', 'standalone', and 'option_group_id'. Displays * updated message, if updated variable is part of the URL query. * * @package WordPress * @subpackage Administration */wp_reset_vars(array('action', 'standalone', 'option_group_id'));settings_errors();?>
<?php/** * Object Cache API * * @link http://codex.wordpress.org/Function_Reference/WP_Cache * * @package WordPress * @subpackage Cache *//** * Adds data to the cache, if the cache key doesn't aleady exist. * * @since 2.0.0 * @uses $wp_object_cache Object Cache Class * @see WP_Object_Cache::add() * * @param int|string $key The cache ID to use for retrieval later * @param mixed $data The data to add to the cache store * @param string $flag The group to add the cache to * @param int $expire When the cache data should be expired * @return unknown */function wp_cache_add($key, $data, $flag = '', $expire = 0) {	global $wp_object_cache;	return $wp_object_cache->add($key, $data, $flag, $expire);}/** * Closes the cache. * * This function has ceased to do anything since WordPress 2.5. The * functionality was removed along with the rest of the persistant cache. This * does not mean that plugins can't implement this function when they need to * make sure that the cache is cleaned up after WordPress no longer needs it. * * @since 2.0.0 * * @return bool Always returns True */function wp_cache_close() {	return true;}/** * Removes the cache contents matching ID and flag. * * @since 2.0.0 * @uses $wp_object_cache Object Cache Class * @see WP_Object_Cache::delete() * * @param int|string $id What the contents in the cache are called * @param string $flag Where the cache contents are grouped * @return bool True on successful removal, false on failure */function wp_cache_delete($id, $flag = '') {	global $wp_object_cache;	return $wp_object_cache->delete($id, $flag);}/** * Removes all cache items. * * @since 2.0.0 * @uses $wp_object_cache Object Cache Class * @see WP_Object_Cache::flush() * * @return bool Always returns true */function wp_cache_flush() {	global $wp_object_cache;	return $wp_object_cache->flush();}/** * Retrieves the cache contents from the cache by ID and flag. * * @since 2.0.0 * @uses $wp_object_cache Object Cache Class * @see WP_Object_Cache::get() * * @param int|string $id What the contents in the cache are called * @param string $flag Where the cache contents are grouped * @return bool|mixed False on failure to retrieve contents or the cache *		contents on success */function wp_cache_get($id, $flag = '') {	global $wp_object_cache;	return $wp_object_cache->get($id, $flag);}/** * Sets up Object Cache Global and assigns it. * * @since 2.0.0 * @global WP_Object_Cache $wp_object_cache WordPress Object Cache */function wp_cache_init() {	$GLOBALS['wp_object_cache'] =& new WP_Object_Cache();}/** * Replaces the contents of the cache with new data. * * @since 2.0.0 * @uses $wp_object_cache Object Cache Class * @see WP_Object_Cache::replace() * * @param int|string $id What to call the contents in the cache * @param mixed $data The contents to store in the cache * @param string $flag Where to group the cache contents * @param int $expire When to expire the cache contents * @return bool False if cache ID and group already exists, true on success */function wp_cache_replace($key, $data, $flag = '', $expire = 0) {	global $wp_object_cache;	return $wp_object_cache->replace($key, $data, $flag, $expire);}/** * Saves the data to the cache. * * @since 2.0 * @uses $wp_object_cache Object Cache Class * @see WP_Object_Cache::set() * * @param int|string $id What to call the contents in the cache * @param mixed $data The contents to store in the cache * @param string $flag Where to group the cache contents * @param int $expire When to expire the cache contents * @return bool False if cache ID and group already exists, true on success */function wp_cache_set($key, $data, $flag = '', $expire = 0) {	global $wp_object_cache;	return $wp_object_cache->set($key, $data, $flag, $expire);}/** * Adds a group or set of groups to the list of global groups. * * @since 2.6.0 * * @param string|array $groups A group or an array of groups to add */function wp_cache_add_global_groups( $groups ) {	global $wp_object_cache;	return $wp_object_cache->add_global_groups($groups);}/** * Adds a group or set of groups to the list of non-persistent groups. * * @since 2.6.0 * * @param string|array $groups A group or an array of groups to add */function wp_cache_add_non_persistent_groups( $groups ) {	// Default cache doesn't persist so nothing to do here.	return;}/** * Reset internal cache keys and structures.  If the cache backend uses global blog or site IDs as part of its cache keys, * this function instructs the backend to reset those keys and perform any cleanup since blog or site IDs have changed since cache init. * * @since 2.6.0 * * @param string|array $groups A group or an array of groups to add */function wp_cache_reset() {	global $wp_object_cache;	return $wp_object_cache->reset();}/** * WordPress Object Cache * * The WordPress Object Cache is used to save on trips to the database. The * Object Cache stores all of the cache data to memory and makes the cache * contents available by using a key, which is used to name and later retrieve * the cache contents. * * The Object Cache can be replaced by other caching mechanisms by placing files * in the wp-content folder which is looked at in wp-settings. If that file * exists, then this file will not be included. * * @package WordPress * @subpackage Cache * @since 2.0 */class WP_Object_Cache {	/**	 * Holds the cached objects	 *	 * @var array	 * @access private	 * @since 2.0.0	 */	var $cache = array ();	/**	 * Cache objects that do not exist in the cache	 *	 * @var array	 * @access private	 * @since 2.0.0	 */	var $non_existent_objects = array ();	/**	 * The amount of times the cache data was already stored in the cache.	 *	 * @since 2.5.0	 * @access private	 * @var int	 */	var $cache_hits = 0;	/**	 * Amount of times the cache did not have the request in cache	 *	 * @var int	 * @access public	 * @since 2.0.0	 */	var $cache_misses = 0;	/**	 * List of global groups	 *	 * @var array	 * @access protected	 * @since 3.0.0	 */	var $global_groups = array();	/**	 * Adds data to the cache if it doesn't already exist.	 *	 * @uses WP_Object_Cache::get Checks to see if the cache already has data.	 * @uses WP_Object_Cache::set Sets the data after the checking the cache	 *		contents existance.	 *	 * @since 2.0.0	 *	 * @param int|string $id What to call the contents in the cache	 * @param mixed $data The contents to store in the cache	 * @param string $group Where to group the cache contents	 * @param int $expire When to expire the cache contents	 * @return bool False if cache ID and group already exists, true on success	 */	function add( $id, $data, $group = 'default', $expire = '' ) {		if ( empty ($group) )			$group = 'default';		if (false !== $this->get($id, $group))			return false;		return $this->set($id, $data, $group, $expire);	}	/**	 * Sets the list of global groups.	 *	 * @since 3.0.0	 *	 * @param array $groups List of groups that are global.	 */	function add_global_groups( $groups ) {		$groups = (array) $groups;		$this->global_groups = array_merge($this->global_groups, $groups);		$this->global_groups = array_unique($this->global_groups);	}	/**	 * Remove the contents of the cache ID in the group	 *	 * If the cache ID does not exist in the group and $force parameter is set	 * to false, then nothing will happen. The $force parameter is set to false	 * by default.	 *	 * On success the group and the id will be added to the	 * $non_existent_objects property in the class.	 *	 * @since 2.0.0	 *	 * @param int|string $id What the contents in the cache are called	 * @param string $group Where the cache contents are grouped	 * @param bool $force Optional. Whether to force the unsetting of the cache	 *		ID in the group	 * @return bool False if the contents weren't deleted and true on success	 */	function delete($id, $group = 'default', $force = false) {		if (empty ($group))			$group = 'default';		if (!$force && false === $this->get($id, $group))			return false;		unset ($this->cache[$group][$id]);		$this->non_existent_objects[$group][$id] = true;		return true;	}	/**	 * Clears the object cache of all data	 *	 * @since 2.0.0	 *	 * @return bool Always returns true	 */	function flush() {		$this->cache = array ();		return true;	}	/**	 * Retrieves the cache contents, if it exists	 *	 * The contents will be first attempted to be retrieved by searching by the	 * ID in the cache group. If the cache is hit (success) then the contents	 * are returned.	 *	 * On failure, the $non_existent_objects property is checked and if the	 * cache group and ID exist in there the cache misses will not be	 * incremented. If not in the nonexistent objects property, then the cache	 * misses will be incremented and the cache group and ID will be added to	 * the nonexistent objects.	 *	 * @since 2.0.0	 *	 * @param int|string $id What the contents in the cache are called	 * @param string $group Where the cache contents are grouped	 * @return bool|mixed False on failure to retrieve contents or the cache	 *		contents on success	 */	function get($id, $group = 'default') {		if ( empty ($group) )			$group = 'default';		if ( isset ($this->cache[$group][$id]) ) {			$this->cache_hits += 1;			if ( is_object($this->cache[$group][$id]) )				return wp_clone($this->cache[$group][$id]);			else				return $this->cache[$group][$id];		}		if ( isset ($this->non_existent_objects[$group][$id]) )			return false;		$this->non_existent_objects[$group][$id] = true;		$this->cache_misses += 1;		return false;	}	/**	 * Replace the contents in the cache, if contents already exist	 *	 * @since 2.0.0	 * @see WP_Object_Cache::set()	 *	 * @param int|string $id What to call the contents in the cache	 * @param mixed $data The contents to store in the cache	 * @param string $group Where to group the cache contents	 * @param int $expire When to expire the cache contents	 * @return bool False if not exists, true if contents were replaced	 */	function replace($id, $data, $group = 'default', $expire = '') {		if (empty ($group))			$group = 'default';		if ( false === $this->get($id, $group) )			return false;		return $this->set($id, $data, $group, $expire);	}	/**	 * Reset keys	 *	 * @since 3.0.0	 */	function reset() {		// Clear out non-global caches since the blog ID has changed.		foreach ( array_keys($this->cache) as $group ) {			if ( !in_array($group, $this->global_groups) )				unset($this->cache[$group]);		}	}	/**	 * Sets the data contents into the cache	 *	 * The cache contents is grouped by the $group parameter followed by the	 * $id. This allows for duplicate ids in unique groups. Therefore, naming of	 * the group should be used with care and should follow normal function	 * naming guidelines outside of core WordPress usage.	 *	 * The $expire parameter is not used, because the cache will automatically	 * expire for each time a page is accessed and PHP finishes. The method is	 * more for cache plugins which use files.	 *	 * @since 2.0.0	 *	 * @param int|string $id What to call the contents in the cache	 * @param mixed $data The contents to store in the cache	 * @param string $group Where to group the cache contents	 * @param int $expire Not Used	 * @return bool Always returns true	 */	function set($id, $data, $group = 'default', $expire = '') {		if ( empty ($group) )			$group = 'default';		if ( NULL === $data )			$data = '';		if ( is_object($data) )			$data = wp_clone($data);		$this->cache[$group][$id] = $data;		if ( isset($this->non_existent_objects[$group][$id]) )			unset ($this->non_existent_objects[$group][$id]);		return true;	}	/**	 * Echoes the stats of the caching.	 *	 * Gives the cache hits, and cache misses. Also prints every cached group,	 * key and the data.	 *	 * @since 2.0.0	 */	function stats() {		echo "<p>";		echo "<strong>Cache Hits:</strong> {$this->cache_hits}<br />";		echo "<strong>Cache Misses:</strong> {$this->cache_misses}<br />";		echo "</p>";		foreach ($this->cache as $group => $cache) {			echo "<p>";			echo "<strong>Group:</strong> $group<br />";			echo "<strong>Cache:</strong>";			echo "<pre>";			print_r($cache);			echo "</pre>";		}	}	/**	 * PHP4 constructor; Calls PHP 5 style constructor	 *	 * @since 2.0.0	 *	 * @return WP_Object_Cache	 */	function WP_Object_Cache() {		return $this->__construct();	}	/**	 * Sets up object properties; PHP 5 style constructor	 *	 * @since 2.0.8	 * @return null|WP_Object_Cache If cache is disabled, returns null.	 */	function __construct() {		/**		 * @todo This should be moved to the PHP4 style constructor, PHP5		 * already calls __destruct()		 */		register_shutdown_function(array(&$this, "__destruct"));	}	/**	 * Will save the object cache before object is completely destroyed.	 *	 * Called upon object destruction, which should be when PHP ends.	 *	 * @since  2.0.8	 *	 * @return bool True value. Won't be used by PHP	 */	function __destruct() {		return true;	}}?>
<?php/** * The custom header image script. * * @package WordPress * @subpackage Administration *//** * The custom header image class. * * @since 2.1.0 * @package WordPress * @subpackage Administration */class Custom_Image_Header {	/**	 * Callback for administration header.	 *	 * @var callback	 * @since 2.1.0	 * @access private	 */	var $admin_header_callback;	/**	 * Callback for header div.	 *	 * @var callback	 * @since 3.0.0	 * @access private	 */	var $admin_image_div_callback;	/**	 * Holds default headers.	 *	 * @var array	 * @since 3.0.0	 * @access private	 */	var $default_headers = array();	/**	 * Holds the page menu hook.	 *	 * @var string	 * @since 3.0.0	 * @access private	 */	var $page = '';	/**	 * PHP4 Constructor - Register administration header callback.	 *	 * @since 2.1.0	 * @param callback $admin_header_callback	 * @param callback $admin_image_div_callback Optional custom image div output callback.	 * @return Custom_Image_Header	 */	function Custom_Image_Header($admin_header_callback, $admin_image_div_callback = '') {		$this->admin_header_callback = $admin_header_callback;		$this->admin_image_div_callback = $admin_image_div_callback;	}	/**	 * Set up the hooks for the Custom Header admin page.	 *	 * @since 2.1.0	 */	function init() {		if ( ! current_user_can('edit_theme_options') )			return;		$this->page = $page = add_theme_page(__('Header'), __('Header'), 'edit_theme_options', 'custom-header', array(&$this, 'admin_page'));		add_action("admin_print_scripts-$page", array(&$this, 'js_includes'));		add_action("admin_print_styles-$page", array(&$this, 'css_includes'));		add_action("admin_head-$page", array(&$this, 'help') );		add_action("admin_head-$page", array(&$this, 'take_action'), 50);		add_action("admin_head-$page", array(&$this, 'js'), 50);		add_action("admin_head-$page", $this->admin_header_callback, 51);	}	/**	 * Adds contextual help.	 *	 * @since 3.0.0	 */	function help() {		add_contextual_help( $this->page, '<p>' . __( 'You can set a custom image header for your site. Simply upload the image and crop it, and the new header will go live immediately.' ) . '</p>' .		'<p>' . __( 'If you want to discard your custom header and go back to the default included in your theme, click on the buttons to remove the custom image and restore the original header image.' ) . '</p>' .		'<p>' . __( 'Some themes come with additional header images bundled. If you see multiple images displayed, select the one you&#8217;d like and click the Save Changes button.' ) . '</p>' .		'<p><strong>' . __( 'For more information:' ) . '</strong></p>' .		'<p>' . __( '<a href="http://codex.wordpress.org/Appearance_Header_SubPanel" target="_blank">Documentation on Custom Header</a>' ) . '</p>' .		'<p>' . __( '<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>' ) . '</p>' );	}	/**	 * Get the current step.	 *	 * @since 2.6.0	 *	 * @return int Current step	 */	function step() {		if ( ! isset( $_GET['step'] ) )			return 1;		$step = (int) $_GET['step'];		if ( $step < 1 || 3 < $step )			$step = 1;		return $step;	}	/**	 * Set up the enqueue for the JavaScript files.	 *	 * @since 2.1.0	 */	function js_includes() {		$step = $this->step();		if ( ( 1 == $step || 3 == $step ) && $this->header_text() )			wp_enqueue_script('farbtastic');		elseif ( 2 == $step )			wp_enqueue_script('imgareaselect');	}	/**	 * Set up the enqueue for the CSS files	 *	 * @since 2.7	 */	function css_includes() {		$step = $this->step();		if ( ( 1 == $step || 3 == $step ) && $this->header_text() )			wp_enqueue_style('farbtastic');		elseif ( 2 == $step )			wp_enqueue_style('imgareaselect');	}	/**	 * Check if header text is allowed	 *	 * @since 3.0.0	 */	function header_text() {		if ( defined( 'NO_HEADER_TEXT' ) && NO_HEADER_TEXT )			return false;		return true;	}	/**	 * Execute custom header modification.	 *	 * @since 2.6.0	 */	function take_action() {		if ( ! current_user_can('edit_theme_options') )			return;		if ( empty( $_POST ) )			return;		$this->updated = true;		if ( isset( $_POST['resetheader'] ) ) {			check_admin_referer( 'custom-header-options', '_wpnonce-custom-header-options' );			remove_theme_mod( 'header_image' );			return;		}		if ( isset( $_POST['resettext'] ) ) {			check_admin_referer( 'custom-header-options', '_wpnonce-custom-header-options' );			remove_theme_mod('header_textcolor');			return;		}		if ( isset( $_POST['removeheader'] ) ) {			check_admin_referer( 'custom-header-options', '_wpnonce-custom-header-options' );			set_theme_mod( 'header_image', '' );			return;		}		if ( isset( $_POST['text-color'] ) ) {			check_admin_referer( 'custom-header-options', '_wpnonce-custom-header-options' );			$_POST['text-color'] = str_replace( '#', '', $_POST['text-color'] );			if ( 'blank' == $_POST['text-color'] ) {				set_theme_mod( 'header_textcolor', 'blank' );			} else {				$color = preg_replace('/[^0-9a-fA-F]/', '', $_POST['text-color']);				if ( strlen($color) == 6 || strlen($color) == 3 )					set_theme_mod('header_textcolor', $color);			}		}		if ( isset($_POST['default-header']) ) {			check_admin_referer( 'custom-header-options', '_wpnonce-custom-header-options' );			$this->process_default_headers();			if ( isset($this->default_headers[$_POST['default-header']]) )				set_theme_mod('header_image', esc_url($this->default_headers[$_POST['default-header']]['url']));		}	}	/**	 * Process the default headers	 *	 * @since 3.0.0	 */	function process_default_headers() {		global $_wp_default_headers;		if ( !empty($this->headers) )			return;		if ( !isset($_wp_default_headers) )			return;		$this->default_headers = $_wp_default_headers;		foreach ( array_keys($this->default_headers) as $header ) {			$this->default_headers[$header]['url'] =  sprintf( $this->default_headers[$header]['url'], get_template_directory_uri(), get_stylesheet_directory_uri() );			$this->default_headers[$header]['thumbnail_url'] =  sprintf( $this->default_headers[$header]['thumbnail_url'], get_template_directory_uri(), get_stylesheet_directory_uri() );		}	}	/**	 * Display UI for selecting one of several default headers.	 *	 * @since 3.0.0	 */	function show_default_header_selector() {		echo '<div id="available-headers">';		foreach ( $this->default_headers as $header_key => $header ) {			$header_thumbnail = $header['thumbnail_url'];			$header_url = $header['url'];			$header_desc = $header['description'];			echo '<div class="default-header">';			echo '<label><input name="default-header" type="radio" value="' . esc_attr($header_key) . '" ' . checked($header_url, get_theme_mod( 'header_image' ), false) . ' />';			echo '<img src="' . $header_thumbnail . '" alt="' . esc_attr($header_desc) .'" title="' . esc_attr($header_desc) .'" /></label>';			echo '</div>';		}		echo '<div class="clear"></div></div>';	}	/**	 * Execute Javascript depending on step.	 *	 * @since 2.1.0	 */	function js() {		$step = $this->step();		if ( ( 1 == $step || 3 == $step ) && $this->header_text() )			$this->js_1();		elseif ( 2 == $step )			$this->js_2();	}	/**	 * Display Javascript based on Step 1 and 3.	 *	 * @since 2.6.0	 */	function js_1() { ?><script type="text/javascript">/* <![CDATA[ */	var text_objects = ['#name', '#desc', '#text-color-row'];	var farbtastic;	var default_color = '#<?php echo HEADER_TEXTCOLOR; ?>';	var old_color = null;	function pickColor(color) {		jQuery('#name').css('color', color);		jQuery('#desc').css('color', color);		jQuery('#text-color').val(color);		farbtastic.setColor(color);	}	function toggle_text(s) {		if (jQuery(s).attr('id') == 'showtext' && jQuery('#text-color').val() != 'blank')			return;		if (jQuery(s).attr('id') == 'hidetext' && jQuery('#text-color').val() == 'blank')			return;		if (jQuery('#text-color').val() == 'blank') {			//Show text			if (old_color == '#blank')				old_color = default_color;			jQuery( text_objects.toString() ).show();			jQuery('#text-color').val(old_color);			jQuery('#name').css('color', old_color);			jQuery('#desc').css('color', old_color);			pickColor(old_color);		} else {			//Hide text			jQuery( text_objects.toString() ).hide();			old_color = jQuery('#text-color').val();			jQuery('#text-color').val('blank');		}	}	jQuery(document).ready(function() {		jQuery('#pickcolor').click(function() {			jQuery('#color-picker').show();		});		jQuery('input[name="hidetext"]').click(function() {			toggle_text(this);		});		jQuery('#defaultcolor').click(function() {			pickColor(default_color);			jQuery('#text-color').val(default_color)		});		jQuery('#text-color').keyup(function() {			var _hex = jQuery('#text-color').val();			var hex = _hex;			if ( hex[0] != '#' )				hex = '#' + hex;			hex = hex.replace(/[^#a-fA-F0-9]+/, '');			if ( hex != _hex )				jQuery('#text-color').val(hex);			if ( hex.length == 4 || hex.length == 7 )				pickColor( hex );		});		jQuery(document).mousedown(function(){			jQuery('#color-picker').each( function() {				var display = jQuery(this).css('display');				if (display == 'block')					jQuery(this).fadeOut(2);			});		});		farbtastic = jQuery.farbtastic('#color-picker', function(color) { pickColor(color); });		<?php if ( $color = get_theme_mod('header_textcolor', HEADER_TEXTCOLOR) ) { ?>		pickColor('#<?php echo $color; ?>');		<?php } ?>		<?php if ( 'blank' == get_theme_mod( 'header_textcolor', HEADER_TEXTCOLOR ) || '' == get_theme_mod('header_textcolor', HEADER_TEXTCOLOR) || ! $this->header_text() ) { ?>		toggle_text();		<?php } ?>		});</script><?php	}	/**	 * Display Javascript based on Step 2.	 *	 * @since 2.6.0	 */	function js_2() { ?><script type="text/javascript">/* <![CDATA[ */	function onEndCrop( coords ) {		jQuery( '#x1' ).val(coords.x);		jQuery( '#y1' ).val(coords.y);		jQuery( '#width' ).val(coords.w);		jQuery( '#height' ).val(coords.h);	}	jQuery(document).ready(function() {		var xinit = <?php echo HEADER_IMAGE_WIDTH; ?>;		var yinit = <?php echo HEADER_IMAGE_HEIGHT; ?>;		var ratio = xinit / yinit;		var ximg = jQuery('img#upload').width();		var yimg = jQuery('img#upload').height();		if ( yimg < yinit || ximg < xinit ) {			if ( ximg / yimg > ratio ) {				yinit = yimg;				xinit = yinit * ratio;			} else {				xinit = ximg;				yinit = xinit / ratio;			}		}		jQuery('img#upload').imgAreaSelect({			handles: true,			keys: true,			aspectRatio: xinit + ':' + yinit,			show: true,			x1: 0,			y1: 0,			x2: xinit,			y2: yinit,			maxHeight: <?php echo HEADER_IMAGE_HEIGHT; ?>,			maxWidth: <?php echo HEADER_IMAGE_WIDTH; ?>,			onInit: function () {				jQuery('#width').val(xinit);				jQuery('#height').val(yinit);			},			onSelectChange: function(img, c) {				jQuery('#x1').val(c.x1);				jQuery('#y1').val(c.y1);				jQuery('#width').val(c.width);				jQuery('#height').val(c.height);			}		});	});/* ]]> */</script><?php	}	/**	 * Display first step of custom header image page.	 *	 * @since 2.1.0	 */	function step_1() {		$this->process_default_headers();?><div class="wrap"><?php screen_icon(); ?><h2><?php _e('Custom Header'); ?></h2><?php if ( ! empty( $this->updated ) ) { ?><div id="message" class="updated"><p><?php printf( __( 'Header updated. <a href="%s">Visit your site</a> to see how it looks.' ), home_url( '/' ) ); ?></p></div><?php } ?><h3><?php _e( 'Header Image' ) ?></h3><table class="form-table"><tbody><tr valign="top"><th scope="row"><?php _e( 'Preview' ); ?></th><td >	<?php if ( $this->admin_image_div_callback ) {	  call_user_func( $this->admin_image_div_callback );	} else {	?>	<div id="headimg" style="max-width:<?php echo HEADER_IMAGE_WIDTH; ?>px;height:<?php echo HEADER_IMAGE_HEIGHT; ?>px;background-image:url(<?php esc_url ( header_image() ) ?>);">		<?php		if ( 'blank' == get_theme_mod('header_textcolor', HEADER_TEXTCOLOR) || '' == get_theme_mod('header_textcolor', HEADER_TEXTCOLOR) || ! $this->header_text() )			$style = ' style="display:none;"';		else			$style = ' style="color:#' . get_theme_mod( 'header_textcolor', HEADER_TEXTCOLOR ) . ';"';		?>		<h1><a id="name"<?php echo $style; ?> onclick="return false;" href="<?php bloginfo('url'); ?>"><?php bloginfo( 'name' ); ?></a></h1>		<div id="desc"<?php echo $style; ?>><?php bloginfo( 'description' ); ?></div>	</div>	<?php } ?></td></tr><tr valign="top"><th scope="row"><?php _e( 'Upload Image' ); ?></th><td>	<p><?php _e( 'You can upload a custom header image to be shown at the top of your site instead of the default one. On the next screen you will be able to crop the image.' ); ?><br />	<?php printf( __( 'Images of exactly <strong>%1$d &times; %2$d pixels</strong> will be used as-is.' ), HEADER_IMAGE_WIDTH, HEADER_IMAGE_HEIGHT ); ?></p>	<form enctype="multipart/form-data" id="upload-form" method="post" action="<?php echo esc_attr( add_query_arg( 'step', 2 ) ) ?>">	<p>		<label for="upload"><?php _e( 'Choose an image from your computer:' ); ?></label><br />		<input type="file" id="upload" name="import" />		<input type="hidden" name="action" value="save" />		<?php wp_nonce_field( 'custom-header-upload', '_wpnonce-custom-header-upload' ) ?>		<input type="submit" class="button" value="<?php esc_attr_e( 'Upload' ); ?>" />	</p>	</form></td></tr></tbody></table><form method="post" action="<?php echo esc_attr( add_query_arg( 'step', 1 ) ) ?>"><table class="form-table"><tbody>	<?php if ( ! empty( $this->default_headers ) ) : ?><tr valign="top"><th scope="row"><?php _e( 'Default Images' ); ?></th><td>	<p><?php _e( 'If you don&lsquo;t want to upload your own image, you can use one of these cool headers.' ) ?></p>	<?php		$this->show_default_header_selector();	?></td></tr>	<?php endif;	if ( get_header_image() ) : ?><tr valign="top"><th scope="row"><?php _e( 'Remove Image' ); ?></th><td>	<p><?php _e( 'This will remove the header image. You will not be able to restore any customizations.' ) ?></p>	<input type="submit" class="button" name="removeheader" value="<?php esc_attr_e( 'Remove Header Image' ); ?>" /></td></tr>	<?php endif;	if ( defined( 'HEADER_IMAGE' ) ) : ?><tr valign="top"><th scope="row"><?php _e( 'Reset Image' ); ?></th><td>	<p><?php _e( 'This will restore the original header image. You will not be able to restore any customizations.' ) ?></p>	<input type="submit" class="button" name="resetheader" value="<?php esc_attr_e( 'Restore Original Header Image' ); ?>" /></td></tr>	<?php endif; ?></tbody></table>	<?php if ( $this->header_text() ) : ?><h3><?php _e( 'Header Text' ) ?></h3><table class="form-table"><tbody><tr valign="top" class="hide-if-no-js"><th scope="row"><?php _e( 'Display Text' ); ?></th><td>	<p>	<?php $hidetext = get_theme_mod( 'header_textcolor', HEADER_TEXTCOLOR ); ?>	<label><input type="radio" value="1" name="hidetext" id="hidetext"<?php checked( ( 'blank' == $hidetext || empty( $hidetext ) )  ? true : false ); ?> /> <?php _e( 'No' ); ?></label>	<label><input type="radio" value="0" name="hidetext" id="showtext"<?php checked( ( 'blank' == $hidetext || empty( $hidetext ) ) ? false : true ); ?> /> <?php _e( 'Yes' ); ?></label>	</p></td></tr><tr valign="top" id="text-color-row"><th scope="row"><?php _e( 'Text Color' ); ?></th><td>	<p>		<input type="text" name="text-color" id="text-color" value="#<?php echo esc_attr( get_theme_mod( 'header_textcolor', HEADER_TEXTCOLOR ) ); ?>" />		<span class="description hide-if-js"><?php _e( 'If you want to hide header text, add <strong>#blank</strong> as text color.' );?></span>		<input type="button" class="button hide-if-no-js" value="<?php esc_attr_e( 'Select a Color' ); ?>" id="pickcolor" />	</p>	<div id="color-picker" style="z-index: 100; background:#eee; border:1px solid #ccc; position:absolute; display:none;"></div></td></tr>	<?php if ( defined('HEADER_TEXTCOLOR') && get_theme_mod('header_textcolor') ) { ?><tr valign="top"><th scope="row"><?php _e('Reset Text Color'); ?></th><td>	<p><?php _e( 'This will restore the original header text. You will not be able to restore any customizations.' ) ?></p>	<input type="submit" class="button" name="resettext" value="<?php esc_attr_e( 'Restore Original Header Text' ); ?>" /></td></tr>	<?php } ?></tbody></table>	<?php endif;wp_nonce_field( 'custom-header-options', '_wpnonce-custom-header-options' ); ?><p class="submit"><input type="submit" class="button-primary" name="save-header-options" value="<?php esc_attr_e( 'Save Changes' ); ?>" /></p></form></div><?php }	/**	 * Display second step of custom header image page.	 *	 * @since 2.1.0	 */	function step_2() {		check_admin_referer('custom-header-upload', '_wpnonce-custom-header-upload');		$overrides = array('test_form' => false);		$file = wp_handle_upload($_FILES['import'], $overrides);		if ( isset($file['error']) )			wp_die( $file['error'],  __( 'Image Upload Error' ) );		$url = $file['url'];		$type = $file['type'];		$file = $file['file'];		$filename = basename($file);		// Construct the object array		$object = array(		'post_title' => $filename,		'post_content' => $url,		'post_mime_type' => $type,		'guid' => $url);		// Save the data		$id = wp_insert_attachment($object, $file);		list($width, $height, $type, $attr) = getimagesize( $file );		if ( $width == HEADER_IMAGE_WIDTH && $height == HEADER_IMAGE_HEIGHT ) {			// Add the meta-data			wp_update_attachment_metadata( $id, wp_generate_attachment_metadata( $id, $file ) );			set_theme_mod('header_image', esc_url($url));			do_action('wp_create_file_in_uploads', $file, $id); // For replication			return $this->finished();		} elseif ( $width > HEADER_IMAGE_WIDTH ) {			$oitar = $width / HEADER_IMAGE_WIDTH;			$image = wp_crop_image($file, 0, 0, $width, $height, HEADER_IMAGE_WIDTH, $height / $oitar, false, str_replace(basename($file), 'midsize-'.basename($file), $file));			if ( is_wp_error( $image ) )				wp_die( __( 'Image could not be processed.  Please go back and try again.' ), __( 'Image Processing Error' ) );			$image = apply_filters('wp_create_file_in_uploads', $image, $id); // For replication			$url = str_replace(basename($url), basename($image), $url);			$width = $width / $oitar;			$height = $height / $oitar;		} else {			$oitar = 1;		}		?><div class="wrap"><?php screen_icon(); ?><h2><?php _e( 'Crop Header Image' ); ?></h2><form method="post" action="<?php echo esc_attr(add_query_arg('step', 3)); ?>">	<p class="hide-if-no-js"><?php _e('Choose the part of the image you want to use as your header.'); ?></p>	<p class="hide-if-js"><strong><?php _e( 'You need Javascript to choose a part of the image.'); ?></strong></p>	<div id="crop_image" style="position: relative">		<img src="<?php echo esc_url( $url ); ?>" id="upload" width="<?php echo $width; ?>" height="<?php echo $height; ?>" />	</div>	<p class="submit">	<input type="hidden" name="x1" id="x1" value="0"/>	<input type="hidden" name="y1" id="y1" value="0"/>	<input type="hidden" name="width" id="width" value="<?php echo esc_attr( $width ); ?>"/>	<input type="hidden" name="height" id="height" value="<?php echo esc_attr( $height ); ?>"/>	<input type="hidden" name="attachment_id" id="attachment_id" value="<?php echo esc_attr( $id ); ?>" />	<input type="hidden" name="oitar" id="oitar" value="<?php echo esc_attr( $oitar ); ?>" />	<?php wp_nonce_field( 'custom-header-crop-image' ) ?>	<input type="submit" class="button-primary" value="<?php esc_attr_e( 'Crop and Publish' ); ?>" />	</p></form></div>		<?php	}	/**	 * Display third step of custom header image page.	 *	 * @since 2.1.0	 */	function step_3() {		check_admin_referer('custom-header-crop-image');		if ( $_POST['oitar'] > 1 ) {			$_POST['x1'] = $_POST['x1'] * $_POST['oitar'];			$_POST['y1'] = $_POST['y1'] * $_POST['oitar'];			$_POST['width'] = $_POST['width'] * $_POST['oitar'];			$_POST['height'] = $_POST['height'] * $_POST['oitar'];		}		$original = get_attached_file( $_POST['attachment_id'] );		$cropped = wp_crop_image($_POST['attachment_id'], $_POST['x1'], $_POST['y1'], $_POST['width'], $_POST['height'], HEADER_IMAGE_WIDTH, HEADER_IMAGE_HEIGHT);		if ( is_wp_error( $cropped ) )			wp_die( __( 'Image could not be processed.  Please go back and try again.' ), __( 'Image Processing Error' ) );		$cropped = apply_filters('wp_create_file_in_uploads', $cropped, $_POST['attachment_id']); // For replication		$parent = get_post($_POST['attachment_id']);		$parent_url = $parent->guid;		$url = str_replace(basename($parent_url), basename($cropped), $parent_url);		// Construct the object array		$object = array(			'ID' => $_POST['attachment_id'],			'post_title' => basename($cropped),			'post_content' => $url,			'post_mime_type' => 'image/jpeg',			'guid' => $url		);		// Update the attachment		wp_insert_attachment($object, $cropped);		wp_update_attachment_metadata( $_POST['attachment_id'], wp_generate_attachment_metadata( $_POST['attachment_id'], $cropped ) );		set_theme_mod('header_image', $url);		// cleanup		$medium = str_replace(basename($original), 'midsize-'.basename($original), $original);		@unlink( apply_filters( 'wp_delete_file', $medium ) );		@unlink( apply_filters( 'wp_delete_file', $original ) );		return $this->finished();	}	/**	 * Display last step of custom header image page.	 *	 * @since 2.1.0	 */	function finished() {		$this->updated = true;		$this->step_1();	}	/**	 * Display the page based on the current step.	 *	 * @since 2.1.0	 */	function admin_page() {		if ( ! current_user_can('edit_theme_options') )			wp_die(__('You do not have permission to customize headers.'));		$step = $this->step();		if ( 1 == $step )			$this->step_1();		elseif ( 2 == $step )			$this->step_2();		elseif ( 3 == $step )			$this->step_3();	}}?>
<?php/** * File contains all the administration image manipulation functions. * * @package WordPress * @subpackage Administration *//** * Create a thumbnail from an Image given a maximum side size. * * This function can handle most image file formats which PHP supports. If PHP * does not have the functionality to save in a file of the same format, the * thumbnail will be created as a jpeg. * * @since 1.2.0 * * @param mixed $file Filename of the original image, Or attachment id. * @param int $max_side Maximum length of a single side for the thumbnail. * @param mixed $deprecated Never used. * @return string Thumbnail path on success, Error string on failure. */function wp_create_thumbnail( $file, $max_side, $deprecated = '' ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '1.2' );	$thumbpath = image_resize( $file, $max_side, $max_side );	return apply_filters( 'wp_create_thumbnail', $thumbpath );}/** * Crop an Image to a given size. * * @since 2.1.0 * * @param string|int $src_file The source file or Attachment ID. * @param int $src_x The start x position to crop from. * @param int $src_y The start y position to crop from. * @param int $src_w The width to crop. * @param int $src_h The height to crop. * @param int $dst_w The destination width. * @param int $dst_h The destination height. * @param int $src_abs Optional. If the source crop points are absolute. * @param string $dst_file Optional. The destination file to write to. * @return string|WP_Error|false New filepath on success, WP_Error or false on failure. */function wp_crop_image( $src_file, $src_x, $src_y, $src_w, $src_h, $dst_w, $dst_h, $src_abs = false, $dst_file = false ) {	if ( is_numeric( $src_file ) ) // Handle int as attachment ID		$src_file = get_attached_file( $src_file );	$src = wp_load_image( $src_file );	if ( !is_resource( $src ) )		return new WP_Error( 'error_loading_image', $src, $src_file );	$dst = wp_imagecreatetruecolor( $dst_w, $dst_h );	if ( $src_abs ) {		$src_w -= $src_x;		$src_h -= $src_y;	}	if (function_exists('imageantialias'))		imageantialias( $dst, true );	imagecopyresampled( $dst, $src, 0, 0, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h );	imagedestroy( $src ); // Free up memory	if ( ! $dst_file )		$dst_file = str_replace( basename( $src_file ), 'cropped-' . basename( $src_file ), $src_file );	$dst_file = preg_replace( '/\\.[^\\.]+$/', '.jpg', $dst_file );	if ( imagejpeg( $dst, $dst_file, apply_filters( 'jpeg_quality', 90, 'wp_crop_image' ) ) )		return $dst_file;	else		return false;}/** * Generate post thumbnail attachment meta data. * * @since 2.1.0 * * @param int $attachment_id Attachment Id to process. * @param string $file Filepath of the Attached image. * @return mixed Metadata for attachment. */function wp_generate_attachment_metadata( $attachment_id, $file ) {	$attachment = get_post( $attachment_id );	$metadata = array();	if ( preg_match('!^image/!', get_post_mime_type( $attachment )) && file_is_displayable_image($file) ) {		$imagesize = getimagesize( $file );		$metadata['width'] = $imagesize[0];		$metadata['height'] = $imagesize[1];		list($uwidth, $uheight) = wp_constrain_dimensions($metadata['width'], $metadata['height'], 128, 96);		$metadata['hwstring_small'] = "height='$uheight' width='$uwidth'";		// Make the file path relative to the upload dir		$metadata['file'] = _wp_relative_upload_path($file);		// make thumbnails and other intermediate sizes		global $_wp_additional_image_sizes;		foreach ( get_intermediate_image_sizes() as $s ) {			$sizes[$s] = array( 'width' => '', 'height' => '', 'crop' => FALSE );			if ( isset( $_wp_additional_image_sizes[$s]['width'] ) )				$sizes[$s]['width'] = intval( $_wp_additional_image_sizes[$s]['width'] ); // For theme-added sizes			else				$sizes[$s]['width'] = get_option( "{$s}_size_w" ); // For default sizes set in options			if ( isset( $_wp_additional_image_sizes[$s]['height'] ) )				$sizes[$s]['height'] = intval( $_wp_additional_image_sizes[$s]['height'] ); // For theme-added sizes			else				$sizes[$s]['height'] = get_option( "{$s}_size_h" ); // For default sizes set in options			if ( isset( $_wp_additional_image_sizes[$s]['crop'] ) )				$sizes[$s]['crop'] = intval( $_wp_additional_image_sizes[$s]['crop'] ); // For theme-added sizes			else				$sizes[$s]['crop'] = get_option( "{$s}_crop" ); // For default sizes set in options		}		$sizes = apply_filters( 'intermediate_image_sizes_advanced', $sizes );		foreach ($sizes as $size => $size_data ) {			$resized = image_make_intermediate_size( $file, $size_data['width'], $size_data['height'], $size_data['crop'] );			if ( $resized )				$metadata['sizes'][$size] = $resized;		}		// fetch additional metadata from exif/iptc		$image_meta = wp_read_image_metadata( $file );		if ( $image_meta )			$metadata['image_meta'] = $image_meta;	}	return apply_filters( 'wp_generate_attachment_metadata', $metadata, $attachment_id );}/** * Calculated the new dimentions for a downsampled image. * * @since 2.0.0 * @see wp_constrain_dimensions() * * @param int $width Current width of the image * @param int $height Current height of the image * @return mixed Array(height,width) of shrunk dimensions. */function get_udims( $width, $height) {	return wp_constrain_dimensions( $width, $height, 128, 96 );}/** * Convert a fraction string to a decimal. * * @since 2.5.0 * * @param string $str * @return int|float */function wp_exif_frac2dec($str) {	@list( $n, $d ) = explode( '/', $str );	if ( !empty($d) )		return $n / $d;	return $str;}/** * Convert the exif date format to a unix timestamp. * * @since 2.5.0 * * @param string $str * @return int */function wp_exif_date2ts($str) {	@list( $date, $time ) = explode( ' ', trim($str) );	@list( $y, $m, $d ) = explode( ':', $date );	return strtotime( "{$y}-{$m}-{$d} {$time}" );}/** * Get extended image metadata, exif or iptc as available. * * Retrieves the EXIF metadata aperture, credit, camera, caption, copyright, iso * created_timestamp, focal_length, shutter_speed, and title. * * The IPTC metadata that is retrieved is APP13, credit, byline, created date * and time, caption, copyright, and title. Also includes FNumber, Model, * DateTimeDigitized, FocalLength, ISOSpeedRatings, and ExposureTime. * * @todo Try other exif libraries if available. * @since 2.5.0 * * @param string $file * @return bool|array False on failure. Image metadata array on success. */function wp_read_image_metadata( $file ) {	if ( ! file_exists( $file ) )		return false;	list( , , $sourceImageType ) = getimagesize( $file );	// exif contains a bunch of data we'll probably never need formatted in ways	// that are difficult to use. We'll normalize it and just extract the fields	// that are likely to be useful.  Fractions and numbers are converted to	// floats, dates to unix timestamps, and everything else to strings.	$meta = array(		'aperture' => 0,		'credit' => '',		'camera' => '',		'caption' => '',		'created_timestamp' => 0,		'copyright' => '',		'focal_length' => 0,		'iso' => 0,		'shutter_speed' => 0,		'title' => '',	);	// read iptc first, since it might contain data not available in exif such	// as caption, description etc	if ( is_callable( 'iptcparse' ) ) {		getimagesize( $file, $info );		if ( ! empty( $info['APP13'] ) ) {			$iptc = iptcparse( $info['APP13'] );			// headline, "A brief synopsis of the caption."			if ( ! empty( $iptc['2#105'][0] ) )				$meta['title'] = utf8_encode( trim( $iptc['2#105'][0] ) );			// title, "Many use the Title field to store the filename of the image, though the field may be used in many ways."			elseif ( ! empty( $iptc['2#005'][0] ) )				$meta['title'] = utf8_encode( trim( $iptc['2#005'][0] ) );			if ( ! empty( $iptc['2#120'][0] ) ) { // description / legacy caption				$caption = utf8_encode( trim( $iptc['2#120'][0] ) );				if ( empty( $meta['title'] ) ) {					// Assume the title is stored in 2:120 if it's short.					if ( strlen( $caption ) < 80 )						$meta['title'] = $caption;					else						$meta['caption'] = $caption;				} elseif ( $caption != $meta['title'] ) {					$meta['caption'] = $caption;				}			}			if ( ! empty( $iptc['2#110'][0] ) ) // credit				$meta['credit'] = utf8_encode(trim($iptc['2#110'][0]));			elseif ( ! empty( $iptc['2#080'][0] ) ) // creator / legacy byline				$meta['credit'] = utf8_encode(trim($iptc['2#080'][0]));			if ( ! empty( $iptc['2#055'][0] ) and ! empty( $iptc['2#060'][0] ) ) // created date and time				$meta['created_timestamp'] = strtotime( $iptc['2#055'][0] . ' ' . $iptc['2#060'][0] );			if ( ! empty( $iptc['2#116'][0] ) ) // copyright				$meta['copyright'] = utf8_encode( trim( $iptc['2#116'][0] ) );		 }	}	// fetch additional info from exif if available	if ( is_callable( 'exif_read_data' ) && in_array( $sourceImageType, apply_filters( 'wp_read_image_metadata_types', array( IMAGETYPE_JPEG, IMAGETYPE_TIFF_II, IMAGETYPE_TIFF_MM ) ) ) ) {		$exif = @exif_read_data( $file );		if ( !empty( $exif['Title'] ) )			$meta['title'] = utf8_encode( trim( $exif['Title'] ) );		if ( ! empty( $exif['ImageDescription'] ) ) {			if ( empty( $meta['title'] ) && strlen( $exif['ImageDescription'] ) < 80 ) {				// Assume the title is stored in ImageDescription				$meta['title'] = utf8_encode( trim( $exif['ImageDescription'] ) );				if ( ! empty( $exif['COMPUTED']['UserComment'] ) && trim( $exif['COMPUTED']['UserComment'] ) != $meta['title'] )					$meta['caption'] = utf8_encode( trim( $exif['COMPUTED']['UserComment'] ) );			} elseif ( trim( $exif['ImageDescription'] ) != $meta['title'] ) {				$meta['caption'] = utf8_encode( trim( $exif['ImageDescription'] ) );			}		} elseif ( ! empty( $exif['Comments'] ) && trim( $exif['Comments'] ) != $meta['title'] ) {			$meta['caption'] = utf8_encode( trim( $exif['Comments'] ) );		}		if ( ! empty( $exif['Artist'] ) )			$meta['credit'] = utf8_encode( trim( $exif['Artist'] ) );		elseif ( ! empty($exif['Author'] ) )			$meta['credit'] = utf8_encode( trim( $exif['Author'] ) );		if ( ! empty( $exif['Copyright'] ) )			$meta['copyright'] = utf8_encode( trim( $exif['Copyright'] ) );		if ( ! empty($exif['FNumber'] ) )			$meta['aperture'] = round( wp_exif_frac2dec( $exif['FNumber'] ), 2 );		if ( ! empty($exif['Model'] ) )			$meta['camera'] = utf8_encode( trim( $exif['Model'] ) );		if ( ! empty($exif['DateTimeDigitized'] ) )			$meta['created_timestamp'] = wp_exif_date2ts($exif['DateTimeDigitized'] );		if ( ! empty($exif['FocalLength'] ) )			$meta['focal_length'] = wp_exif_frac2dec( $exif['FocalLength'] );		if ( ! empty($exif['ISOSpeedRatings'] ) )			$meta['iso'] = utf8_encode( trim( $exif['ISOSpeedRatings'] ) );		if ( ! empty($exif['ExposureTime'] ) )			$meta['shutter_speed'] = wp_exif_frac2dec( $exif['ExposureTime'] );	}	return apply_filters( 'wp_read_image_metadata', $meta, $file, $sourceImageType );}/** * Validate that file is an image. * * @since 2.5.0 * * @param string $path File path to test if valid image. * @return bool True if valid image, false if not valid image. */function file_is_valid_image($path) {	$size = @getimagesize($path);	return !empty($size);}/** * Validate that file is suitable for displaying within a web page. * * @since 2.5.0 * @uses apply_filters() Calls 'file_is_displayable_image' on $result and $path. * * @param string $path File path to test. * @return bool True if suitable, false if not suitable. */function file_is_displayable_image($path) {	$info = @getimagesize($path);	if ( empty($info) )		$result = false;	elseif ( !in_array($info[2], array(IMAGETYPE_GIF, IMAGETYPE_JPEG, IMAGETYPE_PNG)) )	// only gif, jpeg and png images can reliably be displayed		$result = false;	else		$result = true;	return apply_filters('file_is_displayable_image', $result, $path);}
<?php/** * WordPress Translation API * * @package WordPress * @subpackage i18n *//** * Gets the current locale. * * If the locale is set, then it will filter the locale in the 'locale' filter * hook and return the value. * * If the locale is not set already, then the WPLANG constant is used if it is * defined. Then it is filtered through the 'locale' filter hook and the value * for the locale global set and the locale is returned. * * The process to get the locale should only be done once but the locale will * always be filtered using the 'locale' hook. * * @since 1.5.0 * @uses apply_filters() Calls 'locale' hook on locale value. * @uses $locale Gets the locale stored in the global. * * @return string The locale of the blog or from the 'locale' hook. */function get_locale() {	global $locale;	if ( isset( $locale ) )		return apply_filters( 'locale', $locale );	// WPLANG is defined in wp-config.	if ( defined( 'WPLANG' ) )		$locale = WPLANG;	// If multisite, check options.	if ( is_multisite() && !defined('WP_INSTALLING') ) {		$ms_locale = get_option('WPLANG');		if ( $ms_locale === false )			$ms_locale = get_site_option('WPLANG');		if ( $ms_locale !== false )			$locale = $ms_locale;	}	if ( empty( $locale ) )		$locale = 'en_US';	return apply_filters( 'locale', $locale );}/** * Retrieves the translation of $text. If there is no translation, or * the domain isn't loaded the original text is returned. * * @see __() Don't use translate() directly, use __() * @since 2.2.0 * @uses apply_filters() Calls 'gettext' on domain translated text *		with the untranslated text as second parameter. * * @param string $text Text to translate. * @param string $domain Domain to retrieve the translated text. * @return string Translated text */function translate( $text, $domain = 'default' ) {	$translations = &get_translations_for_domain( $domain );	return apply_filters( 'gettext', $translations->translate( $text ), $text, $domain );}function before_last_bar( $string ) {	$last_bar = strrpos( $string, '|' );	if ( false == $last_bar )		return $string;	else		return substr( $string, 0, $last_bar );}function translate_with_gettext_context( $text, $context, $domain = 'default' ) {	$translations = &get_translations_for_domain( $domain );	return apply_filters( 'gettext_with_context', $translations->translate( $text, $context ), $text, $context, $domain );}/** * Retrieves the translation of $text. If there is no translation, or * the domain isn't loaded the original text is returned. * * @see translate() An alias of translate() * @since 2.1.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text * @return string Translated text */function __( $text, $domain = 'default' ) {	return translate( $text, $domain );}/** * Retrieves the translation of $text and escapes it for safe use in an attribute. * If there is no translation, or the domain isn't loaded the original text is returned. * * @see translate() An alias of translate() * @see esc_attr() * @since 2.8.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text * @return string Translated text */function esc_attr__( $text, $domain = 'default' ) {	return esc_attr( translate( $text, $domain ) );}/** * Retrieves the translation of $text and escapes it for safe use in HTML output. * If there is no translation, or the domain isn't loaded the original text is returned. * * @see translate() An alias of translate() * @see esc_html() * @since 2.8.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text * @return string Translated text */function esc_html__( $text, $domain = 'default' ) {	return esc_html( translate( $text, $domain ) );}/** * Displays the returned translated text from translate(). * * @see translate() Echoes returned translate() string * @since 1.2.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text */function _e( $text, $domain = 'default' ) {	echo translate( $text, $domain );}/** * Displays translated text that has been escaped for safe use in an attribute. * * @see translate() Echoes returned translate() string * @see esc_attr() * @since 2.8.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text */function esc_attr_e( $text, $domain = 'default' ) {	echo esc_attr( translate( $text, $domain ) );}/** * Displays translated text that has been escaped for safe use in HTML output. * * @see translate() Echoes returned translate() string * @see esc_html() * @since 2.8.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text */function esc_html_e( $text, $domain = 'default' ) {	echo esc_html( translate( $text, $domain ) );}/** * Retrieve translated string with gettext context * * Quite a few times, there will be collisions with similar translatable text * found in more than two places but with different translated context. * * By including the context in the pot file translators can translate the two * string differently. * * @since 2.8.0 * * @param string $text Text to translate * @param string $context Context information for the translators * @param string $domain Optional. Domain to retrieve the translated text * @return string Translated context string without pipe */function _x( $single, $context, $domain = 'default' ) {	return translate_with_gettext_context( $single, $context, $domain );}/** * Displays translated string with gettext context * * @see _x * @since 3.0.0 * * @param string $text Text to translate * @param string $context Context information for the translators * @param string $domain Optional. Domain to retrieve the translated text * @return string Translated context string without pipe */function _ex( $single, $context, $domain = 'default' ) {	echo _x( $single, $context, $domain );}function esc_attr_x( $single, $context, $domain = 'default' ) {	return esc_attr( translate_with_gettext_context( $single, $context, $domain ) );}function esc_html_x( $single, $context, $domain = 'default' ) {	return esc_html( translate_with_gettext_context( $single, $context, $domain ) );}/** * Retrieve the plural or single form based on the amount. * * If the domain is not set in the $l10n list, then a comparison will be made * and either $plural or $single parameters returned. * * If the domain does exist, then the parameters $single, $plural, and $number * will first be passed to the domain's ngettext method. Then it will be passed * to the 'ngettext' filter hook along with the same parameters. The expected * type will be a string. * * @since 2.8.0 * @uses $l10n Gets list of domain translated string (gettext_reader) objects * @uses apply_filters() Calls 'ngettext' hook on domains text returned, *		along with $single, $plural, and $number parameters. Expected to return string. * * @param string $single The text that will be used if $number is 1 * @param string $plural The text that will be used if $number is not 1 * @param int $number The number to compare against to use either $single or $plural * @param string $domain Optional. The domain identifier the text should be retrieved in * @return string Either $single or $plural translated text */function _n( $single, $plural, $number, $domain = 'default' ) {	$translations = &get_translations_for_domain( $domain );	$translation = $translations->translate_plural( $single, $plural, $number );	return apply_filters( 'ngettext', $translation, $single, $plural, $number, $domain );}/** * A hybrid of _n() and _x(). It supports contexts and plurals. * * @see _n() * @see _x() * */function _nx($single, $plural, $number, $context, $domain = 'default') {	$translations = &get_translations_for_domain( $domain );	$translation = $translations->translate_plural( $single, $plural, $number, $context );	return apply_filters( 'ngettext_with_context', $translation, $single, $plural, $number, $context, $domain );}/** * Register plural strings in POT file, but don't translate them. * * Used when you want do keep structures with translatable plural strings and * use them later. * * Example: *  $messages = array( *  	'post' => _n_noop('%s post', '%s posts'), *  	'page' => _n_noop('%s pages', '%s pages') *  ); *  ... *  $message = $messages[$type]; *  $usable_text = sprintf(_n($message[0], $message[1], $count), $count); * * @since 2.5 * @param $single Single form to be i18ned * @param $plural Plural form to be i18ned * @return array array($single, $plural) */function _n_noop( $single, $plural ) {	return array( $single, $plural );}/** * Register plural strings with context in POT file, but don't translate them. * * @see _n_noop() */function _nx_noop( $single, $plural, $context ) {	return array( $single, $plural, $context );}/** * Loads a MO file into the domain $domain. * * If the domain already exists, the translations will be merged. If both * sets have the same string, the translation from the original value will be taken. * * On success, the .mo file will be placed in the $l10n global by $domain * and will be a MO object. * * @since 1.5.0 * @uses $l10n Gets list of domain translated string objects * * @param string $domain Unique identifier for retrieving translated strings * @param string $mofile Path to the .mo file * @return bool true on success, false on failure */function load_textdomain( $domain, $mofile ) {	global $l10n;	$plugin_override = apply_filters( 'override_load_textdomain', false, $domain, $mofile );	if ( true == $plugin_override ) {		return true;	}	do_action( 'load_textdomain', $domain, $mofile );	$mofile = apply_filters( 'load_textdomain_mofile', $mofile, $domain );	if ( !is_readable( $mofile ) ) return false;	$mo = new MO();	if ( !$mo->import_from_file( $mofile ) ) return false;	if ( isset( $l10n[$domain] ) )		$mo->merge_with( $l10n[$domain] );	$l10n[$domain] = &$mo;	return true;}/** * Unloads translations for a domain * * @since 3.0.0 * @param string $domain Textdomain to be unloaded * @return bool Whether textdomain was unloaded */function unload_textdomain( $domain ) {	global $l10n;	$plugin_override = apply_filters( 'override_unload_textdomain', false, $domain );	if ( $plugin_override )		return true;	do_action( 'unload_textdomain', $domain );	if ( isset( $l10n[$domain] ) ) {		unset( $l10n[$domain] );		return true;	}	return false;}/** * Loads default translated strings based on locale. * * Loads the .mo file in WP_LANG_DIR constant path from WordPress root. The * translated (.mo) file is named based off of the locale. * * @since 1.5.0 */function load_default_textdomain() {	$locale = get_locale();	load_textdomain( 'default', WP_LANG_DIR . "/$locale.mo" );	if ( is_multisite() || ( defined( 'WP_NETWORK_ADMIN_PAGE' ) && WP_NETWORK_ADMIN_PAGE ) ) {		load_textdomain( 'default', WP_LANG_DIR . "/ms-$locale.mo" );	}}/** * Loads the plugin's translated strings. * * If the path is not given then it will be the root of the plugin directory. * The .mo file should be named based on the domain with a dash, and then the locale exactly. * * @since 1.5.0 * * @param string $domain Unique identifier for retrieving translated strings * @param string $abs_rel_path Optional. Relative path to ABSPATH of a folder, * 	where the .mo file resides. Deprecated, but still functional until 2.7 * @param string $plugin_rel_path Optional. Relative path to WP_PLUGIN_DIR. This is the preferred argument to use. It takes precendence over $abs_rel_path */function load_plugin_textdomain( $domain, $abs_rel_path = false, $plugin_rel_path = false ) {	$locale = apply_filters( 'plugin_locale', get_locale(), $domain );	if ( false !== $plugin_rel_path	) {		$path = WP_PLUGIN_DIR . '/' . trim( $plugin_rel_path, '/' );	} else if ( false !== $abs_rel_path ) {		_deprecated_argument( __FUNCTION__, '2.7' );		$path = ABSPATH . trim( $abs_rel_path, '/' );	} else {		$path = WP_PLUGIN_DIR;	}	$mofile = $path . '/'. $domain . '-' . $locale . '.mo';	return load_textdomain( $domain, $mofile );}/** * Load the translated strings for a plugin residing in the mu-plugins dir. * * @since 3.0.0 * * @param string $domain Unique identifier for retrieving translated strings * @param strings $mu_plugin_rel_path Relative to WPMU_PLUGIN_DIR directory in which * the MO file resides. Defaults is empty string. */function load_muplugin_textdomain( $domain, $mu_plugin_rel_path = '' ) {	$locale = apply_filters( 'plugin_locale', get_locale(), $domain );	$path = WPMU_PLUGIN_DIR . '/' . ltrim( $mu_plugin_rel_path, '/' );	load_textdomain( $domain, trailingslashit( $path ) . "$domain-$locale.mo" );}/** * Loads the theme's translated strings. * * If the current locale exists as a .mo file in the theme's root directory, it * will be included in the translated strings by the $domain. * * The .mo files must be named based on the locale exactly. * * @since 1.5.0 * * @param string $domain Unique identifier for retrieving translated strings */function load_theme_textdomain( $domain, $path = false ) {	$locale = apply_filters( 'theme_locale', get_locale(), $domain );	$path = ( empty( $path ) ) ? get_template_directory() : $path;	$mofile = "$path/$locale.mo";	return load_textdomain($domain, $mofile);}/** * Loads the child themes translated strings. * * If the current locale exists as a .mo file in the child themes root directory, it * will be included in the translated strings by the $domain. * * The .mo files must be named based on the locale exactly. * * @since 2.9.0 * * @param string $domain Unique identifier for retrieving translated strings */function load_child_theme_textdomain( $domain, $path = false ) {	$locale = apply_filters( 'theme_locale', get_locale(), $domain );	$path = ( empty( $path ) ) ? get_stylesheet_directory() : $path;	$mofile = "$path/$locale.mo";	return load_textdomain($domain, $mofile);}/** * Returns the Translations instance for a domain. If there isn't one, * returns empty Translations instance. * * @param string $domain * @return object A Translation instance */function &get_translations_for_domain( $domain ) {	global $l10n;	if ( !isset( $l10n[$domain] ) ) {		$l10n[$domain] = &new NOOP_Translations;	}	return $l10n[$domain];}/** * Whether there are translations for the domain * * @since 3.0.0 * @param string $domain * @return bool Whether there are translations */function is_textdomain_loaded( $domain ) {	global $l10n;	return isset( $l10n[$domain] );}/** * Translates role name. Since the role names are in the database and * not in the source there are dummy gettext calls to get them into the POT * file and this function properly translates them back. * * The before_last_bar() call is needed, because older installs keep the roles * using the old context format: 'Role name|User role' and just skipping the * content after the last bar is easier than fixing them in the DB. New installs * won't suffer from that problem. */function translate_user_role( $name ) {	return translate_with_gettext_context( before_last_bar($name), 'User role' );}/** * Get all available languages based on the presence of *.mo files in a given directory. The default directory is WP_LANG_DIR. * * @since 3.0.0 * * @param string $dir A directory in which to search for language files. The default directory is WP_LANG_DIR. * @return array Array of language codes or an empty array if no languages are present.  Language codes are formed by stripping the .mo extension from the language file names. */function get_available_languages( $dir = null ) {	$languages = array();	foreach( (array)glob( ( is_null( $dir) ? WP_LANG_DIR : $dir ) . '/*.mo' ) as $lang_file ) {		$lang_file = basename($lang_file, '.mo');		if ( 0 !== strpos( $lang_file, 'continents-cities' ) && 0 !== strpos( $lang_file, 'ms-' ) )			$languages[] = $lang_file;	}	return $languages;}
<?php/** * User Registration API * * @package WordPress *//** * Checks whether the given username exists. * * @since 2.0.0 * * @param string $username Username. * @return null|int The user's ID on success, and null on failure. */function username_exists( $username ) {	if ( $user = get_userdatabylogin( $username ) ) {		return $user->ID;	} else {		return null;	}}/** * Checks whether the given email exists. * * @since 2.1.0 * @uses $wpdb * * @param string $email Email. * @return bool|int The user's ID on success, and false on failure. */function email_exists( $email ) {	if ( $user = get_user_by_email($email) )		return $user->ID;	return false;}/** * Checks whether an username is valid. * * @since 2.0.1 * @uses apply_filters() Calls 'validate_username' hook on $valid check and $username as parameters * * @param string $username Username. * @return bool Whether username given is valid */function validate_username( $username ) {	$sanitized = sanitize_user( $username, true );	$valid = ( $sanitized == $username );	return apply_filters( 'validate_username', $valid, $username );}/** * Insert an user into the database. * * Can update a current user or insert a new user based on whether the user's ID * is present. * * Can be used to update the user's info (see below), set the user's role, and * set the user's preference on whether they want the rich editor on. * * Most of the $userdata array fields have filters associated with the values. * The exceptions are 'rich_editing', 'role', 'jabber', 'aim', 'yim', * 'user_registered', and 'ID'. The filters have the prefix 'pre_user_' followed * by the field name. An example using 'description' would have the filter * called, 'pre_user_description' that can be hooked into. * * The $userdata array can contain the following fields: * 'ID' - An integer that will be used for updating an existing user. * 'user_pass' - A string that contains the plain text password for the user. * 'user_login' - A string that contains the user's username for logging in. * 'user_nicename' - A string that contains a nicer looking name for the user. *		The default is the user's username. * 'user_url' - A string containing the user's URL for the user's web site. * 'user_email' - A string containing the user's email address. * 'display_name' - A string that will be shown on the site. Defaults to user's *		username. It is likely that you will want to change this, for both *		appearance and security through obscurity (that is if you don't use and *		delete the default 'admin' user). * 'nickname' - The user's nickname, defaults to the user's username. * 'first_name' - The user's first name. * 'last_name' - The user's last name. * 'description' - A string containing content about the user. * 'rich_editing' - A string for whether to enable the rich editor. False *		if not empty. * 'user_registered' - The date the user registered. Format is 'Y-m-d H:i:s'. * 'role' - A string used to set the user's role. * 'jabber' - User's Jabber account. * 'aim' - User's AOL IM account. * 'yim' - User's Yahoo IM account. * * @since 2.0.0 * @uses $wpdb WordPress database layer. * @uses apply_filters() Calls filters for most of the $userdata fields with the prefix 'pre_user'. See note above. * @uses do_action() Calls 'profile_update' hook when updating giving the user's ID * @uses do_action() Calls 'user_register' hook when creating a new user giving the user's ID * * @param array $userdata An array of user data. * @return int|WP_Error The newly created user's ID or a WP_Error object if the user could not be created. */function wp_insert_user($userdata) {	global $wpdb;	extract($userdata, EXTR_SKIP);	// Are we updating or creating?	if ( !empty($ID) ) {		$ID = (int) $ID;		$update = true;		$old_user_data = get_userdata($ID);	} else {		$update = false;		// Hash the password		$user_pass = wp_hash_password($user_pass);	}	$user_login = sanitize_user($user_login, true);	$user_login = apply_filters('pre_user_login', $user_login);	//Remove any non-printable chars from the login string to see if we have ended up with an empty username	$user_login = trim($user_login);	if ( empty($user_login) )		return new WP_Error('empty_user_login', __('Cannot create a user with an empty login name.') );	if ( !$update && username_exists( $user_login ) )		return new WP_Error('existing_user_login', __('This username is already registered.') );	if ( empty($user_nicename) )		$user_nicename = sanitize_title( $user_login );	$user_nicename = apply_filters('pre_user_nicename', $user_nicename);	if ( empty($user_url) )		$user_url = '';	$user_url = apply_filters('pre_user_url', $user_url);	if ( empty($user_email) )		$user_email = '';	$user_email = apply_filters('pre_user_email', $user_email);	if ( !$update && ! defined( 'WP_IMPORTING' ) && email_exists($user_email) )		return new WP_Error('existing_user_email', __('This email address is already registered.') );	if ( empty($display_name) )		$display_name = $user_login;	$display_name = apply_filters('pre_user_display_name', $display_name);	if ( empty($nickname) )		$nickname = $user_login;	$nickname = apply_filters('pre_user_nickname', $nickname);	if ( empty($first_name) )		$first_name = '';	$first_name = apply_filters('pre_user_first_name', $first_name);	if ( empty($last_name) )		$last_name = '';	$last_name = apply_filters('pre_user_last_name', $last_name);	if ( empty($description) )		$description = '';	$description = apply_filters('pre_user_description', $description);	if ( empty($rich_editing) )		$rich_editing = 'true';	if ( empty($comment_shortcuts) )		$comment_shortcuts = 'false';	if ( empty($admin_color) )		$admin_color = 'fresh';	$admin_color = preg_replace('|[^a-z0-9 _.\-@]|i', '', $admin_color);	if ( empty($use_ssl) )		$use_ssl = 0;	if ( empty($user_registered) )		$user_registered = gmdate('Y-m-d H:i:s');	$user_nicename_check = $wpdb->get_var( $wpdb->prepare("SELECT ID FROM $wpdb->users WHERE user_nicename = %s AND user_login != %s LIMIT 1" , $user_nicename, $user_login));	if ( $user_nicename_check ) {		$suffix = 2;		while ($user_nicename_check) {			$alt_user_nicename = $user_nicename . "-$suffix";			$user_nicename_check = $wpdb->get_var( $wpdb->prepare("SELECT ID FROM $wpdb->users WHERE user_nicename = %s AND user_login != %s LIMIT 1" , $alt_user_nicename, $user_login));			$suffix++;		}		$user_nicename = $alt_user_nicename;	}	$data = compact( 'user_pass', 'user_email', 'user_url', 'user_nicename', 'display_name', 'user_registered' );	$data = stripslashes_deep( $data );	if ( $update ) {		$wpdb->update( $wpdb->users, $data, compact( 'ID' ) );		$user_id = (int) $ID;	} else {		$wpdb->insert( $wpdb->users, $data + compact( 'user_login' ) );		$user_id = (int) $wpdb->insert_id;	}	update_user_meta( $user_id, 'first_name', $first_name);	update_user_meta( $user_id, 'last_name', $last_name);	update_user_meta( $user_id, 'nickname', $nickname );	update_user_meta( $user_id, 'description', $description );	update_user_meta( $user_id, 'rich_editing', $rich_editing);	update_user_meta( $user_id, 'comment_shortcuts', $comment_shortcuts);	update_user_meta( $user_id, 'admin_color', $admin_color);	update_user_meta( $user_id, 'use_ssl', $use_ssl);	foreach ( _wp_get_user_contactmethods() as $method => $name ) {		if ( empty($$method) )			$$method = '';		update_user_meta( $user_id, $method, $$method );	}	if ( isset($role) ) {		$user = new WP_User($user_id);		$user->set_role($role);	} elseif ( !$update ) {		$user = new WP_User($user_id);		$user->set_role(get_option('default_role'));	}	wp_cache_delete($user_id, 'users');	wp_cache_delete($user_login, 'userlogins');	if ( $update )		do_action('profile_update', $user_id, $old_user_data);	else		do_action('user_register', $user_id);	return $user_id;}/** * Update an user in the database. * * It is possible to update a user's password by specifying the 'user_pass' * value in the $userdata parameter array. * * If $userdata does not contain an 'ID' key, then a new user will be created * and the new user's ID will be returned. * * If current user's password is being updated, then the cookies will be * cleared. * * @since 2.0.0 * @see wp_insert_user() For what fields can be set in $userdata * @uses wp_insert_user() Used to update existing user or add new one if user doesn't exist already * * @param array $userdata An array of user data. * @return int The updated user's ID. */function wp_update_user($userdata) {	$ID = (int) $userdata['ID'];	// First, get all of the original fields	$user = get_userdata($ID);	// Escape data pulled from DB.	$user = add_magic_quotes(get_object_vars($user));	// If password is changing, hash it now.	if ( ! empty($userdata['user_pass']) ) {		$plaintext_pass = $userdata['user_pass'];		$userdata['user_pass'] = wp_hash_password($userdata['user_pass']);	}	wp_cache_delete($user[ 'user_email' ], 'useremail');	// Merge old and new fields with new fields overwriting old ones.	$userdata = array_merge($user, $userdata);	$user_id = wp_insert_user($userdata);	// Update the cookies if the password changed.	$current_user = wp_get_current_user();	if ( $current_user->id == $ID ) {		if ( isset($plaintext_pass) ) {			wp_clear_auth_cookie();			wp_set_auth_cookie($ID);		}	}	return $user_id;}/** * A simpler way of inserting an user into the database. * * Creates a new user with just the username, password, and email. For a more * detail creation of a user, use wp_insert_user() to specify more infomation. * * @since 2.0.0 * @see wp_insert_user() More complete way to create a new user * * @param string $username The user's username. * @param string $password The user's password. * @param string $email The user's email (optional). * @return int The new user's ID. */function wp_create_user($username, $password, $email = '') {	$user_login = esc_sql( $username );	$user_email = esc_sql( $email    );	$user_pass = $password;	$userdata = compact('user_login', 'user_email', 'user_pass');	return wp_insert_user($userdata);}/** * Set up the default contact methods * * @access private * @since * * @return array $user_contactmethods Array of contact methods and their labels. */function _wp_get_user_contactmethods() {	$user_contactmethods = array(		'aim' => __('AIM'),		'yim' => __('Yahoo IM'),		'jabber' => __('Jabber / Google Talk')	);	return apply_filters('user_contactmethods',$user_contactmethods);}?>
<?php/** * Revisions administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');wp_enqueue_script('list-revisions');wp_reset_vars(array('revision', 'left', 'right', 'action'));$revision_id = absint($revision);$left        = absint($left);$right       = absint($right);$redirect = 'edit.php';switch ( $action ) :case 'restore' :	if ( !$revision = wp_get_post_revision( $revision_id ) )		break;	if ( !current_user_can( 'edit_post', $revision->post_parent ) )		break;	if ( !$post = get_post( $revision->post_parent ) )		break;	// Revisions disabled and we're not looking at an autosave	if ( ( ! WP_POST_REVISIONS || !post_type_supports($post->post_type, 'revisions') ) && !wp_is_post_autosave( $revision ) ) {		$redirect = 'edit.php?post_type=' . $post->post_type;		break;	}	check_admin_referer( "restore-post_$post->ID|$revision->ID" );	wp_restore_post_revision( $revision->ID );	$redirect = add_query_arg( array( 'message' => 5, 'revision' => $revision->ID ), get_edit_post_link( $post->ID, 'url' ) );	break;case 'diff' :	if ( !$left_revision  = get_post( $left ) )		break;	if ( !$right_revision = get_post( $right ) )		break;	if ( !current_user_can( 'read_post', $left_revision->ID ) || !current_user_can( 'read_post', $right_revision->ID ) )		break;	// If we're comparing a revision to itself, redirect to the 'view' page for that revision or the edit page for that post	if ( $left_revision->ID == $right_revision->ID ) {		$redirect = get_edit_post_link( $left_revision->ID );		include( './js/revisions-js.php' );		break;	}	// Don't allow reverse diffs?	if ( strtotime($right_revision->post_modified_gmt) < strtotime($left_revision->post_modified_gmt) ) {		$redirect = add_query_arg( array( 'left' => $right, 'right' => $left ) );		break;	}	if ( $left_revision->ID == $right_revision->post_parent ) // right is a revision of left		$post =& $left_revision;	elseif ( $left_revision->post_parent == $right_revision->ID ) // left is a revision of right		$post =& $right_revision;	elseif ( $left_revision->post_parent == $right_revision->post_parent ) // both are revisions of common parent		$post = get_post( $left_revision->post_parent );	else		break; // Don't diff two unrelated revisions	if ( ! WP_POST_REVISIONS || !post_type_supports($post->post_type, 'revisions') ) { // Revisions disabled		if (			// we're not looking at an autosave			( !wp_is_post_autosave( $left_revision ) && !wp_is_post_autosave( $right_revision ) )		||			// we're not comparing an autosave to the current post			( $post->ID !== $left_revision->ID && $post->ID !== $right_revision->ID )		) {			$redirect = 'edit.php?post_type=' . $post->post_type;			break;		}	}	if (		// They're the same		$left_revision->ID == $right_revision->ID	||		// Neither is a revision		( !wp_get_post_revision( $left_revision->ID ) && !wp_get_post_revision( $right_revision->ID ) )	)		break;	$post_title = '<a href="' . get_edit_post_link() . '">' . get_the_title() . '</a>';	$h2 = sprintf( __( 'Compare Revisions of &#8220;%1$s&#8221;' ), $post_title );	$title = __( 'Revisions' );	$left  = $left_revision->ID;	$right = $right_revision->ID;	$redirect = false;	break;case 'view' :default :	if ( !$revision = wp_get_post_revision( $revision_id ) )		break;	if ( !$post = get_post( $revision->post_parent ) )		break;	if ( !current_user_can( 'read_post', $revision->ID ) || !current_user_can( 'read_post', $post->ID ) )		break;	// Revisions disabled and we're not looking at an autosave	if ( ( ! WP_POST_REVISIONS || !post_type_supports($post->post_type, 'revisions') ) && !wp_is_post_autosave( $revision ) ) {		$redirect = 'edit.php?post_type=' . $post->post_type;		break;	}	$post_title = '<a href="' . get_edit_post_link() . '">' . get_the_title() . '</a>';	$revision_title = wp_post_revision_title( $revision, false );	$h2 = sprintf( __( 'Revision for &#8220;%1$s&#8221; created on %2$s' ), $post_title, $revision_title );	$title = __( 'Revisions' );	// Sets up the diff radio buttons	$left  = $revision->ID;	$right = $post->ID;	$redirect = false;	break;endswitch;// Empty post_type means either malformed object found, or no valid parent was found.if ( !$redirect && empty($post->post_type) )	$redirect = 'edit.php';if ( !empty($redirect) ) {	wp_redirect( $redirect );	exit;}// This is so that the correct "Edit" menu item is selected.if ( !empty($post->post_type) && 'post' != $post->post_type )	$parent_file = $submenu_file = 'edit.php?post_type=' . $post->post_type;else	$parent_file = $submenu_file = 'edit.php';require_once( './admin-header.php' );?><div class="wrap"><h2 class="long-header"><?php echo $h2; ?></h2><table class="form-table ie-fixed">	<col class="th" /><?php if ( 'diff' == $action ) : ?><tr id="revision">	<th scope="row"></th>	<th scope="col" class="th-full">		<span class="alignleft"><?php printf( __('Older: %s'), wp_post_revision_title( $left_revision ) ); ?></span>		<span class="alignright"><?php printf( __('Newer: %s'), wp_post_revision_title( $right_revision ) ); ?></span>	</th></tr><?php endif;// use get_post_to_edit filters?$identical = true;foreach ( _wp_post_revision_fields() as $field => $field_title ) :	if ( 'diff' == $action ) {		$left_content = apply_filters( "_wp_post_revision_field_$field", $left_revision->$field, $field );		$right_content = apply_filters( "_wp_post_revision_field_$field", $right_revision->$field, $field );		if ( !$content = wp_text_diff( $left_content, $right_content ) )			continue; // There is no difference between left and right		$identical = false;	} else {		add_filter( "_wp_post_revision_field_$field", 'htmlspecialchars' );		$content = apply_filters( "_wp_post_revision_field_$field", $revision->$field, $field );	}	?>	<tr id="revision-field-<?php echo $field; ?>">		<th scope="row"><?php echo esc_html( $field_title ); ?></th>		<td><div class="pre"><?php echo $content; ?></div></td>	</tr>	<?phpendforeach;if ( 'diff' == $action && $identical ) :	?>	<tr><td colspan="2"><div class="updated"><p><?php _e( 'These revisions are identical.' ); ?></p></div></td></tr>	<?phpendif;?></table><br class="clear" /><h2><?php echo $title; ?></h2><?php$args = array( 'format' => 'form-table', 'parent' => true, 'right' => $right, 'left' => $left );if ( ! WP_POST_REVISIONS || !post_type_supports($post->post_type, 'revisions') )	$args['type'] = 'autosave';wp_list_post_revisions( $post, $args );?></div><?phprequire_once( './admin-footer.php' );
<?php/** * The template for displaying Search Results pages. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main"><?php if ( have_posts() ) : ?>				<h1 class="page-title"><?php printf( __( 'Search Results for: %s', 'twentyten' ), '<span>' . get_search_query() . '</span>' ); ?></h1>				<?php				/* Run the loop for the search to output the results.				 * If you want to overload this in a child theme then include a file				 * called loop-search.php and that will be used instead.				 */				 get_template_part( 'loop', 'search' );				?><?php else : ?>				<div id="post-0" class="post no-results not-found">					<h2 class="entry-title"><?php _e( 'Nothing Found', 'twentyten' ); ?></h2>					<div class="entry-content">						<p><?php _e( 'Sorry, but nothing matched your search criteria. Please try again with some different keywords.', 'twentyten' ); ?></p>						<?php get_search_form(); ?>					</div><!-- .entry-content -->				</div><!-- #post-0 --><?php endif; ?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
<?php/** * Redirects to the Comments RSS2 feed * This file is deprecated and only exists for backwards compatibility * * @package WordPress */require( './wp-load.php' );wp_redirect( get_bloginfo( 'comments_rss2_url' ), 301 );?>
<?php/** * WordPress SSH2 Filesystem. * * @package WordPress * @subpackage Filesystem *//** * WordPress Filesystem Class for implementing SSH2. * * To use this class you must follow these steps for PHP 5.2.6+ * * @contrib http://kevin.vanzonneveld.net/techblog/article/make_ssh_connections_with_php/ - Installation Notes * * Complie libssh2 (Note: Only 0.14 is officaly working with PHP 5.2.6+ right now, But many users have found the latest versions work) * * cd /usr/src * wget http://surfnet.dl.sourceforge.net/sourceforge/libssh2/libssh2-0.14.tar.gz * tar -zxvf libssh2-0.14.tar.gz * cd libssh2-0.14/ * ./configure * make all install * * Note: Do not leave the directory yet! * * Enter: pecl install -f ssh2 * * Copy the ssh.so file it creates to your PHP Module Directory. * Open up your PHP.INI file and look for where extensions are placed. * Add in your PHP.ini file: extension=ssh2.so * * Restart Apache! * Check phpinfo() streams to confirm that: ssh2.shell, ssh2.exec, ssh2.tunnel, ssh2.scp, ssh2.sftp  exist. * * Note: as of WordPress 2.8, This utilises the PHP5+ function 'stream_get_contents' * * @since 2.7 * @package WordPress * @subpackage Filesystem * @uses WP_Filesystem_Base Extends class */class WP_Filesystem_SSH2 extends WP_Filesystem_Base {	var $link = false;	var $sftp_link = false;	var $keys = false;	var $errors = array();	var $options = array();	function WP_Filesystem_SSH2($opt='') {		$this->method = 'ssh2';		$this->errors = new WP_Error();		//Check if possible to use ssh2 functions.		if ( ! extension_loaded('ssh2') ) {			$this->errors->add('no_ssh2_ext', __('The ssh2 PHP extension is not available'));			return false;		}		if ( !function_exists('stream_get_contents') ) {			$this->errors->add('ssh2_php_requirement', __('The ssh2 PHP extension is available, however, we require the PHP5 function <code>stream_get_contents()</code>'));			return false;		}		// Set defaults:		if ( empty($opt['port']) )			$this->options['port'] = 22;		else			$this->options['port'] = $opt['port'];		if ( empty($opt['hostname']) )			$this->errors->add('empty_hostname', __('SSH2 hostname is required'));		else			$this->options['hostname'] = $opt['hostname'];		if ( ! empty($opt['base']) )			$this->wp_base = $opt['base'];		// Check if the options provided are OK.		if ( !empty ($opt['public_key']) && !empty ($opt['private_key']) ) {			$this->options['public_key'] = $opt['public_key'];			$this->options['private_key'] = $opt['private_key'];			$this->options['hostkey'] = array('hostkey' => 'ssh-rsa');			$this->keys = true;		} elseif ( empty ($opt['username']) ) {			$this->errors->add('empty_username', __('SSH2 username is required'));		}		if ( !empty($opt['username']) )			$this->options['username'] = $opt['username'];		if ( empty ($opt['password']) ) {			if ( !$this->keys )	//password can be blank if we are using keys				$this->errors->add('empty_password', __('SSH2 password is required'));		} else {			$this->options['password'] = $opt['password'];		}	}	function connect() {		if ( ! $this->keys ) {			$this->link = @ssh2_connect($this->options['hostname'], $this->options['port']);		} else {			$this->link = @ssh2_connect($this->options['hostname'], $this->options['port'], $this->options['hostkey']);		}		if ( ! $this->link ) {			$this->errors->add('connect', sprintf(__('Failed to connect to SSH2 Server %1$s:%2$s'), $this->options['hostname'], $this->options['port']));			return false;		}		if ( !$this->keys ) {			if ( ! @ssh2_auth_password($this->link, $this->options['username'], $this->options['password']) ) {				$this->errors->add('auth', sprintf(__('Username/Password incorrect for %s'), $this->options['username']));				return false;			}		} else {			if ( ! @ssh2_auth_pubkey_file($this->link, $this->options['username'], $this->options['public_key'], $this->options['private_key'], $this->options['password'] ) ) {				$this->errors->add('auth', sprintf(__('Public and Private keys incorrect for %s'), $this->options['username']));				return false;			}		}		$this->sftp_link = ssh2_sftp($this->link);		return true;	}	function run_command( $command, $returnbool = false) {		if ( ! $this->link )			return false;		if ( ! ($stream = ssh2_exec($this->link, $command)) ) {			$this->errors->add('command', sprintf(__('Unable to perform command: %s'), $command));		} else {			stream_set_blocking( $stream, true );			stream_set_timeout( $stream, FS_TIMEOUT );			$data = stream_get_contents( $stream );			fclose( $stream );			if ( $returnbool )				return ( $data === false ) ? false : '' != trim($data);			else				return $data;		}		return false;	}	function get_contents($file, $type = '', $resumepos = 0 ) {		$file = ltrim($file, '/');		return file_get_contents('ssh2.sftp://' . $this->sftp_link . '/' . $file);	}	function get_contents_array($file) {		$file = ltrim($file, '/');		return file('ssh2.sftp://' . $this->sftp_link . '/' . $file);	}	function put_contents($file, $contents, $mode = false ) {		$file = ltrim($file, '/');		$ret = file_put_contents('ssh2.sftp://' . $this->sftp_link . '/' . $file, $contents);		$this->chmod($file, $mode);		return false !== $ret;	}	function cwd() {		$cwd = $this->run_command('pwd');		if ( $cwd )			$cwd = trailingslashit($cwd);		return $cwd;	}	function chdir($dir) {		return $this->run_command('cd ' . $dir, true);	}	function chgrp($file, $group, $recursive = false ) {		if ( ! $this->exists($file) )			return false;		if ( ! $recursive || ! $this->is_dir($file) )			return $this->run_command(sprintf('chgrp %o %s', $mode, escapeshellarg($file)), true);		return $this->run_command(sprintf('chgrp -R %o %s', $mode, escapeshellarg($file)), true);	}	function chmod($file, $mode = false, $recursive = false) {		if ( ! $this->exists($file) )			return false;		if ( ! $mode ) {			if ( $this->is_file($file) )				$mode = FS_CHMOD_FILE;			elseif ( $this->is_dir($file) )				$mode = FS_CHMOD_DIR;			else				return false;		}		if ( ! $recursive || ! $this->is_dir($file) )			return $this->run_command(sprintf('chmod %o %s', $mode, escapeshellarg($file)), true);		return $this->run_command(sprintf('chmod -R %o %s', $mode, escapeshellarg($file)), true);	}	function chown($file, $owner, $recursive = false ) {		if ( ! $this->exists($file) )			return false;		if ( ! $recursive || ! $this->is_dir($file) )			return $this->run_command(sprintf('chown %o %s', $mode, escapeshellarg($file)), true);		return $this->run_command(sprintf('chown -R %o %s', $mode, escapeshellarg($file)), true);	}	function owner($file) {		$owneruid = @fileowner('ssh2.sftp://' . $this->sftp_link . '/' . ltrim($file, '/'));		if ( ! $owneruid )			return false;		if ( ! function_exists('posix_getpwuid') )			return $owneruid;		$ownerarray = posix_getpwuid($owneruid);		return $ownerarray['name'];	}	function getchmod($file) {		return substr(decoct(@fileperms( 'ssh2.sftp://' . $this->sftp_link . '/' . ltrim($file, '/') )),3);	}	function group($file) {		$gid = @filegroup('ssh2.sftp://' . $this->sftp_link . '/' . ltrim($file, '/'));		if ( ! $gid )			return false;		if ( ! function_exists('posix_getgrgid') )			return $gid;		$grouparray = posix_getgrgid($gid);		return $grouparray['name'];	}	function copy($source, $destination, $overwrite = false ) {		if ( ! $overwrite && $this->exists($destination) )			return false;		$content = $this->get_contents($source);		if ( false === $content)			return false;		return $this->put_contents($destination, $content);	}	function move($source, $destination, $overwrite = false) {		return @ssh2_sftp_rename($this->link, $source, $destination);	}	function delete($file, $recursive = false) {		if ( $this->is_file($file) )			return ssh2_sftp_unlink($this->sftp_link, $file);		if ( ! $recursive )			 return ssh2_sftp_rmdir($this->sftp_link, $file);		$filelist = $this->dirlist($file);		if ( is_array($filelist) ) {			foreach ( $filelist as $filename => $fileinfo) {				$this->delete($file . '/' . $filename, $recursive);			}		}		return ssh2_sftp_rmdir($this->sftp_link, $file);	}	function exists($file) {		$file = ltrim($file, '/');		return file_exists('ssh2.sftp://' . $this->sftp_link . '/' . $file);	}	function is_file($file) {		$file = ltrim($file, '/');		return is_file('ssh2.sftp://' . $this->sftp_link . '/' . $file);	}	function is_dir($path) {		$path = ltrim($path, '/');		return is_dir('ssh2.sftp://' . $this->sftp_link . '/' . $path);	}	function is_readable($file) {		$file = ltrim($file, '/');		return is_readable('ssh2.sftp://' . $this->sftp_link . '/' . $file);	}	function is_writable($file) {		$file = ltrim($file, '/');		return is_writable('ssh2.sftp://' . $this->sftp_link . '/' . $file);	}	function atime($file) {		$file = ltrim($file, '/');		return fileatime('ssh2.sftp://' . $this->sftp_link . '/' . $file);	}	function mtime($file) {		$file = ltrim($file, '/');		return filemtime('ssh2.sftp://' . $this->sftp_link . '/' . $file);	}	function size($file) {		$file = ltrim($file, '/');		return filesize('ssh2.sftp://' . $this->sftp_link . '/' . $file);	}	function touch($file, $time = 0, $atime = 0) {		//Not implmented.	}	function mkdir($path, $chmod = false, $chown = false, $chgrp = false) {		$path = untrailingslashit($path);		if ( ! $chmod )			$chmod = FS_CHMOD_DIR;		if ( ! ssh2_sftp_mkdir($this->sftp_link, $path, $chmod, true) )			return false;		if ( $chown )			$this->chown($path, $chown);		if ( $chgrp )			$this->chgrp($path, $chgrp);		return true;	}	function rmdir($path, $recursive = false) {		return $this->delete($path, $recursive);	}	function dirlist($path, $include_hidden = true, $recursive = false) {		if ( $this->is_file($path) ) {			$limit_file = basename($path);			$path = dirname($path);		} else {			$limit_file = false;		}		if ( ! $this->is_dir($path) )			return false;		$ret = array();		$dir = @dir('ssh2.sftp://' . $this->sftp_link .'/' . ltrim($path, '/') );		if ( ! $dir )			return false;		while (false !== ($entry = $dir->read()) ) {			$struc = array();			$struc['name'] = $entry;			if ( '.' == $struc['name'] || '..' == $struc['name'] )				continue; //Do not care about these folders.			if ( ! $include_hidden && '.' == $struc['name'][0] )				continue;			if ( $limit_file && $struc['name'] != $limit_file )				continue;			$struc['perms'] 	= $this->gethchmod($path.'/'.$entry);			$struc['permsn']	= $this->getnumchmodfromh($struc['perms']);			$struc['number'] 	= false;			$struc['owner']    	= $this->owner($path.'/'.$entry);			$struc['group']    	= $this->group($path.'/'.$entry);			$struc['size']    	= $this->size($path.'/'.$entry);			$struc['lastmodunix']= $this->mtime($path.'/'.$entry);			$struc['lastmod']   = date('M j',$struc['lastmodunix']);			$struc['time']    	= date('h:i:s',$struc['lastmodunix']);			$struc['type']		= $this->is_dir($path.'/'.$entry) ? 'd' : 'f';			if ( 'd' == $struc['type'] ) {				if ( $recursive )					$struc['files'] = $this->dirlist($path . '/' . $struc['name'], $include_hidden, $recursive);				else					$struc['files'] = array();			}			$ret[ $struc['name'] ] = $struc;		}		$dir->close();		unset($dir);		return $ret;	}}
<?php/** * Defines constants and global variables that can be overridden, generally in wp-config.php. * * @package WordPress * @subpackage Multisite * @since 3.0.0 *//** * Defines Multisite upload constants. * * @since 3.0.0 */function ms_upload_constants(  ) {	global $wpdb;	/** @since 3.0.0 */	// Base uploads dir relative to ABSPATH	if ( !defined( 'UPLOADBLOGSDIR' ) )		define( 'UPLOADBLOGSDIR', 'wp-content/blogs.dir' );	/** @since 3.0.0 */	if ( !defined( 'UPLOADS' ) ) {		// Uploads dir relative to ABSPATH		define( 'UPLOADS', UPLOADBLOGSDIR . "/{$wpdb->blogid}/files/" );		if ( 'wp-content/blogs.dir' == UPLOADBLOGSDIR )			define( 'BLOGUPLOADDIR', WP_CONTENT_DIR . "/blogs.dir/{$wpdb->blogid}/files/" );	}}/** * Defines Multisite cookie constants. * * @since 3.0.0 */function ms_cookie_constants(  ) {	global $current_site;	/**	 * @since 1.2.0	 */	if ( !defined( 'COOKIEPATH' ) )		define( 'COOKIEPATH', $current_site->path );	/**	 * @since 1.5.0	 */	if ( !defined( 'SITECOOKIEPATH' ) )		define( 'SITECOOKIEPATH', $current_site->path );	/**	 * @since 2.6.0	 */	if ( !defined( 'ADMIN_COOKIE_PATH' ) ) {		if( !is_subdomain_install() ) {			define( 'ADMIN_COOKIE_PATH', SITECOOKIEPATH );		} else {			define( 'ADMIN_COOKIE_PATH', SITECOOKIEPATH . 'wp-admin' );		}	}	/**	 * @since 2.0.0	 */	if ( !defined('COOKIE_DOMAIN') && is_subdomain_install() ) {		if ( !empty( $current_site->cookie_domain ) )			define('COOKIE_DOMAIN', '.' . $current_site->cookie_domain);		else			define('COOKIE_DOMAIN', '.' . $current_site->domain);	}}/** * Defines Multisite file constants. * * @since 3.0.0 */function ms_file_constants(  ) {	/**	 * Optional support for X-Sendfile header	 * @since 3.0.0	 */	if ( !defined( 'WPMU_SENDFILE' ) )		define( 'WPMU_SENDFILE', false );	/**	 * Optional support for X-Accel-Redirect header	 * @since 3.0.0	 */	if ( !defined( 'WPMU_ACCEL_REDIRECT' ) )		define( 'WPMU_ACCEL_REDIRECT', false );}/** * Defines Multisite subdomain constants and handles warnings and notices. * * VHOST is deprecated in favor of SUBDOMAIN_INSTALL, which is a bool. * * On first call, the constants are checked and defined. On second call, * we will have translations loaded and can trigger warnings easily. * * @since 3.0.0 */function ms_subdomain_constants() {	static $error = null;	static $error_warn = false;	if ( false === $error )		return;	if ( $error ) {		$vhost_deprecated = __( 'The constant <code>VHOST</code> <strong>is deprecated</strong>. Use the boolean constant <code>SUBDOMAIN_INSTALL</code> in wp-config.php to enable a subdomain configuration. Use is_subdomain_install() to check whether a subdomain configuration is enabled.' );		if ( $error_warn ) {			trigger_error( __( '<strong>Conflicting values for the constants VHOST and SUBDOMAIN_INSTALL.</strong> The value of SUBDOMAIN_INSTALL will be assumed to be your subdomain configuration setting.' ) . ' ' . $vhost_deprecated, E_USER_WARNING );		} else {	 		_deprecated_argument( 'define()', '3.0', $vhost_deprecated );		}		return;	}	if ( defined( 'SUBDOMAIN_INSTALL' ) && defined( 'VHOST' ) ) {		if ( SUBDOMAIN_INSTALL == ( 'yes' == VHOST ) ) {			$error = true;		} else {			$error = $error_warn = true;		}	} elseif ( defined( 'SUBDOMAIN_INSTALL' ) ) {		define( 'VHOST', SUBDOMAIN_INSTALL ? 'yes' : 'no' );	} elseif ( defined( 'VHOST' ) ) {		$error = true;		define( 'SUBDOMAIN_INSTALL', 'yes' == VHOST );	} else {		define( 'SUBDOMAIN_INSTALL', false );		define( 'VHOST', 'no' );	}}add_action( 'init', 'ms_subdomain_constants' );?>
<?php/** * Outputs the OPML XML format for getting the links defined in the link * administration. This can be used to export links from one blog over to * another. Links aren't exported by the WordPress export, so this file handles * that. * * This file is not added by default to WordPress theme pages when outputting * feed links. It will have to be added manually for browsers and users to pick * up that this file exists. * * @package WordPress */if ( empty($wp) ) {	require_once('./wp-load.php');	wp();}header('Content-Type: text/xml; charset=' . get_option('blog_charset'), true);$link_cat = '';if ( !empty($_GET['link_cat']) ) {	$link_cat = $_GET['link_cat'];	if ( !in_array($link_cat, array('all', '0')) )		$link_cat = absint( (string)urldecode($link_cat) );}echo '<?xml version="1.0"?'.">\n";?><opml version="1.0">	<head>		<title><?php printf( __('Links for %s'), esc_attr(get_bloginfo('name', 'display')) ); ?></title>		<dateCreated><?php echo gmdate("D, d M Y H:i:s"); ?> GMT</dateCreated>		<?php do_action('opml_head'); ?>	</head>	<body><?phpif ( empty($link_cat) )	$cats = get_categories(array('type' => 'link', 'hierarchical' => 0));else	$cats = get_categories(array('type' => 'link', 'hierarchical' => 0, 'include' => $link_cat));foreach ( (array)$cats as $cat ) :	$catname = apply_filters('link_category', $cat->name);?><outline type="category" title="<?php echo esc_attr($catname); ?>"><?php	$bookmarks = get_bookmarks(array("category" => $cat->term_id));	foreach ( (array)$bookmarks as $bookmark ) :		$title = apply_filters('link_title', $bookmark->link_name);?>	<outline text="<?php echo esc_attr($title); ?>" type="link" xmlUrl="<?php echo esc_attr($bookmark->link_rss); ?>" htmlUrl="<?php echo esc_attr($bookmark->link_url); ?>" updated="<?php if ('0000-00-00 00:00:00' != $bookmark->link_updated) echo $bookmark->link_updated; ?>" /><?php	endforeach; // $bookmarks?></outline><?phpendforeach; // $cats?></body></opml>
<?php/** * Simple and uniform HTTP request API. * * Will eventually replace and standardize the WordPress HTTP requests made. * * @link http://trac.wordpress.org/ticket/4779 HTTP API Proposal * * @package WordPress * @subpackage HTTP * @since 2.7.0 *//** * Returns the initialized WP_Http Object * * @since 2.7.0 * @access private * * @return WP_Http HTTP Transport object. */function &_wp_http_get_object() {	static $http;	if ( is_null($http) )		$http = new WP_Http();	return $http;}/** * Retrieve the raw response from the HTTP request. * * The array structure is a little complex. * * <code> * $res = array( 'headers' => array(), 'response' => array('code' => int, 'message' => string) ); * </code> * * All of the headers in $res['headers'] are with the name as the key and the * value as the value. So to get the User-Agent, you would do the following. * * <code> * $user_agent = $res['headers']['user-agent']; * </code> * * The body is the raw response content and can be retrieved from $res['body']. * * This function is called first to make the request and there are other API * functions to abstract out the above convoluted setup. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_request($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->request($url, $args);}/** * Retrieve the raw response from the HTTP request using the GET method. * * @see wp_remote_request() For more information on the response array format. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_get($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->get($url, $args);}/** * Retrieve the raw response from the HTTP request using the POST method. * * @see wp_remote_request() For more information on the response array format. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_post($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->post($url, $args);}/** * Retrieve the raw response from the HTTP request using the HEAD method. * * @see wp_remote_request() For more information on the response array format. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_head($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->head($url, $args);}/** * Retrieve only the headers from the raw response. * * @since 2.7.0 * * @param array $response HTTP response. * @return array The headers of the response. Empty array if incorrect parameter given. */function wp_remote_retrieve_headers(&$response) {	if ( is_wp_error($response) || ! isset($response['headers']) || ! is_array($response['headers']))		return array();	return $response['headers'];}/** * Retrieve a single header by name from the raw response. * * @since 2.7.0 * * @param array $response * @param string $header Header name to retrieve value from. * @return string The header value. Empty string on if incorrect parameter given, or if the header doesnt exist. */function wp_remote_retrieve_header(&$response, $header) {	if ( is_wp_error($response) || ! isset($response['headers']) || ! is_array($response['headers']))		return '';	if ( array_key_exists($header, $response['headers']) )		return $response['headers'][$header];	return '';}/** * Retrieve only the response code from the raw response. * * Will return an empty array if incorrect parameter value is given. * * @since 2.7.0 * * @param array $response HTTP response. * @return string the response code. Empty string on incorrect parameter given. */function wp_remote_retrieve_response_code(&$response) {	if ( is_wp_error($response) || ! isset($response['response']) || ! is_array($response['response']))		return '';	return $response['response']['code'];}/** * Retrieve only the response message from the raw response. * * Will return an empty array if incorrect parameter value is given. * * @since 2.7.0 * * @param array $response HTTP response. * @return string The response message. Empty string on incorrect parameter given. */function wp_remote_retrieve_response_message(&$response) {	if ( is_wp_error($response) || ! isset($response['response']) || ! is_array($response['response']))		return '';	return $response['response']['message'];}/** * Retrieve only the body from the raw response. * * @since 2.7.0 * * @param array $response HTTP response. * @return string The body of the response. Empty string if no body or incorrect parameter given. */function wp_remote_retrieve_body(&$response) {	if ( is_wp_error($response) || ! isset($response['body']) )		return '';	return $response['body'];}?>
<?php/** * Add Link Administration Panel. * * @package WordPress * @subpackage Administration *//** Load WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can('manage_links') )	wp_die(__('You do not have sufficient permissions to add links to this site.'));$title = __('Add New Link');$parent_file = 'link-manager.php';wp_reset_vars(array('action', 'cat_id', 'linkurl', 'name', 'image',	'description', 'visible', 'target', 'category', 'link_id',	'submit', 'order_by', 'links_show_cat_id', 'rating', 'rel',	'notes', 'linkcheck[]'));wp_enqueue_script('link');wp_enqueue_script('xfn');$link = get_default_link_to_edit();include('./edit-link-form.php');require('./admin-footer.php');?>
<?php/** * Bookmark Template Functions for usage in Themes * * @package WordPress * @subpackage Template *//** * The formatted output of a list of bookmarks. * * The $bookmarks array must contain bookmark objects and will be iterated over * to retrieve the bookmark to be used in the output. * * The output is formatted as HTML with no way to change that format. However, * what is between, before, and after can be changed. The link itself will be * HTML. * * This function is used internally by wp_list_bookmarks() and should not be * used by themes. * * The defaults for overwriting are: * 'show_updated' - Default is 0 (integer). Will show the time of when the *		bookmark was last updated. * 'show_description' - Default is 0 (integer). Whether to show the description *		of the bookmark. * 'show_images' - Default is 1 (integer). Whether to show link image if *		available. * 'show_name' - Default is 0 (integer). Whether to show link name if *		available. * 'before' - Default is '<li>' (string). The html or text to prepend to each *		bookmarks. * 'after' - Default is '</li>' (string). The html or text to append to each *		bookmarks. * 'link_before' - Default is '' (string). The html or text to prepend to each *		bookmarks inside the <a> tag. * 'link_after' - Default is '' (string). The html or text to append to each *		bookmarks inside the <a> tag. * 'between' - Default is '\n' (string). The string for use in between the link, *		description, and image. * 'show_rating' - Default is 0 (integer). Whether to show the link rating. * * @since 2.1.0 * @access private * @usedby wp_list_bookmarks() * * @param array $bookmarks List of bookmarks to traverse * @param string|array $args Optional. Overwrite the defaults. * @return string Formatted output in HTML */function _walk_bookmarks($bookmarks, $args = '' ) {	$defaults = array(		'show_updated' => 0, 'show_description' => 0,		'show_images' => 1, 'show_name' => 0,		'before' => '<li>', 'after' => '</li>', 'between' => "\n",		'show_rating' => 0, 'link_before' => '', 'link_after' => ''	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	$output = ''; // Blank string to start with.	foreach ( (array) $bookmarks as $bookmark ) {		if ( !isset($bookmark->recently_updated) )			$bookmark->recently_updated = false;		$output .= $before;		if ( $show_updated && $bookmark->recently_updated )			$output .= get_option('links_recently_updated_prepend');		$the_link = '#';		if ( !empty($bookmark->link_url) )			$the_link = esc_url($bookmark->link_url);		$desc = esc_attr(sanitize_bookmark_field('link_description', $bookmark->link_description, $bookmark->link_id, 'display'));		$name = esc_attr(sanitize_bookmark_field('link_name', $bookmark->link_name, $bookmark->link_id, 'display')); 		$title = $desc;		if ( $show_updated )			if ( '00' != substr($bookmark->link_updated_f, 0, 2) ) {				$title .= ' (';				$title .= sprintf(__('Last updated: %s'), date(get_option('links_updated_date_format'), $bookmark->link_updated_f + (get_option('gmt_offset') * 3600)));				$title .= ')';			}		$alt = ' alt="' . $name . ( $show_description ? ' ' . $title : '' ) . '"';		if ( '' != $title )			$title = ' title="' . $title . '"';		$rel = $bookmark->link_rel;		if ( '' != $rel )			$rel = ' rel="' . esc_attr($rel) . '"';		$target = $bookmark->link_target;		if ( '' != $target )			$target = ' target="' . $target . '"';		$output .= '<a href="' . $the_link . '"' . $rel . $title . $target . '>';		$output .= $link_before;		if ( $bookmark->link_image != null && $show_images ) {			if ( strpos($bookmark->link_image, 'http') === 0 )				$output .= "<img src=\"$bookmark->link_image\" $alt $title />";			else // If it's a relative path				$output .= "<img src=\"" . get_option('siteurl') . "$bookmark->link_image\" $alt $title />";			if ( $show_name )				$output .= " $name";		} else {			$output .= $name;		}		$output .= $link_after;		$output .= '</a>';		if ( $show_updated && $bookmark->recently_updated )			$output .= get_option('links_recently_updated_append');		if ( $show_description && '' != $desc )			$output .= $between . $desc;		if ( $show_rating )			$output .= $between . sanitize_bookmark_field('link_rating', $bookmark->link_rating, $bookmark->link_id, 'display');		$output .= "$after\n";	} // end while	return $output;}/** * Retrieve or echo all of the bookmarks. * * List of default arguments are as follows: * 'orderby' - Default is 'name' (string). How to order the links by. String is *		based off of the bookmark scheme. * 'order' - Default is 'ASC' (string). Either 'ASC' or 'DESC'. Orders in either *		ascending or descending order. * 'limit' - Default is -1 (integer) or show all. The amount of bookmarks to *		display. * 'category' - Default is empty string (string). Include the links in what *		category ID(s). * 'category_name' - Default is empty string (string). Get links by category *		name. * 'hide_invisible' - Default is 1 (integer). Whether to show (default) or hide *		links marked as 'invisible'. * 'show_updated' - Default is 0 (integer). Will show the time of when the *		bookmark was last updated. * 'echo' - Default is 1 (integer). Whether to echo (default) or return the *		formatted bookmarks. * 'categorize' - Default is 1 (integer). Whether to show links listed by *		category (default) or show links in one column. * 'show_description' - Default is 0 (integer). Whether to show the description *		of the bookmark. * * These options define how the Category name will appear before the category * links are displayed, if 'categorize' is 1. If 'categorize' is 0, then it will * display for only the 'title_li' string and only if 'title_li' is not empty. * 'title_li' - Default is 'Bookmarks' (translatable string). What to show *		before the links appear. * 'title_before' - Default is '<h2>' (string). The HTML or text to show before *		the 'title_li' string. * 'title_after' - Default is '</h2>' (string). The HTML or text to show after *		the 'title_li' string. * 'class' - Default is 'linkcat' (string). The CSS class to use for the *		'title_li'. * * 'category_before' - Default is '<li id="%id" class="%class">'. String must *		contain '%id' and '%class' to get * the id of the category and the 'class' argument. These are used for *		formatting in themes. * Argument will be displayed before the 'title_before' argument. * 'category_after' - Default is '</li>' (string). The HTML or text that will *		appear after the list of links. * * These are only used if 'categorize' is set to 1 or true. * 'category_orderby' - Default is 'name'. How to order the bookmark category *		based on term scheme. * 'category_order' - Default is 'ASC'. Set the order by either ASC (ascending) *		or DESC (descending). * * @see _walk_bookmarks() For other arguments that can be set in this function *		and passed to _walk_bookmarks(). * @see get_bookmarks() For other arguments that can be set in this function and *		passed to get_bookmarks(). * @link http://codex.wordpress.org/Template_Tags/wp_list_bookmarks * * @since 2.1.0 * @uses _list_bookmarks() Used to iterate over all of the bookmarks and return *		the html * @uses get_terms() Gets all of the categories that are for links. * * @param string|array $args Optional. Overwrite the defaults of the function * @return string|null Will only return if echo option is set to not echo. *		Default is not return anything. */function wp_list_bookmarks($args = '') {	$defaults = array(		'orderby' => 'name', 'order' => 'ASC',		'limit' => -1, 'category' => '', 'exclude_category' => '',		'category_name' => '', 'hide_invisible' => 1,		'show_updated' => 0, 'echo' => 1,		'categorize' => 1, 'title_li' => __('Bookmarks'),		'title_before' => '<h2>', 'title_after' => '</h2>',		'category_orderby' => 'name', 'category_order' => 'ASC',		'class' => 'linkcat', 'category_before' => '<li id="%id" class="%class">',		'category_after' => '</li>'	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	$output = '';	if ( $categorize ) {		//Split the bookmarks into ul's for each category		$cats = get_terms('link_category', array('name__like' => $category_name, 'include' => $category, 'exclude' => $exclude_category, 'orderby' => $category_orderby, 'order' => $category_order, 'hierarchical' => 0));		foreach ( (array) $cats as $cat ) {			$params = array_merge($r, array('category'=>$cat->term_id));			$bookmarks = get_bookmarks($params);			if ( empty($bookmarks) )				continue;			$output .= str_replace(array('%id', '%class'), array("linkcat-$cat->term_id", $class), $category_before);			$catname = apply_filters( "link_category", $cat->name );			$output .= "$title_before$catname$title_after\n\t<ul class='xoxo blogroll'>\n";			$output .= _walk_bookmarks($bookmarks, $r);			$output .= "\n\t</ul>\n$category_after\n";		}	} else {		//output one single list using title_li for the title		$bookmarks = get_bookmarks($r);		if ( !empty($bookmarks) ) {			if ( !empty( $title_li ) ){				$output .= str_replace(array('%id', '%class'), array("linkcat-$category", $class), $category_before);				$output .= "$title_before$title_li$title_after\n\t<ul class='xoxo blogroll'>\n";				$output .= _walk_bookmarks($bookmarks, $r);				$output .= "\n\t</ul>\n$category_after\n";			} else {				$output .= _walk_bookmarks($bookmarks, $r);			}		}	}	$output = apply_filters( 'wp_list_bookmarks', $output );	if ( !$echo )		return $output;	echo $output;}?>
<?php/** * Author Template functions for use in themes. * * These functions must be used within the WordPress Loop. * * @link http://codex.wordpress.org/Author_Templates * * @package WordPress * @subpackage Template *//** * Retrieve the author of the current post. * * @since 1.5 * @uses $authordata The current author's DB object. * @uses apply_filters() Calls 'the_author' hook on the author display name. * * @param string $deprecated Deprecated. * @return string The author's display name. */function get_the_author($deprecated = '') {	global $authordata;	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.1' );	return apply_filters('the_author', is_object($authordata) ? $authordata->display_name : null);}/** * Display the name of the author of the current post. * * The behavior of this function is based off of old functionality predating * get_the_author(). This function is not deprecated, but is designed to echo * the value from get_the_author() and as an result of any old theme that might * still use the old behavior will also pass the value from get_the_author(). * * The normal, expected behavior of this function is to echo the author and not * return it. However, backwards compatiability has to be maintained. * * @since 0.71 * @see get_the_author() * @link http://codex.wordpress.org/Template_Tags/the_author * * @param string $deprecated Deprecated. * @param string $deprecated_echo Deprecated. Use get_the_author(). Echo the string or return it. * @return string The author's display name, from get_the_author(). */function the_author( $deprecated = '', $deprecated_echo = true ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.1' );	if ( $deprecated_echo !== true )		_deprecated_argument( __FUNCTION__, '1.5', __('Use <code>get_the_author()</code> instead if you do not want the value echoed.') );	if ( $deprecated_echo )		echo get_the_author();	return get_the_author();}/** * Retrieve the author who last edited the current post. * * @since 2.8 * @uses $post The current post's DB object. * @uses get_post_meta() Retrieves the ID of the author who last edited the current post. * @uses get_userdata() Retrieves the author's DB object. * @uses apply_filters() Calls 'the_modified_author' hook on the author display name. * @return string The author's display name. */function get_the_modified_author() {	global $post;	if ( $last_id = get_post_meta($post->ID, '_edit_last', true) ) {		$last_user = get_userdata($last_id);		return apply_filters('the_modified_author', $last_user->display_name);	}}/** * Display the name of the author who last edited the current post. * * @since 2.8 * @see get_the_author() * @return string The author's display name, from get_the_modified_author(). */function the_modified_author() {	echo get_the_modified_author();}/** * Retrieve the requested data of the author of the current post. * @link http://codex.wordpress.org/Template_Tags/the_author_meta * @since 2.8.0 * @uses $authordata The current author's DB object (if $user_id not specified). * @param string $field selects the field of the users record. * @param int $user_id Optional. User ID. * @return string The author's field from the current author's DB object. */function get_the_author_meta($field = '', $user_id = false) {	if ( ! $user_id )		global $authordata;	else		$authordata = get_userdata( $user_id );	$field = strtolower($field);	$user_field = "user_$field";	if ( 'id' == $field )		$value = isset($authordata->ID) ? (int)$authordata->ID : 0;	elseif ( isset($authordata->$user_field) )		$value = $authordata->$user_field;	else		$value = isset($authordata->$field) ? $authordata->$field : '';	return apply_filters('get_the_author_' . $field, $value, $user_id);}/** * Retrieve the requested data of the author of the current post. * @link http://codex.wordpress.org/Template_Tags/the_author_meta * @since 2.8.0 * @param string $field selects the field of the users record. * @param int $user_id Optional. User ID. * @echo string The author's field from the current author's DB object. */function the_author_meta($field = '', $user_id = false) {	echo apply_filters('the_author_' . $field, get_the_author_meta($field, $user_id), $user_id);}/** * Retrieve either author's link or author's name. * * If the author has a home page set, return an HTML link, otherwise just return the * author's name. * * @uses get_the_author_meta() * @uses get_the_author() */function get_the_author_link() {	if ( get_the_author_meta('url') ) {		return '<a href="' . get_the_author_meta('url') . '" title="' . esc_attr( sprintf(__("Visit %s&#8217;s website"), get_the_author()) ) . '" rel="external">' . get_the_author() . '</a>';	} else {		return get_the_author();	}}/** * Display either author's link or author's name. * * If the author has a home page set, echo an HTML link, otherwise just echo the * author's name. * * @link http://codex.wordpress.org/Template_Tags/the_author_link * @since 2.1 * @uses get_the_author_link() */function the_author_link() {	echo get_the_author_link();}/** * Retrieve the number of posts by the author of the current post. * * @since 1.5 * @uses $post The current post in the Loop's DB object. * @uses count_user_posts() * @return int The number of posts by the author. */function get_the_author_posts() {	global $post;	return count_user_posts($post->post_author);}/** * Display the number of posts by the author of the current post. * * @link http://codex.wordpress.org/Template_Tags/the_author_posts * @since 0.71 * @uses get_the_author_posts() Echoes returned value from function. */function the_author_posts() {	echo get_the_author_posts();}/** * Display an HTML link to the author page of the author of the current post. * * Does just echo get_author_posts_url() function, like the others do. The * reason for this, is that another function is used to help in printing the * link to the author's posts. * * @link http://codex.wordpress.org/Template_Tags/the_author_posts_link * @since 1.2.0 * @uses $authordata The current author's DB object. * @uses get_author_posts_url() * @uses get_the_author() * @param string $deprecated Deprecated. */function the_author_posts_link($deprecated = '') {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.1' );	global $authordata;	$link = sprintf(		'<a href="%1$s" title="%2$s">%3$s</a>',		get_author_posts_url( $authordata->ID, $authordata->user_nicename ),		esc_attr( sprintf( __( 'Posts by %s' ), get_the_author() ) ),		get_the_author()	);	echo apply_filters( 'the_author_posts_link', $link );}/** * Retrieve the URL to the author page of the author of the current post. * * @since 2.1.0 * @uses $wp_rewrite WP_Rewrite * @return string The URL to the author's page. */function get_author_posts_url($author_id, $author_nicename = '') {	global $wp_rewrite;	$auth_ID = (int) $author_id;	$link = $wp_rewrite->get_author_permastruct();	if ( empty($link) ) {		$file = home_url() . '/';		$link = $file . '?author=' . $auth_ID;	} else {		if ( '' == $author_nicename ) {			$user = get_userdata($author_id);			if ( !empty($user->user_nicename) )				$author_nicename = $user->user_nicename;		}		$link = str_replace('%author%', $author_nicename, $link);		$link = home_url() . trailingslashit($link);	}	$link = apply_filters('author_link', $link, $author_id, $author_nicename);	return $link;}/** * List all the authors of the blog, with several options available. * * <ul> * <li>optioncount (boolean) (false): Show the count in parenthesis next to the * author's name.</li> * <li>exclude_admin (boolean) (true): Exclude the 'admin' user that is * installed bydefault.</li> * <li>show_fullname (boolean) (false): Show their full names.</li> * <li>hide_empty (boolean) (true): Don't show authors without any posts.</li> * <li>feed (string) (''): If isn't empty, show links to author's feeds.</li> * <li>feed_image (string) (''): If isn't empty, use this image to link to * feeds.</li> * <li>echo (boolean) (true): Set to false to return the output, instead of * echoing.</li> * <li>style (string) ('list'): Whether to display list of authors in list form * or as a string.</li> * <li>html (bool) (true): Whether to list the items in html for or plaintext. * </li> * </ul> * * @link http://codex.wordpress.org/Template_Tags/wp_list_authors * @since 1.2.0 * @param array $args The argument array. * @return null|string The output, if echo is set to false. */function wp_list_authors($args = '') {	global $wpdb;	$defaults = array(		'optioncount' => false, 'exclude_admin' => true,		'show_fullname' => false, 'hide_empty' => true,		'feed' => '', 'feed_image' => '', 'feed_type' => '', 'echo' => true,		'style' => 'list', 'html' => true	);	$r = wp_parse_args( $args, $defaults );	extract($r, EXTR_SKIP);	$return = '';	/** @todo Move select to get_authors(). */	$users = get_users_of_blog();	$author_ids = array();	foreach ( (array) $users as $user )		$author_ids[] = $user->user_id;	if ( count($author_ids) > 0  ) {		$author_ids = implode(',', $author_ids );		$authors = $wpdb->get_results( "SELECT ID, user_nicename from $wpdb->users WHERE ID IN($author_ids) " . ($exclude_admin ? "AND user_login <> 'admin' " : '') . "ORDER BY display_name" );	} else {		$authors = array();	}	$author_count = array();	foreach ( (array) $wpdb->get_results("SELECT DISTINCT post_author, COUNT(ID) AS count FROM $wpdb->posts WHERE post_type = 'post' AND " . get_private_posts_cap_sql( 'post' ) . " GROUP BY post_author") as $row )		$author_count[$row->post_author] = $row->count;	foreach ( (array) $authors as $author ) {		$link = '';		$author = get_userdata( $author->ID );		$posts = (isset($author_count[$author->ID])) ? $author_count[$author->ID] : 0;		$name = $author->display_name;		if ( $show_fullname && ($author->first_name != '' && $author->last_name != '') )			$name = "$author->first_name $author->last_name";		if( !$html ) {			if ( $posts == 0 ) {				if ( ! $hide_empty )					$return .= $name . ', ';			} else				$return .= $name . ', ';			// No need to go further to process HTML.			continue;		}		if ( !($posts == 0 && $hide_empty) && 'list' == $style )			$return .= '<li>';		if ( $posts == 0 ) {			if ( ! $hide_empty )				$link = $name;		} else {			$link = '<a href="' . get_author_posts_url($author->ID, $author->user_nicename) . '" title="' . esc_attr( sprintf(__("Posts by %s"), $author->display_name) ) . '">' . $name . '</a>';			if ( (! empty($feed_image)) || (! empty($feed)) ) {				$link .= ' ';				if (empty($feed_image))					$link .= '(';				$link .= '<a href="' . get_author_feed_link($author->ID) . '"';				if ( !empty($feed) ) {					$title = ' title="' . esc_attr($feed) . '"';					$alt = ' alt="' . esc_attr($feed) . '"';					$name = $feed;					$link .= $title;				}				$link .= '>';				if ( !empty($feed_image) )					$link .= "<img src=\"" . esc_url($feed_image) . "\" style=\"border: none;\"$alt$title" . ' />';				else					$link .= $name;				$link .= '</a>';				if ( empty($feed_image) )					$link .= ')';			}			if ( $optioncount )				$link .= ' ('. $posts . ')';		}		if ( $posts || ! $hide_empty )			$return .= $link . ( ( 'list' == $style ) ? '</li>' : ', ' );	}	$return = trim($return, ', ');	if ( ! $echo )		return $return;	echo $return;}?>
<?php/** * My Sites dashboard. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */require_once( './admin.php' );if ( !is_multisite() )	wp_die( __( 'Multisite support is not enabled.' ) );if ( ! current_user_can('read') )	wp_die( __( 'You do not have sufficient permissions to view this page.' ) );$action = isset( $_POST['action'] ) ? $_POST['action'] : 'splash';$blogs = get_blogs_of_user( $current_user->id );if ( empty( $blogs ) )	wp_die( __( 'You must be a member of at least one site to use this page.' ) );$updated = false;if ( 'updateblogsettings' == $action && isset( $_POST['primary_blog'] ) ) {	check_admin_referer( 'update-my-sites' );	$blog = get_blog_details( (int) $_POST['primary_blog'] );	if ( $blog && isset( $blog->domain ) ) {		update_user_option( $current_user->id, 'primary_blog', (int) $_POST['primary_blog'], true );		$updated = true;	} else {		wp_die( __( 'The primary site you chose does not exist.' ) );	}}$title = __( 'My Sites' );$parent_file = 'index.php';add_contextual_help($current_screen,	'<p>' . __('This screen shows an individual user all of their sites in this network, and also allows that user to set a primary site. He or she can use the links under each site to visit either the frontend or the dashboard for that site.') . '</p>' .	'<p>' . __('Up until WordPress version 3.0, what is now called a Multi-site Network had to be installed separately as WordPress MU (multi-user).') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Dashboard_My_Sites_SubPanel" target="_blank">My Sites Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once( './admin-header.php' );if ( $updated ) { ?>	<div id="message" class="updated"><p><strong><?php _e( 'Settings saved.' ); ?></strong></p></div><?php } ?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><form id="myblogs" action="" method="post">	<?php	choose_primary_blog();	do_action( 'myblogs_allblogs_options' );	?>	<br clear="all" />	<table class="widefat fixed">	<?php	$settings_html = apply_filters( 'myblogs_options', '', 'global' );	if ( $settings_html != '' ) {		echo '<tr><td valign="top"><h3>' . __( 'Global Settings' ) . '</h3></td><td>';		echo $settings_html;		echo '</td></tr>';	}	reset( $blogs );	$num = count( $blogs );	$cols = 1;	if ( $num >= 20 )		$cols = 4;	elseif ( $num >= 10 )		$cols = 2;	$num_rows = ceil( $num / $cols );	$split = 0;	for ( $i = 1; $i <= $num_rows; $i++ ) {		$rows[] = array_slice( $blogs, $split, $cols );		$split = $split + $cols;	}	$c = '';	foreach ( $rows as $row ) {		$c = $c == 'alternate' ? '' : 'alternate';		echo "<tr class='$c'>";		$i = 0;		foreach ( $row as $user_blog ) {			$s = $i == 3 ? '' : 'border-right: 1px solid #ccc;';			echo "<td valign='top' style='$s'>";			echo "<h3>{$user_blog->blogname}</h3>";			echo "<p>" . apply_filters( 'myblogs_blog_actions', "<a href='" . esc_url( get_home_url( $user_blog->userblog_id ) ). "'>" . __( 'Visit' ) . "</a> | <a href='" . esc_url( get_admin_url( $user_blog->userblog_id ) ) . "'>" . __( 'Dashboard' ) . "</a>", $user_blog ) . "</p>";			echo apply_filters( 'myblogs_options', '', $user_blog );			echo "</td>";			$i++;		}		echo "</tr>";	}?>	</table>	<input type="hidden" name="action" value="updateblogsettings" />	<?php wp_nonce_field( 'update-my-sites' ); ?>	<p>	 <input type="submit" class="button-primary" value="<?php _e( 'Save Changes' ) ?>" />	</p>	</form>	</div><?phpinclude( './admin-footer.php' );?>
<?php/** * PemFTP - A Ftp implementation in pure PHP * * @package PemFTP * @since 2.5 * * @version 1.0 * @copyright Alexey Dotsenko * @author Alexey Dotsenko * @link http://www.phpclasses.org/browse/package/1743.html Site * @license LGPL License http://www.opensource.org/licenses/lgpl-license.html *//** * FTP implementation using fsockopen to connect. * * @package PemFTP * @subpackage Pure * @since 2.5 * * @version 1.0 * @copyright Alexey Dotsenko * @author Alexey Dotsenko * @link http://www.phpclasses.org/browse/package/1743.html Site * @license LGPL License http://www.opensource.org/licenses/lgpl-license.html */class ftp extends ftp_base {	function ftp($verb=FALSE, $le=FALSE) {		$this->__construct($verb, $le);	}	function __construct($verb=FALSE, $le=FALSE) {		parent::__construct(false, $verb, $le);	}// <!-- --------------------------------------------------------------------------------------- -->// <!--       Private functions                                                                 -->// <!-- --------------------------------------------------------------------------------------- -->	function _settimeout($sock) {		if(!@stream_set_timeout($sock, $this->_timeout)) {			$this->PushError('_settimeout','socket set send timeout');			$this->_quit();			return FALSE;		}		return TRUE;	}	function _connect($host, $port) {		$this->SendMSG("Creating socket");		$sock = @fsockopen($host, $port, $errno, $errstr, $this->_timeout);		if (!$sock) {			$this->PushError('_connect','socket connect failed', $errstr." (".$errno.")");			return FALSE;		}		$this->_connected=true;		return $sock;	}	function _readmsg($fnction="_readmsg"){		if(!$this->_connected) {			$this->PushError($fnction, 'Connect first');			return FALSE;		}		$result=true;		$this->_message="";		$this->_code=0;		$go=true;		do {			$tmp=@fgets($this->_ftp_control_sock, 512);			if($tmp===false) {				$go=$result=false;				$this->PushError($fnction,'Read failed');			} else {				$this->_message.=$tmp;				if(preg_match("/^([0-9]{3})(-(.*[".CRLF."]{1,2})+\\1)? [^".CRLF."]+[".CRLF."]{1,2}$/", $this->_message, $regs)) $go=false;			}		} while($go);		if($this->LocalEcho) echo "GET < ".rtrim($this->_message, CRLF).CRLF;		$this->_code=(int)$regs[1];		return $result;	}	function _exec($cmd, $fnction="_exec") {		if(!$this->_ready) {			$this->PushError($fnction,'Connect first');			return FALSE;		}		if($this->LocalEcho) echo "PUT > ",$cmd,CRLF;		$status=@fputs($this->_ftp_control_sock, $cmd.CRLF);		if($status===false) {			$this->PushError($fnction,'socket write failed');			return FALSE;		}		$this->_lastaction=time();		if(!$this->_readmsg($fnction)) return FALSE;		return TRUE;	}	function _data_prepare($mode=FTP_ASCII) {		if(!$this->_settype($mode)) return FALSE;		if($this->_passive) {			if(!$this->_exec("PASV", "pasv")) {				$this->_data_close();				return FALSE;			}			if(!$this->_checkCode()) {				$this->_data_close();				return FALSE;			}			$ip_port = explode(",", ereg_replace("^.+ \\(?([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},[0-9]{1,3},[0-9]+,[0-9]+)\\)?.*".CRLF."$", "\\1", $this->_message));			$this->_datahost=$ip_port[0].".".$ip_port[1].".".$ip_port[2].".".$ip_port[3];            $this->_dataport=(((int)$ip_port[4])<<8) + ((int)$ip_port[5]);			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			$this->_ftp_data_sock=@fsockopen($this->_datahost, $this->_dataport, $errno, $errstr, $this->_timeout);			if(!$this->_ftp_data_sock) {				$this->PushError("_data_prepare","fsockopen fails", $errstr." (".$errno.")");				$this->_data_close();				return FALSE;			}			else $this->_ftp_data_sock;		} else {			$this->SendMSG("Only passive connections available!");			return FALSE;		}		return TRUE;	}	function _data_read($mode=FTP_ASCII, $fp=NULL) {		if(is_resource($fp)) $out=0;		else $out="";		if(!$this->_passive) {			$this->SendMSG("Only passive connections available!");			return FALSE;		}		while (!feof($this->_ftp_data_sock)) {			$block=fread($this->_ftp_data_sock, $this->_ftp_buff_size);			if($mode!=FTP_BINARY) $block=preg_replace("/\r\n|\r|\n/", $this->_eol_code[$this->OS_local], $block);			if(is_resource($fp)) $out+=fwrite($fp, $block, strlen($block));			else $out.=$block;		}		return $out;	}	function _data_write($mode=FTP_ASCII, $fp=NULL) {		if(is_resource($fp)) $out=0;		else $out="";		if(!$this->_passive) {			$this->SendMSG("Only passive connections available!");			return FALSE;		}		if(is_resource($fp)) {			while(!feof($fp)) {				$block=fread($fp, $this->_ftp_buff_size);				if(!$this->_data_write_block($mode, $block)) return false;			}		} elseif(!$this->_data_write_block($mode, $fp)) return false;		return TRUE;	}	function _data_write_block($mode, $block) {		if($mode!=FTP_BINARY) $block=preg_replace("/\r\n|\r|\n/", $this->_eol_code[$this->OS_remote], $block);		do {			if(($t=@fwrite($this->_ftp_data_sock, $block))===FALSE) {				$this->PushError("_data_write","Can't write to socket");				return FALSE;			}			$block=substr($block, $t);		} while(!empty($block));		return true;	}	function _data_close() {		@fclose($this->_ftp_data_sock);		$this->SendMSG("Disconnected data from remote host");		return TRUE;	}	function _quit($force=FALSE) {		if($this->_connected or $force) {			@fclose($this->_ftp_control_sock);			$this->_connected=false;			$this->SendMSG("Socket closed");		}	}}?>
<?php/** * WordPress Post Thumbnail Template Functions. * * Support for post thumbnails * Themes function.php must call add_theme_support( 'post-thumbnails' ) to use these. * * @package WordPress * @subpackage Template *//** * Check if post has an image attached. * * @since 2.9.0 * * @param int $post_id Optional. Post ID. * @return bool Whether post has an image attached. */function has_post_thumbnail( $post_id = NULL ) {	global $id;	$post_id = ( NULL === $post_id ) ? $id : $post_id;	return !! get_post_thumbnail_id( $post_id );}/** * Retrieve Post Thumbnail ID. * * @since 2.9.0 * * @param int $post_id Optional. Post ID. * @return int */function get_post_thumbnail_id( $post_id = NULL ) {	global $id;	$post_id = ( NULL === $post_id ) ? $id : $post_id;	return get_post_meta( $post_id, '_thumbnail_id', true );}/** * Display Post Thumbnail. * * @since 2.9.0 * * @param int $size Optional. Image size.  Defaults to 'post-thumbnail', which theme sets using set_post_thumbnail_size( $width, $height, $crop_flag );. * @param string|array $attr Optional. Query string or array of attributes. */function the_post_thumbnail( $size = 'post-thumbnail', $attr = '' ) {	echo get_the_post_thumbnail( NULL, $size, $attr );}/** * Retrieve Post Thumbnail. * * @since 2.9.0 * * @param int $post_id Optional. Post ID. * @param string $size Optional. Image size.  Defaults to 'thumbnail'. * @param string|array $attr Optional. Query string or array of attributes.  */function get_the_post_thumbnail( $post_id = NULL, $size = 'post-thumbnail', $attr = '' ) {	global $id;	$post_id = ( NULL === $post_id ) ? $id : $post_id;	$post_thumbnail_id = get_post_thumbnail_id( $post_id );	$size = apply_filters( 'post_thumbnail_size', $size );	if ( $post_thumbnail_id ) {		do_action( 'begin_fetch_post_thumbnail_html', $post_id, $post_thumbnail_id, $size ); // for "Just In Time" filtering of all of wp_get_attachment_image()'s filters		$html = wp_get_attachment_image( $post_thumbnail_id, $size, false, $attr );		do_action( 'end_fetch_post_thumbnail_html', $post_id, $post_thumbnail_id, $size );	} else {		$html = '';	}	return apply_filters( 'post_thumbnail_html', $html, $post_id, $post_thumbnail_id, $size, $attr );}?>
<?php/** * XML-RPC protocol support for WordPress * * @license GPL v2 <./license.txt> * @package WordPress *//** * Whether this is a XMLRPC Request * * @var bool */define('XMLRPC_REQUEST', true);// Some browser-embedded clients send cookies. We don't want them.$_COOKIE = array();// A bug in PHP < 5.2.2 makes $HTTP_RAW_POST_DATA not set by default,// but we can do it ourself.if ( !isset( $HTTP_RAW_POST_DATA ) ) {	$HTTP_RAW_POST_DATA = file_get_contents( 'php://input' );}// fix for mozBlog and other cases where '<?xml' isn't on the very first lineif ( isset($HTTP_RAW_POST_DATA) )	$HTTP_RAW_POST_DATA = trim($HTTP_RAW_POST_DATA);/** Include the bootstrap for setting up WordPress environment */include('./wp-load.php');if ( isset( $_GET['rsd'] ) ) { // http://archipelago.phrasewise.com/rsdheader('Content-Type: text/xml; charset=' . get_option('blog_charset'), true);?><?php echo '<?xml version="1.0" encoding="'.get_option('blog_charset').'"?'.'>'; ?><rsd version="1.0" xmlns="http://archipelago.phrasewise.com/rsd">  <service>    <engineName>WordPress</engineName>    <engineLink>http://wordpress.org/</engineLink>    <homePageLink><?php bloginfo_rss('url') ?></homePageLink>    <apis>      <api name="WordPress" blogID="1" preferred="true" apiLink="<?php echo site_url('xmlrpc.php', 'rpc') ?>" />      <api name="Movable Type" blogID="1" preferred="false" apiLink="<?php echo site_url('xmlrpc.php', 'rpc') ?>" />      <api name="MetaWeblog" blogID="1" preferred="false" apiLink="<?php echo site_url('xmlrpc.php', 'rpc') ?>" />      <api name="Blogger" blogID="1" preferred="false" apiLink="<?php echo site_url('xmlrpc.php', 'rpc') ?>" />      <api name="Atom" blogID="" preferred="false" apiLink="<?php echo apply_filters('atom_service_url', site_url('wp-app.php/service', 'rpc') ) ?>" />    </apis>  </service></rsd><?phpexit;}include_once(ABSPATH . 'wp-admin/includes/admin.php');include_once(ABSPATH . WPINC . '/class-IXR.php');// Turn off all warnings and errors.// error_reporting(0);/** * Posts submitted via the xmlrpc interface get that title * @name post_default_title * @var string */$post_default_title = "";/** * Whether to enable XMLRPC Logging. * * @name xmlrpc_logging * @var int|bool */$xmlrpc_logging = 0;/** * logIO() - Writes logging info to a file. * * @uses $xmlrpc_logging * @package WordPress * @subpackage Logging * * @param string $io Whether input or output * @param string $msg Information describing logging reason. * @return bool Always return true */function logIO($io,$msg) {	global $xmlrpc_logging;	if ($xmlrpc_logging) {		$fp = fopen("../xmlrpc.log","a+");		$date = gmdate("Y-m-d H:i:s ");		$iot = ($io == "I") ? " Input: " : " Output: ";		fwrite($fp, "\n\n".$date.$iot.$msg);		fclose($fp);	}	return true;}if ( isset($HTTP_RAW_POST_DATA) )	logIO("I", $HTTP_RAW_POST_DATA);/** * WordPress XMLRPC server implementation. * * Implements compatability for Blogger API, MetaWeblog API, MovableType, and * pingback. Additional WordPress API for managing comments, pages, posts, * options, etc. * * Since WordPress 2.6.0, WordPress XMLRPC server can be disabled in the * administration panels. * * @package WordPress * @subpackage Publishing * @since 1.5.0 */class wp_xmlrpc_server extends IXR_Server {	/**	 * Register all of the XMLRPC methods that XMLRPC server understands.	 *	 * PHP4 constructor and sets up server and method property. Passes XMLRPC	 * methods through the 'xmlrpc_methods' filter to allow plugins to extend	 * or replace XMLRPC methods.	 *	 * @since 1.5.0	 *	 * @return wp_xmlrpc_server	 */	function wp_xmlrpc_server() {		$this->methods = array(			// WordPress API			'wp.getUsersBlogs'		=> 'this:wp_getUsersBlogs',			'wp.getPage'			=> 'this:wp_getPage',			'wp.getPages'			=> 'this:wp_getPages',			'wp.newPage'			=> 'this:wp_newPage',			'wp.deletePage'			=> 'this:wp_deletePage',			'wp.editPage'			=> 'this:wp_editPage',			'wp.getPageList'		=> 'this:wp_getPageList',			'wp.getAuthors'			=> 'this:wp_getAuthors',			'wp.getCategories'		=> 'this:mw_getCategories',		// Alias			'wp.getTags'			=> 'this:wp_getTags',			'wp.newCategory'		=> 'this:wp_newCategory',			'wp.deleteCategory'		=> 'this:wp_deleteCategory',			'wp.suggestCategories'	=> 'this:wp_suggestCategories',			'wp.uploadFile'			=> 'this:mw_newMediaObject',	// Alias			'wp.getCommentCount'	=> 'this:wp_getCommentCount',			'wp.getPostStatusList'	=> 'this:wp_getPostStatusList',			'wp.getPageStatusList'	=> 'this:wp_getPageStatusList',			'wp.getPageTemplates'	=> 'this:wp_getPageTemplates',			'wp.getOptions'			=> 'this:wp_getOptions',			'wp.setOptions'			=> 'this:wp_setOptions',			'wp.getComment'			=> 'this:wp_getComment',			'wp.getComments'		=> 'this:wp_getComments',			'wp.deleteComment'		=> 'this:wp_deleteComment',			'wp.editComment'		=> 'this:wp_editComment',			'wp.newComment'			=> 'this:wp_newComment',			'wp.getCommentStatusList' => 'this:wp_getCommentStatusList',			// Blogger API			'blogger.getUsersBlogs' => 'this:blogger_getUsersBlogs',			'blogger.getUserInfo' => 'this:blogger_getUserInfo',			'blogger.getPost' => 'this:blogger_getPost',			'blogger.getRecentPosts' => 'this:blogger_getRecentPosts',			'blogger.getTemplate' => 'this:blogger_getTemplate',			'blogger.setTemplate' => 'this:blogger_setTemplate',			'blogger.newPost' => 'this:blogger_newPost',			'blogger.editPost' => 'this:blogger_editPost',			'blogger.deletePost' => 'this:blogger_deletePost',			// MetaWeblog API (with MT extensions to structs)			'metaWeblog.newPost' => 'this:mw_newPost',			'metaWeblog.editPost' => 'this:mw_editPost',			'metaWeblog.getPost' => 'this:mw_getPost',			'metaWeblog.getRecentPosts' => 'this:mw_getRecentPosts',			'metaWeblog.getCategories' => 'this:mw_getCategories',			'metaWeblog.newMediaObject' => 'this:mw_newMediaObject',			// MetaWeblog API aliases for Blogger API			// see http://www.xmlrpc.com/stories/storyReader$2460			'metaWeblog.deletePost' => 'this:blogger_deletePost',			'metaWeblog.getTemplate' => 'this:blogger_getTemplate',			'metaWeblog.setTemplate' => 'this:blogger_setTemplate',			'metaWeblog.getUsersBlogs' => 'this:blogger_getUsersBlogs',			// MovableType API			'mt.getCategoryList' => 'this:mt_getCategoryList',			'mt.getRecentPostTitles' => 'this:mt_getRecentPostTitles',			'mt.getPostCategories' => 'this:mt_getPostCategories',			'mt.setPostCategories' => 'this:mt_setPostCategories',			'mt.supportedMethods' => 'this:mt_supportedMethods',			'mt.supportedTextFilters' => 'this:mt_supportedTextFilters',			'mt.getTrackbackPings' => 'this:mt_getTrackbackPings',			'mt.publishPost' => 'this:mt_publishPost',			// PingBack			'pingback.ping' => 'this:pingback_ping',			'pingback.extensions.getPingbacks' => 'this:pingback_extensions_getPingbacks',			'demo.sayHello' => 'this:sayHello',			'demo.addTwoNumbers' => 'this:addTwoNumbers'		);		$this->initialise_blog_option_info( );		$this->methods = apply_filters('xmlrpc_methods', $this->methods);	}	function serve_request() {		$this->IXR_Server($this->methods);	}	/**	 * Test XMLRPC API by saying, "Hello!" to client.	 *	 * @since 1.5.0	 *	 * @param array $args Method Parameters.	 * @return string	 */	function sayHello($args) {		return 'Hello!';	}	/**	 * Test XMLRPC API by adding two numbers for client.	 *	 * @since 1.5.0	 *	 * @param array $args Method Parameters.	 * @return int	 */	function addTwoNumbers($args) {		$number1 = $args[0];		$number2 = $args[1];		return $number1 + $number2;	}	/**	 * Check user's credentials.	 *	 * @since 1.5.0	 *	 * @param string $user_login User's username.	 * @param string $user_pass User's password.	 * @return bool Whether authentication passed.	 * @deprecated use wp_xmlrpc_server::login	 * @see wp_xmlrpc_server::login	 */	function login_pass_ok($user_login, $user_pass) {		if ( !get_option( 'enable_xmlrpc' ) ) {			$this->error = new IXR_Error( 405, sprintf( __( 'XML-RPC services are disabled on this site.  An admin user can enable them at %s'),  admin_url('options-writing.php') ) );			return false;		}		if (!user_pass_ok($user_login, $user_pass)) {			$this->error = new IXR_Error(403, __('Bad login/pass combination.'));			return false;		}		return true;	}	/**	 * Log user in.	 *	 * @since 2.8	 *	 * @param string $username User's username.	 * @param string $password User's password.	 * @return mixed WP_User object if authentication passed, false otherwise	 */	function login($username, $password) {		if ( !get_option( 'enable_xmlrpc' ) ) {			$this->error = new IXR_Error( 405, sprintf( __( 'XML-RPC services are disabled on this site.  An admin user can enable them at %s'),  admin_url('options-writing.php') ) );			return false;		}		$user = wp_authenticate($username, $password);		if (is_wp_error($user)) {			$this->error = new IXR_Error(403, __('Bad login/pass combination.'));			return false;		}		wp_set_current_user( $user->ID );		return $user;	}	/**	 * Sanitize string or array of strings for database.	 *	 * @since 1.5.2	 *	 * @param string|array $array Sanitize single string or array of strings.	 * @return string|array Type matches $array and sanitized for the database.	 */	function escape(&$array) {		global $wpdb;		if (!is_array($array)) {			return($wpdb->escape($array));		} else {			foreach ( (array) $array as $k => $v ) {				if ( is_array($v) ) {					$this->escape($array[$k]);				} else if ( is_object($v) ) {					//skip				} else {					$array[$k] = $wpdb->escape($v);				}			}		}	}	/**	 * Retrieve custom fields for post.	 *	 * @since 2.5.0	 *	 * @param int $post_id Post ID.	 * @return array Custom fields, if exist.	 */	function get_custom_fields($post_id) {		$post_id = (int) $post_id;		$custom_fields = array();		foreach ( (array) has_meta($post_id) as $meta ) {			// Don't expose protected fields.			if ( strpos($meta['meta_key'], '_wp_') === 0 ) {				continue;			}			$custom_fields[] = array(				"id"    => $meta['meta_id'],				"key"   => $meta['meta_key'],				"value" => $meta['meta_value']			);		}		return $custom_fields;	}	/**	 * Set custom fields for post.	 *	 * @since 2.5.0	 *	 * @param int $post_id Post ID.	 * @param array $fields Custom fields.	 */	function set_custom_fields($post_id, $fields) {		$post_id = (int) $post_id;		foreach ( (array) $fields as $meta ) {			if ( isset($meta['id']) ) {				$meta['id'] = (int) $meta['id'];				if ( isset($meta['key']) ) {					update_meta($meta['id'], $meta['key'], $meta['value']);				}				else {					delete_meta($meta['id']);				}			}			else {				$_POST['metakeyinput'] = $meta['key'];				$_POST['metavalue'] = $meta['value'];				add_meta($post_id);			}		}	}	/**	 * Set up blog options property.	 *	 * Passes property through 'xmlrpc_blog_options' filter.	 *	 * @since 2.6.0	 */	function initialise_blog_option_info( ) {		global $wp_version;		$this->blog_options = array(			// Read only options			'software_name'		=> array(				'desc'			=> __( 'Software Name' ),				'readonly'		=> true,				'value'			=> 'WordPress'			),			'software_version'	=> array(				'desc'			=> __( 'Software Version' ),				'readonly'		=> true,				'value'			=> $wp_version			),			'blog_url'			=> array(				'desc'			=> __( 'Site URL' ),				'readonly'		=> true,				'option'		=> 'siteurl'			),			// Updatable options			'time_zone'			=> array(				'desc'			=> __( 'Time Zone' ),				'readonly'		=> false,				'option'		=> 'gmt_offset'			),			'blog_title'		=> array(				'desc'			=> __( 'Site Title' ),				'readonly'		=> false,				'option'			=> 'blogname'			),			'blog_tagline'		=> array(				'desc'			=> __( 'Site Tagline' ),				'readonly'		=> false,				'option'		=> 'blogdescription'			),			'date_format'		=> array(				'desc'			=> __( 'Date Format' ),				'readonly'		=> false,				'option'		=> 'date_format'			),			'time_format'		=> array(				'desc'			=> __( 'Time Format' ),				'readonly'		=> false,				'option'		=> 'time_format'			),			'users_can_register'	=> array(				'desc'			=> __( 'Allow new users to sign up' ),				'readonly'		=> false,				'option'		=> 'users_can_register'			)		);		$this->blog_options = apply_filters( 'xmlrpc_blog_options', $this->blog_options );	}	/**	 * Retrieve the blogs of the user.	 *	 * @since 2.6.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getUsersBlogs( $args ) {		global $current_site;		// If this isn't on WPMU then just use blogger_getUsersBlogs		if ( !is_multisite() ) {			array_unshift( $args, 1 );			return $this->blogger_getUsersBlogs( $args );		}		$this->escape( $args );		$username = $args[0];		$password = $args[1];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action( 'xmlrpc_call', 'wp.getUsersBlogs' );		$blogs = (array) get_blogs_of_user( $user->ID );		$struct = array( );		foreach ( $blogs as $blog ) {			// Don't include blogs that aren't hosted at this site			if ( $blog->site_id != $current_site->id )				continue;			$blog_id = $blog->userblog_id;			switch_to_blog($blog_id);			$is_admin = current_user_can('manage_options');			$struct[] = array(				'isAdmin'		=> $is_admin,				'url'			=> get_option( 'home' ) . '/',				'blogid'		=> $blog_id,				'blogName'		=> get_option( 'blogname' ),				'xmlrpc'		=> site_url( 'xmlrpc.php' )			);			restore_current_blog( );		}		return $struct;	}	/**	 * Retrieve page.	 *	 * @since 2.2.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getPage($args) {		$this->escape($args);		$blog_id	= (int) $args[0];		$page_id	= (int) $args[1];		$username	= $args[2];		$password	= $args[3];		if ( !$user = $this->login($username, $password) ) {			return $this->error;		}		if ( !current_user_can( 'edit_page', $page_id ) )			return new IXR_Error( 401, __( 'Sorry, you cannot edit this page.' ) );		do_action('xmlrpc_call', 'wp.getPage');		// Lookup page info.		$page = get_page($page_id);		// If we found the page then format the data.		if ( $page->ID && ($page->post_type == "page") ) {			// Get all of the page content and link.			$full_page = get_extended($page->post_content);			$link = post_permalink($page->ID);			// Get info the page parent if there is one.			$parent_title = "";			if ( !empty($page->post_parent) ) {				$parent = get_page($page->post_parent);				$parent_title = $parent->post_title;			}			// Determine comment and ping settings.			$allow_comments = comments_open($page->ID) ? 1 : 0;			$allow_pings = pings_open($page->ID) ? 1 : 0;			// Format page date.			$page_date = mysql2date("Ymd\TH:i:s", $page->post_date, false);			$page_date_gmt = mysql2date("Ymd\TH:i:s", $page->post_date_gmt, false);			// For drafts use the GMT version of the date			if ( $page->post_status == 'draft' )				$page_date_gmt = get_gmt_from_date( mysql2date( 'Y-m-d H:i:s', $page->post_date ), 'Ymd\TH:i:s' );			// Pull the categories info together.			$categories = array();			foreach ( wp_get_post_categories($page->ID) as $cat_id ) {				$categories[] = get_cat_name($cat_id);			}			// Get the author info.			$author = get_userdata($page->post_author);			$page_template = get_post_meta( $page->ID, '_wp_page_template', true );			if ( empty( $page_template ) )				$page_template = 'default';			$page_struct = array(				"dateCreated"			=> new IXR_Date($page_date),				"userid"				=> $page->post_author,				"page_id"				=> $page->ID,				"page_status"			=> $page->post_status,				"description"			=> $full_page["main"],				"title"					=> $page->post_title,				"link"					=> $link,				"permaLink"				=> $link,				"categories"			=> $categories,				"excerpt"				=> $page->post_excerpt,				"text_more"				=> $full_page["extended"],				"mt_allow_comments"		=> $allow_comments,				"mt_allow_pings"		=> $allow_pings,				"wp_slug"				=> $page->post_name,				"wp_password"			=> $page->post_password,				"wp_author"				=> $author->display_name,				"wp_page_parent_id"		=> $page->post_parent,				"wp_page_parent_title"	=> $parent_title,				"wp_page_order"			=> $page->menu_order,				"wp_author_id"			=> $author->ID,				"wp_author_display_name"	=> $author->display_name,				"date_created_gmt"		=> new IXR_Date($page_date_gmt),				"custom_fields"			=> $this->get_custom_fields($page_id),				"wp_page_template"		=> $page_template			);			return($page_struct);		}		// If the page doesn't exist indicate that.		else {			return(new IXR_Error(404, __("Sorry, no such page.")));		}	}	/**	 * Retrieve Pages.	 *	 * @since 2.2.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getPages($args) {		$this->escape($args);		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		$num_pages	= isset($args[3]) ? (int) $args[3] : 10;		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_pages' ) )			return new IXR_Error( 401, __( 'Sorry, you cannot edit pages.' ) );		do_action('xmlrpc_call', 'wp.getPages');		$pages = get_posts( array('post_type' => 'page', 'post_status' => 'any', 'numberposts' => $num_pages) );		$num_pages = count($pages);		// If we have pages, put together their info.		if ( $num_pages >= 1 ) {			$pages_struct = array();			for ( $i = 0; $i < $num_pages; $i++ ) {				$page = wp_xmlrpc_server::wp_getPage(array(					$blog_id, $pages[$i]->ID, $username, $password				));				$pages_struct[] = $page;			}			return($pages_struct);		}		// If no pages were found return an error.		else {			return(array());		}	}	/**	 * Create new page.	 *	 * @since 2.2.0	 *	 * @param array $args Method parameters.	 * @return unknown	 */	function wp_newPage($args) {		// Items not escaped here will be escaped in newPost.		$username	= $this->escape($args[1]);		$password	= $this->escape($args[2]);		$page		= $args[3];		$publish	= $args[4];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'wp.newPage');		// Make sure the user is allowed to add new pages.		if ( !current_user_can("publish_pages") )			return(new IXR_Error(401, __("Sorry, you cannot add new pages.")));		// Mark this as content for a page.		$args[3]["post_type"] = "page";		// Let mw_newPost do all of the heavy lifting.		return($this->mw_newPost($args));	}	/**	 * Delete page.	 *	 * @since 2.2.0	 *	 * @param array $args Method parameters.	 * @return bool True, if success.	 */	function wp_deletePage($args) {		$this->escape($args);		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		$page_id	= (int) $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'wp.deletePage');		// Get the current page based on the page_id and		// make sure it is a page and not a post.		$actual_page = wp_get_single_post($page_id, ARRAY_A);		if ( !$actual_page || ($actual_page["post_type"] != "page") )			return(new IXR_Error(404, __("Sorry, no such page.")));		// Make sure the user can delete pages.		if ( !current_user_can("delete_page", $page_id) )			return(new IXR_Error(401, __("Sorry, you do not have the right to delete this page.")));		// Attempt to delete the page.		$result = wp_delete_post($page_id);		if ( !$result )			return(new IXR_Error(500, __("Failed to delete the page.")));		return(true);	}	/**	 * Edit page.	 *	 * @since 2.2.0	 *	 * @param array $args Method parameters.	 * @return unknown	 */	function wp_editPage($args) {		// Items not escaped here will be escaped in editPost.		$blog_id	= (int) $args[0];		$page_id	= (int) $this->escape($args[1]);		$username	= $this->escape($args[2]);		$password	= $this->escape($args[3]);		$content	= $args[4];		$publish	= $args[5];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'wp.editPage');		// Get the page data and make sure it is a page.		$actual_page = wp_get_single_post($page_id, ARRAY_A);		if ( !$actual_page || ($actual_page["post_type"] != "page") )			return(new IXR_Error(404, __("Sorry, no such page.")));		// Make sure the user is allowed to edit pages.		if ( !current_user_can("edit_page", $page_id) )			return(new IXR_Error(401, __("Sorry, you do not have the right to edit this page.")));		// Mark this as content for a page.		$content["post_type"] = "page";		// Arrange args in the way mw_editPost understands.		$args = array(			$page_id,			$username,			$password,			$content,			$publish		);		// Let mw_editPost do all of the heavy lifting.		return($this->mw_editPost($args));	}	/**	 * Retrieve page list.	 *	 * @since 2.2.0	 *	 * @param array $args Method parameters.	 * @return unknown	 */	function wp_getPageList($args) {		global $wpdb;		$this->escape($args);		$blog_id				= (int) $args[0];		$username				= $args[1];		$password				= $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_pages' ) )			return new IXR_Error( 401, __( 'Sorry, you cannot edit pages.' ) );		do_action('xmlrpc_call', 'wp.getPageList');		// Get list of pages ids and titles		$page_list = $wpdb->get_results("			SELECT ID page_id,				post_title page_title,				post_parent page_parent_id,				post_date_gmt,				post_date,				post_status			FROM {$wpdb->posts}			WHERE post_type = 'page'			ORDER BY ID		");		// The date needs to be formated properly.		$num_pages = count($page_list);		for ( $i = 0; $i < $num_pages; $i++ ) {			$post_date = mysql2date("Ymd\TH:i:s", $page_list[$i]->post_date, false);			$post_date_gmt = mysql2date("Ymd\TH:i:s", $page_list[$i]->post_date_gmt, false);			$page_list[$i]->dateCreated = new IXR_Date($post_date);			$page_list[$i]->date_created_gmt = new IXR_Date($post_date_gmt);			// For drafts use the GMT version of the date			if ( $page_list[$i]->post_status == 'draft' ) {				$page_list[$i]->date_created_gmt = get_gmt_from_date( mysql2date( 'Y-m-d H:i:s', $page_list[$i]->post_date ), 'Ymd\TH:i:s' );				$page_list[$i]->date_created_gmt = new IXR_Date( $page_list[$i]->date_created_gmt );			}			unset($page_list[$i]->post_date_gmt);			unset($page_list[$i]->post_date);			unset($page_list[$i]->post_status);		}		return($page_list);	}	/**	 * Retrieve authors list.	 *	 * @since 2.2.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getAuthors($args) {		$this->escape($args);		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can("edit_posts") )			return(new IXR_Error(401, __("Sorry, you cannot edit posts on this site.")));		do_action('xmlrpc_call', 'wp.getAuthors');		$authors = array();		foreach ( (array) get_users_of_blog() as $row ) {			$authors[] = array(				"user_id"       => $row->user_id,				"user_login"    => $row->user_login,				"display_name"  => $row->display_name			);		}		return($authors);	}	/**	 * Get list of all tags	 *	 * @since 2.7	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getTags( $args ) {		$this->escape( $args );		$blog_id		= (int) $args[0];		$username		= $args[1];		$password		= $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_posts' ) )			return new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view tags.' ) );		do_action( 'xmlrpc_call', 'wp.getKeywords' );		$tags = array( );		if ( $all_tags = get_tags() ) {			foreach( (array) $all_tags as $tag ) {				$struct['tag_id']			= $tag->term_id;				$struct['name']				= $tag->name;				$struct['count']			= $tag->count;				$struct['slug']				= $tag->slug;				$struct['html_url']			= esc_html( get_tag_link( $tag->term_id ) );				$struct['rss_url']			= esc_html( get_tag_feed_link( $tag->term_id ) );				$tags[] = $struct;			}		}		return $tags;	}	/**	 * Create new category.	 *	 * @since 2.2.0	 *	 * @param array $args Method parameters.	 * @return int Category ID.	 */	function wp_newCategory($args) {		$this->escape($args);		$blog_id				= (int) $args[0];		$username				= $args[1];		$password				= $args[2];		$category				= $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'wp.newCategory');		// Make sure the user is allowed to add a category.		if ( !current_user_can("manage_categories") )			return(new IXR_Error(401, __("Sorry, you do not have the right to add a category.")));		// If no slug was provided make it empty so that		// WordPress will generate one.		if ( empty($category["slug"]) )			$category["slug"] = "";		// If no parent_id was provided make it empty		// so that it will be a top level page (no parent).		if ( !isset($category["parent_id"]) )			$category["parent_id"] = "";		// If no description was provided make it empty.		if ( empty($category["description"]) )			$category["description"] = "";		$new_category = array(			"cat_name"				=> $category["name"],			"category_nicename"		=> $category["slug"],			"category_parent"		=> $category["parent_id"],			"category_description"	=> $category["description"]		);		$cat_id = wp_insert_category($new_category);		if ( !$cat_id )			return(new IXR_Error(500, __("Sorry, the new category failed.")));		return($cat_id);	}	/**	 * Remove category.	 *	 * @since 2.5.0	 *	 * @param array $args Method parameters.	 * @return mixed See {@link wp_delete_category()} for return info.	 */	function wp_deleteCategory($args) {		$this->escape($args);		$blog_id		= (int) $args[0];		$username		= $args[1];		$password		= $args[2];		$category_id	= (int) $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'wp.deleteCategory');		if ( !current_user_can("manage_categories") )			return new IXR_Error( 401, __( "Sorry, you do not have the right to delete a category." ) );		return wp_delete_category( $category_id );	}	/**	 * Retrieve category list.	 *	 * @since 2.2.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_suggestCategories($args) {		$this->escape($args);		$blog_id				= (int) $args[0];		$username				= $args[1];		$password				= $args[2];		$category				= $args[3];		$max_results			= (int) $args[4];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_posts' ) )			return new IXR_Error( 401, __( 'Sorry, you must be able to edit posts to this site in order to view categories.' ) );		do_action('xmlrpc_call', 'wp.suggestCategories');		$category_suggestions = array();		$args = array('get' => 'all', 'number' => $max_results, 'name__like' => $category);		foreach ( (array) get_categories($args) as $cat ) {			$category_suggestions[] = array(				"category_id"	=> $cat->cat_ID,				"category_name"	=> $cat->cat_name			);		}		return($category_suggestions);	}	/**	 * Retrieve comment.	 *	 * @since 2.7.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getComment($args) {		$this->escape($args);		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		$comment_id	= (int) $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'moderate_comments' ) )			return new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );		do_action('xmlrpc_call', 'wp.getComment');		if ( ! $comment = get_comment($comment_id) )			return new IXR_Error( 404, __( 'Invalid comment ID.' ) );		// Format page date.		$comment_date = mysql2date("Ymd\TH:i:s", $comment->comment_date, false);		$comment_date_gmt = mysql2date("Ymd\TH:i:s", $comment->comment_date_gmt, false);		if ( '0' == $comment->comment_approved )			$comment_status = 'hold';		else if ( 'spam' == $comment->comment_approved )			$comment_status = 'spam';		else if ( '1' == $comment->comment_approved )			$comment_status = 'approve';		else			$comment_status = $comment->comment_approved;		$link = get_comment_link($comment);		$comment_struct = array(			"date_created_gmt"		=> new IXR_Date($comment_date_gmt),			"user_id"				=> $comment->user_id,			"comment_id"			=> $comment->comment_ID,			"parent"				=> $comment->comment_parent,			"status"				=> $comment_status,			"content"				=> $comment->comment_content,			"link"					=> $link,			"post_id"				=> $comment->comment_post_ID,			"post_title"			=> get_the_title($comment->comment_post_ID),			"author"				=> $comment->comment_author,			"author_url"			=> $comment->comment_author_url,			"author_email"			=> $comment->comment_author_email,			"author_ip"				=> $comment->comment_author_IP,			"type"					=> $comment->comment_type,		);		return $comment_struct;	}	/**	 * Retrieve comments.	 *	 * @since 2.7.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getComments($args) {		$raw_args = $args;		$this->escape($args);		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		$struct		= $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'moderate_comments' ) )			return new IXR_Error( 401, __( 'Sorry, you cannot edit comments.' ) );		do_action('xmlrpc_call', 'wp.getComments');		if ( isset($struct['status']) )			$status = $struct['status'];		else			$status = '';		$post_id = '';		if ( isset($struct['post_id']) )			$post_id = absint($struct['post_id']);		$offset = 0;		if ( isset($struct['offset']) )			$offset = absint($struct['offset']);		$number = 10;		if ( isset($struct['number']) )			$number = absint($struct['number']);		$comments = get_comments( array('status' => $status, 'post_id' => $post_id, 'offset' => $offset, 'number' => $number ) );		$num_comments = count($comments);		if ( ! $num_comments )			return array();		$comments_struct = array();		for ( $i = 0; $i < $num_comments; $i++ ) {			$comment = wp_xmlrpc_server::wp_getComment(array(				$raw_args[0], $raw_args[1], $raw_args[2], $comments[$i]->comment_ID,			));			$comments_struct[] = $comment;		}		return $comments_struct;	}	/**	 * Remove comment.	 *	 * @since 2.7.0	 *	 * @param array $args Method parameters.	 * @return mixed {@link wp_delete_comment()}	 */	function wp_deleteComment($args) {		$this->escape($args);		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		$comment_ID	= (int) $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'moderate_comments' ) )			return new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );		do_action('xmlrpc_call', 'wp.deleteComment');		if ( ! get_comment($comment_ID) )			return new IXR_Error( 404, __( 'Invalid comment ID.' ) );		return wp_delete_comment($comment_ID);	}	/**	 * Edit comment.	 *	 * @since 2.7.0	 *	 * @param array $args Method parameters.	 * @return bool True, on success.	 */	function wp_editComment($args) {		$this->escape($args);		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		$comment_ID	= (int) $args[3];		$content_struct = $args[4];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'moderate_comments' ) )			return new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );		do_action('xmlrpc_call', 'wp.editComment');		if ( ! get_comment($comment_ID) )			return new IXR_Error( 404, __( 'Invalid comment ID.' ) );		if ( isset($content_struct['status']) ) {			$statuses = get_comment_statuses();			$statuses = array_keys($statuses);			if ( ! in_array($content_struct['status'], $statuses) )				return new IXR_Error( 401, __( 'Invalid comment status.' ) );			$comment_approved = $content_struct['status'];		}		// Do some timestamp voodoo		if ( !empty( $content_struct['date_created_gmt'] ) ) {			$dateCreated = str_replace( 'Z', '', $content_struct['date_created_gmt']->getIso() ) . 'Z'; // We know this is supposed to be GMT, so we're going to slap that Z on there by force			$comment_date = get_date_from_gmt(iso8601_to_datetime($dateCreated));			$comment_date_gmt = iso8601_to_datetime($dateCreated, GMT);		}		if ( isset($content_struct['content']) )			$comment_content = $content_struct['content'];		if ( isset($content_struct['author']) )			$comment_author = $content_struct['author'];		if ( isset($content_struct['author_url']) )			$comment_author_url = $content_struct['author_url'];		if ( isset($content_struct['author_email']) )			$comment_author_email = $content_struct['author_email'];		// We've got all the data -- post it:		$comment = compact('comment_ID', 'comment_content', 'comment_approved', 'comment_date', 'comment_date_gmt', 'comment_author', 'comment_author_email', 'comment_author_url');		$result = wp_update_comment($comment);		if ( is_wp_error( $result ) )			return new IXR_Error(500, $result->get_error_message());		if ( !$result )			return new IXR_Error(500, __('Sorry, the comment could not be edited. Something wrong happened.'));		return true;	}	/**	 * Create new comment.	 *	 * @since 2.7.0	 *	 * @param array $args Method parameters.	 * @return mixed {@link wp_new_comment()}	 */	function wp_newComment($args) {		global $wpdb;		$this->escape($args);		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		$post		= $args[3];		$content_struct = $args[4];		$allow_anon = apply_filters('xmlrpc_allow_anonymous_comments', false);		$user = $this->login($username, $password);		if ( !$user ) {			$logged_in = false;			if ( $allow_anon && get_option('comment_registration') )				return new IXR_Error( 403, __( 'You must be registered to comment' ) );			else if ( !$allow_anon )				return $this->error;		} else {			$logged_in = true;		}		if ( is_numeric($post) )			$post_id = absint($post);		else			$post_id = url_to_postid($post);		if ( ! $post_id )			return new IXR_Error( 404, __( 'Invalid post ID.' ) );		if ( ! get_post($post_id) )			return new IXR_Error( 404, __( 'Invalid post ID.' ) );		$comment['comment_post_ID'] = $post_id;		if ( $logged_in ) {			$comment['comment_author'] = $wpdb->escape( $user->display_name );			$comment['comment_author_email'] = $wpdb->escape( $user->user_email );			$comment['comment_author_url'] = $wpdb->escape( $user->user_url );			$comment['user_ID'] = $user->ID;		} else {			$comment['comment_author'] = '';			if ( isset($content_struct['author']) )				$comment['comment_author'] = $content_struct['author'];			$comment['comment_author_email'] = '';			if ( isset($content_struct['author_email']) )				$comment['comment_author_email'] = $content_struct['author_email'];			$comment['comment_author_url'] = '';			if ( isset($content_struct['author_url']) )				$comment['comment_author_url'] = $content_struct['author_url'];			$comment['user_ID'] = 0;			if ( get_option('require_name_email') ) {				if ( 6 > strlen($comment['comment_author_email']) || '' == $comment['comment_author'] )					return new IXR_Error( 403, __( 'Comment author name and email are required' ) );				elseif ( !is_email($comment['comment_author_email']) )					return new IXR_Error( 403, __( 'A valid email address is required' ) );			}		}		$comment['comment_parent'] = isset($content_struct['comment_parent']) ? absint($content_struct['comment_parent']) : 0;		$comment['comment_content'] = $content_struct['content'];		do_action('xmlrpc_call', 'wp.newComment');		return wp_new_comment($comment);	}	/**	 * Retrieve all of the comment status.	 *	 * @since 2.7.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getCommentStatusList($args) {		$this->escape( $args );		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'moderate_comments' ) )			return new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );		do_action('xmlrpc_call', 'wp.getCommentStatusList');		return get_comment_statuses( );	}	/**	 * Retrieve comment count.	 *	 * @since 2.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getCommentCount( $args ) {		$this->escape($args);		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		$post_id	= (int) $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_posts' ) )			return new IXR_Error( 403, __( 'You are not allowed access to details about comments.' ) );		do_action('xmlrpc_call', 'wp.getCommentCount');		$count = wp_count_comments( $post_id );		return array(			"approved" => $count->approved,			"awaiting_moderation" => $count->moderated,			"spam" => $count->spam,			"total_comments" => $count->total_comments		);	}	/**	 * Retrieve post statuses.	 *	 * @since 2.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getPostStatusList( $args ) {		$this->escape( $args );		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_posts' ) )			return new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );		do_action('xmlrpc_call', 'wp.getPostStatusList');		return get_post_statuses( );	}	/**	 * Retrieve page statuses.	 *	 * @since 2.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getPageStatusList( $args ) {		$this->escape( $args );		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_posts' ) )			return new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );		do_action('xmlrpc_call', 'wp.getPageStatusList');		return get_page_statuses( );	}	/**	 * Retrieve page templates.	 *	 * @since 2.6.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getPageTemplates( $args ) {		$this->escape( $args );		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_pages' ) )			return new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );		$templates = get_page_templates( );		$templates['Default'] = 'default';		return $templates;	}	/**	 * Retrieve blog options.	 *	 * @since 2.6.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function wp_getOptions( $args ) {		$this->escape( $args );		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		$options	= (array) $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		// If no specific options where asked for, return all of them		if ( count( $options ) == 0 )			$options = array_keys($this->blog_options);		return $this->_getOptions($options);	}	/**	 * Retrieve blog options value from list.	 *	 * @since 2.6.0	 *	 * @param array $options Options to retrieve.	 * @return array	 */	function _getOptions($options) {		$data = array( );		foreach ( $options as $option ) {			if ( array_key_exists( $option, $this->blog_options ) ) {				$data[$option] = $this->blog_options[$option];				//Is the value static or dynamic?				if ( isset( $data[$option]['option'] ) ) {					$data[$option]['value'] = get_option( $data[$option]['option'] );					unset($data[$option]['option']);				}			}		}		return $data;	}	/**	 * Update blog options.	 *	 * @since 2.6.0	 *	 * @param array $args Method parameters.	 * @return unknown	 */	function wp_setOptions( $args ) {		$this->escape( $args );		$blog_id	= (int) $args[0];		$username	= $args[1];		$password	= $args[2];		$options	= (array) $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'manage_options' ) )			return new IXR_Error( 403, __( 'You are not allowed to update options.' ) );		foreach ( $options as $o_name => $o_value ) {			$option_names[] = $o_name;			if ( !array_key_exists( $o_name, $this->blog_options ) )				continue;			if ( $this->blog_options[$o_name]['readonly'] == true )				continue;			update_option( $this->blog_options[$o_name]['option'], $o_value );		}		//Now return the updated values		return $this->_getOptions($option_names);	}	/* Blogger API functions.	 * specs on http://plant.blogger.com/api and http://groups.yahoo.com/group/bloggerDev/	 */	/**	 * Retrieve blogs that user owns.	 *	 * Will make more sense once we support multiple blogs.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function blogger_getUsersBlogs($args) {		if ( is_multisite() )			return $this->_multisite_getUsersBlogs($args);		$this->escape($args);		$username = $args[1];		$password  = $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'blogger.getUsersBlogs');		$is_admin = current_user_can('manage_options');		$struct = array(			'isAdmin'  => $is_admin,			'url'      => get_option('home') . '/',			'blogid'   => '1',			'blogName' => get_option('blogname'),			'xmlrpc'   => site_url( 'xmlrpc.php' )		);		return array($struct);	}	/**	 * Private function for retrieving a users blogs for multisite setups	 *	 * @access protected	 */	function _multisite_getUsersBlogs($args) {		global $current_blog;		$domain = $current_blog->domain;		$path = $current_blog->path . 'xmlrpc.php';		$protocol = is_ssl() ? 'https' : 'http';		$rpc = new IXR_Client("$protocol://{$domain}{$path}");		$rpc->query('wp.getUsersBlogs', $args[1], $args[2]);		$blogs = $rpc->getResponse();		if ( isset($blogs['faultCode']) )			return new IXR_Error($blogs['faultCode'], $blogs['faultString']);		if ( $_SERVER['HTTP_HOST'] == $domain && $_SERVER['REQUEST_URI'] == $path ) {			return $blogs;		} else {			foreach ( (array) $blogs as $blog ) {				if ( strpos($blog['url'], $_SERVER['HTTP_HOST']) )					return array($blog);			}			return array();		}	}	/**	 * Retrieve user's data.	 *	 * Gives your client some info about you, so you don't have to.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function blogger_getUserInfo($args) {		$this->escape($args);		$username = $args[1];		$password  = $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_posts' ) )			return new IXR_Error( 401, __( 'Sorry, you do not have access to user data on this site.' ) );		do_action('xmlrpc_call', 'blogger.getUserInfo');		$struct = array(			'nickname'  => $user->nickname,			'userid'    => $user->ID,			'url'       => $user->user_url,			'lastname'  => $user->last_name,			'firstname' => $user->first_name		);		return $struct;	}	/**	 * Retrieve post.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function blogger_getPost($args) {		$this->escape($args);		$post_ID    = (int) $args[1];		$username = $args[2];		$password  = $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_post', $post_ID ) )			return new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );		do_action('xmlrpc_call', 'blogger.getPost');		$post_data = wp_get_single_post($post_ID, ARRAY_A);		$categories = implode(',', wp_get_post_categories($post_ID));		$content  = '<title>'.stripslashes($post_data['post_title']).'</title>';		$content .= '<category>'.$categories.'</category>';		$content .= stripslashes($post_data['post_content']);		$struct = array(			'userid'    => $post_data['post_author'],			'dateCreated' => new IXR_Date(mysql2date('Ymd\TH:i:s', $post_data['post_date'], false)),			'content'     => $content,			'postid'  => $post_data['ID']		);		return $struct;	}	/**	 * Retrieve list of recent posts.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function blogger_getRecentPosts($args) {		$this->escape($args);		$blog_ID    = (int) $args[1]; /* though we don't use it yet */		$username = $args[2];		$password  = $args[3];		$num_posts  = $args[4];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'blogger.getRecentPosts');		$posts_list = wp_get_recent_posts($num_posts);		if ( !$posts_list ) {			$this->error = new IXR_Error(500, __('Either there are no posts, or something went wrong.'));			return $this->error;		}		foreach ($posts_list as $entry) {			if ( !current_user_can( 'edit_post', $entry['ID'] ) )				continue;			$post_date = mysql2date('Ymd\TH:i:s', $entry['post_date'], false);			$categories = implode(',', wp_get_post_categories($entry['ID']));			$content  = '<title>'.stripslashes($entry['post_title']).'</title>';			$content .= '<category>'.$categories.'</category>';			$content .= stripslashes($entry['post_content']);			$struct[] = array(				'userid' => $entry['post_author'],				'dateCreated' => new IXR_Date($post_date),				'content' => $content,				'postid' => $entry['ID'],			);		}		$recent_posts = array();		for ( $j=0; $j<count($struct); $j++ ) {			array_push($recent_posts, $struct[$j]);		}		return $recent_posts;	}	/**	 * Retrieve blog_filename content.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return string	 */	function blogger_getTemplate($args) {		$this->escape($args);		$blog_ID    = (int) $args[1];		$username = $args[2];		$password  = $args[3];		$template   = $args[4]; /* could be 'main' or 'archiveIndex', but we don't use it */		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'blogger.getTemplate');		if ( !current_user_can('edit_themes') )			return new IXR_Error(401, __('Sorry, this user can not edit the template.'));		/* warning: here we make the assumption that the blog's URL is on the same server */		$filename = get_option('home') . '/';		$filename = preg_replace('#https?://.+?/#', $_SERVER['DOCUMENT_ROOT'].'/', $filename);		$f = fopen($filename, 'r');		$content = fread($f, filesize($filename));		fclose($f);		/* so it is actually editable with a windows/mac client */		// FIXME: (or delete me) do we really want to cater to bad clients at the expense of good ones by BEEPing up their line breaks? commented.     $content = str_replace("\n", "\r\n", $content);		return $content;	}	/**	 * Updates the content of blog_filename.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return bool True when done.	 */	function blogger_setTemplate($args) {		$this->escape($args);		$blog_ID    = (int) $args[1];		$username = $args[2];		$password  = $args[3];		$content    = $args[4];		$template   = $args[5]; /* could be 'main' or 'archiveIndex', but we don't use it */		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'blogger.setTemplate');		if ( !current_user_can('edit_themes') )			return new IXR_Error(401, __('Sorry, this user cannot edit the template.'));		/* warning: here we make the assumption that the blog's URL is on the same server */		$filename = get_option('home') . '/';		$filename = preg_replace('#https?://.+?/#', $_SERVER['DOCUMENT_ROOT'].'/', $filename);		if ($f = fopen($filename, 'w+')) {			fwrite($f, $content);			fclose($f);		} else {			return new IXR_Error(500, __('Either the file is not writable, or something wrong happened. The file has not been updated.'));		}		return true;	}	/**	 * Create new post.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return int	 */	function blogger_newPost($args) {		$this->escape($args);		$blog_ID    = (int) $args[1]; /* though we don't use it yet */		$username = $args[2];		$password  = $args[3];		$content    = $args[4];		$publish    = $args[5];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'blogger.newPost');		$cap = ($publish) ? 'publish_posts' : 'edit_posts';		if ( !current_user_can($cap) )			return new IXR_Error(401, __('Sorry, you are not allowed to post on this site.'));		$post_status = ($publish) ? 'publish' : 'draft';		$post_author = $user->ID;		$post_title = xmlrpc_getposttitle($content);		$post_category = xmlrpc_getpostcategory($content);		$post_content = xmlrpc_removepostdata($content);		$post_date = current_time('mysql');		$post_date_gmt = current_time('mysql', 1);		$post_data = compact('blog_ID', 'post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_title', 'post_category', 'post_status');		$post_ID = wp_insert_post($post_data);		if ( is_wp_error( $post_ID ) )			return new IXR_Error(500, $post_ID->get_error_message());		if ( !$post_ID )			return new IXR_Error(500, __('Sorry, your entry could not be posted. Something wrong happened.'));		$this->attach_uploads( $post_ID, $post_content );		logIO('O', "Posted ! ID: $post_ID");		return $post_ID;	}	/**	 * Edit a post.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return bool true when done.	 */	function blogger_editPost($args) {		$this->escape($args);		$post_ID     = (int) $args[1];		$username  = $args[2];		$password   = $args[3];		$content     = $args[4];		$publish     = $args[5];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'blogger.editPost');		$actual_post = wp_get_single_post($post_ID,ARRAY_A);		if ( !$actual_post || $actual_post['post_type'] != 'post' )			return new IXR_Error(404, __('Sorry, no such post.'));		$this->escape($actual_post);		if ( !current_user_can('edit_post', $post_ID) )			return new IXR_Error(401, __('Sorry, you do not have the right to edit this post.'));		extract($actual_post, EXTR_SKIP);		if ( ('publish' == $post_status) && !current_user_can('publish_posts') )			return new IXR_Error(401, __('Sorry, you do not have the right to publish this post.'));		$post_title = xmlrpc_getposttitle($content);		$post_category = xmlrpc_getpostcategory($content);		$post_content = xmlrpc_removepostdata($content);		$postdata = compact('ID', 'post_content', 'post_title', 'post_category', 'post_status', 'post_excerpt');		$result = wp_update_post($postdata);		if ( !$result )			return new IXR_Error(500, __('For some strange yet very annoying reason, this post could not be edited.'));		$this->attach_uploads( $ID, $post_content );		return true;	}	/**	 * Remove a post.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return bool True when post is deleted.	 */	function blogger_deletePost($args) {		$this->escape($args);		$post_ID     = (int) $args[1];		$username  = $args[2];		$password   = $args[3];		$publish     = $args[4];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'blogger.deletePost');		$actual_post = wp_get_single_post($post_ID,ARRAY_A);		if ( !$actual_post || $actual_post['post_type'] != 'post' )			return new IXR_Error(404, __('Sorry, no such post.'));		if ( !current_user_can('edit_post', $post_ID) )			return new IXR_Error(401, __('Sorry, you do not have the right to delete this post.'));		$result = wp_delete_post($post_ID);		if ( !$result )			return new IXR_Error(500, __('For some strange yet very annoying reason, this post could not be deleted.'));		return true;	}	/* MetaWeblog API functions	 * specs on wherever Dave Winer wants them to be	 */	/**	 * Create a new post.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return int	 */	function mw_newPost($args) {		$this->escape($args);		$blog_ID     = (int) $args[0]; // we will support this in the near future		$username  = $args[1];		$password   = $args[2];		$content_struct = $args[3];		$publish     = $args[4];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'metaWeblog.newPost');		$cap = ( $publish ) ? 'publish_posts' : 'edit_posts';		$error_message = __( 'Sorry, you are not allowed to publish posts on this site.' );		$post_type = 'post';		$page_template = '';		if ( !empty( $content_struct['post_type'] ) ) {			if ( $content_struct['post_type'] == 'page' ) {				$cap = ( $publish ) ? 'publish_pages' : 'edit_pages';				$error_message = __( 'Sorry, you are not allowed to publish pages on this site.' );				$post_type = 'page';				if ( !empty( $content_struct['wp_page_template'] ) )					$page_template = $content_struct['wp_page_template'];			} elseif ( $content_struct['post_type'] == 'post' ) {				// This is the default, no changes needed			} else {				// No other post_type values are allowed here				return new IXR_Error( 401, __( 'Invalid post type.' ) );			}		}		if ( !current_user_can( $cap ) )			return new IXR_Error( 401, $error_message );		// Let WordPress generate the post_name (slug) unless		// one has been provided.		$post_name = "";		if ( isset($content_struct["wp_slug"]) )			$post_name = $content_struct["wp_slug"];		// Only use a password if one was given.		if ( isset($content_struct["wp_password"]) )			$post_password = $content_struct["wp_password"];		// Only set a post parent if one was provided.		if ( isset($content_struct["wp_page_parent_id"]) )			$post_parent = $content_struct["wp_page_parent_id"];		// Only set the menu_order if it was provided.		if ( isset($content_struct["wp_page_order"]) )			$menu_order = $content_struct["wp_page_order"];		$post_author = $user->ID;		// If an author id was provided then use it instead.		if ( isset($content_struct["wp_author_id"]) && ($user->ID != $content_struct["wp_author_id"]) ) {			switch ( $post_type ) {				case "post":					if ( !current_user_can("edit_others_posts") )						return(new IXR_Error(401, __("You are not allowed to post as this user")));					break;				case "page":					if ( !current_user_can("edit_others_pages") )						return(new IXR_Error(401, __("You are not allowed to create pages as this user")));					break;				default:					return(new IXR_Error(401, __("Invalid post type.")));					break;			}			$post_author = $content_struct["wp_author_id"];		}		$post_title = $content_struct['title'];		$post_content = $content_struct['description'];		$post_status = $publish ? 'publish' : 'draft';		if ( isset( $content_struct["{$post_type}_status"] ) ) {			switch ( $content_struct["{$post_type}_status"] ) {				case 'draft':				case 'private':				case 'publish':					$post_status = $content_struct["{$post_type}_status"];					break;				case 'pending':					// Pending is only valid for posts, not pages.					if ( $post_type === 'post' )						$post_status = $content_struct["{$post_type}_status"];					break;				default:					$post_status = $publish ? 'publish' : 'draft';					break;			}		}		$post_excerpt = $content_struct['mt_excerpt'];		$post_more = $content_struct['mt_text_more'];		$tags_input = $content_struct['mt_keywords'];		if ( isset($content_struct["mt_allow_comments"]) ) {			if ( !is_numeric($content_struct["mt_allow_comments"]) ) {				switch ( $content_struct["mt_allow_comments"] ) {					case "closed":						$comment_status = "closed";						break;					case "open":						$comment_status = "open";						break;					default:						$comment_status = get_option("default_comment_status");						break;				}			} else {				switch ( (int) $content_struct["mt_allow_comments"] ) {					case 0:					case 2:						$comment_status = "closed";						break;					case 1:						$comment_status = "open";						break;					default:						$comment_status = get_option("default_comment_status");						break;				}			}		} else {			$comment_status = get_option("default_comment_status");		}		if ( isset($content_struct["mt_allow_pings"]) ) {			if ( !is_numeric($content_struct["mt_allow_pings"]) ) {				switch ( $content_struct['mt_allow_pings'] ) {					case "closed":						$ping_status = "closed";						break;					case "open":						$ping_status = "open";						break;					default:						$ping_status = get_option("default_ping_status");						break;				}			} else {				switch ( (int) $content_struct["mt_allow_pings"] ) {					case 0:						$ping_status = "closed";						break;					case 1:						$ping_status = "open";						break;					default:						$ping_status = get_option("default_ping_status");						break;				}			}		} else {			$ping_status = get_option("default_ping_status");		}		if ( $post_more )			$post_content = $post_content . "<!--more-->" . $post_more;		$to_ping = $content_struct['mt_tb_ping_urls'];		if ( is_array($to_ping) )			$to_ping = implode(' ', $to_ping);		// Do some timestamp voodoo		if ( !empty( $content_struct['date_created_gmt'] ) )			$dateCreated = str_replace( 'Z', '', $content_struct['date_created_gmt']->getIso() ) . 'Z'; // We know this is supposed to be GMT, so we're going to slap that Z on there by force		elseif ( !empty( $content_struct['dateCreated']) )			$dateCreated = $content_struct['dateCreated']->getIso();		if ( !empty( $dateCreated ) ) {			$post_date = get_date_from_gmt(iso8601_to_datetime($dateCreated));			$post_date_gmt = iso8601_to_datetime($dateCreated, GMT);		} else {			$post_date = current_time('mysql');			$post_date_gmt = current_time('mysql', 1);		}		$catnames = $content_struct['categories'];		logIO('O', 'Post cats: ' . var_export($catnames,true));		$post_category = array();		if ( is_array($catnames) ) {			foreach ($catnames as $cat) {				$post_category[] = get_cat_ID($cat);			}		}		// We've got all the data -- post it:		$postdata = compact('post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_title', 'post_category', 'post_status', 'post_excerpt', 'comment_status', 'ping_status', 'to_ping', 'post_type', 'post_name', 'post_password', 'post_parent', 'menu_order', 'tags_input', 'page_template');		$post_ID = wp_insert_post($postdata, true);		if ( is_wp_error( $post_ID ) )			return new IXR_Error(500, $post_ID->get_error_message());		if ( !$post_ID )			return new IXR_Error(500, __('Sorry, your entry could not be posted. Something wrong happened.'));		// Only posts can be sticky		if ( $post_type == 'post' && isset( $content_struct['sticky'] ) ) {			if ( $content_struct['sticky'] == true )				stick_post( $post_ID );			elseif ( $content_struct['sticky'] == false )				unstick_post( $post_ID );		}		if ( isset($content_struct['custom_fields']) )			$this->set_custom_fields($post_ID, $content_struct['custom_fields']);		// Handle enclosures		$this->add_enclosure_if_new($post_ID, $content_struct['enclosure']);		$this->attach_uploads( $post_ID, $post_content );		logIO('O', "Posted ! ID: $post_ID");		return strval($post_ID);	}	function add_enclosure_if_new($post_ID, $enclosure) {		if ( is_array( $enclosure ) && isset( $enclosure['url'] ) && isset( $enclosure['length'] ) && isset( $enclosure['type'] ) ) {			$encstring = $enclosure['url'] . "\n" . $enclosure['length'] . "\n" . $enclosure['type'];			$found = false;			foreach ( (array) get_post_custom($post_ID) as $key => $val) {				if ($key == 'enclosure') {					foreach ( (array) $val as $enc ) {						if ($enc == $encstring) {							$found = true;							break 2;						}					}				}			}			if (!$found)				add_post_meta( $post_ID, 'enclosure', $encstring );		}	}	/**	 * Attach upload to a post.	 *	 * @since 2.1.0	 *	 * @param int $post_ID Post ID.	 * @param string $post_content Post Content for attachment.	 */	function attach_uploads( $post_ID, $post_content ) {		global $wpdb;		// find any unattached files		$attachments = $wpdb->get_results( "SELECT ID, guid FROM {$wpdb->posts} WHERE post_parent = '0' AND post_type = 'attachment'" );		if ( is_array( $attachments ) ) {			foreach ( $attachments as $file ) {				if ( strpos( $post_content, $file->guid ) !== false )					$wpdb->update($wpdb->posts, array('post_parent' => $post_ID), array('ID' => $file->ID) );			}		}	}	/**	 * Edit a post.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return bool True on success.	 */	function mw_editPost($args) {		$this->escape($args);		$post_ID     = (int) $args[0];		$username  = $args[1];		$password   = $args[2];		$content_struct = $args[3];		$publish     = $args[4];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'metaWeblog.editPost');		$cap = ( $publish ) ? 'publish_posts' : 'edit_posts';		$error_message = __( 'Sorry, you are not allowed to publish posts on this site.' );		$post_type = 'post';		$page_template = '';		if ( !empty( $content_struct['post_type'] ) ) {			if ( $content_struct['post_type'] == 'page' ) {				$cap = ( $publish ) ? 'publish_pages' : 'edit_pages';				$error_message = __( 'Sorry, you are not allowed to publish pages on this site.' );				$post_type = 'page';				if ( !empty( $content_struct['wp_page_template'] ) )					$page_template = $content_struct['wp_page_template'];			} elseif ( $content_struct['post_type'] == 'post' ) {				// This is the default, no changes needed			} else {				// No other post_type values are allowed here				return new IXR_Error( 401, __( 'Invalid post type.' ) );			}		}		if ( !current_user_can( $cap ) )			return new IXR_Error( 401, $error_message );		$postdata = wp_get_single_post($post_ID, ARRAY_A);		// If there is no post data for the give post id, stop		// now and return an error.  Other wise a new post will be		// created (which was the old behavior).		if ( empty($postdata["ID"]) )			return(new IXR_Error(404, __("Invalid post ID.")));		$this->escape($postdata);		extract($postdata, EXTR_SKIP);		// Let WordPress manage slug if none was provided.		$post_name = "";		if ( isset($content_struct["wp_slug"]) )			$post_name = $content_struct["wp_slug"];		// Only use a password if one was given.		if ( isset($content_struct["wp_password"]) )			$post_password = $content_struct["wp_password"];		// Only set a post parent if one was given.		if ( isset($content_struct["wp_page_parent_id"]) )			$post_parent = $content_struct["wp_page_parent_id"];		// Only set the menu_order if it was given.		if ( isset($content_struct["wp_page_order"]) )			$menu_order = $content_struct["wp_page_order"];		$post_author = $postdata["post_author"];		// Only set the post_author if one is set.		if ( isset($content_struct["wp_author_id"]) && ($user->ID != $content_struct["wp_author_id"]) ) {			switch ( $post_type ) {				case "post":					if ( !current_user_can("edit_others_posts") )						return(new IXR_Error(401, __("You are not allowed to change the post author as this user.")));					break;				case "page":					if ( !current_user_can("edit_others_pages") )						return(new IXR_Error(401, __("You are not allowed to change the page author as this user.")));					break;				default:					return(new IXR_Error(401, __("Invalid post type.")));					break;			}			$post_author = $content_struct["wp_author_id"];		}		if ( isset($content_struct["mt_allow_comments"]) ) {			if ( !is_numeric($content_struct["mt_allow_comments"]) ) {				switch ( $content_struct["mt_allow_comments"] ) {					case "closed":						$comment_status = "closed";						break;					case "open":						$comment_status = "open";						break;					default:						$comment_status = get_option("default_comment_status");						break;				}			} else {				switch ( (int) $content_struct["mt_allow_comments"] ) {					case 0:					case 2:						$comment_status = "closed";						break;					case 1:						$comment_status = "open";						break;					default:						$comment_status = get_option("default_comment_status");						break;				}			}		}		if ( isset($content_struct["mt_allow_pings"]) ) {			if ( !is_numeric($content_struct["mt_allow_pings"]) ) {				switch ( $content_struct["mt_allow_pings"] ) {					case "closed":						$ping_status = "closed";						break;					case "open":						$ping_status = "open";						break;					default:						$ping_status = get_option("default_ping_status");						break;				}			} else {				switch ( (int) $content_struct["mt_allow_pings"] ) {					case 0:						$ping_status = "closed";						break;					case 1:						$ping_status = "open";						break;					default:						$ping_status = get_option("default_ping_status");						break;				}			}		}		$post_title = $content_struct['title'];		$post_content = $content_struct['description'];		$catnames = $content_struct['categories'];		$post_category = array();		if ( is_array($catnames) ) {			foreach ($catnames as $cat) {		 		$post_category[] = get_cat_ID($cat);			}		}		$post_excerpt = $content_struct['mt_excerpt'];		$post_more = $content_struct['mt_text_more'];		$post_status = $publish ? 'publish' : 'draft';		if ( isset( $content_struct["{$post_type}_status"] ) ) {			switch( $content_struct["{$post_type}_status"] ) {				case 'draft':				case 'private':				case 'publish':					$post_status = $content_struct["{$post_type}_status"];					break;				case 'pending':					// Pending is only valid for posts, not pages.					if ( $post_type === 'post' )						$post_status = $content_struct["{$post_type}_status"];					break;				default:					$post_status = $publish ? 'publish' : 'draft';					break;			}		}		$tags_input = $content_struct['mt_keywords'];		if ( ('publish' == $post_status) ) {			if ( ( 'page' == $post_type ) && !current_user_can('publish_pages') )				return new IXR_Error(401, __('Sorry, you do not have the right to publish this page.'));			else if ( !current_user_can('publish_posts') )				return new IXR_Error(401, __('Sorry, you do not have the right to publish this post.'));		}		if ( $post_more )			$post_content = $post_content . "<!--more-->" . $post_more;		$to_ping = $content_struct['mt_tb_ping_urls'];		if ( is_array($to_ping) )			$to_ping = implode(' ', $to_ping);		// Do some timestamp voodoo		if ( !empty( $content_struct['date_created_gmt'] ) )			$dateCreated = str_replace( 'Z', '', $content_struct['date_created_gmt']->getIso() ) . 'Z'; // We know this is supposed to be GMT, so we're going to slap that Z on there by force		elseif ( !empty( $content_struct['dateCreated']) )			$dateCreated = $content_struct['dateCreated']->getIso();		if ( !empty( $dateCreated ) ) {			$post_date = get_date_from_gmt(iso8601_to_datetime($dateCreated));			$post_date_gmt = iso8601_to_datetime($dateCreated, GMT);		} else {			$post_date     = $postdata['post_date'];			$post_date_gmt = $postdata['post_date_gmt'];		}		// We've got all the data -- post it:		$newpost = compact('ID', 'post_content', 'post_title', 'post_category', 'post_status', 'post_excerpt', 'comment_status', 'ping_status', 'post_date', 'post_date_gmt', 'to_ping', 'post_name', 'post_password', 'post_parent', 'menu_order', 'post_author', 'tags_input', 'page_template');		$result = wp_update_post($newpost, true);		if ( is_wp_error( $result ) )			return new IXR_Error(500, $result->get_error_message());		if ( !$result )			return new IXR_Error(500, __('Sorry, your entry could not be edited. Something wrong happened.'));		// Only posts can be sticky		if ( $post_type == 'post' && isset( $content_struct['sticky'] ) ) {			if ( $content_struct['sticky'] == true )				stick_post( $post_ID );			elseif ( $content_struct['sticky'] == false )				unstick_post( $post_ID );		}		if ( isset($content_struct['custom_fields']) )			$this->set_custom_fields($post_ID, $content_struct['custom_fields']);		// Handle enclosures		$this->add_enclosure_if_new($post_ID, $content_struct['enclosure']);		$this->attach_uploads( $ID, $post_content );		logIO('O',"(MW) Edited ! ID: $post_ID");		return true;	}	/**	 * Retrieve post.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function mw_getPost($args) {		$this->escape($args);		$post_ID     = (int) $args[0];		$username  = $args[1];		$password   = $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_post', $post_ID ) )			return new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );		do_action('xmlrpc_call', 'metaWeblog.getPost');		$postdata = wp_get_single_post($post_ID, ARRAY_A);		if ($postdata['post_date'] != '') {			$post_date = mysql2date('Ymd\TH:i:s', $postdata['post_date'], false);			$post_date_gmt = mysql2date('Ymd\TH:i:s', $postdata['post_date_gmt'], false);			// For drafts use the GMT version of the post date			if ( $postdata['post_status'] == 'draft' )				$post_date_gmt = get_gmt_from_date( mysql2date( 'Y-m-d H:i:s', $postdata['post_date'] ), 'Ymd\TH:i:s' );			$categories = array();			$catids = wp_get_post_categories($post_ID);			foreach($catids as $catid)				$categories[] = get_cat_name($catid);			$tagnames = array();			$tags = wp_get_post_tags( $post_ID );			if ( !empty( $tags ) ) {				foreach ( $tags as $tag )					$tagnames[] = $tag->name;				$tagnames = implode( ', ', $tagnames );			} else {				$tagnames = '';			}			$post = get_extended($postdata['post_content']);			$link = post_permalink($postdata['ID']);			// Get the author info.			$author = get_userdata($postdata['post_author']);			$allow_comments = ('open' == $postdata['comment_status']) ? 1 : 0;			$allow_pings = ('open' == $postdata['ping_status']) ? 1 : 0;			// Consider future posts as published			if ( $postdata['post_status'] === 'future' )				$postdata['post_status'] = 'publish';			$sticky = false;			if ( is_sticky( $post_ID ) )				$sticky = true;			$enclosure = array();			foreach ( (array) get_post_custom($post_ID) as $key => $val) {				if ($key == 'enclosure') {					foreach ( (array) $val as $enc ) {						$encdata = split("\n", $enc);						$enclosure['url'] = trim(htmlspecialchars($encdata[0]));						$enclosure['length'] = (int) trim($encdata[1]);						$enclosure['type'] = trim($encdata[2]);						break 2;					}				}			}			$resp = array(				'dateCreated' => new IXR_Date($post_date),				'userid' => $postdata['post_author'],				'postid' => $postdata['ID'],				'description' => $post['main'],				'title' => $postdata['post_title'],				'link' => $link,				'permaLink' => $link,				// commented out because no other tool seems to use this				//	      'content' => $entry['post_content'],				'categories' => $categories,				'mt_excerpt' => $postdata['post_excerpt'],				'mt_text_more' => $post['extended'],				'mt_allow_comments' => $allow_comments,				'mt_allow_pings' => $allow_pings,				'mt_keywords' => $tagnames,				'wp_slug' => $postdata['post_name'],				'wp_password' => $postdata['post_password'],				'wp_author_id' => $author->ID,				'wp_author_display_name'	=> $author->display_name,				'date_created_gmt' => new IXR_Date($post_date_gmt),				'post_status' => $postdata['post_status'],				'custom_fields' => $this->get_custom_fields($post_ID),				'sticky' => $sticky			);			if ( !empty($enclosure) ) $resp['enclosure'] = $enclosure;			return $resp;		} else {			return new IXR_Error(404, __('Sorry, no such post.'));		}	}	/**	 * Retrieve list of recent posts.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function mw_getRecentPosts($args) {		$this->escape($args);		$blog_ID     = (int) $args[0];		$username  = $args[1];		$password   = $args[2];		$num_posts   = (int) $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'metaWeblog.getRecentPosts');		$posts_list = wp_get_recent_posts($num_posts);		if ( !$posts_list )			return array( );		foreach ($posts_list as $entry) {			if ( !current_user_can( 'edit_post', $entry['ID'] ) )				continue;			$post_date = mysql2date('Ymd\TH:i:s', $entry['post_date'], false);			$post_date_gmt = mysql2date('Ymd\TH:i:s', $entry['post_date_gmt'], false);			// For drafts use the GMT version of the date			if ( $entry['post_status'] == 'draft' )				$post_date_gmt = get_gmt_from_date( mysql2date( 'Y-m-d H:i:s', $entry['post_date'] ), 'Ymd\TH:i:s' );			$categories = array();			$catids = wp_get_post_categories($entry['ID']);			foreach( $catids as $catid )				$categories[] = get_cat_name($catid);			$tagnames = array();			$tags = wp_get_post_tags( $entry['ID'] );			if ( !empty( $tags ) ) {				foreach ( $tags as $tag ) {					$tagnames[] = $tag->name;				}				$tagnames = implode( ', ', $tagnames );			} else {				$tagnames = '';			}			$post = get_extended($entry['post_content']);			$link = post_permalink($entry['ID']);			// Get the post author info.			$author = get_userdata($entry['post_author']);			$allow_comments = ('open' == $entry['comment_status']) ? 1 : 0;			$allow_pings = ('open' == $entry['ping_status']) ? 1 : 0;			// Consider future posts as published			if ( $entry['post_status'] === 'future' )				$entry['post_status'] = 'publish';			$struct[] = array(				'dateCreated' => new IXR_Date($post_date),				'userid' => $entry['post_author'],				'postid' => $entry['ID'],				'description' => $post['main'],				'title' => $entry['post_title'],				'link' => $link,				'permaLink' => $link,				// commented out because no other tool seems to use this				// 'content' => $entry['post_content'],				'categories' => $categories,				'mt_excerpt' => $entry['post_excerpt'],				'mt_text_more' => $post['extended'],				'mt_allow_comments' => $allow_comments,				'mt_allow_pings' => $allow_pings,				'mt_keywords' => $tagnames,				'wp_slug' => $entry['post_name'],				'wp_password' => $entry['post_password'],				'wp_author_id' => $author->ID,				'wp_author_display_name' => $author->display_name,				'date_created_gmt' => new IXR_Date($post_date_gmt),				'post_status' => $entry['post_status'],				'custom_fields' => $this->get_custom_fields($entry['ID'])			);		}		$recent_posts = array();		for ( $j=0; $j<count($struct); $j++ ) {			array_push($recent_posts, $struct[$j]);		}		return $recent_posts;	}	/**	 * Retrieve the list of categories on a given blog.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function mw_getCategories($args) {		$this->escape($args);		$blog_ID     = (int) $args[0];		$username  = $args[1];		$password   = $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_posts' ) )			return new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view categories.' ) );		do_action('xmlrpc_call', 'metaWeblog.getCategories');		$categories_struct = array();		if ( $cats = get_categories(array('get' => 'all')) ) {			foreach ( $cats as $cat ) {				$struct['categoryId'] = $cat->term_id;				$struct['parentId'] = $cat->parent;				$struct['description'] = $cat->name;				$struct['categoryDescription'] = $cat->description;				$struct['categoryName'] = $cat->name;				$struct['htmlUrl'] = esc_html(get_category_link($cat->term_id));				$struct['rssUrl'] = esc_html(get_category_feed_link($cat->term_id, 'rss2'));				$categories_struct[] = $struct;			}		}		return $categories_struct;	}	/**	 * Uploads a file, following your settings.	 *	 * Adapted from a patch by Johann Richard.	 *	 * @link http://mycvs.org/archives/2004/06/30/file-upload-to-wordpress-in-ecto/	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function mw_newMediaObject($args) {		global $wpdb;		$blog_ID     = (int) $args[0];		$username  = $wpdb->escape($args[1]);		$password   = $wpdb->escape($args[2]);		$data        = $args[3];		$name = sanitize_file_name( $data['name'] );		$type = $data['type'];		$bits = $data['bits'];		logIO('O', '(MW) Received '.strlen($bits).' bytes');		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'metaWeblog.newMediaObject');		if ( !current_user_can('upload_files') ) {			logIO('O', '(MW) User does not have upload_files capability');			$this->error = new IXR_Error(401, __('You are not allowed to upload files to this site.'));			return $this->error;		}		if ( $upload_err = apply_filters( "pre_upload_error", false ) )			return new IXR_Error(500, $upload_err);		if ( !empty($data["overwrite"]) && ($data["overwrite"] == true) ) {			// Get postmeta info on the object.			$old_file = $wpdb->get_row("				SELECT ID				FROM {$wpdb->posts}				WHERE post_title = '{$name}'					AND post_type = 'attachment'			");			// Delete previous file.			wp_delete_attachment($old_file->ID);			// Make sure the new name is different by pre-pending the			// previous post id.			$filename = preg_replace("/^wpid\d+-/", "", $name);			$name = "wpid{$old_file->ID}-{$filename}";		}		$upload = wp_upload_bits($name, $type, $bits);		if ( ! empty($upload['error']) ) {			$errorString = sprintf(__('Could not write file %1$s (%2$s)'), $name, $upload['error']);			logIO('O', '(MW) ' . $errorString);			return new IXR_Error(500, $errorString);		}		// Construct the attachment array		// attach to post_id 0		$post_id = 0;		$attachment = array(			'post_title' => $name,			'post_content' => '',			'post_type' => 'attachment',			'post_parent' => $post_id,			'post_mime_type' => $type,			'guid' => $upload[ 'url' ]		);		// Save the data		$id = wp_insert_attachment( $attachment, $upload[ 'file' ], $post_id );		wp_update_attachment_metadata( $id, wp_generate_attachment_metadata( $id, $upload['file'] ) );		return apply_filters( 'wp_handle_upload', array( 'file' => $name, 'url' => $upload[ 'url' ], 'type' => $type ), 'upload' );	}	/* MovableType API functions	 * specs on http://www.movabletype.org/docs/mtmanual_programmatic.html	 */	/**	 * Retrieve the post titles of recent posts.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function mt_getRecentPostTitles($args) {		$this->escape($args);		$blog_ID     = (int) $args[0];		$username  = $args[1];		$password   = $args[2];		$num_posts   = (int) $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'mt.getRecentPostTitles');		$posts_list = wp_get_recent_posts($num_posts);		if ( !$posts_list ) {			$this->error = new IXR_Error(500, __('Either there are no posts, or something went wrong.'));			return $this->error;		}		foreach ($posts_list as $entry) {			if ( !current_user_can( 'edit_post', $entry['ID'] ) )				continue;			$post_date = mysql2date('Ymd\TH:i:s', $entry['post_date'], false);			$post_date_gmt = mysql2date('Ymd\TH:i:s', $entry['post_date_gmt'], false);			// For drafts use the GMT version of the date			if ( $entry['post_status'] == 'draft' )				$post_date_gmt = get_gmt_from_date( mysql2date( 'Y-m-d H:i:s', $entry['post_date'] ), 'Ymd\TH:i:s' );			$struct[] = array(				'dateCreated' => new IXR_Date($post_date),				'userid' => $entry['post_author'],				'postid' => $entry['ID'],				'title' => $entry['post_title'],				'date_created_gmt' => new IXR_Date($post_date_gmt)			);		}		$recent_posts = array();		for ( $j=0; $j<count($struct); $j++ ) {			array_push($recent_posts, $struct[$j]);		}		return $recent_posts;	}	/**	 * Retrieve list of all categories on blog.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function mt_getCategoryList($args) {		$this->escape($args);		$blog_ID     = (int) $args[0];		$username  = $args[1];		$password   = $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_posts' ) )			return new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view categories.' ) );		do_action('xmlrpc_call', 'mt.getCategoryList');		$categories_struct = array();		if ( $cats = get_categories(array('hide_empty' => 0, 'hierarchical' => 0)) ) {			foreach ( $cats as $cat ) {				$struct['categoryId'] = $cat->term_id;				$struct['categoryName'] = $cat->name;				$categories_struct[] = $struct;			}		}		return $categories_struct;	}	/**	 * Retrieve post categories.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function mt_getPostCategories($args) {		$this->escape($args);		$post_ID     = (int) $args[0];		$username  = $args[1];		$password   = $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		if ( !current_user_can( 'edit_post', $post_ID ) )			return new IXR_Error( 401, __( 'Sorry, you can not edit this post.' ) );		do_action('xmlrpc_call', 'mt.getPostCategories');		$categories = array();		$catids = wp_get_post_categories(intval($post_ID));		// first listed category will be the primary category		$isPrimary = true;		foreach ( $catids as $catid ) {			$categories[] = array(				'categoryName' => get_cat_name($catid),				'categoryId' => (string) $catid,				'isPrimary' => $isPrimary			);			$isPrimary = false;		}		return $categories;	}	/**	 * Sets categories for a post.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return bool True on success.	 */	function mt_setPostCategories($args) {		$this->escape($args);		$post_ID     = (int) $args[0];		$username  = $args[1];		$password   = $args[2];		$categories  = $args[3];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'mt.setPostCategories');		if ( !current_user_can('edit_post', $post_ID) )			return new IXR_Error(401, __('Sorry, you cannot edit this post.'));		foreach ( $categories as $cat ) {			$catids[] = $cat['categoryId'];		}		wp_set_post_categories($post_ID, $catids);		return true;	}	/**	 * Retrieve an array of methods supported by this server.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function mt_supportedMethods($args) {		do_action('xmlrpc_call', 'mt.supportedMethods');		$supported_methods = array();		foreach ( $this->methods as $key => $value ) {			$supported_methods[] = $key;		}		return $supported_methods;	}	/**	 * Retrieve an empty array because we don't support per-post text filters.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 */	function mt_supportedTextFilters($args) {		do_action('xmlrpc_call', 'mt.supportedTextFilters');		return apply_filters('xmlrpc_text_filters', array());	}	/**	 * Retrieve trackbacks sent to a given post.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return mixed	 */	function mt_getTrackbackPings($args) {		global $wpdb;		$post_ID = intval($args);		do_action('xmlrpc_call', 'mt.getTrackbackPings');		$actual_post = wp_get_single_post($post_ID, ARRAY_A);		if ( !$actual_post )			return new IXR_Error(404, __('Sorry, no such post.'));		$comments = $wpdb->get_results( $wpdb->prepare("SELECT comment_author_url, comment_content, comment_author_IP, comment_type FROM $wpdb->comments WHERE comment_post_ID = %d", $post_ID) );		if ( !$comments )			return array();		$trackback_pings = array();		foreach ( $comments as $comment ) {			if ( 'trackback' == $comment->comment_type ) {				$content = $comment->comment_content;				$title = substr($content, 8, (strpos($content, '</strong>') - 8));				$trackback_pings[] = array(					'pingTitle' => $title,					'pingURL'   => $comment->comment_author_url,					'pingIP'    => $comment->comment_author_IP				);			}		}		return $trackback_pings;	}	/**	 * Sets a post's publish status to 'publish'.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return int	 */	function mt_publishPost($args) {		$this->escape($args);		$post_ID     = (int) $args[0];		$username  = $args[1];		$password   = $args[2];		if ( !$user = $this->login($username, $password) )			return $this->error;		do_action('xmlrpc_call', 'mt.publishPost');		if ( !current_user_can('edit_post', $post_ID) )			return new IXR_Error(401, __('Sorry, you cannot edit this post.'));		$postdata = wp_get_single_post($post_ID,ARRAY_A);		$postdata['post_status'] = 'publish';		// retain old cats		$cats = wp_get_post_categories($post_ID);		$postdata['post_category'] = $cats;		$this->escape($postdata);		$result = wp_update_post($postdata);		return $result;	}	/* PingBack functions	 * specs on www.hixie.ch/specs/pingback/pingback	 */	/**	 * Retrieves a pingback and registers it.	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function pingback_ping($args) {		global $wpdb;		do_action('xmlrpc_call', 'pingback.ping');		$this->escape($args);		$pagelinkedfrom = $args[0];		$pagelinkedto   = $args[1];		$title = '';		$pagelinkedfrom = str_replace('&amp;', '&', $pagelinkedfrom);		$pagelinkedto = str_replace('&amp;', '&', $pagelinkedto);		$pagelinkedto = str_replace('&', '&amp;', $pagelinkedto);		// Check if the page linked to is in our site		$pos1 = strpos($pagelinkedto, str_replace(array('http://www.','http://','https://www.','https://'), '', get_option('home')));		if ( !$pos1 )			return new IXR_Error(0, __('Is there no link to us?'));		// let's find which post is linked to		// FIXME: does url_to_postid() cover all these cases already?		//        if so, then let's use it and drop the old code.		$urltest = parse_url($pagelinkedto);		if ( $post_ID = url_to_postid($pagelinkedto) ) {			$way = 'url_to_postid()';		} elseif ( preg_match('#p/[0-9]{1,}#', $urltest['path'], $match) ) {			// the path defines the post_ID (archives/p/XXXX)			$blah = explode('/', $match[0]);			$post_ID = (int) $blah[1];			$way = 'from the path';		} elseif ( preg_match('#p=[0-9]{1,}#', $urltest['query'], $match) ) {			// the querystring defines the post_ID (?p=XXXX)			$blah = explode('=', $match[0]);			$post_ID = (int) $blah[1];			$way = 'from the querystring';		} elseif ( isset($urltest['fragment']) ) {			// an #anchor is there, it's either...			if ( intval($urltest['fragment']) ) {				// ...an integer #XXXX (simpliest case)				$post_ID = (int) $urltest['fragment'];				$way = 'from the fragment (numeric)';			} elseif ( preg_match('/post-[0-9]+/',$urltest['fragment']) ) {				// ...a post id in the form 'post-###'				$post_ID = preg_replace('/[^0-9]+/', '', $urltest['fragment']);				$way = 'from the fragment (post-###)';			} elseif ( is_string($urltest['fragment']) ) {				// ...or a string #title, a little more complicated				$title = preg_replace('/[^a-z0-9]/i', '.', $urltest['fragment']);				$sql = $wpdb->prepare("SELECT ID FROM $wpdb->posts WHERE post_title RLIKE %s", $title);				if (! ($post_ID = $wpdb->get_var($sql)) ) {					// returning unknown error '0' is better than die()ing			  		return new IXR_Error(0, '');				}				$way = 'from the fragment (title)';			}		} else {			// TODO: Attempt to extract a post ID from the given URL	  		return new IXR_Error(33, __('The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.'));		}		$post_ID = (int) $post_ID;		logIO("O","(PB) URL='$pagelinkedto' ID='$post_ID' Found='$way'");		$post = get_post($post_ID);		if ( !$post ) // Post_ID not found	  		return new IXR_Error(33, __('The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.'));		if ( $post_ID == url_to_postid($pagelinkedfrom) )			return new IXR_Error(0, __('The source URL and the target URL cannot both point to the same resource.'));		// Check if pings are on		if ( !pings_open($post) )	  		return new IXR_Error(33, __('The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.'));		// Let's check that the remote site didn't already pingback this entry		if ( $wpdb->get_results( $wpdb->prepare("SELECT * FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_author_url = %s", $post_ID, $pagelinkedfrom) ) )			return new IXR_Error( 48, __( 'The pingback has already been registered.' ) );		// very stupid, but gives time to the 'from' server to publish !		sleep(1);		// Let's check the remote site		$linea = wp_remote_fopen( $pagelinkedfrom );		if ( !$linea )	  		return new IXR_Error(16, __('The source URL does not exist.'));		$linea = apply_filters('pre_remote_source', $linea, $pagelinkedto);		// Work around bug in strip_tags():		$linea = str_replace('<!DOC', '<DOC', $linea);		$linea = preg_replace( '/[\s\r\n\t]+/', ' ', $linea ); // normalize spaces		$linea = preg_replace( "/ <(h1|h2|h3|h4|h5|h6|p|th|td|li|dt|dd|pre|caption|input|textarea|button|body)[^>]*>/", "\n\n", $linea );		preg_match('|<title>([^<]*?)</title>|is', $linea, $matchtitle);		$title = $matchtitle[1];		if ( empty( $title ) )			return new IXR_Error(32, __('We cannot find a title on that page.'));		$linea = strip_tags( $linea, '<a>' ); // just keep the tag we need		$p = explode( "\n\n", $linea );		$preg_target = preg_quote($pagelinkedto, '|');		foreach ( $p as $para ) {			if ( strpos($para, $pagelinkedto) !== false ) { // it exists, but is it a link?				preg_match("|<a[^>]+?".$preg_target."[^>]*>([^>]+?)</a>|", $para, $context);				// If the URL isn't in a link context, keep looking				if ( empty($context) )					continue;				// We're going to use this fake tag to mark the context in a bit				// the marker is needed in case the link text appears more than once in the paragraph				$excerpt = preg_replace('|\</?wpcontext\>|', '', $para);				// prevent really long link text				if ( strlen($context[1]) > 100 )					$context[1] = substr($context[1], 0, 100) . '...';				$marker = '<wpcontext>'.$context[1].'</wpcontext>';    // set up our marker				$excerpt= str_replace($context[0], $marker, $excerpt); // swap out the link for our marker				$excerpt = strip_tags($excerpt, '<wpcontext>');        // strip all tags but our context marker				$excerpt = trim($excerpt);				$preg_marker = preg_quote($marker, '|');				$excerpt = preg_replace("|.*?\s(.{0,100}$preg_marker.{0,100})\s.*|s", '$1', $excerpt);				$excerpt = strip_tags($excerpt); // YES, again, to remove the marker wrapper				break;			}		}		if ( empty($context) ) // Link to target not found			return new IXR_Error(17, __('The source URL does not contain a link to the target URL, and so cannot be used as a source.'));		$pagelinkedfrom = str_replace('&', '&amp;', $pagelinkedfrom);		$context = '[...] ' . esc_html( $excerpt ) . ' [...]';		$pagelinkedfrom = $wpdb->escape( $pagelinkedfrom );		$comment_post_ID = (int) $post_ID;		$comment_author = $title;		$this->escape($comment_author);		$comment_author_url = $pagelinkedfrom;		$comment_content = $context;		$this->escape($comment_content);		$comment_type = 'pingback';		$commentdata = compact('comment_post_ID', 'comment_author', 'comment_author_url', 'comment_content', 'comment_type');		$comment_ID = wp_new_comment($commentdata);		do_action('pingback_post', $comment_ID);		return sprintf(__('Pingback from %1$s to %2$s registered. Keep the web talking! :-)'), $pagelinkedfrom, $pagelinkedto);	}	/**	 * Retrieve array of URLs that pingbacked the given URL.	 *	 * Specs on http://www.aquarionics.com/misc/archives/blogite/0198.html	 *	 * @since 1.5.0	 *	 * @param array $args Method parameters.	 * @return array	 */	function pingback_extensions_getPingbacks($args) {		global $wpdb;		do_action('xmlrpc_call', 'pingback.extensions.getPingbacks');		$this->escape($args);		$url = $args;		$post_ID = url_to_postid($url);		if ( !$post_ID ) {			// We aren't sure that the resource is available and/or pingback enabled	  		return new IXR_Error(33, __('The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.'));		}		$actual_post = wp_get_single_post($post_ID, ARRAY_A);		if ( !$actual_post ) {			// No such post = resource not found	  		return new IXR_Error(32, __('The specified target URL does not exist.'));		}		$comments = $wpdb->get_results( $wpdb->prepare("SELECT comment_author_url, comment_content, comment_author_IP, comment_type FROM $wpdb->comments WHERE comment_post_ID = %d", $post_ID) );		if ( !$comments )			return array();		$pingbacks = array();		foreach ( $comments as $comment ) {			if ( 'pingback' == $comment->comment_type )				$pingbacks[] = $comment->comment_author_url;		}		return $pingbacks;	}}$wp_xmlrpc_server = new wp_xmlrpc_server();$wp_xmlrpc_server->serve_request();?>
<?php/** * Site/blog functions that work with the blogs table and related data. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */// @todo use update_blog_detailsfunction wpmu_update_blogs_date() {	global $wpdb;	$wpdb->update( $wpdb->blogs, array('last_updated' => current_time('mysql', true)), array('blog_id' => $wpdb->blogid) );	refresh_blog_details( $wpdb->blogid );	do_action( 'wpmu_blog_updated', $wpdb->blogid );}function get_blogaddress_by_id( $blog_id ) {	$bloginfo = get_blog_details( (int) $blog_id, false ); // only get bare details!	return esc_url( 'http://' . $bloginfo->domain . $bloginfo->path );}function get_blogaddress_by_name( $blogname ) {	global $current_site;	if ( is_subdomain_install() ) {		if ( $blogname == 'main' )			$blogname = 'www';		$url = rtrim( network_home_url(), '/' );		if ( !empty( $blogname ) )			$url = preg_replace( '|^([^\.]+://)|', '$1' . $blogname . '.', $url );	} else {		$url = network_home_url( $blogname );	}	return esc_url( $url . '/' );}function get_blogaddress_by_domain( $domain, $path ){	if ( is_subdomain_install() ) {		$url = "http://".$domain.$path;	} else {		if ( $domain != $_SERVER['HTTP_HOST'] ) {			$blogname = substr( $domain, 0, strpos( $domain, '.' ) );			$url = 'http://' . substr( $domain, strpos( $domain, '.' ) + 1 ) . $path;			// we're not installing the main blog			if ( $blogname != 'www.' )				$url .= $blogname . '/';		} else { // main blog			$url = 'http://' . $domain . $path;		}	}	return esc_url( $url );}function get_id_from_blogname( $name ) {	global $wpdb, $current_site;	$blog_id = wp_cache_get( "get_id_from_blogname_" . $name, 'blog-details' );	if ( $blog_id )		return $blog_id;	if ( is_subdomain_install() ) {		$domain = $name . '.' . $current_site->domain;		$path = $current_site->path;	} else {		$domain = $current_site->domain;		$path = $current_site->path . $name . '/';	}	$blog_id = $wpdb->get_var( $wpdb->prepare("SELECT blog_id FROM {$wpdb->blogs} WHERE domain = %s AND path = %s", $domain, $path) );	wp_cache_set( 'get_id_from_blogname_' . $name, $blog_id, 'blog-details' );	return $blog_id;}/** * Retrieve the details for a blog from the blogs table and blog options. * * @since 3.0.0 * @param int|string|array $fields A blog ID, a blog name, or an array of fields to query against. * @param bool $get_all Whether to retrieve all details or only the details in the blogs table. Default is true. * @return object Blog details. */function get_blog_details( $fields, $get_all = true ) {	global $wpdb;	if ( is_array($fields ) ) {		if ( isset($fields['blog_id']) ) {			$blog_id = $fields['blog_id'];		} elseif ( isset($fields['domain']) && isset($fields['path']) ) {			$key = md5( $fields['domain'] . $fields['path'] );			$blog = wp_cache_get($key, 'blog-lookup');			if ( false !== $blog )				return $blog;			if ( substr( $fields['domain'], 0, 4 ) == 'www.' ) {				$nowww = substr( $fields['domain'], 4 );				$blog = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->blogs WHERE domain IN (%s,%s) AND path = %s ORDER BY CHAR_LENGTH(domain) DESC", $nowww, $fields['domain'], $fields['path'] ) );			} else {				$blog = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->blogs WHERE domain = %s AND path = %s", $fields['domain'], $fields['path'] ) );			}			if ( $blog ) {				wp_cache_set($blog->blog_id . 'short', $blog, 'blog-details');				$blog_id = $blog->blog_id;			} else {				return false;			}		} elseif ( isset($fields['domain']) && is_subdomain_install() ) {			$key = md5( $fields['domain'] );			$blog = wp_cache_get($key, 'blog-lookup');			if ( false !== $blog )				return $blog;			if ( substr( $fields['domain'], 0, 4 ) == 'www.' ) {				$nowww = substr( $fields['domain'], 4 );				$blog = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->blogs WHERE domain IN (%s,%s) ORDER BY CHAR_LENGTH(domain) DESC", $nowww, $fields['domain'] ) );			} else {				$blog = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->blogs WHERE domain = %s", $fields['domain'] ) );			}			if ( $blog ) {				wp_cache_set($blog->blog_id . 'short', $blog, 'blog-details');				$blog_id = $blog->blog_id;			} else {				return false;			}		} else {			return false;		}	} else {		if ( !is_numeric( $fields ) )			$blog_id = get_id_from_blogname( $fields );		else			$blog_id = $fields;	}	$blog_id = (int) $blog_id;	$all = $get_all == true ? '' : 'short';	$details = wp_cache_get( $blog_id . $all, 'blog-details' );	if ( $details ) {		if ( ! is_object( $details ) ) {			if ( $details == -1 ) {				return false;			} else {				// Clear old pre-serialized objects. Cache clients do better with that.				wp_cache_delete( $blog_id . $all, 'blog-details' );				unset($details);			}		} else {			return $details;		}	}	// Try the other cache.	if ( $get_all ) {		$details = wp_cache_get( $blog_id . 'short', 'blog-details' );	} else {		$details = wp_cache_get( $blog_id, 'blog-details' );		// If short was requested and full cache is set, we can return.		if ( $details ) {			if ( ! is_object( $details ) ) {				if ( $details == -1 ) {					return false;				} else {					// Clear old pre-serialized objects. Cache clients do better with that.					wp_cache_delete( $blog_id, 'blog-details' );					unset($details);				}			} else {				return $details;			}		}	}	if ( empty($details) ) {		$details = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->blogs WHERE blog_id = %d /* get_blog_details */", $blog_id ) );		if ( ! $details ) {			// Set the full cache.			wp_cache_set( $blog_id, -1, 'blog-details' );			return false;		}	}	if ( ! $get_all ) {		wp_cache_set( $blog_id . $all, $details, 'blog-details' );		return $details;	}	$details->blogname		= get_blog_option( $blog_id, 'blogname' );	$details->siteurl		= get_blog_option( $blog_id, 'siteurl' );	$details->post_count	= get_blog_option( $blog_id, 'post_count' );	$details = apply_filters( 'blog_details', $details );	wp_cache_set( $blog_id . $all, $details, 'blog-details' );	$key = md5( $details->domain . $details->path );	wp_cache_set( $key, $details, 'blog-lookup' );	return $details;}/** * Clear the blog details cache. * * @since 3.0.0 * * @param int $blog_id Blog ID */function refresh_blog_details( $blog_id ) {	$blog_id = (int) $blog_id;	$details = get_blog_details( $blog_id, false );	wp_cache_delete( $blog_id , 'blog-details' );	wp_cache_delete( $blog_id . 'short' , 'blog-details' );	wp_cache_delete( md5( $details->domain . $details->path )  , 'blog-lookup' );	wp_cache_delete( 'current_blog_' . $details->domain, 'site-options' );	wp_cache_delete( 'current_blog_' . $details->domain . $details->path, 'site-options' );}/** * Update the details for a blog. Updates the blogs table for a given blog id. * * @since 3.0.0 * * @param int $blog_id Blog ID * @param array $details Array of details keyed by blogs table field names. * @return bool True if update succeeds, false otherwise. */function update_blog_details( $blog_id, $details = array() ) {	global $wpdb;	if ( empty($details) )		return false;	if ( is_object($details) )		$details = get_object_vars($details);	$current_details = get_blog_details($blog_id, false);	if ( empty($current_details) )		return false;	$current_details = get_object_vars($current_details);	$details = array_merge($current_details, $details);	$details['last_updated'] = current_time('mysql', true);	$update_details = array();	$fields = array( 'site_id', 'domain', 'path', 'registered', 'last_updated', 'public', 'archived', 'mature', 'spam', 'deleted', 'lang_id');	foreach ( array_intersect( array_keys( $details ), $fields ) as $field )		$update_details[$field] = $details[$field];	$wpdb->update( $wpdb->blogs, $update_details, array('blog_id' => $blog_id) );	// If spam status changed, issue actions.	if ( $details[ 'spam' ] != $current_details[ 'spam' ] ) {		if ( $details[ 'spam' ] == 1 )			do_action( "make_spam_blog", $blog_id );		else			do_action( "make_ham_blog", $blog_id );	}	if ( isset($details[ 'public' ]) )		update_blog_option( $blog_id, 'blog_public', $details[ 'public' ], false );	refresh_blog_details($blog_id);	return true;}/** * Retrieve option value based on setting name and blog_id. * * If the option does not exist or does not have a value, then the return value * will be false. This is useful to check whether you need to install an option * and is commonly used during installation of plugin options and to test * whether upgrading is required. * * There is a filter called 'blog_option_$option' with the $option being * replaced with the option name. The filter takes two parameters. $value and * $blog_id. It returns $value. * The 'option_$option' filter in get_option() is not called. * * @since NA * @package WordPress MU * @subpackage Option * @uses apply_filters() Calls 'blog_option_$optionname' with the option name value. * * @param int $blog_id is the id of the blog. * @param string $setting Name of option to retrieve. Should already be SQL-escaped * @param string $default (optional) Default value returned if option not found. * @return mixed Value set for the option. */function get_blog_option( $blog_id, $setting, $default = false ) {	global $wpdb;	$key = $blog_id."-".$setting."-blog_option";	$value = wp_cache_get( $key, "site-options" );	if ( $value == null ) {		if ( $blog_id == $wpdb->blogid ) {			$value = get_option( $setting, $default );			$notoptions = wp_cache_get( 'notoptions', 'options' );			if ( isset( $notoptions[$setting] ) ) {				wp_cache_set( $key, 'noop', 'site-options' );				$value = $default;			} elseif ( $value == false ) {				wp_cache_set( $key, 'falsevalue', 'site-options' );			} else {				wp_cache_set( $key, $value, 'site-options' );			}			return apply_filters( 'blog_option_' . $setting, $value, $blog_id );		} else {			$blog_prefix = $wpdb->get_blog_prefix( $blog_id );			$row = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM {$blog_prefix}options WHERE option_name = %s", $setting ) );			if ( is_object( $row ) ) { // Has to be get_row instead of get_var because of funkiness with 0, false, null values				$value = $row->option_value;				if ( $value == false )					wp_cache_set( $key, 'falsevalue', 'site-options' );				else					wp_cache_set( $key, $value, 'site-options' );			} else { // option does not exist, so we must cache its non-existence				wp_cache_set( $key, 'noop', 'site-options' );				$value = $default;			}		}	} elseif ( $value == 'noop' ) {		$value = $default;	} elseif ( $value == 'falsevalue' ) {		$value = false;	}	// If home is not set use siteurl.	if ( 'home' == $setting && '' == $value )		return get_blog_option( $blog_id, 'siteurl' );	if ( 'siteurl' == $setting || 'home' == $setting || 'category_base' == $setting )		$value = untrailingslashit( $value );	if (! @unserialize( $value ) )		$value = stripslashes( $value );	return apply_filters( 'blog_option_' . $setting, maybe_unserialize( $value ), $blog_id );}function add_blog_option( $id, $key, $value ) {	$id = (int) $id;	switch_to_blog($id);	add_option( $key, $value );	restore_current_blog();	wp_cache_set( $id."-".$key."-blog_option", $value, 'site-options' );}function delete_blog_option( $id, $key ) {	$id = (int) $id;	switch_to_blog($id);	delete_option( $key );	restore_current_blog();	wp_cache_set( $id."-".$key."-blog_option", '', 'site-options' );}function update_blog_option( $id, $key, $value, $refresh = true ) {	$id = (int) $id;	switch_to_blog($id);	update_option( $key, $value );	restore_current_blog();	if ( $refresh == true )		refresh_blog_details( $id );	wp_cache_set( $id."-".$key."-blog_option", $value, 'site-options');}function switch_to_blog( $new_blog, $validate = false ) {	global $wpdb, $table_prefix, $blog_id, $switched, $switched_stack, $wp_roles, $current_user, $wp_object_cache;	if ( empty($new_blog) )		$new_blog = $blog_id;	if ( $validate && ! get_blog_details( $new_blog ) )		return false;	if ( empty($switched_stack) )		$switched_stack = array();	$switched_stack[] = $blog_id;	/* If we're switching to the same blog id that we're on,	* set the right vars, do the associated actions, but skip	* the extra unnecessary work */	if ( $blog_id == $new_blog ) {		do_action( 'switch_blog', $blog_id, $blog_id );		$switched = true;		return true;	}	$wpdb->set_blog_id($new_blog);	$table_prefix = $wpdb->prefix;	$prev_blog_id = $blog_id;	$blog_id = $new_blog;	if ( is_object( $wp_roles ) ) {		$wpdb->suppress_errors();		if ( method_exists( $wp_roles ,'_init' ) )			$wp_roles->_init();		elseif ( method_exists( $wp_roles, '__construct' ) )			$wp_roles->__construct();		$wpdb->suppress_errors( false );	}	if ( is_object( $current_user ) )		$current_user->for_blog( $blog_id );	if ( is_object( $wp_object_cache ) && isset( $wp_object_cache->global_groups ) )		$global_groups = $wp_object_cache->global_groups;	else		$global_groups = false;	wp_cache_init();	if ( function_exists('wp_cache_add_global_groups') ) {		if ( is_array( $global_groups ) )			wp_cache_add_global_groups( $global_groups );		else			wp_cache_add_global_groups( array( 'users', 'userlogins', 'usermeta', 'site-options', 'site-lookup', 'blog-lookup', 'blog-details', 'rss', 'site-transient', 'global-posts' ) );		wp_cache_add_non_persistent_groups(array( 'comment', 'counts', 'plugins' ));	}	do_action('switch_blog', $blog_id, $prev_blog_id);	$switched = true;	return true;}function restore_current_blog() {	global $table_prefix, $wpdb, $blog_id, $switched, $switched_stack, $wp_roles, $current_user, $wp_object_cache;	if ( !$switched )		return false;	if ( !is_array( $switched_stack ) )		return false;	$blog = array_pop( $switched_stack );	if ( $blog_id == $blog ) {		do_action( 'switch_blog', $blog, $blog );		/* If we still have items in the switched stack, consider ourselves still 'switched' */		$switched = ( is_array( $switched_stack ) && count( $switched_stack ) > 0 );		return true;	}	$wpdb->set_blog_id($blog);	$prev_blog_id = $blog_id;	$blog_id = $blog;	$table_prefix = $wpdb->prefix;	if ( is_object( $wp_roles ) ) {		$wpdb->suppress_errors();		if ( method_exists( $wp_roles ,'_init' ) )			$wp_roles->_init();		elseif ( method_exists( $wp_roles, '__construct' ) )			$wp_roles->__construct();		$wpdb->suppress_errors( false );	}	if ( is_object( $current_user ) )		$current_user->for_blog( $blog_id );	if ( is_object( $wp_object_cache ) && isset( $wp_object_cache->global_groups ) )		$global_groups = $wp_object_cache->global_groups;	else		$global_groups = false;	wp_cache_init();	if ( function_exists('wp_cache_add_global_groups') ) {		if ( is_array( $global_groups ) )			wp_cache_add_global_groups( $global_groups );		else			wp_cache_add_global_groups( array( 'users', 'userlogins', 'usermeta', 'site-options', 'site-lookup', 'blog-lookup', 'blog-details', 'rss', 'site-transient' ) );		wp_cache_add_non_persistent_groups(array( 'comment', 'counts', 'plugins' ));	}	do_action('switch_blog', $blog_id, $prev_blog_id);	/* If we still have items in the switched stack, consider ourselves still 'switched' */	$switched = ( is_array( $switched_stack ) && count( $switched_stack ) > 0 );	return true;}function is_archived( $id ) {	return get_blog_status($id, 'archived');}function update_archived( $id, $archived ) {	update_blog_status($id, 'archived', $archived);	return $archived;}/** * Update a blog details field. * * @since 3.0.0 * * @param int $blog_id BLog ID * @param string $pref A field name * @param string $value Value for $pref * @param bool $refresh Whether to refresh the blog details cache. Default is true. */function update_blog_status( $blog_id, $pref, $value, $refresh = true ) {	global $wpdb;	if ( !in_array( $pref, array( 'site_id', 'domain', 'path', 'registered', 'last_updated', 'public', 'archived', 'mature', 'spam', 'deleted', 'lang_id') ) )		return $value;	$wpdb->update( $wpdb->blogs, array($pref => $value, 'last_updated' => current_time('mysql', true)), array('blog_id' => $blog_id) );	if ( $refresh )		refresh_blog_details($blog_id);	if ( $pref == 'spam' ) {		if ( $value == 1 )			do_action( "make_spam_blog", $blog_id );		else			do_action( "make_ham_blog", $blog_id );	}	return $value;}function get_blog_status( $id, $pref ) {	global $wpdb;	$details = get_blog_details( $id, false );	if ( $details )		return $details->$pref;	return $wpdb->get_var( $wpdb->prepare("SELECT %s FROM {$wpdb->blogs} WHERE blog_id = %d", $pref, $id) );}function get_last_updated( $deprecated = '', $start = 0, $quantity = 40 ) {	global $wpdb;	return $wpdb->get_results( $wpdb->prepare("SELECT blog_id, domain, path FROM $wpdb->blogs WHERE site_id = %d AND public = '1' AND archived = '0' AND mature = '0' AND spam = '0' AND deleted = '0' AND last_updated != '0000-00-00 00:00:00' ORDER BY last_updated DESC limit %d, %d", $wpdb->siteid, $start, $quantity ) , ARRAY_A );}?>
<?php/** * The custom background script. * * @package WordPress * @subpackage Administration *//** * The custom background class. * * @since 3.0.0 * @package WordPress * @subpackage Administration */class Custom_Background {	/**	 * Callback for administration header.	 *	 * @var callback	 * @since unknown	 * @access private	 */	var $admin_header_callback;	/**	 * Callback for header div.	 *	 * @var callback	 * @since 3.0.0	 * @access private	 */	var $admin_image_div_callback;	/**	 * Holds the page menu hook.	 *	 * @var string	 * @since 3.0.0	 * @access private	 */	var $page = '';	/**	 * PHP4 Constructor - Register administration header callback.	 *	 * @since 3.0.0	 * @param callback $admin_header_callback	 * @param callback $admin_image_div_callback Optional custom image div output callback.	 * @return Custom_Background	 */	function Custom_Background($admin_header_callback = '', $admin_image_div_callback = '') {		$this->admin_header_callback = $admin_header_callback;		$this->admin_image_div_callback = $admin_image_div_callback;	}	/**	 * Set up the hooks for the Custom Background admin page.	 *	 * @since 3.0.0	 */	function init() {		if ( ! current_user_can('edit_theme_options') )			return;		$this->page = $page = add_theme_page(__('Background'), __('Background'), 'edit_theme_options', 'custom-background', array(&$this, 'admin_page'));		add_action("load-$page", array(&$this, 'admin_load'));		add_action("load-$page", array(&$this, 'take_action'), 49);		add_action("load-$page", array(&$this, 'handle_upload'), 49);		if ( $this->admin_header_callback )			add_action("admin_head-$page", $this->admin_header_callback, 51);	}	/**	 * Set up the enqueue for the CSS & JavaScript files.	 *	 * @since 3.0.0	 */	function admin_load() {		add_contextual_help( $this->page, '<p>' . __( 'You can customize the look of your site without touching any of your theme&#8217;s code by using a custom background. Your background can be an image or a color.' ) . '</p>' .		'<p>' . __( 'To use a background image, simply upload it, then choose your display options below. You can display a single instance of your image, or tile it to fill the screen. You can have your background fixed in place, so your site content moves on top of it, or you can have it scroll with your site.' ) . '</p>' .		'<p>' . __( 'You can also choose a background color. If you know the hexadecimal code for the color you want, enter it in the Color field. If not, click on the Select a Color link, and a color picker will allow you to choose the exact shade you want.' ) . '</p>' .		'<p>' . __( 'Don&#8217;t forget to click on the Save Changes button when you are finished.' ) . '</p>' .		'<p><strong>' . __( 'For more information:' ) . '</strong></p>' .		'<p>' . __( '<a href="http://codex.wordpress.org/Appearance_Background_SubPanel" target="_blank">Documentation on Custom Background</a>' ) . '</p>' .		'<p>' . __( '<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>' ) . '</p>' );		wp_enqueue_script('custom-background');		wp_enqueue_style('farbtastic');	}	/**	 * Execute custom background modification.	 *	 * @since 3.0.0	 */	function take_action() {		if ( empty($_POST) )			return;		if ( isset($_POST['reset-background']) ) {			check_admin_referer('custom-background-reset', '_wpnonce-custom-background-reset');			remove_theme_mod('background_image');			remove_theme_mod('background_image_thumb');			$this->updated = true;			return;		}		if ( isset($_POST['remove-background']) ) {			// @TODO: Uploaded files are not removed here.			check_admin_referer('custom-background-remove', '_wpnonce-custom-background-remove');			set_theme_mod('background_image', '');			set_theme_mod('background_image_thumb', '');			$this->updated = true;			return;		}		if ( isset($_POST['background-repeat']) ) {			check_admin_referer('custom-background');			if ( in_array($_POST['background-repeat'], array('repeat', 'no-repeat', 'repeat-x', 'repeat-y')) )				$repeat = $_POST['background-repeat'];			else				$repeat = 'repeat';			set_theme_mod('background_repeat', $repeat);		}		if ( isset($_POST['background-position-x']) ) {			check_admin_referer('custom-background');			if ( in_array($_POST['background-position-x'], array('center', 'right', 'left')) )				$position = $_POST['background-position-x'];			else				$position = 'left';			set_theme_mod('background_position_x', $position);		}		if ( isset($_POST['background-attachment']) ) {			check_admin_referer('custom-background');			if ( in_array($_POST['background-attachment'], array('fixed', 'scroll')) )				$attachment = $_POST['background-attachment'];			else				$attachment = 'fixed';			set_theme_mod('background_attachment', $attachment);		}		if ( isset($_POST['background-color']) ) {			check_admin_referer('custom-background');			$color = preg_replace('/[^0-9a-fA-F]/', '', $_POST['background-color']);			if ( strlen($color) == 6 || strlen($color) == 3 )				set_theme_mod('background_color', $color);			else				set_theme_mod('background_color', '');		}		$this->updated = true;	}	/**	 * Display the custom background page.	 *	 * @since 3.0.0	 */	function admin_page() {?><div class="wrap" id="custom-background"><?php screen_icon(); ?><h2><?php _e('Custom Background'); ?></h2><?php if ( !empty($this->updated) ) { ?><div id="message" class="updated"><p><?php printf( __( 'Background updated. <a href="%s">Visit your site</a> to see how it looks.' ), home_url( '/' ) ); ?></p></div><?php }	if ( $this->admin_image_div_callback ) {		call_user_func($this->admin_image_div_callback);	} else {?><h3><?php _e('Background Image'); ?></h3><table class="form-table"><tbody><tr valign="top"><th scope="row"><?php _e('Preview'); ?></th><td><?php$background_styles = '';if ( $bgcolor = get_background_color() )	$background_styles .= 'background-color: #' . $bgcolor . ';';if ( get_background_image() ) {	// background-image URL must be single quote, see below	$background_styles .= ' background-image: url(\'' . get_theme_mod('background_image_thumb', '') . '\');'		. ' background-repeat: ' . get_theme_mod('background_repeat', 'repeat') . ';'		. ' background-position: top ' . get_theme_mod('background_position_x', 'left');}?><div id="custom-background-image" style="<?php echo $background_styles; ?>"><?php // must be double quote, see above ?><?php if ( get_background_image() ) { ?><img class="custom-background-image" src="<?php echo get_theme_mod('background_image_thumb', ''); ?>" style="visibility:hidden;" alt="" /><br /><img class="custom-background-image" src="<?php echo get_theme_mod('background_image_thumb', ''); ?>" style="visibility:hidden;" alt="" /><?php } ?></div><?php } ?></td></tr><?php if ( get_background_image() ) : ?><tr valign="top"><th scope="row"><?php _e('Remove Image'); ?></th><td><form method="post" action=""><?php wp_nonce_field('custom-background-remove', '_wpnonce-custom-background-remove'); ?><input type="submit" class="button" name="remove-background" value="<?php esc_attr_e('Remove Background Image'); ?>" /><br/><?php _e('This will remove the background image. You will not be able to restore any customizations.') ?></form></td></tr><?php endif; ?><?php if ( defined( 'BACKGROUND_IMAGE' ) ) : // Show only if a default background image exists ?><tr valign="top"><th scope="row"><?php _e('Restore Original Image'); ?></th><td><form method="post" action=""><?php wp_nonce_field('custom-background-reset', '_wpnonce-custom-background-reset'); ?><input type="submit" class="button" name="reset-background" value="<?php esc_attr_e('Restore Original Image'); ?>" /><br/><?php _e('This will restore the original background image. You will not be able to restore any customizations.') ?></form></td></tr><?php endif; ?><tr valign="top"><th scope="row"><?php _e('Upload Image'); ?></th><td><form enctype="multipart/form-data" id="upload-form" method="post" action=""><label for="upload"><?php _e('Choose an image from your computer:'); ?></label><br /><input type="file" id="upload" name="import" /><input type="hidden" name="action" value="save" /><?php wp_nonce_field('custom-background-upload', '_wpnonce-custom-background-upload') ?><input type="submit" class="button" value="<?php esc_attr_e('Upload'); ?>" /></p></form></td></tr></tbody></table><h3><?php _e('Display Options') ?></h3><form method="post" action=""><table class="form-table"><tbody><?php if ( get_background_image() ) : ?><tr valign="top"><th scope="row"><?php _e( 'Position' ); ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e( 'Background Position' ); ?></span></legend><label><input name="background-position-x" type="radio" value="left"<?php checked('left', get_theme_mod('background_position_x', 'left')); ?> /><?php _e('Left') ?></label><label><input name="background-position-x" type="radio" value="center"<?php checked('center', get_theme_mod('background_position_x', 'left')); ?> /><?php _e('Center') ?></label><label><input name="background-position-x" type="radio" value="right"<?php checked('right', get_theme_mod('background_position_x', 'left')); ?> /><?php _e('Right') ?></label></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e( 'Repeat' ); ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e( 'Background Repeat' ); ?></span></legend><label><input type="radio" name="background-repeat" value="no-repeat"<?php checked('no-repeat', get_theme_mod('background_repeat', 'repeat')); ?>> <?php _e('No Repeat'); ?></option></label>	<label><input type="radio" name="background-repeat" value="repeat"<?php checked('repeat', get_theme_mod('background_repeat', 'repeat')); ?>> <?php _e('Tile'); ?></option></label>	<label><input type="radio" name="background-repeat" value="repeat-x"<?php checked('repeat-x', get_theme_mod('background_repeat', 'repeat')); ?>> <?php _e('Tile Horizontally'); ?></option></label>	<label><input type="radio" name="background-repeat" value="repeat-y"<?php checked('repeat-y', get_theme_mod('background_repeat', 'repeat')); ?>> <?php _e('Tile Vertically'); ?></option></label></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e( 'Attachment' ); ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e( 'Background Attachment' ); ?></span></legend><label><input name="background-attachment" type="radio" value="scroll" <?php checked('scroll', get_theme_mod('background_attachment', 'scroll')); ?> /><?php _e('Scroll') ?></label><label><input name="background-attachment" type="radio" value="fixed" <?php checked('fixed', get_theme_mod('background_attachment', 'scroll')); ?> /><?php _e('Fixed') ?></label></fieldset></td></tr><?php endif; // get_background_image() ?><tr valign="top"><th scope="row"><?php _e( 'Color' ); ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e( 'Background Color' ); ?></span></legend><input type="text" name="background-color" id="background-color" value="#<?php echo esc_attr(get_background_color()) ?>" /><a class="hide-if-no-js" href="#" id="pickcolor"><?php _e('Select a Color'); ?></a><div id="colorPickerDiv" style="z-index: 100; background:#eee; border:1px solid #ccc; position:absolute; display:none;"></div></fieldset></td></tr></tbody></table><?php wp_nonce_field('custom-background'); ?><p class="submit"><input type="submit" class="button-primary" name="save-background-options" value="<?php esc_attr_e('Save Changes'); ?>" /></p></form></div><?php	}	/**	 * Handle a Image upload for the background image.	 *	 * @since 3.0.0	 */	function handle_upload() {		if ( empty($_FILES) )			return;		check_admin_referer('custom-background-upload', '_wpnonce-custom-background-upload');		$overrides = array('test_form' => false);		$file = wp_handle_upload($_FILES['import'], $overrides);		if ( isset($file['error']) )			wp_die( $file['error'] );		$url = $file['url'];		$type = $file['type'];		$file = $file['file'];		$filename = basename($file);		// Construct the object array		$object = array(			'post_title' => $filename,			'post_content' => $url,			'post_mime_type' => $type,			'guid' => $url		);		// Save the data		$id = wp_insert_attachment($object, $file);		// Add the meta-data		wp_update_attachment_metadata( $id, wp_generate_attachment_metadata( $id, $file ) );		set_theme_mod('background_image', esc_url($url));		$thumbnail = wp_get_attachment_image_src( $id, 'thumbnail' );		set_theme_mod('background_image_thumb', esc_url( $thumbnail[0] ) );		do_action('wp_create_file_in_uploads', $file, $id); // For replication		$this->updated = true;	}}?>
<?php// --------------------------------------------------------------------------------// PhpConcept Library - Zip Module 2.8.2// --------------------------------------------------------------------------------// License GNU/LGPL - Vincent Blavet - August 2009// http://www.phpconcept.net// --------------------------------------------------------------------------------//// Presentation ://   PclZip is a PHP library that manage ZIP archives.//   So far tests show that archives generated by PclZip are readable by//   WinZip application and other tools.//// Description ://   See readme.txt and http://www.phpconcept.net//// Warning ://   This library and the associated files are non commercial, non professional//   work.//   It should not have unexpected results. However if any damage is caused by//   this software the author can not be responsible.//   The use of this software is at the risk of the user.//// --------------------------------------------------------------------------------// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $// --------------------------------------------------------------------------------  // ----- Constants  if (!defined('PCLZIP_READ_BLOCK_SIZE')) {    define( 'PCLZIP_READ_BLOCK_SIZE', 2048 );  }  // ----- File list separator  // In version 1.x of PclZip, the separator for file list is a space  // (which is not a very smart choice, specifically for windows paths !).  // A better separator should be a comma (,). This constant gives you the  // abilty to change that.  // However notice that changing this value, may have impact on existing  // scripts, using space separated filenames.  // Recommanded values for compatibility with older versions :  //define( 'PCLZIP_SEPARATOR', ' ' );  // Recommanded values for smart separation of filenames.  if (!defined('PCLZIP_SEPARATOR')) {    define( 'PCLZIP_SEPARATOR', ',' );  }  // ----- Error configuration  // 0 : PclZip Class integrated error handling  // 1 : PclError external library error handling. By enabling this  //     you must ensure that you have included PclError library.  // [2,...] : reserved for futur use  if (!defined('PCLZIP_ERROR_EXTERNAL')) {    define( 'PCLZIP_ERROR_EXTERNAL', 0 );  }  // ----- Optional static temporary directory  //       By default temporary files are generated in the script current  //       path.  //       If defined :  //       - MUST BE terminated by a '/'.  //       - MUST be a valid, already created directory  //       Samples :  // define( 'PCLZIP_TEMPORARY_DIR', '/temp/' );  // define( 'PCLZIP_TEMPORARY_DIR', 'C:/Temp/' );  if (!defined('PCLZIP_TEMPORARY_DIR')) {    define( 'PCLZIP_TEMPORARY_DIR', '' );  }  // ----- Optional threshold ratio for use of temporary files  //       Pclzip sense the size of the file to add/extract and decide to  //       use or not temporary file. The algorythm is looking for  //       memory_limit of PHP and apply a ratio.  //       threshold = memory_limit * ratio.  //       Recommended values are under 0.5. Default 0.47.  //       Samples :  // define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.5 );  if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) {    define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.47 );  }// --------------------------------------------------------------------------------// ***** UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED *****// --------------------------------------------------------------------------------  // ----- Global variables  $g_pclzip_version = "2.8.2";  // ----- Error codes  //   -1 : Unable to open file in binary write mode  //   -2 : Unable to open file in binary read mode  //   -3 : Invalid parameters  //   -4 : File does not exist  //   -5 : Filename is too long (max. 255)  //   -6 : Not a valid zip file  //   -7 : Invalid extracted file size  //   -8 : Unable to create directory  //   -9 : Invalid archive extension  //  -10 : Invalid archive format  //  -11 : Unable to delete file (unlink)  //  -12 : Unable to rename file (rename)  //  -13 : Invalid header checksum  //  -14 : Invalid archive size  define( 'PCLZIP_ERR_USER_ABORTED', 2 );  define( 'PCLZIP_ERR_NO_ERROR', 0 );  define( 'PCLZIP_ERR_WRITE_OPEN_FAIL', -1 );  define( 'PCLZIP_ERR_READ_OPEN_FAIL', -2 );  define( 'PCLZIP_ERR_INVALID_PARAMETER', -3 );  define( 'PCLZIP_ERR_MISSING_FILE', -4 );  define( 'PCLZIP_ERR_FILENAME_TOO_LONG', -5 );  define( 'PCLZIP_ERR_INVALID_ZIP', -6 );  define( 'PCLZIP_ERR_BAD_EXTRACTED_FILE', -7 );  define( 'PCLZIP_ERR_DIR_CREATE_FAIL', -8 );  define( 'PCLZIP_ERR_BAD_EXTENSION', -9 );  define( 'PCLZIP_ERR_BAD_FORMAT', -10 );  define( 'PCLZIP_ERR_DELETE_FILE_FAIL', -11 );  define( 'PCLZIP_ERR_RENAME_FILE_FAIL', -12 );  define( 'PCLZIP_ERR_BAD_CHECKSUM', -13 );  define( 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14 );  define( 'PCLZIP_ERR_MISSING_OPTION_VALUE', -15 );  define( 'PCLZIP_ERR_INVALID_OPTION_VALUE', -16 );  define( 'PCLZIP_ERR_ALREADY_A_DIRECTORY', -17 );  define( 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18 );  define( 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19 );  define( 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20 );  define( 'PCLZIP_ERR_DIRECTORY_RESTRICTION', -21 );  // ----- Options values  define( 'PCLZIP_OPT_PATH', 77001 );  define( 'PCLZIP_OPT_ADD_PATH', 77002 );  define( 'PCLZIP_OPT_REMOVE_PATH', 77003 );  define( 'PCLZIP_OPT_REMOVE_ALL_PATH', 77004 );  define( 'PCLZIP_OPT_SET_CHMOD', 77005 );  define( 'PCLZIP_OPT_EXTRACT_AS_STRING', 77006 );  define( 'PCLZIP_OPT_NO_COMPRESSION', 77007 );  define( 'PCLZIP_OPT_BY_NAME', 77008 );  define( 'PCLZIP_OPT_BY_INDEX', 77009 );  define( 'PCLZIP_OPT_BY_EREG', 77010 );  define( 'PCLZIP_OPT_BY_PREG', 77011 );  define( 'PCLZIP_OPT_COMMENT', 77012 );  define( 'PCLZIP_OPT_ADD_COMMENT', 77013 );  define( 'PCLZIP_OPT_PREPEND_COMMENT', 77014 );  define( 'PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015 );  define( 'PCLZIP_OPT_REPLACE_NEWER', 77016 );  define( 'PCLZIP_OPT_STOP_ON_ERROR', 77017 );  // Having big trouble with crypt. Need to multiply 2 long int  // which is not correctly supported by PHP ...  //define( 'PCLZIP_OPT_CRYPT', 77018 );  define( 'PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019 );  define( 'PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020 );  define( 'PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD', 77020 ); // alias  define( 'PCLZIP_OPT_TEMP_FILE_ON', 77021 );  define( 'PCLZIP_OPT_ADD_TEMP_FILE_ON', 77021 ); // alias  define( 'PCLZIP_OPT_TEMP_FILE_OFF', 77022 );  define( 'PCLZIP_OPT_ADD_TEMP_FILE_OFF', 77022 ); // alias  // ----- File description attributes  define( 'PCLZIP_ATT_FILE_NAME', 79001 );  define( 'PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002 );  define( 'PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003 );  define( 'PCLZIP_ATT_FILE_MTIME', 79004 );  define( 'PCLZIP_ATT_FILE_CONTENT', 79005 );  define( 'PCLZIP_ATT_FILE_COMMENT', 79006 );  // ----- Call backs values  define( 'PCLZIP_CB_PRE_EXTRACT', 78001 );  define( 'PCLZIP_CB_POST_EXTRACT', 78002 );  define( 'PCLZIP_CB_PRE_ADD', 78003 );  define( 'PCLZIP_CB_POST_ADD', 78004 );  /* For futur use  define( 'PCLZIP_CB_PRE_LIST', 78005 );  define( 'PCLZIP_CB_POST_LIST', 78006 );  define( 'PCLZIP_CB_PRE_DELETE', 78007 );  define( 'PCLZIP_CB_POST_DELETE', 78008 );  */  // --------------------------------------------------------------------------------  // Class : PclZip  // Description :  //   PclZip is the class that represent a Zip archive.  //   The public methods allow the manipulation of the archive.  // Attributes :  //   Attributes must not be accessed directly.  // Methods :  //   PclZip() : Object creator  //   create() : Creates the Zip archive  //   listContent() : List the content of the Zip archive  //   extract() : Extract the content of the archive  //   properties() : List the properties of the archive  // --------------------------------------------------------------------------------  class PclZip  {    // ----- Filename of the zip file    var $zipname = '';    // ----- File descriptor of the zip file    var $zip_fd = 0;    // ----- Internal error handling    var $error_code = 1;    var $error_string = '';    // ----- Current status of the magic_quotes_runtime    // This value store the php configuration for magic_quotes    // The class can then disable the magic_quotes and reset it after    var $magic_quotes_status;  // --------------------------------------------------------------------------------  // Function : PclZip()  // Description :  //   Creates a PclZip object and set the name of the associated Zip archive  //   filename.  //   Note that no real action is taken, if the archive does not exist it is not  //   created. Use create() for that.  // --------------------------------------------------------------------------------  function PclZip($p_zipname)  {    // ----- Tests the zlib    if (!function_exists('gzopen'))    {      die('Abort '.basename(__FILE__).' : Missing zlib extensions');    }    // ----- Set the attributes    $this->zipname = $p_zipname;    $this->zip_fd = 0;    $this->magic_quotes_status = -1;    // ----- Return    return;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   create($p_filelist, $p_add_dir="", $p_remove_dir="")  //   create($p_filelist, $p_option, $p_option_value, ...)  // Description :  //   This method supports two different synopsis. The first one is historical.  //   This method creates a Zip Archive. The Zip file is created in the  //   filesystem. The files and directories indicated in $p_filelist  //   are added in the archive. See the parameters description for the  //   supported format of $p_filelist.  //   When a directory is in the list, the directory and its content is added  //   in the archive.  //   In this synopsis, the function takes an optional variable list of  //   options. See bellow the supported options.  // Parameters :  //   $p_filelist : An array containing file or directory names, or  //                 a string containing one filename or one directory name, or  //                 a string containing a list of filenames and/or directory  //                 names separated by spaces.  //   $p_add_dir : A path to add before the real path of the archived file,  //                in order to have it memorized in the archive.  //   $p_remove_dir : A path to remove from the real path of the file to archive,  //                   in order to have a shorter path memorized in the archive.  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir  //                   is removed first, before $p_add_dir is added.  // Options :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_OPT_COMMENT :  //   PCLZIP_CB_PRE_ADD :  //   PCLZIP_CB_POST_ADD :  // Return Values :  //   0 on failure,  //   The list of the added files, with a status of the add action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function create($p_filelist)  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Set default values    $v_options = array();    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Look for arguments    if ($v_size > 1) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Remove from the options list the first argument      array_shift($v_arg_list);      $v_size--;      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_ADD => 'optional',                                                   PCLZIP_CB_POST_ADD => 'optional',                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',                                                   PCLZIP_OPT_COMMENT => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'                                                   //, PCLZIP_OPT_CRYPT => 'optional'                                             ));        if ($v_result != 1) {          return 0;        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];        }        else if ($v_size > 2) {          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,		                       "Invalid number / type of arguments");          return 0;        }      }    }    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Init    $v_string_list = array();    $v_att_list = array();    $v_filedescr_list = array();    $p_result_list = array();    // ----- Look if the $p_filelist is really an array    if (is_array($p_filelist)) {      // ----- Look if the first element is also an array      //       This will mean that this is a file description entry      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {        $v_att_list = $p_filelist;      }      // ----- The list is a list of string names      else {        $v_string_list = $p_filelist;      }    }    // ----- Look if the $p_filelist is a string    else if (is_string($p_filelist)) {      // ----- Create a list from the string      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);    }    // ----- Invalid variable type for $p_filelist    else {      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_filelist");      return 0;    }    // ----- Reformat the string list    if (sizeof($v_string_list) != 0) {      foreach ($v_string_list as $v_string) {        if ($v_string != '') {          $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;        }        else {        }      }    }    // ----- For each file in the list check the attributes    $v_supported_attributes    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'             ,PCLZIP_ATT_FILE_MTIME => 'optional'             ,PCLZIP_ATT_FILE_CONTENT => 'optional'             ,PCLZIP_ATT_FILE_COMMENT => 'optional'						);    foreach ($v_att_list as $v_entry) {      $v_result = $this->privFileDescrParseAtt($v_entry,                                               $v_filedescr_list[],                                               $v_options,                                               $v_supported_attributes);      if ($v_result != 1) {        return 0;      }    }    // ----- Expand the filelist (expand directories)    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Call the create fct    $v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Return    return $p_result_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   add($p_filelist, $p_add_dir="", $p_remove_dir="")  //   add($p_filelist, $p_option, $p_option_value, ...)  // Description :  //   This method supports two synopsis. The first one is historical.  //   This methods add the list of files in an existing archive.  //   If a file with the same name already exists, it is added at the end of the  //   archive, the first one is still present.  //   If the archive does not exist, it is created.  // Parameters :  //   $p_filelist : An array containing file or directory names, or  //                 a string containing one filename or one directory name, or  //                 a string containing a list of filenames and/or directory  //                 names separated by spaces.  //   $p_add_dir : A path to add before the real path of the archived file,  //                in order to have it memorized in the archive.  //   $p_remove_dir : A path to remove from the real path of the file to archive,  //                   in order to have a shorter path memorized in the archive.  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir  //                   is removed first, before $p_add_dir is added.  // Options :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_OPT_COMMENT :  //   PCLZIP_OPT_ADD_COMMENT :  //   PCLZIP_OPT_PREPEND_COMMENT :  //   PCLZIP_CB_PRE_ADD :  //   PCLZIP_CB_POST_ADD :  // Return Values :  //   0 on failure,  //   The list of the added files, with a status of the add action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function add($p_filelist)  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Set default values    $v_options = array();    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Look for arguments    if ($v_size > 1) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Remove form the options list the first argument      array_shift($v_arg_list);      $v_size--;      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_ADD => 'optional',                                                   PCLZIP_CB_POST_ADD => 'optional',                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',                                                   PCLZIP_OPT_COMMENT => 'optional',                                                   PCLZIP_OPT_ADD_COMMENT => 'optional',                                                   PCLZIP_OPT_PREPEND_COMMENT => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'                                                   //, PCLZIP_OPT_CRYPT => 'optional'												   ));        if ($v_result != 1) {          return 0;        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];        }        else if ($v_size > 2) {          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");          // ----- Return          return 0;        }      }    }    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Init    $v_string_list = array();    $v_att_list = array();    $v_filedescr_list = array();    $p_result_list = array();    // ----- Look if the $p_filelist is really an array    if (is_array($p_filelist)) {      // ----- Look if the first element is also an array      //       This will mean that this is a file description entry      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {        $v_att_list = $p_filelist;      }      // ----- The list is a list of string names      else {        $v_string_list = $p_filelist;      }    }    // ----- Look if the $p_filelist is a string    else if (is_string($p_filelist)) {      // ----- Create a list from the string      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);    }    // ----- Invalid variable type for $p_filelist    else {      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type '".gettype($p_filelist)."' for p_filelist");      return 0;    }    // ----- Reformat the string list    if (sizeof($v_string_list) != 0) {      foreach ($v_string_list as $v_string) {        $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;      }    }    // ----- For each file in the list check the attributes    $v_supported_attributes    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'             ,PCLZIP_ATT_FILE_MTIME => 'optional'             ,PCLZIP_ATT_FILE_CONTENT => 'optional'             ,PCLZIP_ATT_FILE_COMMENT => 'optional'						);    foreach ($v_att_list as $v_entry) {      $v_result = $this->privFileDescrParseAtt($v_entry,                                               $v_filedescr_list[],                                               $v_options,                                               $v_supported_attributes);      if ($v_result != 1) {        return 0;      }    }    // ----- Expand the filelist (expand directories)    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Call the create fct    $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Return    return $p_result_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : listContent()  // Description :  //   This public method, gives the list of the files and directories, with their  //   properties.  //   The properties of each entries in the list are (used also in other functions) :  //     filename : Name of the file. For a create or add action it is the filename  //                given by the user. For an extract function it is the filename  //                of the extracted file.  //     stored_filename : Name of the file / directory stored in the archive.  //     size : Size of the stored file.  //     compressed_size : Size of the file's data compressed in the archive  //                       (without the headers overhead)  //     mtime : Last known modification date of the file (UNIX timestamp)  //     comment : Comment associated with the file  //     folder : true | false  //     index : index of the file in the archive  //     status : status of the action (depending of the action) :  //              Values are :  //                ok : OK !  //                filtered : the file / dir is not extracted (filtered by user)  //                already_a_directory : the file can not be extracted because a  //                                      directory with the same name already exists  //                write_protected : the file can not be extracted because a file  //                                  with the same name already exists and is  //                                  write protected  //                newer_exist : the file was not extracted because a newer file exists  //                path_creation_fail : the file is not extracted because the folder  //                                     does not exist and can not be created  //                write_error : the file was not extracted because there was a  //                              error while writing the file  //                read_error : the file was not extracted because there was a error  //                             while reading the file  //                invalid_header : the file was not extracted because of an archive  //                                 format error (bad file header)  //   Note that each time a method can continue operating when there  //   is an action error on a file, the error is only logged in the file status.  // Return Values :  //   0 on an unrecoverable failure,  //   The list of the files in the archive.  // --------------------------------------------------------------------------------  function listContent()  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Call the extracting fct    $p_list = array();    if (($v_result = $this->privList($p_list)) != 1)    {      unset($p_list);      return(0);    }    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   extract($p_path="./", $p_remove_path="")  //   extract([$p_option, $p_option_value, ...])  // Description :  //   This method supports two synopsis. The first one is historical.  //   This method extract all the files / directories from the archive to the  //   folder indicated in $p_path.  //   If you want to ignore the 'root' part of path of the memorized files  //   you can indicate this in the optional $p_remove_path parameter.  //   By default, if a newer file with the same name already exists, the  //   file is not extracted.  //  //   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions  //   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append  //   at the end of the path value of PCLZIP_OPT_PATH.  // Parameters :  //   $p_path : Path where the files and directories are to be extracted  //   $p_remove_path : First part ('root' part) of the memorized path  //                    (if any similar) to remove while extracting.  // Options :  //   PCLZIP_OPT_PATH :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_CB_PRE_EXTRACT :  //   PCLZIP_CB_POST_EXTRACT :  // Return Values :  //   0 or a negative value on failure,  //   The list of the extracted files, with a status of the action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function extract()  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Set default values    $v_options = array();//    $v_path = "./";    $v_path = '';    $v_remove_path = "";    $v_remove_all_path = false;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Default values for option    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;    // ----- Look for arguments    if ($v_size > 0) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',                                                   PCLZIP_CB_POST_EXTRACT => 'optional',                                                   PCLZIP_OPT_SET_CHMOD => 'optional',                                                   PCLZIP_OPT_BY_NAME => 'optional',                                                   PCLZIP_OPT_BY_EREG => 'optional',                                                   PCLZIP_OPT_BY_PREG => 'optional',                                                   PCLZIP_OPT_BY_INDEX => 'optional',                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',                                                   PCLZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'												    ));        if ($v_result != 1) {          return 0;        }        // ----- Set the arguments        if (isset($v_options[PCLZIP_OPT_PATH])) {          $v_path = $v_options[PCLZIP_OPT_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];        }        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {          // ----- Check for '/' in last path char          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {            $v_path .= '/';          }          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_path = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_remove_path = $v_arg_list[1];        }        else if ($v_size > 2) {          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");          // ----- Return          return 0;        }      }    }    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Trace    // ----- Call the extracting fct    $p_list = array();    $v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path,	                                     $v_remove_all_path, $v_options);    if ($v_result < 1) {      unset($p_list);      return(0);    }    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   extractByIndex($p_index, $p_path="./", $p_remove_path="")  //   extractByIndex($p_index, [$p_option, $p_option_value, ...])  // Description :  //   This method supports two synopsis. The first one is historical.  //   This method is doing a partial extract of the archive.  //   The extracted files or folders are identified by their index in the  //   archive (from 0 to n).  //   Note that if the index identify a folder, only the folder entry is  //   extracted, not all the files included in the archive.  // Parameters :  //   $p_index : A single index (integer) or a string of indexes of files to  //              extract. The form of the string is "0,4-6,8-12" with only numbers  //              and '-' for range or ',' to separate ranges. No spaces or ';'  //              are allowed.  //   $p_path : Path where the files and directories are to be extracted  //   $p_remove_path : First part ('root' part) of the memorized path  //                    (if any similar) to remove while extracting.  // Options :  //   PCLZIP_OPT_PATH :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and  //     not as files.  //     The resulting content is in a new field 'content' in the file  //     structure.  //     This option must be used alone (any other options are ignored).  //   PCLZIP_CB_PRE_EXTRACT :  //   PCLZIP_CB_POST_EXTRACT :  // Return Values :  //   0 on failure,  //   The list of the extracted files, with a status of the action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  //function extractByIndex($p_index, options...)  function extractByIndex($p_index)  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Set default values    $v_options = array();//    $v_path = "./";    $v_path = '';    $v_remove_path = "";    $v_remove_all_path = false;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Default values for option    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;    // ----- Look for arguments    if ($v_size > 1) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Remove form the options list the first argument      array_shift($v_arg_list);      $v_size--;      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',                                                   PCLZIP_CB_POST_EXTRACT => 'optional',                                                   PCLZIP_OPT_SET_CHMOD => 'optional',                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'												   ));        if ($v_result != 1) {          return 0;        }        // ----- Set the arguments        if (isset($v_options[PCLZIP_OPT_PATH])) {          $v_path = $v_options[PCLZIP_OPT_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];        }        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {          // ----- Check for '/' in last path char          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {            $v_path .= '/';          }          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];        }        if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {          $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;        }        else {        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_path = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_remove_path = $v_arg_list[1];        }        else if ($v_size > 2) {          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");          // ----- Return          return 0;        }      }    }    // ----- Trace    // ----- Trick    // Here I want to reuse extractByRule(), so I need to parse the $p_index    // with privParseOptions()    $v_arg_trick = array (PCLZIP_OPT_BY_INDEX, $p_index);    $v_options_trick = array();    $v_result = $this->privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick,                                        array (PCLZIP_OPT_BY_INDEX => 'optional' ));    if ($v_result != 1) {        return 0;    }    $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Call the extracting fct    if (($v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) < 1) {        return(0);    }    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   delete([$p_option, $p_option_value, ...])  // Description :  //   This method removes files from the archive.  //   If no parameters are given, then all the archive is emptied.  // Parameters :  //   None or optional arguments.  // Options :  //   PCLZIP_OPT_BY_INDEX :  //   PCLZIP_OPT_BY_NAME :  //   PCLZIP_OPT_BY_EREG :  //   PCLZIP_OPT_BY_PREG :  // Return Values :  //   0 on failure,  //   The list of the files which are still present in the archive.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function delete()  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Set default values    $v_options = array();    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Look for arguments    if ($v_size > 0) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Parse the options      $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                        array (PCLZIP_OPT_BY_NAME => 'optional',                                               PCLZIP_OPT_BY_EREG => 'optional',                                               PCLZIP_OPT_BY_PREG => 'optional',                                               PCLZIP_OPT_BY_INDEX => 'optional' ));      if ($v_result != 1) {          return 0;      }    }    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Call the delete fct    $v_list = array();    if (($v_result = $this->privDeleteByRule($v_list, $v_options)) != 1) {      $this->privSwapBackMagicQuotes();      unset($v_list);      return(0);    }    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : deleteByIndex()  // Description :  //   ***** Deprecated *****  //   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.  // --------------------------------------------------------------------------------  function deleteByIndex($p_index)  {    $p_list = $this->delete(PCLZIP_OPT_BY_INDEX, $p_index);    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : properties()  // Description :  //   This method gives the properties of the archive.  //   The properties are :  //     nb : Number of files in the archive  //     comment : Comment associated with the archive file  //     status : not_exist, ok  // Parameters :  //   None  // Return Values :  //   0 on failure,  //   An array with the archive properties.  // --------------------------------------------------------------------------------  function properties()  {    // ----- Reset the error handler    $this->privErrorReset();    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Check archive    if (!$this->privCheckFormat()) {      $this->privSwapBackMagicQuotes();      return(0);    }    // ----- Default properties    $v_prop = array();    $v_prop['comment'] = '';    $v_prop['nb'] = 0;    $v_prop['status'] = 'not_exist';    // ----- Look if file exists    if (@is_file($this->zipname))    {      // ----- Open the zip file      if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)      {        $this->privSwapBackMagicQuotes();        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in binary read mode');        // ----- Return        return 0;      }      // ----- Read the central directory informations      $v_central_dir = array();      if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)      {        $this->privSwapBackMagicQuotes();        return 0;      }      // ----- Close the zip file      $this->privCloseFd();      // ----- Set the user attributes      $v_prop['comment'] = $v_central_dir['comment'];      $v_prop['nb'] = $v_central_dir['entries'];      $v_prop['status'] = 'ok';    }    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_prop;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : duplicate()  // Description :  //   This method creates an archive by copying the content of an other one. If  //   the archive already exist, it is replaced by the new one without any warning.  // Parameters :  //   $p_archive : The filename of a valid archive, or  //                a valid PclZip object.  // Return Values :  //   1 on success.  //   0 or a negative value on error (error code).  // --------------------------------------------------------------------------------  function duplicate($p_archive)  {    $v_result = 1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Look if the $p_archive is a PclZip object    if ((is_object($p_archive)) && (get_class($p_archive) == 'pclzip'))    {      // ----- Duplicate the archive      $v_result = $this->privDuplicate($p_archive->zipname);    }    // ----- Look if the $p_archive is a string (so a filename)    else if (is_string($p_archive))    {      // ----- Check that $p_archive is a valid zip file      // TBC : Should also check the archive format      if (!is_file($p_archive)) {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "No file with filename '".$p_archive."'");        $v_result = PCLZIP_ERR_MISSING_FILE;      }      else {        // ----- Duplicate the archive        $v_result = $this->privDuplicate($p_archive);      }    }    // ----- Invalid variable    else    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add");      $v_result = PCLZIP_ERR_INVALID_PARAMETER;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : merge()  // Description :  //   This method merge the $p_archive_to_add archive at the end of the current  //   one ($this).  //   If the archive ($this) does not exist, the merge becomes a duplicate.  //   If the $p_archive_to_add archive does not exist, the merge is a success.  // Parameters :  //   $p_archive_to_add : It can be directly the filename of a valid zip archive,  //                       or a PclZip object archive.  // Return Values :  //   1 on success,  //   0 or negative values on error (see below).  // --------------------------------------------------------------------------------  function merge($p_archive_to_add)  {    $v_result = 1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Look if the $p_archive_to_add is a PclZip object    if ((is_object($p_archive_to_add)) && (get_class($p_archive_to_add) == 'pclzip'))    {      // ----- Merge the archive      $v_result = $this->privMerge($p_archive_to_add);    }    // ----- Look if the $p_archive_to_add is a string (so a filename)    else if (is_string($p_archive_to_add))    {      // ----- Create a temporary archive      $v_object_archive = new PclZip($p_archive_to_add);      // ----- Merge the archive      $v_result = $this->privMerge($v_object_archive);    }    // ----- Invalid variable    else    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add");      $v_result = PCLZIP_ERR_INVALID_PARAMETER;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : errorCode()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function errorCode()  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      return(PclErrorCode());    }    else {      return($this->error_code);    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : errorName()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function errorName($p_with_code=false)  {    $v_name = array ( PCLZIP_ERR_NO_ERROR => 'PCLZIP_ERR_NO_ERROR',                      PCLZIP_ERR_WRITE_OPEN_FAIL => 'PCLZIP_ERR_WRITE_OPEN_FAIL',                      PCLZIP_ERR_READ_OPEN_FAIL => 'PCLZIP_ERR_READ_OPEN_FAIL',                      PCLZIP_ERR_INVALID_PARAMETER => 'PCLZIP_ERR_INVALID_PARAMETER',                      PCLZIP_ERR_MISSING_FILE => 'PCLZIP_ERR_MISSING_FILE',                      PCLZIP_ERR_FILENAME_TOO_LONG => 'PCLZIP_ERR_FILENAME_TOO_LONG',                      PCLZIP_ERR_INVALID_ZIP => 'PCLZIP_ERR_INVALID_ZIP',                      PCLZIP_ERR_BAD_EXTRACTED_FILE => 'PCLZIP_ERR_BAD_EXTRACTED_FILE',                      PCLZIP_ERR_DIR_CREATE_FAIL => 'PCLZIP_ERR_DIR_CREATE_FAIL',                      PCLZIP_ERR_BAD_EXTENSION => 'PCLZIP_ERR_BAD_EXTENSION',                      PCLZIP_ERR_BAD_FORMAT => 'PCLZIP_ERR_BAD_FORMAT',                      PCLZIP_ERR_DELETE_FILE_FAIL => 'PCLZIP_ERR_DELETE_FILE_FAIL',                      PCLZIP_ERR_RENAME_FILE_FAIL => 'PCLZIP_ERR_RENAME_FILE_FAIL',                      PCLZIP_ERR_BAD_CHECKSUM => 'PCLZIP_ERR_BAD_CHECKSUM',                      PCLZIP_ERR_INVALID_ARCHIVE_ZIP => 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP',                      PCLZIP_ERR_MISSING_OPTION_VALUE => 'PCLZIP_ERR_MISSING_OPTION_VALUE',                      PCLZIP_ERR_INVALID_OPTION_VALUE => 'PCLZIP_ERR_INVALID_OPTION_VALUE',                      PCLZIP_ERR_UNSUPPORTED_COMPRESSION => 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION',                      PCLZIP_ERR_UNSUPPORTED_ENCRYPTION => 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION'                      ,PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE => 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE'                      ,PCLZIP_ERR_DIRECTORY_RESTRICTION => 'PCLZIP_ERR_DIRECTORY_RESTRICTION'                    );    if (isset($v_name[$this->error_code])) {      $v_value = $v_name[$this->error_code];    }    else {      $v_value = 'NoName';    }    if ($p_with_code) {      return($v_value.' ('.$this->error_code.')');    }    else {      return($v_value);    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : errorInfo()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function errorInfo($p_full=false)  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      return(PclErrorString());    }    else {      if ($p_full) {        return($this->errorName(true)." : ".$this->error_string);      }      else {        return($this->error_string." [code ".$this->error_code."]");      }    }  }  // --------------------------------------------------------------------------------// --------------------------------------------------------------------------------// ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****// *****                                                        *****// *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****// --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCheckFormat()  // Description :  //   This method check that the archive exists and is a valid zip archive.  //   Several level of check exists. (futur)  // Parameters :  //   $p_level : Level of check. Default 0.  //              0 : Check the first bytes (magic codes) (default value))  //              1 : 0 + Check the central directory (futur)  //              2 : 1 + Check each file header (futur)  // Return Values :  //   true on success,  //   false on error, the error code is set.  // --------------------------------------------------------------------------------  function privCheckFormat($p_level=0)  {    $v_result = true;	// ----- Reset the file system cache    clearstatcache();    // ----- Reset the error handler    $this->privErrorReset();    // ----- Look if the file exits    if (!is_file($this->zipname)) {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "Missing archive file '".$this->zipname."'");      return(false);    }    // ----- Check that the file is readeable    if (!is_readable($this->zipname)) {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to read archive '".$this->zipname."'");      return(false);    }    // ----- Check the magic code    // TBC    // ----- Check the central header    // TBC    // ----- Check each file header    // TBC    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privParseOptions()  // Description :  //   This internal methods reads the variable list of arguments ($p_options_list,  //   $p_size) and generate an array with the options and values ($v_result_list).  //   $v_requested_options contains the options that can be present and those that  //   must be present.  //   $v_requested_options is an array, with the option value as key, and 'optional',  //   or 'mandatory' as value.  // Parameters :  //   See above.  // Return Values :  //   1 on success.  //   0 on failure.  // --------------------------------------------------------------------------------  function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options=false)  {    $v_result=1;    // ----- Read the options    $i=0;    while ($i<$p_size) {      // ----- Check if the option is supported      if (!isset($v_requested_options[$p_options_list[$i]])) {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid optional parameter '".$p_options_list[$i]."' for this method");        // ----- Return        return PclZip::errorCode();      }      // ----- Look for next option      switch ($p_options_list[$i]) {        // ----- Look for options that request a path value        case PCLZIP_OPT_PATH :        case PCLZIP_OPT_REMOVE_PATH :        case PCLZIP_OPT_ADD_PATH :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);          $i++;        break;        case PCLZIP_OPT_TEMP_FILE_THRESHOLD :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            return PclZip::errorCode();          }          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");            return PclZip::errorCode();          }          // ----- Check the value          $v_value = $p_options_list[$i+1];          if ((!is_integer($v_value)) || ($v_value<0)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Integer expected for option '".PclZipUtilOptionText($p_options_list[$i])."'");            return PclZip::errorCode();          }          // ----- Get the value (and convert it in bytes)          $v_result_list[$p_options_list[$i]] = $v_value*1048576;          $i++;        break;        case PCLZIP_OPT_TEMP_FILE_ON :          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");            return PclZip::errorCode();          }          $v_result_list[$p_options_list[$i]] = true;        break;        case PCLZIP_OPT_TEMP_FILE_OFF :          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'");            return PclZip::errorCode();          }          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'");            return PclZip::errorCode();          }          $v_result_list[$p_options_list[$i]] = true;        break;        case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (   is_string($p_options_list[$i+1])              && ($p_options_list[$i+1] != '')) {            $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);            $i++;          }          else {          }        break;        // ----- Look for options that request an array of string for value        case PCLZIP_OPT_BY_NAME :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (is_string($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i+1];          }          else if (is_array($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          $i++;        break;        // ----- Look for options that request an EREG or PREG expression        case PCLZIP_OPT_BY_EREG :          // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG          // to PCLZIP_OPT_BY_PREG          $p_options_list[$i] = PCLZIP_OPT_BY_PREG;        case PCLZIP_OPT_BY_PREG :        //case PCLZIP_OPT_CRYPT :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (is_string($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          $i++;        break;        // ----- Look for options that takes a string        case PCLZIP_OPT_COMMENT :        case PCLZIP_OPT_ADD_COMMENT :        case PCLZIP_OPT_PREPEND_COMMENT :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE,			                     "Missing parameter value for option '"								 .PclZipUtilOptionText($p_options_list[$i])								 ."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (is_string($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE,			                     "Wrong parameter value for option '"								 .PclZipUtilOptionText($p_options_list[$i])								 ."'");            // ----- Return            return PclZip::errorCode();          }          $i++;        break;        // ----- Look for options that request an array of index        case PCLZIP_OPT_BY_INDEX :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_work_list = array();          if (is_string($p_options_list[$i+1])) {              // ----- Remove spaces              $p_options_list[$i+1] = strtr($p_options_list[$i+1], ' ', '');              // ----- Parse items              $v_work_list = explode(",", $p_options_list[$i+1]);          }          else if (is_integer($p_options_list[$i+1])) {              $v_work_list[0] = $p_options_list[$i+1].'-'.$p_options_list[$i+1];          }          else if (is_array($p_options_list[$i+1])) {              $v_work_list = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Value must be integer, string or array for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Reduce the index list          // each index item in the list must be a couple with a start and          // an end value : [0,3], [5-5], [8-10], ...          // ----- Check the format of each item          $v_sort_flag=false;          $v_sort_value=0;          for ($j=0; $j<sizeof($v_work_list); $j++) {              // ----- Explode the item              $v_item_list = explode("-", $v_work_list[$j]);              $v_size_item_list = sizeof($v_item_list);              // ----- TBC : Here we might check that each item is a              // real integer ...              // ----- Look for single value              if ($v_size_item_list == 1) {                  // ----- Set the option value                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];              }              elseif ($v_size_item_list == 2) {                  // ----- Set the option value                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];              }              else {                  // ----- Error log                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Too many values in index range for option '".PclZipUtilOptionText($p_options_list[$i])."'");                  // ----- Return                  return PclZip::errorCode();              }              // ----- Look for list sort              if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {                  $v_sort_flag=true;                  // ----- TBC : An automatic sort should be writen ...                  // ----- Error log                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Invalid order of index range for option '".PclZipUtilOptionText($p_options_list[$i])."'");                  // ----- Return                  return PclZip::errorCode();              }              $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];          }          // ----- Sort the items          if ($v_sort_flag) {              // TBC : To Be Completed          }          // ----- Next option          $i++;        break;        // ----- Look for options that request no value        case PCLZIP_OPT_REMOVE_ALL_PATH :        case PCLZIP_OPT_EXTRACT_AS_STRING :        case PCLZIP_OPT_NO_COMPRESSION :        case PCLZIP_OPT_EXTRACT_IN_OUTPUT :        case PCLZIP_OPT_REPLACE_NEWER :        case PCLZIP_OPT_STOP_ON_ERROR :          $v_result_list[$p_options_list[$i]] = true;        break;        // ----- Look for options that request an octal value        case PCLZIP_OPT_SET_CHMOD :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          $i++;        break;        // ----- Look for options that request a call-back        case PCLZIP_CB_PRE_EXTRACT :        case PCLZIP_CB_POST_EXTRACT :        case PCLZIP_CB_PRE_ADD :        case PCLZIP_CB_POST_ADD :        /* for futur use        case PCLZIP_CB_PRE_DELETE :        case PCLZIP_CB_POST_DELETE :        case PCLZIP_CB_PRE_LIST :        case PCLZIP_CB_POST_LIST :        */          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_function_name = $p_options_list[$i+1];          // ----- Check that the value is a valid existing function          if (!function_exists($v_function_name)) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Function '".$v_function_name."()' is not an existing function for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Set the attribute          $v_result_list[$p_options_list[$i]] = $v_function_name;          $i++;        break;        default :          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,		                       "Unknown parameter '"							   .$p_options_list[$i]."'");          // ----- Return          return PclZip::errorCode();      }      // ----- Next options      $i++;    }    // ----- Look for mandatory options    if ($v_requested_options !== false) {      for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {        // ----- Look for mandatory option        if ($v_requested_options[$key] == 'mandatory') {          // ----- Look if present          if (!isset($v_result_list[$key])) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter ".PclZipUtilOptionText($key)."(".$key.")");            // ----- Return            return PclZip::errorCode();          }        }      }    }    // ----- Look for default values    if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privOptionDefaultThreshold()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privOptionDefaultThreshold(&$p_options)  {    $v_result=1;    if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])        || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {      return $v_result;    }    // ----- Get 'memory_limit' configuration value    $v_memory_limit = ini_get('memory_limit');    $v_memory_limit = trim($v_memory_limit);    $last = strtolower(substr($v_memory_limit, -1));    if($last == 'g')        //$v_memory_limit = $v_memory_limit*1024*1024*1024;        $v_memory_limit = $v_memory_limit*1073741824;    if($last == 'm')        //$v_memory_limit = $v_memory_limit*1024*1024;        $v_memory_limit = $v_memory_limit*1048576;    if($last == 'k')        $v_memory_limit = $v_memory_limit*1024;    $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit*PCLZIP_TEMPORARY_FILE_RATIO);    // ----- Sanity check : No threshold if value lower than 1M    if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) {      unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privFileDescrParseAtt()  // Description :  // Parameters :  // Return Values :  //   1 on success.  //   0 on failure.  // --------------------------------------------------------------------------------  function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options=false)  {    $v_result=1;    // ----- For each file in the list check the attributes    foreach ($p_file_list as $v_key => $v_value) {      // ----- Check if the option is supported      if (!isset($v_requested_options[$v_key])) {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file attribute '".$v_key."' for this file");        // ----- Return        return PclZip::errorCode();      }      // ----- Look for attribute      switch ($v_key) {        case PCLZIP_ATT_FILE_NAME :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['filename'] = PclZipUtilPathReduction($v_value);          if ($p_filedescr['filename'] == '') {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty filename for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }        break;        case PCLZIP_ATT_FILE_NEW_SHORT_NAME :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value);          if ($p_filedescr['new_short_name'] == '') {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty short filename for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }        break;        case PCLZIP_ATT_FILE_NEW_FULL_NAME :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value);          if ($p_filedescr['new_full_name'] == '') {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty full filename for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }        break;        // ----- Look for options that takes a string        case PCLZIP_ATT_FILE_COMMENT :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['comment'] = $v_value;        break;        case PCLZIP_ATT_FILE_MTIME :          if (!is_integer($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". Integer expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['mtime'] = $v_value;        break;        case PCLZIP_ATT_FILE_CONTENT :          $p_filedescr['content'] = $v_value;        break;        default :          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,		                           "Unknown parameter '".$v_key."'");          // ----- Return          return PclZip::errorCode();      }      // ----- Look for mandatory options      if ($v_requested_options !== false) {        for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {          // ----- Look for mandatory option          if ($v_requested_options[$key] == 'mandatory') {            // ----- Look if present            if (!isset($p_file_list[$key])) {              PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter ".PclZipUtilOptionText($key)."(".$key.")");              return PclZip::errorCode();            }          }        }      }    // end foreach    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privFileDescrExpand()  // Description :  //   This method look for each item of the list to see if its a file, a folder  //   or a string to be added as file. For any other type of files (link, other)  //   just ignore the item.  //   Then prepare the information that will be stored for that file.  //   When its a folder, expand the folder with all the files that are in that  //   folder (recursively).  // Parameters :  // Return Values :  //   1 on success.  //   0 on failure.  // --------------------------------------------------------------------------------  function privFileDescrExpand(&$p_filedescr_list, &$p_options)  {    $v_result=1;    // ----- Create a result list    $v_result_list = array();    // ----- Look each entry    for ($i=0; $i<sizeof($p_filedescr_list); $i++) {      // ----- Get filedescr      $v_descr = $p_filedescr_list[$i];      // ----- Reduce the filename      $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false);      $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']);      // ----- Look for real file or folder      if (file_exists($v_descr['filename'])) {        if (@is_file($v_descr['filename'])) {          $v_descr['type'] = 'file';        }        else if (@is_dir($v_descr['filename'])) {          $v_descr['type'] = 'folder';        }        else if (@is_link($v_descr['filename'])) {          // skip          continue;        }        else {          // skip          continue;        }      }      // ----- Look for string added as file      else if (isset($v_descr['content'])) {        $v_descr['type'] = 'virtual_file';      }      // ----- Missing file      else {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '".$v_descr['filename']."' does not exist");        // ----- Return        return PclZip::errorCode();      }      // ----- Calculate the stored filename      $this->privCalculateStoredFilename($v_descr, $p_options);      // ----- Add the descriptor in result list      $v_result_list[sizeof($v_result_list)] = $v_descr;      // ----- Look for folder      if ($v_descr['type'] == 'folder') {        // ----- List of items in folder        $v_dirlist_descr = array();        $v_dirlist_nb = 0;        if ($v_folder_handler = @opendir($v_descr['filename'])) {          while (($v_item_handler = @readdir($v_folder_handler)) !== false) {            // ----- Skip '.' and '..'            if (($v_item_handler == '.') || ($v_item_handler == '..')) {                continue;            }            // ----- Compose the full filename            $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'].'/'.$v_item_handler;            // ----- Look for different stored filename            // Because the name of the folder was changed, the name of the            // files/sub-folders also change            if (($v_descr['stored_filename'] != $v_descr['filename'])                 && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {              if ($v_descr['stored_filename'] != '') {                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'].'/'.$v_item_handler;              }              else {                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler;              }            }            $v_dirlist_nb++;          }          @closedir($v_folder_handler);        }        else {          // TBC : unable to open folder in read mode        }        // ----- Expand each element of the list        if ($v_dirlist_nb != 0) {          // ----- Expand          if (($v_result = $this->privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) {            return $v_result;          }          // ----- Concat the resulting list          $v_result_list = array_merge($v_result_list, $v_dirlist_descr);        }        else {        }        // ----- Free local array        unset($v_dirlist_descr);      }    }    // ----- Get the result list    $p_filedescr_list = $v_result_list;    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCreate()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privCreate($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    $v_list_detail = array();    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Open the file in write mode    if (($v_result = $this->privOpenFd('wb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Add the list of files    $v_result = $this->privAddList($p_filedescr_list, $p_result_list, $p_options);    // ----- Close    $this->privCloseFd();    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAdd()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privAdd($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    $v_list_detail = array();    // ----- Look if the archive exists or is empty    if ((!is_file($this->zipname)) || (filesize($this->zipname) == 0))    {      // ----- Do a create      $v_result = $this->privCreate($p_filedescr_list, $p_result_list, $p_options);      // ----- Return      return $v_result;    }    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Open the zip file    if (($v_result=$this->privOpenFd('rb')) != 1)    {      // ----- Magic quotes trick      $this->privSwapBackMagicQuotes();      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privCloseFd();      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Go to beginning of File    @rewind($this->zip_fd);    // ----- Creates a temporay file    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';    // ----- Open the temporary file in write mode    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)    {      $this->privCloseFd();      $this->privSwapBackMagicQuotes();      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_zip_temp_name.'\' in binary write mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Copy the files from the archive to the temporary file    // TBC : Here I should better append the file and go back to erase the central dir    $v_size = $v_central_dir['offset'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($this->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Swap the file descriptor    // Here is a trick : I swap the temporary fd with the zip fd, in order to use    // the following methods on the temporary fil and not the real archive    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Add the files    $v_header_list = array();    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)    {      fclose($v_zip_temp_fd);      $this->privCloseFd();      @unlink($v_zip_temp_name);      $this->privSwapBackMagicQuotes();      // ----- Return      return $v_result;    }    // ----- Store the offset of the central dir    $v_offset = @ftell($this->zip_fd);    // ----- Copy the block of file headers from the old archive    $v_size = $v_central_dir['size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($v_zip_temp_fd, $v_read_size);      @fwrite($this->zip_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Create the Central Dir files header    for ($i=0, $v_count=0; $i<sizeof($v_header_list); $i++)    {      // ----- Create the file header      if ($v_header_list[$i]['status'] == 'ok') {        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {          fclose($v_zip_temp_fd);          $this->privCloseFd();          @unlink($v_zip_temp_name);          $this->privSwapBackMagicQuotes();          // ----- Return          return $v_result;        }        $v_count++;      }      // ----- Transform the header to a 'usable' info      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);    }    // ----- Zip file comment    $v_comment = $v_central_dir['comment'];    if (isset($p_options[PCLZIP_OPT_COMMENT])) {      $v_comment = $p_options[PCLZIP_OPT_COMMENT];    }    if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) {      $v_comment = $v_comment.$p_options[PCLZIP_OPT_ADD_COMMENT];    }    if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) {      $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT].$v_comment;    }    // ----- Calculate the size of the central header    $v_size = @ftell($this->zip_fd)-$v_offset;    // ----- Create the central dir footer    if (($v_result = $this->privWriteCentralHeader($v_count+$v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1)    {      // ----- Reset the file list      unset($v_header_list);      $this->privSwapBackMagicQuotes();      // ----- Return      return $v_result;    }    // ----- Swap back the file descriptor    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Close    $this->privCloseFd();    // ----- Close the temporary file    @fclose($v_zip_temp_fd);    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Delete the zip file    // TBC : I should test the result ...    @unlink($this->zipname);    // ----- Rename the temporary file    // TBC : I should test the result ...    //@rename($v_zip_temp_name, $this->zipname);    PclZipUtilRename($v_zip_temp_name, $this->zipname);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privOpenFd()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privOpenFd($p_mode)  {    $v_result=1;    // ----- Look if already open    if ($this->zip_fd != 0)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \''.$this->zipname.'\' already open');      // ----- Return      return PclZip::errorCode();    }    // ----- Open the zip file    if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in '.$p_mode.' mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCloseFd()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privCloseFd()  {    $v_result=1;    if ($this->zip_fd != 0)      @fclose($this->zip_fd);    $this->zip_fd = 0;    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddList()  // Description :  //   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is  //   different from the real path of the file. This is usefull if you want to have PclTar  //   running in any directory, and memorize relative path from an other directory.  // Parameters :  //   $p_list : An array containing the file or directory names to add in the tar  //   $p_result_list : list of added files with their properties (specially the status field)  //   $p_add_dir : Path to add in the filename path archived  //   $p_remove_dir : Path to remove in the filename path archived  // Return Values :  // --------------------------------------------------------------------------------//  function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)  function privAddList($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    // ----- Add the files    $v_header_list = array();    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)    {      // ----- Return      return $v_result;    }    // ----- Store the offset of the central dir    $v_offset = @ftell($this->zip_fd);    // ----- Create the Central Dir files header    for ($i=0,$v_count=0; $i<sizeof($v_header_list); $i++)    {      // ----- Create the file header      if ($v_header_list[$i]['status'] == 'ok') {        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {          // ----- Return          return $v_result;        }        $v_count++;      }      // ----- Transform the header to a 'usable' info      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);    }    // ----- Zip file comment    $v_comment = '';    if (isset($p_options[PCLZIP_OPT_COMMENT])) {      $v_comment = $p_options[PCLZIP_OPT_COMMENT];    }    // ----- Calculate the size of the central header    $v_size = @ftell($this->zip_fd)-$v_offset;    // ----- Create the central dir footer    if (($v_result = $this->privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1)    {      // ----- Reset the file list      unset($v_header_list);      // ----- Return      return $v_result;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddFileList()  // Description :  // Parameters :  //   $p_filedescr_list : An array containing the file description  //                      or directory names to add in the zip  //   $p_result_list : list of added files with their properties (specially the status field)  // Return Values :  // --------------------------------------------------------------------------------  function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    $v_header = array();    // ----- Recuperate the current number of elt in list    $v_nb = sizeof($p_result_list);    // ----- Loop on the files    for ($j=0; ($j<sizeof($p_filedescr_list)) && ($v_result==1); $j++) {      // ----- Format the filename      $p_filedescr_list[$j]['filename']      = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false);      // ----- Skip empty file names      // TBC : Can this be possible ? not checked in DescrParseAtt ?      if ($p_filedescr_list[$j]['filename'] == "") {        continue;      }      // ----- Check the filename      if (   ($p_filedescr_list[$j]['type'] != 'virtual_file')          && (!file_exists($p_filedescr_list[$j]['filename']))) {        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '".$p_filedescr_list[$j]['filename']."' does not exist");        return PclZip::errorCode();      }      // ----- Look if it is a file or a dir with no all path remove option      // or a dir with all its path removed//      if (   (is_file($p_filedescr_list[$j]['filename']))//          || (   is_dir($p_filedescr_list[$j]['filename'])      if (   ($p_filedescr_list[$j]['type'] == 'file')          || ($p_filedescr_list[$j]['type'] == 'virtual_file')          || (   ($p_filedescr_list[$j]['type'] == 'folder')              && (   !isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])                  || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))          ) {        // ----- Add the file        $v_result = $this->privAddFile($p_filedescr_list[$j], $v_header,                                       $p_options);        if ($v_result != 1) {          return $v_result;        }        // ----- Store the file infos        $p_result_list[$v_nb++] = $v_header;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddFile()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privAddFile($p_filedescr, &$p_header, &$p_options)  {    $v_result=1;    // ----- Working variable    $p_filename = $p_filedescr['filename'];    // TBC : Already done in the fileAtt check ... ?    if ($p_filename == "") {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file list parameter (invalid or empty list)");      // ----- Return      return PclZip::errorCode();    }    // ----- Look for a stored different filename    /* TBC : Removed    if (isset($p_filedescr['stored_filename'])) {      $v_stored_filename = $p_filedescr['stored_filename'];    }    else {      $v_stored_filename = $p_filedescr['stored_filename'];    }    */    // ----- Set the file properties    clearstatcache();    $p_header['version'] = 20;    $p_header['version_extracted'] = 10;    $p_header['flag'] = 0;    $p_header['compression'] = 0;    $p_header['crc'] = 0;    $p_header['compressed_size'] = 0;    $p_header['filename_len'] = strlen($p_filename);    $p_header['extra_len'] = 0;    $p_header['disk'] = 0;    $p_header['internal'] = 0;    $p_header['offset'] = 0;    $p_header['filename'] = $p_filename;// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;    $p_header['stored_filename'] = $p_filedescr['stored_filename'];    $p_header['extra'] = '';    $p_header['status'] = 'ok';    $p_header['index'] = -1;    // ----- Look for regular file    if ($p_filedescr['type']=='file') {      $p_header['external'] = 0x00000000;      $p_header['size'] = filesize($p_filename);    }    // ----- Look for regular folder    else if ($p_filedescr['type']=='folder') {      $p_header['external'] = 0x00000010;      $p_header['mtime'] = filemtime($p_filename);      $p_header['size'] = filesize($p_filename);    }    // ----- Look for virtual file    else if ($p_filedescr['type'] == 'virtual_file') {      $p_header['external'] = 0x00000000;      $p_header['size'] = strlen($p_filedescr['content']);    }    // ----- Look for filetime    if (isset($p_filedescr['mtime'])) {      $p_header['mtime'] = $p_filedescr['mtime'];    }    else if ($p_filedescr['type'] == 'virtual_file') {      $p_header['mtime'] = time();    }    else {      $p_header['mtime'] = filemtime($p_filename);    }    // ------ Look for file comment    if (isset($p_filedescr['comment'])) {      $p_header['comment_len'] = strlen($p_filedescr['comment']);      $p_header['comment'] = $p_filedescr['comment'];    }    else {      $p_header['comment_len'] = 0;      $p_header['comment'] = '';    }    // ----- Look for pre-add callback    if (isset($p_options[PCLZIP_CB_PRE_ADD])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_header, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_header['status'] = "skipped";        $v_result = 1;      }      // ----- Update the informations      // Only some fields can be modified      if ($p_header['stored_filename'] != $v_local_header['stored_filename']) {        $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']);      }    }    // ----- Look for empty stored filename    if ($p_header['stored_filename'] == "") {      $p_header['status'] = "filtered";    }    // ----- Check the path length    if (strlen($p_header['stored_filename']) > 0xFF) {      $p_header['status'] = 'filename_too_long';    }    // ----- Look if no error, or file not skipped    if ($p_header['status'] == 'ok') {      // ----- Look for a file      if ($p_filedescr['type'] == 'file') {        // ----- Look for using temporary file to zip        if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))            && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])                || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])                    && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_header['size'])) ) ) {          $v_result = $this->privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);          if ($v_result < PCLZIP_ERR_NO_ERROR) {            return $v_result;          }        }        // ----- Use "in memory" zip algo        else {        // ----- Open the source file        if (($v_file = @fopen($p_filename, "rb")) == 0) {          PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode");          return PclZip::errorCode();        }        // ----- Read the file content        $v_content = @fread($v_file, $p_header['size']);        // ----- Close the file        @fclose($v_file);        // ----- Calculate the CRC        $p_header['crc'] = @crc32($v_content);        // ----- Look for no compression        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {          // ----- Set header parameters          $p_header['compressed_size'] = $p_header['size'];          $p_header['compression'] = 0;        }        // ----- Look for normal compression        else {          // ----- Compress the content          $v_content = @gzdeflate($v_content);          // ----- Set header parameters          $p_header['compressed_size'] = strlen($v_content);          $p_header['compression'] = 8;        }        // ----- Call the header generation        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {          @fclose($v_file);          return $v_result;        }        // ----- Write the compressed (or not) content        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);        }      }      // ----- Look for a virtual file (a file from string)      else if ($p_filedescr['type'] == 'virtual_file') {        $v_content = $p_filedescr['content'];        // ----- Calculate the CRC        $p_header['crc'] = @crc32($v_content);        // ----- Look for no compression        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {          // ----- Set header parameters          $p_header['compressed_size'] = $p_header['size'];          $p_header['compression'] = 0;        }        // ----- Look for normal compression        else {          // ----- Compress the content          $v_content = @gzdeflate($v_content);          // ----- Set header parameters          $p_header['compressed_size'] = strlen($v_content);          $p_header['compression'] = 8;        }        // ----- Call the header generation        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {          @fclose($v_file);          return $v_result;        }        // ----- Write the compressed (or not) content        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);      }      // ----- Look for a directory      else if ($p_filedescr['type'] == 'folder') {        // ----- Look for directory last '/'        if (@substr($p_header['stored_filename'], -1) != '/') {          $p_header['stored_filename'] .= '/';        }        // ----- Set the file properties        $p_header['size'] = 0;        //$p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked        $p_header['external'] = 0x00000010;   // Value for a folder : to be checked        // ----- Call the header generation        if (($v_result = $this->privWriteFileHeader($p_header)) != 1)        {          return $v_result;        }      }    }    // ----- Look for post-add callback    if (isset($p_options[PCLZIP_CB_POST_ADD])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_header, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);      if ($v_result == 0) {        // ----- Ignored        $v_result = 1;      }      // ----- Update the informations      // Nothing can be modified    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddFileUsingTempFile()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options)  {    $v_result=PCLZIP_ERR_NO_ERROR;    // ----- Working variable    $p_filename = $p_filedescr['filename'];    // ----- Open the source file    if (($v_file = @fopen($p_filename, "rb")) == 0) {      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode");      return PclZip::errorCode();    }    // ----- Creates a compressed temporary file    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';    if (($v_file_compressed = @gzopen($v_gzip_temp_name, "wb")) == 0) {      fclose($v_file);      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary write mode');      return PclZip::errorCode();    }    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    $v_size = filesize($p_filename);    while ($v_size != 0) {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($v_file, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @gzputs($v_file_compressed, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Close the file    @fclose($v_file);    @gzclose($v_file_compressed);    // ----- Check the minimum file size    if (filesize($v_gzip_temp_name) < 18) {      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'gzip temporary file \''.$v_gzip_temp_name.'\' has invalid filesize - should be minimum 18 bytes');      return PclZip::errorCode();    }    // ----- Extract the compressed attributes    if (($v_file_compressed = @fopen($v_gzip_temp_name, "rb")) == 0) {      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');      return PclZip::errorCode();    }    // ----- Read the gzip file header    $v_binary_data = @fread($v_file_compressed, 10);    $v_data_header = unpack('a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os', $v_binary_data);    // ----- Check some parameters    $v_data_header['os'] = bin2hex($v_data_header['os']);    // ----- Read the gzip file footer    @fseek($v_file_compressed, filesize($v_gzip_temp_name)-8);    $v_binary_data = @fread($v_file_compressed, 8);    $v_data_footer = unpack('Vcrc/Vcompressed_size', $v_binary_data);    // ----- Set the attributes    $p_header['compression'] = ord($v_data_header['cm']);    //$p_header['mtime'] = $v_data_header['mtime'];    $p_header['crc'] = $v_data_footer['crc'];    $p_header['compressed_size'] = filesize($v_gzip_temp_name)-18;    // ----- Close the file    @fclose($v_file_compressed);    // ----- Call the header generation    if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {      return $v_result;    }    // ----- Add the compressed data    if (($v_file_compressed = @fopen($v_gzip_temp_name, "rb")) == 0)    {      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');      return PclZip::errorCode();    }    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    fseek($v_file_compressed, 10);    $v_size = $p_header['compressed_size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($v_file_compressed, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @fwrite($this->zip_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Close the file    @fclose($v_file_compressed);    // ----- Unlink the temporary file    @unlink($v_gzip_temp_name);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCalculateStoredFilename()  // Description :  //   Based on file descriptor properties and global options, this method  //   calculate the filename that will be stored in the archive.  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privCalculateStoredFilename(&$p_filedescr, &$p_options)  {    $v_result=1;    // ----- Working variables    $p_filename = $p_filedescr['filename'];    if (isset($p_options[PCLZIP_OPT_ADD_PATH])) {      $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH];    }    else {      $p_add_dir = '';    }    if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) {      $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH];    }    else {      $p_remove_dir = '';    }    if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {      $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH];    }    else {      $p_remove_all_dir = 0;    }    // ----- Look for full name change    if (isset($p_filedescr['new_full_name'])) {      // ----- Remove drive letter if any      $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']);    }    // ----- Look for path and/or short name change    else {      // ----- Look for short name change      // Its when we cahnge just the filename but not the path      if (isset($p_filedescr['new_short_name'])) {        $v_path_info = pathinfo($p_filename);        $v_dir = '';        if ($v_path_info['dirname'] != '') {          $v_dir = $v_path_info['dirname'].'/';        }        $v_stored_filename = $v_dir.$p_filedescr['new_short_name'];      }      else {        // ----- Calculate the stored filename        $v_stored_filename = $p_filename;      }      // ----- Look for all path to remove      if ($p_remove_all_dir) {        $v_stored_filename = basename($p_filename);      }      // ----- Look for partial path remove      else if ($p_remove_dir != "") {        if (substr($p_remove_dir, -1) != '/')          $p_remove_dir .= "/";        if (   (substr($p_filename, 0, 2) == "./")            || (substr($p_remove_dir, 0, 2) == "./")) {          if (   (substr($p_filename, 0, 2) == "./")              && (substr($p_remove_dir, 0, 2) != "./")) {            $p_remove_dir = "./".$p_remove_dir;          }          if (   (substr($p_filename, 0, 2) != "./")              && (substr($p_remove_dir, 0, 2) == "./")) {            $p_remove_dir = substr($p_remove_dir, 2);          }        }        $v_compare = PclZipUtilPathInclusion($p_remove_dir,                                             $v_stored_filename);        if ($v_compare > 0) {          if ($v_compare == 2) {            $v_stored_filename = "";          }          else {            $v_stored_filename = substr($v_stored_filename,                                        strlen($p_remove_dir));          }        }      }      // ----- Remove drive letter if any      $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);      // ----- Look for path to add      if ($p_add_dir != "") {        if (substr($p_add_dir, -1) == "/")          $v_stored_filename = $p_add_dir.$v_stored_filename;        else          $v_stored_filename = $p_add_dir."/".$v_stored_filename;      }    }    // ----- Filename (reduce the path of stored name)    $v_stored_filename = PclZipUtilPathReduction($v_stored_filename);    $p_filedescr['stored_filename'] = $v_stored_filename;    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privWriteFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privWriteFileHeader(&$p_header)  {    $v_result=1;    // ----- Store the offset position of the file    $p_header['offset'] = ftell($this->zip_fd);    // ----- Transform UNIX mtime to DOS format mdate/mtime    $v_date = getdate($p_header['mtime']);    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];    // ----- Packed data    $v_binary_data = pack("VvvvvvVVVvv", 0x04034b50,	                      $p_header['version_extracted'], $p_header['flag'],                          $p_header['compression'], $v_mtime, $v_mdate,                          $p_header['crc'], $p_header['compressed_size'],						  $p_header['size'],                          strlen($p_header['stored_filename']),						  $p_header['extra_len']);    // ----- Write the first 148 bytes of the header in the archive    fputs($this->zip_fd, $v_binary_data, 30);    // ----- Write the variable fields    if (strlen($p_header['stored_filename']) != 0)    {      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));    }    if ($p_header['extra_len'] != 0)    {      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privWriteCentralFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privWriteCentralFileHeader(&$p_header)  {    $v_result=1;    // TBC    //for(reset($p_header); $key = key($p_header); next($p_header)) {    //}    // ----- Transform UNIX mtime to DOS format mdate/mtime    $v_date = getdate($p_header['mtime']);    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];    // ----- Packed data    $v_binary_data = pack("VvvvvvvVVVvvvvvVV", 0x02014b50,	                      $p_header['version'], $p_header['version_extracted'],                          $p_header['flag'], $p_header['compression'],						  $v_mtime, $v_mdate, $p_header['crc'],                          $p_header['compressed_size'], $p_header['size'],                          strlen($p_header['stored_filename']),						  $p_header['extra_len'], $p_header['comment_len'],                          $p_header['disk'], $p_header['internal'],						  $p_header['external'], $p_header['offset']);    // ----- Write the 42 bytes of the header in the zip file    fputs($this->zip_fd, $v_binary_data, 46);    // ----- Write the variable fields    if (strlen($p_header['stored_filename']) != 0)    {      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));    }    if ($p_header['extra_len'] != 0)    {      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);    }    if ($p_header['comment_len'] != 0)    {      fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']);    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privWriteCentralHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment)  {    $v_result=1;    // ----- Packed data    $v_binary_data = pack("VvvvvVVv", 0x06054b50, 0, 0, $p_nb_entries,	                      $p_nb_entries, $p_size,						  $p_offset, strlen($p_comment));    // ----- Write the 22 bytes of the header in the zip file    fputs($this->zip_fd, $v_binary_data, 22);    // ----- Write the variable fields    if (strlen($p_comment) != 0)    {      fputs($this->zip_fd, $p_comment, strlen($p_comment));    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privList()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privList(&$p_list)  {    $v_result=1;    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Open the zip file    if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)    {      // ----- Magic quotes trick      $this->privSwapBackMagicQuotes();      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in binary read mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Go to beginning of Central Dir    @rewind($this->zip_fd);    if (@fseek($this->zip_fd, $v_central_dir['offset']))    {      $this->privSwapBackMagicQuotes();      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');      // ----- Return      return PclZip::errorCode();    }    // ----- Read each entry    for ($i=0; $i<$v_central_dir['entries']; $i++)    {      // ----- Read the file header      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)      {        $this->privSwapBackMagicQuotes();        return $v_result;      }      $v_header['index'] = $i;      // ----- Get the only interesting attributes      $this->privConvertHeader2FileInfo($v_header, $p_list[$i]);      unset($v_header);    }    // ----- Close the zip file    $this->privCloseFd();    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privConvertHeader2FileInfo()  // Description :  //   This function takes the file informations from the central directory  //   entries and extract the interesting parameters that will be given back.  //   The resulting file infos are set in the array $p_info  //     $p_info['filename'] : Filename with full path. Given by user (add),  //                           extracted in the filesystem (extract).  //     $p_info['stored_filename'] : Stored filename in the archive.  //     $p_info['size'] = Size of the file.  //     $p_info['compressed_size'] = Compressed size of the file.  //     $p_info['mtime'] = Last modification date of the file.  //     $p_info['comment'] = Comment associated with the file.  //     $p_info['folder'] = true/false : indicates if the entry is a folder or not.  //     $p_info['status'] = status of the action on the file.  //     $p_info['crc'] = CRC of the file content.  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privConvertHeader2FileInfo($p_header, &$p_info)  {    $v_result=1;    // ----- Get the interesting attributes    $v_temp_path = PclZipUtilPathReduction($p_header['filename']);    $p_info['filename'] = $v_temp_path;    $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']);    $p_info['stored_filename'] = $v_temp_path;    $p_info['size'] = $p_header['size'];    $p_info['compressed_size'] = $p_header['compressed_size'];    $p_info['mtime'] = $p_header['mtime'];    $p_info['comment'] = $p_header['comment'];    $p_info['folder'] = (($p_header['external']&0x00000010)==0x00000010);    $p_info['index'] = $p_header['index'];    $p_info['status'] = $p_header['status'];    $p_info['crc'] = $p_header['crc'];    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractByRule()  // Description :  //   Extract a file or directory depending of rules (by index, by name, ...)  // Parameters :  //   $p_file_list : An array where will be placed the properties of each  //                  extracted file  //   $p_path : Path to add while writing the extracted files  //   $p_remove_path : Path to remove (from the file memorized path) while writing the  //                    extracted files. If the path does not match the file path,  //                    the file is extracted with its memorized path.  //                    $p_remove_path does not apply to 'list' mode.  //                    $p_path and $p_remove_path are commulative.  // Return Values :  //   1 on success,0 or less on error (see error code list)  // --------------------------------------------------------------------------------  function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)  {    $v_result=1;    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Check the path    if (   ($p_path == "")	    || (   (substr($p_path, 0, 1) != "/")		    && (substr($p_path, 0, 3) != "../")			&& (substr($p_path,1,2)!=":/")))      $p_path = "./".$p_path;    // ----- Reduce the path last (and duplicated) '/'    if (($p_path != "./") && ($p_path != "/"))    {      // ----- Look for the path end '/'      while (substr($p_path, -1) == "/")      {        $p_path = substr($p_path, 0, strlen($p_path)-1);      }    }    // ----- Look for path to remove format (should end by /)    if (($p_remove_path != "") && (substr($p_remove_path, -1) != '/'))    {      $p_remove_path .= '/';    }    $p_remove_path_size = strlen($p_remove_path);    // ----- Open the zip file    if (($v_result = $this->privOpenFd('rb')) != 1)    {      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      // ----- Close the zip file      $this->privCloseFd();      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Start at beginning of Central Dir    $v_pos_entry = $v_central_dir['offset'];    // ----- Read each entry    $j_start = 0;    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)    {      // ----- Read next Central dir entry      @rewind($this->zip_fd);      if (@fseek($this->zip_fd, $v_pos_entry))      {        // ----- Close the zip file        $this->privCloseFd();        $this->privSwapBackMagicQuotes();        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');        // ----- Return        return PclZip::errorCode();      }      // ----- Read the file header      $v_header = array();      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)      {        // ----- Close the zip file        $this->privCloseFd();        $this->privSwapBackMagicQuotes();        return $v_result;      }      // ----- Store the index      $v_header['index'] = $i;      // ----- Store the file position      $v_pos_entry = ftell($this->zip_fd);      // ----- Look for the specific extract rules      $v_extract = false;      // ----- Look for extract by name rule      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {          // ----- Look if the filename is in the list          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {              // ----- Look for a directory              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == "/") {                  // ----- Look if the directory is in the filename path                  if (   (strlen($v_header['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))                      && (substr($v_header['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {                      $v_extract = true;                  }              }              // ----- Look for a filename              elseif ($v_header['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {                  $v_extract = true;              }          }      }      // ----- Look for extract by ereg rule      // ereg() is deprecated with PHP 5.3      /*      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))               && ($p_options[PCLZIP_OPT_BY_EREG] != "")) {          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header['stored_filename'])) {              $v_extract = true;          }      }      */      // ----- Look for extract by preg rule      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))               && ($p_options[PCLZIP_OPT_BY_PREG] != "")) {          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header['stored_filename'])) {              $v_extract = true;          }      }      // ----- Look for extract by index rule      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {          // ----- Look if the index is in the list          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {                  $v_extract = true;              }              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {                  $j_start = $j+1;              }              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {                  break;              }          }      }      // ----- Look for no rule, which means extract all the archive      else {          $v_extract = true;      }	  // ----- Check compression method	  if (   ($v_extract)	      && (   ($v_header['compression'] != 8)		      && ($v_header['compression'] != 0))) {          $v_header['status'] = 'unsupported_compression';          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		      && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {              $this->privSwapBackMagicQuotes();              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION,			                       "Filename '".$v_header['stored_filename']."' is "				  	    	  	   ."compressed by an unsupported compression "				  	    	  	   ."method (".$v_header['compression'].") ");              return PclZip::errorCode();		  }	  }	  // ----- Check encrypted files	  if (($v_extract) && (($v_header['flag'] & 1) == 1)) {          $v_header['status'] = 'unsupported_encryption';          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		      && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {              $this->privSwapBackMagicQuotes();              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION,			                       "Unsupported encryption for "				  	    	  	   ." filename '".$v_header['stored_filename']								   ."'");              return PclZip::errorCode();		  }    }      // ----- Look for real extraction      if (($v_extract) && ($v_header['status'] != 'ok')) {          $v_result = $this->privConvertHeader2FileInfo($v_header,		                                        $p_file_list[$v_nb_extracted++]);          if ($v_result != 1) {              $this->privCloseFd();              $this->privSwapBackMagicQuotes();              return $v_result;          }          $v_extract = false;      }      // ----- Look for real extraction      if ($v_extract)      {        // ----- Go to the file position        @rewind($this->zip_fd);        if (@fseek($this->zip_fd, $v_header['offset']))        {          // ----- Close the zip file          $this->privCloseFd();          $this->privSwapBackMagicQuotes();          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');          // ----- Return          return PclZip::errorCode();        }        // ----- Look for extraction as string        if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {          $v_string = '';          // ----- Extracting the file          $v_result1 = $this->privExtractFileAsString($v_header, $v_string, $p_options);          if ($v_result1 < 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result1;          }          // ----- Get the only interesting attributes          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1)          {            // ----- Close the zip file            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result;          }          // ----- Set the file content          $p_file_list[$v_nb_extracted]['content'] = $v_string;          // ----- Next extracted file          $v_nb_extracted++;          // ----- Look for user callback abort          if ($v_result1 == 2) {          	break;          }        }        // ----- Look for extraction in standard output        elseif (   (isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT]))		        && ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {          // ----- Extracting the file in standard output          $v_result1 = $this->privExtractFileInOutput($v_header, $p_options);          if ($v_result1 < 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result1;          }          // ----- Get the only interesting attributes          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result;          }          // ----- Look for user callback abort          if ($v_result1 == 2) {          	break;          }        }        // ----- Look for normal extraction        else {          // ----- Extracting the file          $v_result1 = $this->privExtractFile($v_header,		                                      $p_path, $p_remove_path,											  $p_remove_all_path,											  $p_options);          if ($v_result1 < 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result1;          }          // ----- Get the only interesting attributes          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1)          {            // ----- Close the zip file            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result;          }          // ----- Look for user callback abort          if ($v_result1 == 2) {          	break;          }        }      }    }    // ----- Close the zip file    $this->privCloseFd();    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFile()  // Description :  // Parameters :  // Return Values :  //  // 1 : ... ?  // PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback  // --------------------------------------------------------------------------------  function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)  {    $v_result=1;    // ----- Read the file header    if (($v_result = $this->privReadFileHeader($v_header)) != 1)    {      // ----- Return      return $v_result;    }    // ----- Check that the file header is coherent with $p_entry info    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {        // TBC    }    // ----- Look for all path to remove    if ($p_remove_all_path == true) {        // ----- Look for folder entry that not need to be extracted        if (($p_entry['external']&0x00000010)==0x00000010) {            $p_entry['status'] = "filtered";            return $v_result;        }        // ----- Get the basename of the path        $p_entry['filename'] = basename($p_entry['filename']);    }    // ----- Look for path to remove    else if ($p_remove_path != "")    {      if (PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2)      {        // ----- Change the file status        $p_entry['status'] = "filtered";        // ----- Return        return $v_result;      }      $p_remove_path_size = strlen($p_remove_path);      if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path)      {        // ----- Remove the path        $p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);      }    }    // ----- Add the path    if ($p_path != '') {      $p_entry['filename'] = $p_path."/".$p_entry['filename'];    }    // ----- Check a base_dir_restriction    if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {      $v_inclusion      = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION],                                $p_entry['filename']);      if ($v_inclusion == 0) {        PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION,			                     "Filename '".$p_entry['filename']."' is "								 ."outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION");        return PclZip::errorCode();      }    }    // ----- Look for pre-extract callback    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_entry['status'] = "skipped";        $v_result = 1;      }      // ----- Look for abort result      if ($v_result == 2) {        // ----- This status is internal and will be changed in 'skipped'        $p_entry['status'] = "aborted";      	$v_result = PCLZIP_ERR_USER_ABORTED;      }      // ----- Update the informations      // Only some fields can be modified      $p_entry['filename'] = $v_local_header['filename'];    }    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {    // ----- Look for specific actions while the file exist    if (file_exists($p_entry['filename']))    {      // ----- Look if file is a directory      if (is_dir($p_entry['filename']))      {        // ----- Change the file status        $p_entry['status'] = "already_a_directory";        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR        // For historical reason first PclZip implementation does not stop        // when this kind of error occurs.        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		    && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {            PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY,			                     "Filename '".$p_entry['filename']."' is "								 ."already used by an existing directory");            return PclZip::errorCode();		    }      }      // ----- Look if file is write protected      else if (!is_writeable($p_entry['filename']))      {        // ----- Change the file status        $p_entry['status'] = "write_protected";        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR        // For historical reason first PclZip implementation does not stop        // when this kind of error occurs.        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		    && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,			                     "Filename '".$p_entry['filename']."' exists "								 ."and is write protected");            return PclZip::errorCode();		    }      }      // ----- Look if the extracted file is older      else if (filemtime($p_entry['filename']) > $p_entry['mtime'])      {        // ----- Change the file status        if (   (isset($p_options[PCLZIP_OPT_REPLACE_NEWER]))		    && ($p_options[PCLZIP_OPT_REPLACE_NEWER]===true)) {	  	  }		    else {            $p_entry['status'] = "newer_exist";            // ----- Look for PCLZIP_OPT_STOP_ON_ERROR            // For historical reason first PclZip implementation does not stop            // when this kind of error occurs.            if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		        && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {                PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,			             "Newer version of '".$p_entry['filename']."' exists "					    ."and option PCLZIP_OPT_REPLACE_NEWER is not selected");                return PclZip::errorCode();		      }		    }      }      else {      }    }    // ----- Check the directory availability and create it if necessary    else {      if ((($p_entry['external']&0x00000010)==0x00000010) || (substr($p_entry['filename'], -1) == '/'))        $v_dir_to_check = $p_entry['filename'];      else if (!strstr($p_entry['filename'], "/"))        $v_dir_to_check = "";      else        $v_dir_to_check = dirname($p_entry['filename']);        if (($v_result = $this->privDirCheck($v_dir_to_check, (($p_entry['external']&0x00000010)==0x00000010))) != 1) {          // ----- Change the file status          $p_entry['status'] = "path_creation_fail";          // ----- Return          //return $v_result;          $v_result = 1;        }      }    }    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {      // ----- Do the extraction (if not a folder)      if (!(($p_entry['external']&0x00000010)==0x00000010))      {        // ----- Look for not compressed file        if ($p_entry['compression'] == 0) {    		  // ----- Opening destination file          if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0)          {            // ----- Change the file status            $p_entry['status'] = "write_error";            // ----- Return            return $v_result;          }          // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks          $v_size = $p_entry['compressed_size'];          while ($v_size != 0)          {            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);            $v_buffer = @fread($this->zip_fd, $v_read_size);            /* Try to speed up the code            $v_binary_data = pack('a'.$v_read_size, $v_buffer);            @fwrite($v_dest_file, $v_binary_data, $v_read_size);            */            @fwrite($v_dest_file, $v_buffer, $v_read_size);            $v_size -= $v_read_size;          }          // ----- Closing the destination file          fclose($v_dest_file);          // ----- Change the file mtime          touch($p_entry['filename'], $p_entry['mtime']);        }        else {          // ----- TBC          // Need to be finished          if (($p_entry['flag'] & 1) == 1) {            PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, 'File \''.$p_entry['filename'].'\' is encrypted. Encrypted files are not supported.');            return PclZip::errorCode();          }          // ----- Look for using temporary file to unzip          if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))              && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])                  || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])                      && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_entry['size'])) ) ) {            $v_result = $this->privExtractFileUsingTempFile($p_entry, $p_options);            if ($v_result < PCLZIP_ERR_NO_ERROR) {              return $v_result;            }          }          // ----- Look for extract in memory          else {            // ----- Read the compressed file in a buffer (one shot)            $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);            // ----- Decompress the file            $v_file_content = @gzinflate($v_buffer);            unset($v_buffer);            if ($v_file_content === FALSE) {              // ----- Change the file status              // TBC              $p_entry['status'] = "error";              return $v_result;            }            // ----- Opening destination file            if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {              // ----- Change the file status              $p_entry['status'] = "write_error";              return $v_result;            }            // ----- Write the uncompressed data            @fwrite($v_dest_file, $v_file_content, $p_entry['size']);            unset($v_file_content);            // ----- Closing the destination file            @fclose($v_dest_file);          }          // ----- Change the file mtime          @touch($p_entry['filename'], $p_entry['mtime']);        }        // ----- Look for chmod option        if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {          // ----- Change the mode of the file          @chmod($p_entry['filename'], $p_options[PCLZIP_OPT_SET_CHMOD]);        }      }    }  	// ----- Change abort status  	if ($p_entry['status'] == "aborted") {        $p_entry['status'] = "skipped";  	}    // ----- Look for post-extract callback    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);      // ----- Look for abort result      if ($v_result == 2) {      	$v_result = PCLZIP_ERR_USER_ABORTED;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFileUsingTempFile()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privExtractFileUsingTempFile(&$p_entry, &$p_options)  {    $v_result=1;    // ----- Creates a temporary file    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';    if (($v_dest_file = @fopen($v_gzip_temp_name, "wb")) == 0) {      fclose($v_file);      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary write mode');      return PclZip::errorCode();    }    // ----- Write gz file format header    $v_binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($p_entry['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));    @fwrite($v_dest_file, $v_binary_data, 10);    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    $v_size = $p_entry['compressed_size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($this->zip_fd, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @fwrite($v_dest_file, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Write gz file format footer    $v_binary_data = pack('VV', $p_entry['crc'], $p_entry['size']);    @fwrite($v_dest_file, $v_binary_data, 8);    // ----- Close the temporary file    @fclose($v_dest_file);    // ----- Opening destination file    if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {      $p_entry['status'] = "write_error";      return $v_result;    }    // ----- Open the temporary gz file    if (($v_src_file = @gzopen($v_gzip_temp_name, 'rb')) == 0) {      @fclose($v_dest_file);      $p_entry['status'] = "read_error";      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');      return PclZip::errorCode();    }    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    $v_size = $p_entry['size'];    while ($v_size != 0) {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @gzread($v_src_file, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @fwrite($v_dest_file, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    @fclose($v_dest_file);    @gzclose($v_src_file);    // ----- Delete the temporary file    @unlink($v_gzip_temp_name);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFileInOutput()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privExtractFileInOutput(&$p_entry, &$p_options)  {    $v_result=1;    // ----- Read the file header    if (($v_result = $this->privReadFileHeader($v_header)) != 1) {      return $v_result;    }    // ----- Check that the file header is coherent with $p_entry info    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {        // TBC    }    // ----- Look for pre-extract callback    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_entry['status'] = "skipped";        $v_result = 1;      }      // ----- Look for abort result      if ($v_result == 2) {        // ----- This status is internal and will be changed in 'skipped'        $p_entry['status'] = "aborted";      	$v_result = PCLZIP_ERR_USER_ABORTED;      }      // ----- Update the informations      // Only some fields can be modified      $p_entry['filename'] = $v_local_header['filename'];    }    // ----- Trace    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {      // ----- Do the extraction (if not a folder)      if (!(($p_entry['external']&0x00000010)==0x00000010)) {        // ----- Look for not compressed file        if ($p_entry['compressed_size'] == $p_entry['size']) {          // ----- Read the file in a buffer (one shot)          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);          // ----- Send the file to the output          echo $v_buffer;          unset($v_buffer);        }        else {          // ----- Read the compressed file in a buffer (one shot)          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);          // ----- Decompress the file          $v_file_content = gzinflate($v_buffer);          unset($v_buffer);          // ----- Send the file to the output          echo $v_file_content;          unset($v_file_content);        }      }    }	// ----- Change abort status	if ($p_entry['status'] == "aborted") {      $p_entry['status'] = "skipped";	}    // ----- Look for post-extract callback    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);      // ----- Look for abort result      if ($v_result == 2) {      	$v_result = PCLZIP_ERR_USER_ABORTED;      }    }    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFileAsString()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privExtractFileAsString(&$p_entry, &$p_string, &$p_options)  {    $v_result=1;    // ----- Read the file header    $v_header = array();    if (($v_result = $this->privReadFileHeader($v_header)) != 1)    {      // ----- Return      return $v_result;    }    // ----- Check that the file header is coherent with $p_entry info    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {        // TBC    }    // ----- Look for pre-extract callback    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_entry['status'] = "skipped";        $v_result = 1;      }      // ----- Look for abort result      if ($v_result == 2) {        // ----- This status is internal and will be changed in 'skipped'        $p_entry['status'] = "aborted";      	$v_result = PCLZIP_ERR_USER_ABORTED;      }      // ----- Update the informations      // Only some fields can be modified      $p_entry['filename'] = $v_local_header['filename'];    }    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {      // ----- Do the extraction (if not a folder)      if (!(($p_entry['external']&0x00000010)==0x00000010)) {        // ----- Look for not compressed file  //      if ($p_entry['compressed_size'] == $p_entry['size'])        if ($p_entry['compression'] == 0) {          // ----- Reading the file          $p_string = @fread($this->zip_fd, $p_entry['compressed_size']);        }        else {          // ----- Reading the file          $v_data = @fread($this->zip_fd, $p_entry['compressed_size']);          // ----- Decompress the file          if (($p_string = @gzinflate($v_data)) === FALSE) {              // TBC          }        }        // ----- Trace      }      else {          // TBC : error : can not extract a folder in a string      }    }  	// ----- Change abort status  	if ($p_entry['status'] == "aborted") {        $p_entry['status'] = "skipped";  	}    // ----- Look for post-extract callback    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Swap the content to header      $v_local_header['content'] = $p_string;      $p_string = '';      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);      // ----- Swap back the content to header      $p_string = $v_local_header['content'];      unset($v_local_header['content']);      // ----- Look for abort result      if ($v_result == 2) {      	$v_result = PCLZIP_ERR_USER_ABORTED;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privReadFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privReadFileHeader(&$p_header)  {    $v_result=1;    // ----- Read the 4 bytes signature    $v_binary_data = @fread($this->zip_fd, 4);    $v_data = unpack('Vid', $v_binary_data);    // ----- Check signature    if ($v_data['id'] != 0x04034b50)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');      // ----- Return      return PclZip::errorCode();    }    // ----- Read the first 42 bytes of the header    $v_binary_data = fread($this->zip_fd, 26);    // ----- Look for invalid block size    if (strlen($v_binary_data) != 26)    {      $p_header['filename'] = "";      $p_header['status'] = "invalid_header";      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : ".strlen($v_binary_data));      // ----- Return      return PclZip::errorCode();    }    // ----- Extract the values    $v_data = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);    // ----- Get filename    $p_header['filename'] = fread($this->zip_fd, $v_data['filename_len']);    // ----- Get extra_fields    if ($v_data['extra_len'] != 0) {      $p_header['extra'] = fread($this->zip_fd, $v_data['extra_len']);    }    else {      $p_header['extra'] = '';    }    // ----- Extract properties    $p_header['version_extracted'] = $v_data['version'];    $p_header['compression'] = $v_data['compression'];    $p_header['size'] = $v_data['size'];    $p_header['compressed_size'] = $v_data['compressed_size'];    $p_header['crc'] = $v_data['crc'];    $p_header['flag'] = $v_data['flag'];    $p_header['filename_len'] = $v_data['filename_len'];    // ----- Recuperate date in UNIX format    $p_header['mdate'] = $v_data['mdate'];    $p_header['mtime'] = $v_data['mtime'];    if ($p_header['mdate'] && $p_header['mtime'])    {      // ----- Extract time      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;      $v_seconde = ($p_header['mtime'] & 0x001F)*2;      // ----- Extract date      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;      $v_day = $p_header['mdate'] & 0x001F;      // ----- Get UNIX date format      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);    }    else    {      $p_header['mtime'] = time();    }    // TBC    //for(reset($v_data); $key = key($v_data); next($v_data)) {    //}    // ----- Set the stored filename    $p_header['stored_filename'] = $p_header['filename'];    // ----- Set the status field    $p_header['status'] = "ok";    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privReadCentralFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privReadCentralFileHeader(&$p_header)  {    $v_result=1;    // ----- Read the 4 bytes signature    $v_binary_data = @fread($this->zip_fd, 4);    $v_data = unpack('Vid', $v_binary_data);    // ----- Check signature    if ($v_data['id'] != 0x02014b50)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');      // ----- Return      return PclZip::errorCode();    }    // ----- Read the first 42 bytes of the header    $v_binary_data = fread($this->zip_fd, 42);    // ----- Look for invalid block size    if (strlen($v_binary_data) != 42)    {      $p_header['filename'] = "";      $p_header['status'] = "invalid_header";      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : ".strlen($v_binary_data));      // ----- Return      return PclZip::errorCode();    }    // ----- Extract the values    $p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);    // ----- Get filename    if ($p_header['filename_len'] != 0)      $p_header['filename'] = fread($this->zip_fd, $p_header['filename_len']);    else      $p_header['filename'] = '';    // ----- Get extra    if ($p_header['extra_len'] != 0)      $p_header['extra'] = fread($this->zip_fd, $p_header['extra_len']);    else      $p_header['extra'] = '';    // ----- Get comment    if ($p_header['comment_len'] != 0)      $p_header['comment'] = fread($this->zip_fd, $p_header['comment_len']);    else      $p_header['comment'] = '';    // ----- Extract properties    // ----- Recuperate date in UNIX format    //if ($p_header['mdate'] && $p_header['mtime'])    // TBC : bug : this was ignoring time with 0/0/0    if (1)    {      // ----- Extract time      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;      $v_seconde = ($p_header['mtime'] & 0x001F)*2;      // ----- Extract date      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;      $v_day = $p_header['mdate'] & 0x001F;      // ----- Get UNIX date format      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);    }    else    {      $p_header['mtime'] = time();    }    // ----- Set the stored filename    $p_header['stored_filename'] = $p_header['filename'];    // ----- Set default status to ok    $p_header['status'] = 'ok';    // ----- Look if it is a directory    if (substr($p_header['filename'], -1) == '/') {      //$p_header['external'] = 0x41FF0010;      $p_header['external'] = 0x00000010;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCheckFileHeaders()  // Description :  // Parameters :  // Return Values :  //   1 on success,  //   0 on error;  // --------------------------------------------------------------------------------  function privCheckFileHeaders(&$p_local_header, &$p_central_header)  {    $v_result=1;  	// ----- Check the static values  	// TBC  	if ($p_local_header['filename'] != $p_central_header['filename']) {  	}  	if ($p_local_header['version_extracted'] != $p_central_header['version_extracted']) {  	}  	if ($p_local_header['flag'] != $p_central_header['flag']) {  	}  	if ($p_local_header['compression'] != $p_central_header['compression']) {  	}  	if ($p_local_header['mtime'] != $p_central_header['mtime']) {  	}  	if ($p_local_header['filename_len'] != $p_central_header['filename_len']) {  	}  	// ----- Look for flag bit 3  	if (($p_local_header['flag'] & 8) == 8) {          $p_local_header['size'] = $p_central_header['size'];          $p_local_header['compressed_size'] = $p_central_header['compressed_size'];          $p_local_header['crc'] = $p_central_header['crc'];  	}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privReadEndCentralDir()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privReadEndCentralDir(&$p_central_dir)  {    $v_result=1;    // ----- Go to the end of the zip file    $v_size = filesize($this->zipname);    @fseek($this->zip_fd, $v_size);    if (@ftell($this->zip_fd) != $v_size)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \''.$this->zipname.'\'');      // ----- Return      return PclZip::errorCode();    }    // ----- First try : look if this is an archive with no commentaries (most of the time)    // in this case the end of central dir is at 22 bytes of the file end    $v_found = 0;    if ($v_size > 26) {      @fseek($this->zip_fd, $v_size-22);      if (($v_pos = @ftell($this->zip_fd)) != ($v_size-22))      {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\'');        // ----- Return        return PclZip::errorCode();      }      // ----- Read for bytes      $v_binary_data = @fread($this->zip_fd, 4);      $v_data = @unpack('Vid', $v_binary_data);      // ----- Check signature      if ($v_data['id'] == 0x06054b50) {        $v_found = 1;      }      $v_pos = ftell($this->zip_fd);    }    // ----- Go back to the maximum possible size of the Central Dir End Record    if (!$v_found) {      $v_maximum_size = 65557; // 0xFFFF + 22;      if ($v_maximum_size > $v_size)        $v_maximum_size = $v_size;      @fseek($this->zip_fd, $v_size-$v_maximum_size);      if (@ftell($this->zip_fd) != ($v_size-$v_maximum_size))      {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\'');        // ----- Return        return PclZip::errorCode();      }      // ----- Read byte per byte in order to find the signature      $v_pos = ftell($this->zip_fd);      $v_bytes = 0x00000000;      while ($v_pos < $v_size)      {        // ----- Read a byte        $v_byte = @fread($this->zip_fd, 1);        // -----  Add the byte        //$v_bytes = ($v_bytes << 8) | Ord($v_byte);        // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number        // Otherwise on systems where we have 64bit integers the check below for the magic number will fail.        $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte);        // ----- Compare the bytes        if ($v_bytes == 0x504b0506)        {          $v_pos++;          break;        }        $v_pos++;      }      // ----- Look if not found end of central dir      if ($v_pos == $v_size)      {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Unable to find End of Central Dir Record signature");        // ----- Return        return PclZip::errorCode();      }    }    // ----- Read the first 18 bytes of the header    $v_binary_data = fread($this->zip_fd, 18);    // ----- Look for invalid block size    if (strlen($v_binary_data) != 18)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid End of Central Dir Record size : ".strlen($v_binary_data));      // ----- Return      return PclZip::errorCode();    }    // ----- Extract the values    $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);    // ----- Check the global size    if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {	  // ----- Removed in release 2.2 see readme file	  // The check of the file size is a little too strict.	  // Some bugs where found when a zip is encrypted/decrypted with 'crypt'.	  // While decrypted, zip has training 0 bytes	  if (0) {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT,	                       'The central dir is not at the end of the archive.'						   .' Some trailing bytes exists after the archive.');      // ----- Return      return PclZip::errorCode();	  }    }    // ----- Get comment    if ($v_data['comment_size'] != 0) {      $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);    }    else      $p_central_dir['comment'] = '';    $p_central_dir['entries'] = $v_data['entries'];    $p_central_dir['disk_entries'] = $v_data['disk_entries'];    $p_central_dir['offset'] = $v_data['offset'];    $p_central_dir['size'] = $v_data['size'];    $p_central_dir['disk'] = $v_data['disk'];    $p_central_dir['disk_start'] = $v_data['disk_start'];    // TBC    //for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {    //}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDeleteByRule()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privDeleteByRule(&$p_result_list, &$p_options)  {    $v_result=1;    $v_list_detail = array();    // ----- Open the zip file    if (($v_result=$this->privOpenFd('rb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privCloseFd();      return $v_result;    }    // ----- Go to beginning of File    @rewind($this->zip_fd);    // ----- Scan all the files    // ----- Start at beginning of Central Dir    $v_pos_entry = $v_central_dir['offset'];    @rewind($this->zip_fd);    if (@fseek($this->zip_fd, $v_pos_entry))    {      // ----- Close the zip file      $this->privCloseFd();      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');      // ----- Return      return PclZip::errorCode();    }    // ----- Read each entry    $v_header_list = array();    $j_start = 0;    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)    {      // ----- Read the file header      $v_header_list[$v_nb_extracted] = array();      if (($v_result = $this->privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1)      {        // ----- Close the zip file        $this->privCloseFd();        return $v_result;      }      // ----- Store the index      $v_header_list[$v_nb_extracted]['index'] = $i;      // ----- Look for the specific extract rules      $v_found = false;      // ----- Look for extract by name rule      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {          // ----- Look if the filename is in the list          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_found); $j++) {              // ----- Look for a directory              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == "/") {                  // ----- Look if the directory is in the filename path                  if (   (strlen($v_header_list[$v_nb_extracted]['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))                      && (substr($v_header_list[$v_nb_extracted]['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {                      $v_found = true;                  }                  elseif (   (($v_header_list[$v_nb_extracted]['external']&0x00000010)==0x00000010) /* Indicates a folder */                          && ($v_header_list[$v_nb_extracted]['stored_filename'].'/' == $p_options[PCLZIP_OPT_BY_NAME][$j])) {                      $v_found = true;                  }              }              // ----- Look for a filename              elseif ($v_header_list[$v_nb_extracted]['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {                  $v_found = true;              }          }      }      // ----- Look for extract by ereg rule      // ereg() is deprecated with PHP 5.3      /*      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))               && ($p_options[PCLZIP_OPT_BY_EREG] != "")) {          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {              $v_found = true;          }      }      */      // ----- Look for extract by preg rule      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))               && ($p_options[PCLZIP_OPT_BY_PREG] != "")) {          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {              $v_found = true;          }      }      // ----- Look for extract by index rule      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {          // ----- Look if the index is in the list          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_found); $j++) {              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {                  $v_found = true;              }              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {                  $j_start = $j+1;              }              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {                  break;              }          }      }      else {      	$v_found = true;      }      // ----- Look for deletion      if ($v_found)      {        unset($v_header_list[$v_nb_extracted]);      }      else      {        $v_nb_extracted++;      }    }    // ----- Look if something need to be deleted    if ($v_nb_extracted > 0) {        // ----- Creates a temporay file        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';        // ----- Creates a temporary zip archive        $v_temp_zip = new PclZip($v_zip_temp_name);        // ----- Open the temporary zip file in write mode        if (($v_result = $v_temp_zip->privOpenFd('wb')) != 1) {            $this->privCloseFd();            // ----- Return            return $v_result;        }        // ----- Look which file need to be kept        for ($i=0; $i<sizeof($v_header_list); $i++) {            // ----- Calculate the position of the header            @rewind($this->zip_fd);            if (@fseek($this->zip_fd,  $v_header_list[$i]['offset'])) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Error log                PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');                // ----- Return                return PclZip::errorCode();            }            // ----- Read the file header            $v_local_header = array();            if (($v_result = $this->privReadFileHeader($v_local_header)) != 1) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }            // ----- Check that local file header is same as central file header            if ($this->privCheckFileHeaders($v_local_header,			                                $v_header_list[$i]) != 1) {                // TBC            }            unset($v_local_header);            // ----- Write the file header            if (($v_result = $v_temp_zip->privWriteFileHeader($v_header_list[$i])) != 1) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }            // ----- Read/write the data block            if (($v_result = PclZipUtilCopyBlock($this->zip_fd, $v_temp_zip->zip_fd, $v_header_list[$i]['compressed_size'])) != 1) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }        }        // ----- Store the offset of the central dir        $v_offset = @ftell($v_temp_zip->zip_fd);        // ----- Re-Create the Central Dir files header        for ($i=0; $i<sizeof($v_header_list); $i++) {            // ----- Create the file header            if (($v_result = $v_temp_zip->privWriteCentralFileHeader($v_header_list[$i])) != 1) {                $v_temp_zip->privCloseFd();                $this->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }            // ----- Transform the header to a 'usable' info            $v_temp_zip->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);        }        // ----- Zip file comment        $v_comment = '';        if (isset($p_options[PCLZIP_OPT_COMMENT])) {          $v_comment = $p_options[PCLZIP_OPT_COMMENT];        }        // ----- Calculate the size of the central header        $v_size = @ftell($v_temp_zip->zip_fd)-$v_offset;        // ----- Create the central dir footer        if (($v_result = $v_temp_zip->privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) {            // ----- Reset the file list            unset($v_header_list);            $v_temp_zip->privCloseFd();            $this->privCloseFd();            @unlink($v_zip_temp_name);            // ----- Return            return $v_result;        }        // ----- Close        $v_temp_zip->privCloseFd();        $this->privCloseFd();        // ----- Delete the zip file        // TBC : I should test the result ...        @unlink($this->zipname);        // ----- Rename the temporary file        // TBC : I should test the result ...        //@rename($v_zip_temp_name, $this->zipname);        PclZipUtilRename($v_zip_temp_name, $this->zipname);        // ----- Destroy the temporary archive        unset($v_temp_zip);    }    // ----- Remove every files : reset the file    else if ($v_central_dir['entries'] != 0) {        $this->privCloseFd();        if (($v_result = $this->privOpenFd('wb')) != 1) {          return $v_result;        }        if (($v_result = $this->privWriteCentralHeader(0, 0, 0, '')) != 1) {          return $v_result;        }        $this->privCloseFd();    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDirCheck()  // Description :  //   Check if a directory exists, if not it creates it and all the parents directory  //   which may be useful.  // Parameters :  //   $p_dir : Directory path to check.  // Return Values :  //    1 : OK  //   -1 : Unable to create directory  // --------------------------------------------------------------------------------  function privDirCheck($p_dir, $p_is_dir=false)  {    $v_result = 1;    // ----- Remove the final '/'    if (($p_is_dir) && (substr($p_dir, -1)=='/'))    {      $p_dir = substr($p_dir, 0, strlen($p_dir)-1);    }    // ----- Check the directory availability    if ((is_dir($p_dir)) || ($p_dir == ""))    {      return 1;    }    // ----- Extract parent directory    $p_parent_dir = dirname($p_dir);    // ----- Just a check    if ($p_parent_dir != $p_dir)    {      // ----- Look for parent directory      if ($p_parent_dir != "")      {        if (($v_result = $this->privDirCheck($p_parent_dir)) != 1)        {          return $v_result;        }      }    }    // ----- Create the directory    if (!@mkdir($p_dir, 0777))    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, "Unable to create directory '$p_dir'");      // ----- Return      return PclZip::errorCode();    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privMerge()  // Description :  //   If $p_archive_to_add does not exist, the function exit with a success result.  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privMerge(&$p_archive_to_add)  {    $v_result=1;    // ----- Look if the archive_to_add exists    if (!is_file($p_archive_to_add->zipname))    {      // ----- Nothing to merge, so merge is a success      $v_result = 1;      // ----- Return      return $v_result;    }    // ----- Look if the archive exists    if (!is_file($this->zipname))    {      // ----- Do a duplicate      $v_result = $this->privDuplicate($p_archive_to_add->zipname);      // ----- Return      return $v_result;    }    // ----- Open the zip file    if (($v_result=$this->privOpenFd('rb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privCloseFd();      return $v_result;    }    // ----- Go to beginning of File    @rewind($this->zip_fd);    // ----- Open the archive_to_add file    if (($v_result=$p_archive_to_add->privOpenFd('rb')) != 1)    {      $this->privCloseFd();      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir_to_add = array();    if (($v_result = $p_archive_to_add->privReadEndCentralDir($v_central_dir_to_add)) != 1)    {      $this->privCloseFd();      $p_archive_to_add->privCloseFd();      return $v_result;    }    // ----- Go to beginning of File    @rewind($p_archive_to_add->zip_fd);    // ----- Creates a temporay file    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';    // ----- Open the temporary file in write mode    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)    {      $this->privCloseFd();      $p_archive_to_add->privCloseFd();      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_zip_temp_name.'\' in binary write mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Copy the files from the archive to the temporary file    // TBC : Here I should better append the file and go back to erase the central dir    $v_size = $v_central_dir['offset'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($this->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Copy the files from the archive_to_add into the temporary file    $v_size = $v_central_dir_to_add['offset'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($p_archive_to_add->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Store the offset of the central dir    $v_offset = @ftell($v_zip_temp_fd);    // ----- Copy the block of file headers from the old archive    $v_size = $v_central_dir['size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($this->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Copy the block of file headers from the archive_to_add    $v_size = $v_central_dir_to_add['size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($p_archive_to_add->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Merge the file comments    $v_comment = $v_central_dir['comment'].' '.$v_central_dir_to_add['comment'];    // ----- Calculate the size of the (new) central header    $v_size = @ftell($v_zip_temp_fd)-$v_offset;    // ----- Swap the file descriptor    // Here is a trick : I swap the temporary fd with the zip fd, in order to use    // the following methods on the temporary fil and not the real archive fd    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Create the central dir footer    if (($v_result = $this->privWriteCentralHeader($v_central_dir['entries']+$v_central_dir_to_add['entries'], $v_size, $v_offset, $v_comment)) != 1)    {      $this->privCloseFd();      $p_archive_to_add->privCloseFd();      @fclose($v_zip_temp_fd);      $this->zip_fd = null;      // ----- Reset the file list      unset($v_header_list);      // ----- Return      return $v_result;    }    // ----- Swap back the file descriptor    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Close    $this->privCloseFd();    $p_archive_to_add->privCloseFd();    // ----- Close the temporary file    @fclose($v_zip_temp_fd);    // ----- Delete the zip file    // TBC : I should test the result ...    @unlink($this->zipname);    // ----- Rename the temporary file    // TBC : I should test the result ...    //@rename($v_zip_temp_name, $this->zipname);    PclZipUtilRename($v_zip_temp_name, $this->zipname);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDuplicate()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privDuplicate($p_archive_filename)  {    $v_result=1;    // ----- Look if the $p_archive_filename exists    if (!is_file($p_archive_filename))    {      // ----- Nothing to duplicate, so duplicate is a success.      $v_result = 1;      // ----- Return      return $v_result;    }    // ----- Open the zip file    if (($v_result=$this->privOpenFd('wb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Open the temporary file in write mode    if (($v_zip_temp_fd = @fopen($p_archive_filename, 'rb')) == 0)    {      $this->privCloseFd();      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive file \''.$p_archive_filename.'\' in binary write mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Copy the files from the archive to the temporary file    // TBC : Here I should better append the file and go back to erase the central dir    $v_size = filesize($p_archive_filename);    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($v_zip_temp_fd, $v_read_size);      @fwrite($this->zip_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Close    $this->privCloseFd();    // ----- Close the temporary file    @fclose($v_zip_temp_fd);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privErrorLog()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privErrorLog($p_error_code=0, $p_error_string='')  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      PclError($p_error_code, $p_error_string);    }    else {      $this->error_code = $p_error_code;      $this->error_string = $p_error_string;    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privErrorReset()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privErrorReset()  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      PclErrorReset();    }    else {      $this->error_code = 0;      $this->error_string = '';    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDisableMagicQuotes()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privDisableMagicQuotes()  {    $v_result=1;    // ----- Look if function exists    if (   (!function_exists("get_magic_quotes_runtime"))	    || (!function_exists("set_magic_quotes_runtime"))) {      return $v_result;	}    // ----- Look if already done    if ($this->magic_quotes_status != -1) {      return $v_result;	}	// ----- Get and memorize the magic_quote value	$this->magic_quotes_status = @get_magic_quotes_runtime();	// ----- Disable magic_quotes	if ($this->magic_quotes_status == 1) {	  @set_magic_quotes_runtime(0);	}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privSwapBackMagicQuotes()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privSwapBackMagicQuotes()  {    $v_result=1;    // ----- Look if function exists    if (   (!function_exists("get_magic_quotes_runtime"))	    || (!function_exists("set_magic_quotes_runtime"))) {      return $v_result;	}    // ----- Look if something to do    if ($this->magic_quotes_status != -1) {      return $v_result;	}	// ----- Swap back magic_quotes	if ($this->magic_quotes_status == 1) {  	  @set_magic_quotes_runtime($this->magic_quotes_status);	}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  }  // End of class  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilPathReduction()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function PclZipUtilPathReduction($p_dir)  {    $v_result = "";    // ----- Look for not empty path    if ($p_dir != "") {      // ----- Explode path by directory names      $v_list = explode("/", $p_dir);      // ----- Study directories from last to first      $v_skip = 0;      for ($i=sizeof($v_list)-1; $i>=0; $i--) {        // ----- Look for current path        if ($v_list[$i] == ".") {          // ----- Ignore this directory          // Should be the first $i=0, but no check is done        }        else if ($v_list[$i] == "..") {		  $v_skip++;        }        else if ($v_list[$i] == "") {		  // ----- First '/' i.e. root slash		  if ($i == 0) {            $v_result = "/".$v_result;		    if ($v_skip > 0) {		        // ----- It is an invalid path, so the path is not modified		        // TBC		        $v_result = $p_dir;                $v_skip = 0;		    }		  }		  // ----- Last '/' i.e. indicates a directory		  else if ($i == (sizeof($v_list)-1)) {            $v_result = $v_list[$i];		  }		  // ----- Double '/' inside the path		  else {            // ----- Ignore only the double '//' in path,            // but not the first and last '/'		  }        }        else {		  // ----- Look for item to skip		  if ($v_skip > 0) {		    $v_skip--;		  }		  else {            $v_result = $v_list[$i].($i!=(sizeof($v_list)-1)?"/".$v_result:"");		  }        }      }      // ----- Look for skip      if ($v_skip > 0) {        while ($v_skip > 0) {            $v_result = '../'.$v_result;            $v_skip--;        }      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilPathInclusion()  // Description :  //   This function indicates if the path $p_path is under the $p_dir tree. Or,  //   said in an other way, if the file or sub-dir $p_path is inside the dir  //   $p_dir.  //   The function indicates also if the path is exactly the same as the dir.  //   This function supports path with duplicated '/' like '//', but does not  //   support '.' or '..' statements.  // Parameters :  // Return Values :  //   0 if $p_path is not inside directory $p_dir  //   1 if $p_path is inside directory $p_dir  //   2 if $p_path is exactly the same as $p_dir  // --------------------------------------------------------------------------------  function PclZipUtilPathInclusion($p_dir, $p_path)  {    $v_result = 1;    // ----- Look for path beginning by ./    if (   ($p_dir == '.')        || ((strlen($p_dir) >=2) && (substr($p_dir, 0, 2) == './'))) {      $p_dir = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_dir, 1);    }    if (   ($p_path == '.')        || ((strlen($p_path) >=2) && (substr($p_path, 0, 2) == './'))) {      $p_path = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_path, 1);    }    // ----- Explode dir and path by directory separator    $v_list_dir = explode("/", $p_dir);    $v_list_dir_size = sizeof($v_list_dir);    $v_list_path = explode("/", $p_path);    $v_list_path_size = sizeof($v_list_path);    // ----- Study directories paths    $i = 0;    $j = 0;    while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {      // ----- Look for empty dir (path reduction)      if ($v_list_dir[$i] == '') {        $i++;        continue;      }      if ($v_list_path[$j] == '') {        $j++;        continue;      }      // ----- Compare the items      if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != ''))  {        $v_result = 0;      }      // ----- Next items      $i++;      $j++;    }    // ----- Look if everything seems to be the same    if ($v_result) {      // ----- Skip all the empty items      while (($j < $v_list_path_size) && ($v_list_path[$j] == '')) $j++;      while (($i < $v_list_dir_size) && ($v_list_dir[$i] == '')) $i++;      if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) {        // ----- There are exactly the same        $v_result = 2;      }      else if ($i < $v_list_dir_size) {        // ----- The path is shorter than the dir        $v_result = 0;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilCopyBlock()  // Description :  // Parameters :  //   $p_mode : read/write compression mode  //             0 : src & dest normal  //             1 : src gzip, dest normal  //             2 : src normal, dest gzip  //             3 : src & dest gzip  // Return Values :  // --------------------------------------------------------------------------------  function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode=0)  {    $v_result = 1;    if ($p_mode==0)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @fread($p_src, $v_read_size);        @fwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    else if ($p_mode==1)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @gzread($p_src, $v_read_size);        @fwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    else if ($p_mode==2)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @fread($p_src, $v_read_size);        @gzwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    else if ($p_mode==3)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @gzread($p_src, $v_read_size);        @gzwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilRename()  // Description :  //   This function tries to do a simple rename() function. If it fails, it  //   tries to copy the $p_src file in a new $p_dest file and then unlink the  //   first one.  // Parameters :  //   $p_src : Old filename  //   $p_dest : New filename  // Return Values :  //   1 on success, 0 on failure.  // --------------------------------------------------------------------------------  function PclZipUtilRename($p_src, $p_dest)  {    $v_result = 1;    // ----- Try to rename the files    if (!@rename($p_src, $p_dest)) {      // ----- Try to copy & unlink the src      if (!@copy($p_src, $p_dest)) {        $v_result = 0;      }      else if (!@unlink($p_src)) {        $v_result = 0;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilOptionText()  // Description :  //   Translate option value in text. Mainly for debug purpose.  // Parameters :  //   $p_option : the option value.  // Return Values :  //   The option text value.  // --------------------------------------------------------------------------------  function PclZipUtilOptionText($p_option)  {    $v_list = get_defined_constants();    for (reset($v_list); $v_key = key($v_list); next($v_list)) {	    $v_prefix = substr($v_key, 0, 10);	    if ((   ($v_prefix == 'PCLZIP_OPT')           || ($v_prefix == 'PCLZIP_CB_')           || ($v_prefix == 'PCLZIP_ATT'))	        && ($v_list[$v_key] == $p_option)) {        return $v_key;	    }    }    $v_result = 'Unknown';    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilTranslateWinPath()  // Description :  //   Translate windows path by replacing '\' by '/' and optionally removing  //   drive letter.  // Parameters :  //   $p_path : path to translate.  //   $p_remove_disk_letter : true | false  // Return Values :  //   The path translated.  // --------------------------------------------------------------------------------  function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter=true)  {    if (stristr(php_uname(), 'windows')) {      // ----- Look for potential disk letter      if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {          $p_path = substr($p_path, $v_position+1);      }      // ----- Change potential windows directory separator      if ((strpos($p_path, '\\') > 0) || (substr($p_path, 0,1) == '\\')) {          $p_path = strtr($p_path, '\\', '/');      }    }    return $p_path;  }  // --------------------------------------------------------------------------------?>
<?php/** * @package WordPress * @subpackage Theme_Compat * @deprecated 3.0 *  * This file is here for Backwards compatibility with old themes and will be removed in a future version *  */_deprecated_file( sprintf( __( 'Theme without %1$s' ), basename(__FILE__) ), '3.0', null, sprintf( __('Please include a %1$s template in your theme.'), basename(__FILE__) ) );?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>     <title><?php printf(__('%1$s - Comments on %2$s'), get_option('blogname'), the_title('','',false)); ?></title>	<meta http-equiv="Content-Type" content="<?php bloginfo('html_type'); ?>; charset=<?php echo get_option('blog_charset'); ?>" />	<style type="text/css" media="screen">		@import url( <?php bloginfo('stylesheet_url'); ?> );		body { margin: 3px; }	</style></head><body id="commentspopup"><h1 id="header"><a href="" title="<?php echo get_option('blogname'); ?>"><?php echo get_option('blogname'); ?></a></h1><?php/* Don't remove these lines. */add_filter('comment_text', 'popuplinks');if ( have_posts() ) :while( have_posts()) : the_post();?><h2 id="comments"><?php _e('Comments'); ?></h2><p><a href="<?php echo get_post_comments_feed_link($post->ID); ?>"><?php _e('<abbr title="Really Simple Syndication">RSS</abbr> feed for comments on this post.'); ?></a></p><?php if ( pings_open() ) { ?><p><?php printf(__('The <abbr title="Universal Resource Locator">URL</abbr> to TrackBack this entry is: <em>%s</em>'), get_trackback_url()); ?></p><?php } ?><?php// this line is WordPress' motor, do not delete it.$commenter = wp_get_current_commenter();extract($commenter);$comments = get_approved_comments($id);$post = get_post($id);if ( post_password_required($post) ) {  // and it doesn't match the cookie	echo(get_the_password_form());} else { ?><?php if ($comments) { ?><ol id="commentlist"><?php foreach ($comments as $comment) { ?>	<li id="comment-<?php comment_ID() ?>">	<?php comment_text() ?>	<p><cite><?php comment_type(__('Comment'), __('Trackback'), __('Pingback')); ?> <?php printf(__('by %1$s &#8212; %2$s @ <a href="#comment-%3$s">%4$s</a>'), get_comment_author_link(), get_comment_date(), get_comment_ID(), get_comment_time()); ?></cite></p>	</li><?php } // end for each comment ?></ol><?php } else { // this is displayed if there are no comments so far ?>	<p><?php _e('No comments yet.'); ?></p><?php } ?><?php if ( comments_open() ) { ?><h2><?php _e('Leave a comment'); ?></h2><p><?php printf(__('Line and paragraph breaks automatic, e-mail address never displayed, <acronym title="Hypertext Markup Language">HTML</acronym> allowed: <code>%s</code>'), allowed_tags()); ?></p><form action="<?php echo get_option('siteurl'); ?>/wp-comments-post.php" method="post" id="commentform"><?php if ( $user_ID ) : ?>	<p><?php printf(__('Logged in as <a href="%1$s">%2$s</a>. <a href="%3$s" title="Log out of this account">Log out &raquo;</a>'), get_option('siteurl') . '/wp-admin/profile.php', $user_identity, wp_logout_url(get_permalink())); ?></p><?php else : ?>	<p>	  <input type="text" name="author" id="author" class="textarea" value="<?php echo esc_attr($comment_author); ?>" size="28" tabindex="1" />	   <label for="author"><?php _e('Name'); ?></label>	</p>	<p>	  <input type="text" name="email" id="email" value="<?php echo esc_attr($comment_author_email); ?>" size="28" tabindex="2" />	   <label for="email"><?php _e('E-mail'); ?></label>	</p>	<p>	  <input type="text" name="url" id="url" value="<?php echo esc_attr($comment_author_url); ?>" size="28" tabindex="3" />	   <label for="url"><?php _e('<abbr title="Universal Resource Locator">URL</abbr>'); ?></label>	</p><?php endif; ?>	<p>	  <label for="comment"><?php _e('Your Comment'); ?></label>	<br />	  <textarea name="comment" id="comment" cols="70" rows="4" tabindex="4"></textarea>	</p>	<p>	  <input type="hidden" name="comment_post_ID" value="<?php echo $id; ?>" />	  <input type="hidden" name="redirect_to" value="<?php echo esc_attr($_SERVER["REQUEST_URI"]); ?>" />	  <input name="submit" type="submit" tabindex="5" value="<?php _e('Say It!' ); ?>" />	</p>	<?php do_action('comment_form', $post->ID); ?></form><?php } else { // comments are closed ?><p><?php _e('Sorry, the comment form is closed at this time.'); ?></p><?php }} // end password check?><div><strong><a href="javascript:window.close()"><?php _e('Close this window.'); ?></a></strong></div><?php // if you delete this the sky will fall on your headendwhile; // have_posts()else: // have_posts()?><p><?php _e('Sorry, no posts matched your criteria.'); ?></p><?php endif; ?><!-- // this is just the end of the motor - don't touch that line either :) --><?php //} ?><p class="credit"><?php timer_stop(1); ?> <cite><?php printf(__('Powered by <a href="%s" title="Powered by WordPress, state-of-the-art semantic personal publishing platform"><strong>WordPress</strong></a>'), 'http://wordpress.org/'); ?></cite></p><?php // Seen at http://www.mijnkopthee.nl/log2/archive/2003/05/28/esc(18) ?><script type="text/javascript"><!--document.onkeypress = function esc(e) {	if(typeof(e) == "undefined") { e=event; }	if (e.keyCode == 27) { self.close(); }}// --></script></body></html>
<?php/** * Edit link category form for inclusion in administration panels. * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');if ( !current_user_can('manage_categories') )	wp_die(__('You do not have sufficient permissions to edit link categories for this site.'));/** * @var object */if ( ! isset( $category ) )	$category = (object) array();if ( ! empty($cat_ID) ) {	/**	 * @var string	 */	$heading = '<h2>' . __('Edit Link Category') . '</h2>';	$submit_text = __('Update Category');	$form = '<form name="editcat" id="editcat" method="post" action="link-category.php" class="validate">';	$action = 'editedcat';	$nonce_action = 'update-link-category_' . $cat_ID;	do_action('edit_link_category_form_pre', $category);} else {	$heading = '<h2>' . __('Add Link Category') . '</h2>';	$submit_text = __('Add Category');	$form = '<form name="addcat" id="addcat" class="add:the-list: validate" method="post" action="link-category.php">';	$action = 'addcat';	$nonce_action = 'add-link-category';	do_action('add_link_category_form_pre', $category);}/** * @ignore * @since 2.7 * @internal Used to prevent errors in page when no category is being edited. * * @param object $category */function _fill_empty_link_category(&$category) {	if ( ! isset( $category->name ) )		$category->name = '';	if ( ! isset( $category->slug ) )		$category->slug = '';	if ( ! isset( $category->description ) )		$category->description = '';}_fill_empty_link_category($category);?><div class="wrap"><?php screen_icon(); ?><?php echo $heading ?><div id="ajax-response"></div><?php echo $form ?><input type="hidden" name="action" value="<?php echo esc_attr($action) ?>" /><input type="hidden" name="cat_ID" value="<?php echo esc_attr($category->term_id) ?>" /><?php wp_original_referer_field(true, 'previous'); wp_nonce_field($nonce_action); ?>	<table class="form-table">		<tr class="form-field form-required">			<th scope="row" valign="top"><label for="name"><?php _e('Link Category name') ?></label></th>			<td><input name="name" id="name" type="text" value="<?php echo esc_attr($category->name); ?>" size="40" aria-required="true" /></td>		</tr><?php if ( !is_multisite() ) { ?>		<tr class="form-field">			<th scope="row" valign="top"><label for="slug"><?php _e('Link Category slug') ?></label></th>			<td><input name="slug" id="slug" type="text" value="<?php echo esc_attr(apply_filters('editable_slug', $category->slug)); ?>" size="40" /><br />            <?php _e('The &#8220;slug&#8221; is the URL-friendly version of the name. It is usually all lowercase and contains only letters, numbers, and hyphens.'); ?></td>		</tr><?php } ?>		<tr class="form-field">			<th scope="row" valign="top"><label for="description"><?php _e('Description (optional)') ?></label></th>			<td><textarea name="description" id="description" rows="5" cols="50" style="width: 97%;"><?php echo $category->description; ?></textarea><br />			<span class="description"><?php _e('The description is not prominent by default; however, some themes may show it.'); ?></span></td>		</tr>		<?php do_action('edit_link_category_form_fields', $category); ?>	</table><p class="submit"><input type="submit" class="button-primary" name="submit" value="<?php echo esc_attr($submit_text) ?>" /></p><?php do_action('edit_link_category_form', $category); ?></form></div>
<?php/** * @package TinyMCE * @author Moxiecode * @copyright Copyright  2005-2006, Moxiecode Systems AB, All rights reserved. *//** @ignore */require_once('../../../wp-load.php');header('Content-Type: text/html; charset=' . get_bloginfo('charset'));?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" <?php language_attributes(); ?>><head><meta http-equiv="Content-Type" content="<?php bloginfo('html_type'); ?>; charset=<?php echo get_option('blog_charset'); ?>" /><title><?php _e('Rich Editor Help') ?></title><script type="text/javascript" src="tiny_mce_popup.js?ver=3223"></script><?phpwp_admin_css( 'global', true );wp_admin_css( 'wp-admin', true );?><style type="text/css">	#wphead {		font-size: 80%;		border-top: 0;		color: #555;		background-color: #f1f1f1;	}	#wphead h1 {		font-size: 24px;		color: #555;		margin: 0;		padding: 10px;	}	#tabs {		padding: 15px 15px 3px;		background-color: #f1f1f1;		border-bottom: 1px solid #dfdfdf;	}	#tabs li {		display: inline;	}	#tabs a.current {		background-color: #fff;		border-color: #dfdfdf;		border-bottom-color: #fff;		color: #d54e21;	}	#tabs a {		color: #2583AD;		padding: 6px;		border-width: 1px 1px 0;		border-style: solid solid none;		border-color: #f1f1f1;		text-decoration: none;	}	#tabs a:hover {		color: #d54e21;	}	.wrap h2 {		border-bottom-color: #dfdfdf;		color: #555;		margin: 5px 0;		padding: 0;		font-size: 18px;	}	#user_info {		right: 5%;		top: 5px;	}	h3 {		font-size: 1.1em;		margin-top: 10px;		margin-bottom: 0px;	}	#flipper {		margin: 0;		padding: 5px 20px 10px;		background-color: #fff;		border-left: 1px solid #dfdfdf;		border-bottom: 1px solid #dfdfdf;	}	* html {        overflow-x: hidden;        overflow-y: scroll;    }	#flipper div p {		margin-top: 0.4em;		margin-bottom: 0.8em;		text-align: justify;	}	th {		text-align: center;	}	.top th {		text-decoration: underline;	}	.top .key {		text-align: center;		width: 5em;	}	.top .action {		text-align: left;	}	.align {		border-left: 3px double #333;		border-right: 3px double #333;	}	.keys {		margin-bottom: 15px;	}	.keys p {		display: inline-block;		margin: 0px;		padding: 0px;	}	.keys .left { text-align: left; }	.keys .center { text-align: center; }	.keys .right { text-align: right; }	td b {		font-family: "Times New Roman" Times serif;	}	#buttoncontainer {		text-align: center;		margin-bottom: 20px;	}	#buttoncontainer a, #buttoncontainer a:hover {		border-bottom: 0px;	}</style><?php if ( is_rtl() ) : ?><style type="text/css">	#wphead, #tabs {		padding-left: auto;		padding-right: 15px;	}	#flipper {		margin: 5px 0 3px 10px;	}	.keys .left, .top, .action { text-align: right; }	.keys .right { text-align: left; }	td b { font-family: Tahoma, "Times New Roman", Times, serif }</style><?php endif; ?><script type="text/javascript">	function d(id) { return document.getElementById(id); }	function flipTab(n) {		for (i=1;i<=4;i++) {			c = d('content'+i.toString());			t = d('tab'+i.toString());			if ( n == i ) {				c.className = '';				t.className = 'current';			} else {				c.className = 'hidden';				t.className = '';			}		}	}    function init() {        document.getElementById('version').innerHTML = tinymce.majorVersion + "." + tinymce.minorVersion;        document.getElementById('date').innerHTML = tinymce.releaseDate;    }    tinyMCEPopup.onInit.add(init);</script></head><body><div id="wphead"><h1><?php echo get_bloginfo('blogtitle'); ?></h1></div><ul id="tabs">	<li><a id="tab1" href="javascript:flipTab(1)" title="<?php _e('Basics of Rich Editing') ?>" accesskey="1" tabindex="1" class="current"><?php _e('Basics') ?></a></li>	<li><a id="tab2" href="javascript:flipTab(2)" title="<?php _e('Advanced use of the Rich Editor') ?>" accesskey="2" tabindex="2"><?php _e('Advanced') ?></a></li>	<li><a id="tab3" href="javascript:flipTab(3)" title="<?php _e('Hotkeys') ?>" accesskey="3" tabindex="3"><?php _e('Hotkeys') ?></a></li>	<li><a id="tab4" href="javascript:flipTab(4)" title="<?php _e('About the software') ?>" accesskey="4" tabindex="4"><?php _e('About') ?></a></li></ul><div id="flipper" class="wrap"><div id="content1">	<h2><?php _e('Rich Editing Basics') ?></h2>	<p><?php _e('<em>Rich editing</em>, also called WYSIWYG for What You See Is What You Get, means your text is formatted as you type. The rich editor creates HTML code behind the scenes while you concentrate on writing. Font styles, links and images all appear approximately as they will on the internet.') ?></p>	<p><?php _e('WordPress includes a rich HTML editor that works well in all major web browsers used today. However editing HTML is not the same as typing text. Each web page has two major components: the structure, which is the actual HTML code and is produced by the editor as you type, and the display, that is applied to it by the currently selected WordPress theme and is defined in style.css. WordPress is producing valid XHTML 1.0 which means that inserting multiple line breaks (BR tags) after a paragraph would not produce white space on the web page. The BR tags will be removed as invalid by the internal HTML correcting functions.') ?></p>	<p><?php _e('While using the editor, most basic keyboard shortcuts work like in any other text editor. For example: Shift+Enter inserts line break, Ctrl+C = copy, Ctrl+X = cut, Ctrl+Z = undo, Ctrl+Y = redo, Ctrl+A = select all, etc. (on Mac use the Command key instead of Ctrl). See the Hotkeys tab for all available keyboard shortcuts.') ?></p>    <p><?php _e('If you do not like the way the rich editor works, you may turn it off from Your Profile submenu, under Users in the admin menu.') ?></p></div><div id="content2" class="hidden">	<h2><?php _e('Advanced Rich Editing') ?></h2>	<h3><?php _e('Images and Attachments') ?></h3>	<p><?php _e('There is a button in the editor toolbar for inserting images that are already hosted somewhere on the internet. If you have a URL for an image, click this button and enter the URL in the box which appears.') ?></p>	<p><?php _e('If you need to upload an image or another media file from your computer, you can use the Media Library buttons above the editor. The media library will attempt to create a thumbnail-sized copy from each uploaded image. To insert your image into the post, first click on the thumbnail to reveal a menu of options. When you have selected the options you like, click "Send to Editor" and your image or file will appear in the post you are editing. If you are inserting a movie, there are additional options in the "Media" dialog that can be opened from the second toolbar row.') ?></p>	<h3><?php _e('HTML in the Rich Editor') ?></h3>	<p><?php _e('Any HTML entered directly into the rich editor will show up as text when the post is viewed. What you see is what you get. When you want to include HTML elements that cannot be generated with the toolbar buttons, you must enter it by hand in the HTML editor. Examples are tables and &lt;code&gt;. To do this, click the HTML tab and edit the code, then switch back to Visual mode. If the code is valid and understood by the editor, you should see it rendered immediately.') ?></p>	<h3><?php _e('Pasting in the Rich Editor') ?></h3>	<p><?php _e('When pasting content from another web page the results can be inconsistent and depend on your browser and on the web page you are pasting from. The editor tries to correct any invalid HTML code that was pasted, but for best results try using the HTML tab or one of the paste buttons that are on the second row. Alternatively try pasting paragraph by paragraph. In most browsers to select one paragraph at a time, triple-click on it.') ?></p>	<p><?php _e('Pasting content from another application, like Word or Excel, is best done with the Paste from Word button on the second row, or in HTML mode.') ?></p></div><div id="content3" class="hidden">	<h2><?php _e('Writing at Full Speed') ?></h2>    <p><?php _e('Rather than reaching for your mouse to click on the toolbar, use these access keys. Windows and Linux use Ctrl + letter. Macintosh uses Command + letter.') ?></p>	<table class="keys" width="100%" style="border: 0 none;">		<tr class="top"><th class="key center"><?php _e('Letter') ?></th><th class="left"><?php _e('Action') ?></th><th class="key center"><?php _e('Letter') ?></th><th class="left"><?php _e('Action') ?></th></tr>		<tr><th>c</th><td><?php _e('Copy') ?></td><th>v</th><td><?php _e('Paste') ?></td></tr>		<tr><th>a</th><td><?php _e('Select all') ?></td><th>x</th><td><?php _e('Cut') ?></td></tr>		<tr><th>z</th><td><?php _e('Undo') ?></td><th>y</th><td><?php _e('Redo') ?></td></tr>		<script type="text/javascript">		if ( ! tinymce.isWebKit )			document.write("<tr><th>b</th><td><?php _e('Bold') ?></td><th>i</th><td><?php _e('Italic') ?></td></tr>"+			"<tr><th>u</th><td><?php _e('Underline') ?></td><th>1</th><td><?php _e('Heading 1') ?></td></tr>"+			"<tr><th>2</th><td><?php _e('Heading 2') ?></td><th>3</th><td><?php _e('Heading 3') ?></td></tr>"+			"<tr><th>4</th><td><?php _e('Heading 4') ?></td><th>5</th><td><?php _e('Heading 5') ?></td></tr>"+			"<tr><th>6</th><td><?php _e('Heading 6') ?></td><th>9</th><td><?php _e('Address') ?></td></tr>")		</script>	</table>	<p><?php _e('The following shortcuts use different access keys: Alt + Shift + letter.') ?></p>	<table class="keys" width="100%" style="border: 0 none;">		<tr class="top"><th class="key center"><?php _e('Letter') ?></th><th class="left"><?php _e('Action') ?></th><th class="key center"><?php _e('Letter') ?></th><th class="left"><?php _e('Action') ?></th></tr>		<script type="text/javascript">		if ( tinymce.isWebKit )			document.write("<tr><th>b</th><td><?php _e('Bold') ?></td><th>i</th><td><?php _e('Italic') ?></td></tr>")		</script>		<tr><th>n</th><td><?php _e('Check Spelling') ?></td><th>l</th><td><?php _e('Align Left') ?></td></tr>		<tr><th>j</th><td><?php _e('Justify Text') ?></td><th>c</th><td><?php _e('Align Center') ?></td></tr>		<tr><th>d</th><td><span style="text-decoration: line-through;"><?php _e('Strikethrough') ?></span></td><th>r</th><td><?php _e('Align Right') ?></td></tr>		<tr><th>u</th><td><strong>&bull;</strong> <?php _e('List') ?></td><th>a</th><td><?php _e('Insert link') ?></td></tr>		<tr><th>o</th><td>1. <?php _e('List') ?></td><th>s</th><td><?php _e('Remove link') ?></td></tr>		<tr><th>q</th><td><?php _e('Quote') ?></td><th>m</th><td><?php _e('Insert Image') ?></td></tr>		<tr><th>g</th><td><?php _e('Full Screen') ?></td><th>t</th><td><?php _e('Insert More Tag') ?></td></tr>		<tr><th>p</th><td><?php _e('Insert Page Break tag') ?></td><th>h</th><td><?php _e('Help') ?></td></tr>		<tr><th>e</th><td colspan="3"><?php _e('Switch to HTML mode') ?></td></tr>	</table></div><div id="content4" class="hidden">	<h2><?php _e('About TinyMCE'); ?></h2>    <p><?php _e('Version:'); ?> <span id="version"></span> (<span id="date"></span>)</p>	<p><?php printf(__('TinyMCE is a platform independent web based Javascript HTML WYSIWYG editor control released as Open Source under %sLGPL</a>	by Moxiecode Systems AB. It has the ability to convert HTML TEXTAREA fields or other HTML elements to editor instances.'), '<a href="'.home_url('/wp-includes/js/tinymce/license.txt').'" target="_blank" title="'.__('GNU Library General Public Licence').'">') ?></p>	<p><?php _e('Copyright &copy; 2003-2007, <a href="http://www.moxiecode.com" target="_blank">Moxiecode Systems AB</a>, All rights reserved.') ?></p>	<p><?php _e('For more information about this software visit the <a href="http://tinymce.moxiecode.com" target="_blank">TinyMCE website</a>.') ?></p>	<div id="buttoncontainer">		<a href="http://www.moxiecode.com" target="_blank"><img src="themes/advanced/img/gotmoxie.png" alt="<?php _e('Got Moxie?') ?>" style="border: none;" /></a>		<a href="http://sourceforge.net/projects/tinymce/" target="_blank"><img src="themes/advanced/img/sflogo.png" alt="<?php _e('Hosted By Sourceforge') ?>" style="border: none;" /></a>		<a href="http://www.freshmeat.net/projects/tinymce" target="_blank"><img src="themes/advanced/img/fm.gif" alt="<?php _e('Also on freshmeat') ?>" style="border: none;" /></a>	</div></div></div><div class="mceActionPanel">	<div style="margin: 8px auto; text-align: center;padding-bottom: 10px;">		<input type="button" id="cancel" name="cancel" value="<?php _e('Close'); ?>" title="<?php _e('Close'); ?>" onclick="tinyMCEPopup.close();" />	</div></div></body></html>
<?php/** * @package WordPress * @subpackage Theme_Compat * @deprecated 3.0 *  * This file is here for Backwards compatibility with old themes and will be removed in a future version *  */_deprecated_file( sprintf( __( 'Theme without %1$s' ), basename(__FILE__) ), '3.0', null, sprintf( __('Please include a %1$s template in your theme.'), basename(__FILE__) ) );?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" <?php language_attributes(); ?>><head profile="http://gmpg.org/xfn/11"><meta http-equiv="Content-Type" content="<?php bloginfo('html_type'); ?>; charset=<?php bloginfo('charset'); ?>" /><title><?php wp_title('&laquo;', true, 'right'); ?> <?php bloginfo('name'); ?></title><link rel="stylesheet" href="<?php bloginfo('stylesheet_url'); ?>" type="text/css" media="screen" /><link rel="pingback" href="<?php bloginfo('pingback_url'); ?>" /><style type="text/css" media="screen"><?php// Checks to see whether it needs a sidebarif ( empty($withcomments) && !is_single() ) {?>	#page { background: url("<?php bloginfo('stylesheet_directory'); ?>/images/kubrickbg-<?php bloginfo('text_direction'); ?>.jpg") repeat-y top; border: none; }<?php } else { // No sidebar ?>	#page { background: url("<?php bloginfo('stylesheet_directory'); ?>/images/kubrickbgwide.jpg") repeat-y top; border: none; }<?php } ?></style><?php if ( is_singular() ) wp_enqueue_script( 'comment-reply' ); ?><?php wp_head(); ?></head><body <?php body_class(); ?>><div id="page"><div id="header" role="banner">	<div id="headerimg">		<h1><a href="<?php echo home_url(); ?>/"><?php bloginfo('name'); ?></a></h1>		<div class="description"><?php bloginfo('description'); ?></div>	</div></div><hr />
<?php/** * Edit comment form for inclusion in another file. * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');/** * @var string */$submitbutton_text = __('Edit Comment');$toprow_title = sprintf(__('Editing Comment # %s'), $comment->comment_ID);$form_action = 'editedcomment';$form_extra = "' />\n<input type='hidden' name='comment_ID' value='" . esc_attr($comment->comment_ID) . "' />\n<input type='hidden' name='comment_post_ID' value='" . esc_attr($comment->comment_post_ID);$comment->comment_author_email = esc_attr($comment->comment_author_email);?><form name="post" action="comment.php" method="post" id="post"><?php wp_nonce_field('update-comment_' . $comment->comment_ID) ?><div class="wrap"><?php screen_icon(); ?><h2><?php _e('Edit Comment'); ?></h2><div id="poststuff" class="metabox-holder has-right-sidebar"><input type="hidden" name="user_ID" value="<?php echo (int) $user_ID ?>" /><input type="hidden" name="action" value='<?php echo $form_action . $form_extra ?>' /><div id="side-info-column" class="inner-sidebar"><div id="submitdiv" class="stuffbox" ><h3><span class='hndle'><?php _e('Status') ?></span></h3><div class="inside"><div class="submitbox" id="submitcomment"><div id="minor-publishing"><div id="minor-publishing-actions"><div id="preview-action"><a class="preview button" href="<?php echo get_comment_link(); ?>" target="_blank"><?php _e('View Comment'); ?></a></div><div class="clear"></div></div><div id="misc-publishing-actions"><div class="misc-pub-section" id="comment-status-radio"><label class="approved"><input type="radio"<?php checked( $comment->comment_approved, '1' ); ?> name="comment_status" value="1" /><?php /* translators: comment type radio button */ _ex('Approved', 'adjective') ?></label><br /><label class="waiting"><input type="radio"<?php checked( $comment->comment_approved, '0' ); ?> name="comment_status" value="0" /><?php /* translators: comment type radio button */ _ex('Pending', 'adjective') ?></label><br /><label class="spam"><input type="radio"<?php checked( $comment->comment_approved, 'spam' ); ?> name="comment_status" value="spam" /><?php /* translators: comment type radio button */ _ex('Spam', 'adjective'); ?></label></div><div class="misc-pub-section curtime misc-pub-section-last"><?php// translators: Publish box date formt, see http://php.net/date$datef = __( 'M j, Y @ G:i' );$stamp = __('Submitted on: <b>%1$s</b>');$date = date_i18n( $datef, strtotime( $comment->comment_date ) );?><span id="timestamp"><?php printf($stamp, $date); ?></span>&nbsp;<a href="#edit_timestamp" class="edit-timestamp hide-if-no-js" tabindex='4'><?php _e('Edit') ?></a><div id='timestampdiv' class='hide-if-js'><?php touch_time(('editcomment' == $action), 0, 5); ?></div></div></div> <!-- misc actions --><div class="clear"></div></div><div id="major-publishing-actions"><div id="delete-action"><?php echo "<a class='submitdelete deletion' href='" . wp_nonce_url("comment.php?action=" . ( !EMPTY_TRASH_DAYS ? 'deletecomment' : 'trashcomment' ) . "&amp;c=$comment->comment_ID&amp;_wp_original_http_referer=" . urlencode(wp_get_referer()), 'delete-comment_' . $comment->comment_ID) . "'>" . ( !EMPTY_TRASH_DAYS ? __('Delete Permanently') : __('Move to Trash') ) . "</a>\n"; ?></div><div id="publishing-action"><input type="submit" name="save" value="<?php esc_attr_e('Update Comment'); ?>" tabindex="4" class="button-primary" /></div><div class="clear"></div></div></div></div></div></div><div id="post-body"><div id="post-body-content"><div id="namediv" class="stuffbox"><h3><label for="name"><?php _e( 'Author' ) ?></label></h3><div class="inside"><table class="form-table editcomment"><tbody><tr valign="top">	<td class="first"><?php _e( 'Name:' ); ?></td>	<td><input type="text" name="newcomment_author" size="30" value="<?php echo esc_attr( $comment->comment_author ); ?>" tabindex="1" id="name" /></td></tr><tr valign="top">	<td class="first">	<?php		if ( $comment->comment_author_email ) {			printf( __( 'E-mail (%s):' ), get_comment_author_email_link( __( 'send e-mail' ), '', '' ) );		} else {			_e( 'E-mail:' );		}?></td>	<td><input type="text" name="newcomment_author_email" size="30" value="<?php echo $comment->comment_author_email; ?>" tabindex="2" id="email" /></td></tr><tr valign="top">	<td class="first">	<?php		if ( ! empty( $comment->comment_author_url ) && 'http://' != $comment->comment_author_url ) {			$link = '<a href="' . $comment->comment_author_url . '" rel="external nofollow" target="_blank">' . __('visit site') . '</a>';			printf( __( 'URL (%s):' ), apply_filters('get_comment_author_link', $link ) );		} else {			_e( 'URL:' );		} ?></td>	<td><input type="text" id="newcomment_author_url" name="newcomment_author_url" size="30" class="code" value="<?php echo esc_attr($comment->comment_author_url); ?>" tabindex="3" /></td></tr></tbody></table><br /></div></div><div id="postdiv" class="postarea"><?php the_editor($comment->comment_content, 'content', 'newcomment_author_url', false, 4); ?><?php wp_nonce_field( 'closedpostboxes', 'closedpostboxesnonce', false ); ?></div><?phpdo_action('add_meta_boxes', 'comment', $comment);do_action('add_meta_boxes_comment', $comment);do_meta_boxes('comment', 'normal', $comment);?><input type="hidden" name="c" value="<?php echo esc_attr($comment->comment_ID) ?>" /><input type="hidden" name="p" value="<?php echo esc_attr($comment->comment_post_ID) ?>" /><input name="referredby" type="hidden" id="referredby" value="<?php echo esc_url(stripslashes(wp_get_referer())); ?>" /><?php wp_original_referer_field(true, 'previous'); ?><input type="hidden" name="noredir" value="1" /></div></div></div></div></form><script type="text/javascript">try{document.post.name.focus();}catch(e){}</script>
<?php/** * PemFTP - A Ftp implementation in pure PHP * * @package PemFTP * @since 2.5 * * @version 1.0 * @copyright Alexey Dotsenko * @author Alexey Dotsenko * @link http://www.phpclasses.org/browse/package/1743.html Site * @license LGPL License http://www.opensource.org/licenses/lgpl-license.html *//** * Socket Based FTP implementation * * @package PemFTP * @subpackage Socket * @since 2.5 * * @version 1.0 * @copyright Alexey Dotsenko * @author Alexey Dotsenko * @link http://www.phpclasses.org/browse/package/1743.html Site * @license LGPL License http://www.opensource.org/licenses/lgpl-license.html */class ftp extends ftp_base {	function ftp($verb=FALSE, $le=FALSE) {		$this->__construct($verb, $le);	}	function __construct($verb=FALSE, $le=FALSE) {		parent::__construct(true, $verb, $le);	}// <!-- --------------------------------------------------------------------------------------- -->// <!--       Private functions                                                                 -->// <!-- --------------------------------------------------------------------------------------- -->	function _settimeout($sock) {		if(!@socket_set_option($sock, SOL_SOCKET, SO_RCVTIMEO, array("sec"=>$this->_timeout, "usec"=>0))) {			$this->PushError('_connect','socket set receive timeout',socket_strerror(socket_last_error($sock)));			@socket_close($sock);			return FALSE;		}		if(!@socket_set_option($sock, SOL_SOCKET , SO_SNDTIMEO, array("sec"=>$this->_timeout, "usec"=>0))) {			$this->PushError('_connect','socket set send timeout',socket_strerror(socket_last_error($sock)));			@socket_close($sock);			return FALSE;		}		return true;	}	function _connect($host, $port) {		$this->SendMSG("Creating socket");		if(!($sock = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP))) {			$this->PushError('_connect','socket create failed',socket_strerror(socket_last_error($sock)));			return FALSE;		}		if(!$this->_settimeout($sock)) return FALSE;		$this->SendMSG("Connecting to \"".$host.":".$port."\"");		if (!($res = @socket_connect($sock, $host, $port))) {			$this->PushError('_connect','socket connect failed',socket_strerror(socket_last_error($sock)));			@socket_close($sock);			return FALSE;		}		$this->_connected=true;		return $sock;	}	function _readmsg($fnction="_readmsg"){		if(!$this->_connected) {			$this->PushError($fnction,'Connect first');			return FALSE;		}		$result=true;		$this->_message="";		$this->_code=0;		$go=true;		do {			$tmp=@socket_read($this->_ftp_control_sock, 4096, PHP_BINARY_READ);			if($tmp===false) {				$go=$result=false;				$this->PushError($fnction,'Read failed', socket_strerror(socket_last_error($this->_ftp_control_sock)));			} else {				$this->_message.=$tmp;				$go = !preg_match("/^([0-9]{3})(-.+\\1)? [^".CRLF."]+".CRLF."$/Us", $this->_message, $regs);			}		} while($go);		if($this->LocalEcho) echo "GET < ".rtrim($this->_message, CRLF).CRLF;		$this->_code=(int)$regs[1];		return $result;	}	function _exec($cmd, $fnction="_exec") {		if(!$this->_ready) {			$this->PushError($fnction,'Connect first');			return FALSE;		}		if($this->LocalEcho) echo "PUT > ",$cmd,CRLF;		$status=@socket_write($this->_ftp_control_sock, $cmd.CRLF);		if($status===false) {			$this->PushError($fnction,'socket write failed', socket_strerror(socket_last_error($this->stream)));			return FALSE;		}		$this->_lastaction=time();		if(!$this->_readmsg($fnction)) return FALSE;		return TRUE;	}	function _data_prepare($mode=FTP_ASCII) {		if(!$this->_settype($mode)) return FALSE;		$this->SendMSG("Creating data socket");		$this->_ftp_data_sock = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP);		if ($this->_ftp_data_sock < 0) {			$this->PushError('_data_prepare','socket create failed',socket_strerror(socket_last_error($this->_ftp_data_sock)));			return FALSE;		}		if(!$this->_settimeout($this->_ftp_data_sock)) {			$this->_data_close();			return FALSE;		}		if($this->_passive) {			if(!$this->_exec("PASV", "pasv")) {				$this->_data_close();				return FALSE;			}			if(!$this->_checkCode()) {				$this->_data_close();				return FALSE;			}			$ip_port = explode(",", ereg_replace("^.+ \\(?([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},[0-9]{1,3},[0-9]+,[0-9]+)\\)?.*".CRLF."$", "\\1", $this->_message));			$this->_datahost=$ip_port[0].".".$ip_port[1].".".$ip_port[2].".".$ip_port[3];            $this->_dataport=(((int)$ip_port[4])<<8) + ((int)$ip_port[5]);			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			if(!@socket_connect($this->_ftp_data_sock, $this->_datahost, $this->_dataport)) {				$this->PushError("_data_prepare","socket_connect", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			else $this->_ftp_temp_sock=$this->_ftp_data_sock;		} else {			if(!@socket_getsockname($this->_ftp_control_sock, $addr, $port)) {				$this->PushError("_data_prepare","can't get control socket information", socket_strerror(socket_last_error($this->_ftp_control_sock)));				$this->_data_close();				return FALSE;			}			if(!@socket_bind($this->_ftp_data_sock,$addr)){				$this->PushError("_data_prepare","can't bind data socket", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			if(!@socket_listen($this->_ftp_data_sock)) {				$this->PushError("_data_prepare","can't listen data socket", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			if(!@socket_getsockname($this->_ftp_data_sock, $this->_datahost, $this->_dataport)) {				$this->PushError("_data_prepare","can't get data socket information", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			if(!$this->_exec('PORT '.str_replace('.',',',$this->_datahost.'.'.($this->_dataport>>8).'.'.($this->_dataport&0x00FF)), "_port")) {				$this->_data_close();				return FALSE;			}			if(!$this->_checkCode()) {				$this->_data_close();				return FALSE;			}		}		return TRUE;	}	function _data_read($mode=FTP_ASCII, $fp=NULL) {		$NewLine=$this->_eol_code[$this->OS_local];		if(is_resource($fp)) $out=0;		else $out="";		if(!$this->_passive) {			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			$this->_ftp_temp_sock=socket_accept($this->_ftp_data_sock);			if($this->_ftp_temp_sock===FALSE) {				$this->PushError("_data_read","socket_accept", socket_strerror(socket_last_error($this->_ftp_temp_sock)));				$this->_data_close();				return FALSE;			}		}		while(($block=@socket_read($this->_ftp_temp_sock, $this->_ftp_buff_size, PHP_BINARY_READ))!==false) {			if($block==="") break;			if($mode!=FTP_BINARY) $block=preg_replace("/\r\n|\r|\n/", $this->_eol_code[$this->OS_local], $block);			if(is_resource($fp)) $out+=fwrite($fp, $block, strlen($block));			else $out.=$block;		}		return $out;	}	function _data_write($mode=FTP_ASCII, $fp=NULL) {		$NewLine=$this->_eol_code[$this->OS_local];		if(is_resource($fp)) $out=0;		else $out="";		if(!$this->_passive) {			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			$this->_ftp_temp_sock=socket_accept($this->_ftp_data_sock);			if($this->_ftp_temp_sock===FALSE) {				$this->PushError("_data_write","socket_accept", socket_strerror(socket_last_error($this->_ftp_temp_sock)));				$this->_data_close();				return false;			}		}		if(is_resource($fp)) {			while(!feof($fp)) {				$block=fread($fp, $this->_ftp_buff_size);				if(!$this->_data_write_block($mode, $block)) return false;			}		} elseif(!$this->_data_write_block($mode, $fp)) return false;		return true;	}	function _data_write_block($mode, $block) {		if($mode!=FTP_BINARY) $block=preg_replace("/\r\n|\r|\n/", $this->_eol_code[$this->OS_remote], $block);		do {			if(($t=@socket_write($this->_ftp_temp_sock, $block))===FALSE) {				$this->PushError("_data_write","socket_write", socket_strerror(socket_last_error($this->_ftp_temp_sock)));				$this->_data_close();				return FALSE;			}			$block=substr($block, $t);		} while(!empty($block));		return true;	}	function _data_close() {		@socket_close($this->_ftp_temp_sock);		@socket_close($this->_ftp_data_sock);		$this->SendMSG("Disconnected data from remote host");		return TRUE;	}	function _quit() {		if($this->_connected) {			@socket_close($this->_ftp_control_sock);			$this->_connected=false;			$this->SendMSG("Socket closed");		}	}}?>
<?php/** * Multisite themes administration panel. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */require_once( './admin.php' );if ( ! current_user_can( 'manage_network_themes' ) )	wp_die( __( 'You do not have permission to access this page.' ) );$title = __( 'Network Themes' );$parent_file = 'ms-admin.php';add_contextual_help($current_screen,	'<p>' . __('This screen enables and disables the inclusion of themes available to choose in the Appearance menu for each site. It does not activate or deactivate which theme a site is currently using.') . '</p>' .	'<p>' . __('If the network admin disables a theme that is in use, it can still remain selected on that site. If another theme is chosen, the disabled theme will not appear in the site&#8217;s Appearance > Themes screen.') . '</p>' .	'<p>' . __('Themes can be enabled on a site by site basis by the network admin on the Edit Site screen you go to via the Edit action link on the Sites screen.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Super_Admin_Themes_SubPanel" target="_blank">Documentation on Network Themes</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once( './admin-header.php' );if ( isset( $_GET['updated'] ) ) {	?>	<div id="message" class="updated"><p><?php _e( 'Site themes saved.' ) ?></p></div>	<?php}$themes = get_themes();$allowed_themes = get_site_allowed_themes();?><div class="wrap">	<form action="<?php echo esc_url( admin_url( 'ms-edit.php?action=updatethemes' ) ); ?>" method="post">		<?php screen_icon(); ?>		<h2><?php _e( 'Network Themes' ) ?></h2>		<p><?php _e( 'Themes must be enabled for your network before they will be available to individual sites.' ) ?></p>		<p class="submit">			<input type="submit" value="<?php _e( 'Apply Changes' ) ?>" /></p>		<table class="widefat">			<thead>				<tr>					<th style="width:15%;"><?php _e( 'Enable' ) ?></th>					<th style="width:25%;"><?php _e( 'Theme' ) ?></th>					<th style="width:10%;"><?php _e( 'Version' ) ?></th>					<th style="width:60%;"><?php _e( 'Description' ) ?></th>				</tr>			</thead>			<tbody id="plugins">			<?php			$total_theme_count = $activated_themes_count = 0;			$class = '';			foreach ( (array) $themes as $key => $theme ) {				$total_theme_count++;				$theme_key = esc_html( $theme['Stylesheet'] );				$class = ( 'alt' == $class ) ? '' : 'alt';				$class1 = $enabled = $disabled = '';				$enabled = $disabled = false;				if ( isset( $allowed_themes[$theme_key] ) == true ) {					$enabled = true;					$activated_themes_count++;					$class1 = 'active';				} else {					$disabled = true;				}				?>				<tr valign="top" class="<?php echo $class . ' ' . $class1; ?>">					<td>						<label><input name="theme[<?php echo $theme_key ?>]" type="radio" id="enabled_<?php echo $theme_key ?>" value="enabled" <?php checked( $enabled ) ?> /> <?php _e( 'Yes' ) ?></label>						&nbsp;&nbsp;&nbsp;						<label><input name="theme[<?php echo $theme_key ?>]" type="radio" id="disabled_<?php echo $theme_key ?>" value="disabled" <?php checked( $disabled ) ?> /> <?php _e( 'No' ) ?></label>					</td>					<th scope="row" style="text-align:left;"><?php echo $key ?></th>					<td><?php echo $theme['Version'] ?></td>					<td><?php echo $theme['Description'] ?></td>				</tr>			<?php } ?>			</tbody>		</table>		<p class="submit">			<input type="submit" value="<?php _e( 'Apply Changes' ) ?>" /></p>	</form>	<h3><?php _e( 'Total' )?></h3>	<p>		<?php printf( __( 'Themes Installed: %d' ), $total_theme_count); ?>		<br />		<?php printf( __( 'Themes Enabled: %d' ), $activated_themes_count); ?>	</p></div><?php include( './admin-footer.php' ); ?>
<?php/** * Multisite upgrade administration panel. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */require_once('admin.php');if ( !is_multisite() )	wp_die( __( 'Multisite support is not enabled.' ) );require_once( ABSPATH . WPINC . '/http.php' );$title = __( 'Update Network' );$parent_file = 'ms-admin.php';add_contextual_help($current_screen,	'<p>' . __('Only use this screen once you have updated to a new version of WordPress through Dashboard > Updates. Clicking the Update Network button will step through each site in the network, five at a time, and make sure any database upgrades are applied.') . '</p>' .	'<p>' . __('If a version update to core has not happened, clicking this button won&#8217;t affect anything.') . '</p>' .	'<p>' . __('If this process fails for any reason, users logging in to their sites will force the same update.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Super_Admin_Update_SubPanel" target="_blank">Update Network Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once('admin-header.php');if ( ! current_user_can( 'manage_network' ) )	wp_die( __( 'You do not have permission to access this page.' ) );echo '<div class="wrap">';screen_icon();echo '<h2>' . __( 'Update Network' ) . '</h2>';$action = isset($_GET['action']) ? $_GET['action'] : 'show';switch ( $action ) {	case "upgrade":		$n = ( isset($_GET['n']) ) ? intval($_GET['n']) : 0;		if ( $n < 5 ) {			global $wp_db_version;			update_site_option( 'wpmu_upgrade_site', $wp_db_version );		}		$blogs = $wpdb->get_results( "SELECT * FROM {$wpdb->blogs} WHERE site_id = '{$wpdb->siteid}' AND spam = '0' AND deleted = '0' AND archived = '0' ORDER BY registered DESC LIMIT {$n}, 5", ARRAY_A );		if ( empty( $blogs ) ) {			echo '<p>' . __( 'All done!' ) . '</p>';			break;		}		echo "<ul>";		foreach ( (array) $blogs as $details ) {			$siteurl = get_blog_option( $details['blog_id'], 'siteurl' );			echo "<li>$siteurl</li>";			$response = wp_remote_get( trailingslashit( $siteurl ) . "wp-admin/upgrade.php?step=upgrade_db", array( 'timeout' => 120, 'httpversion' => '1.1' ) );			if ( is_wp_error( $response ) )				wp_die( sprintf( __( 'Warning! Problem updating %1$s. Your server may not be able to connect to sites running on it. Error message: <em>%2$s</em>' ), $siteurl, $response->get_error_message() ) );			do_action( 'after_mu_upgrade', $response );			do_action( 'wpmu_upgrade_site', $details[ 'blog_id' ] );		}		echo "</ul>";		?><p><?php _e( 'If your browser doesn&#8217;t start loading the next page automatically, click this link:' ); ?> <a class="button" href="ms-upgrade-network.php?action=upgrade&amp;n=<?php echo ($n + 5) ?>"><?php _e("Next Sites"); ?></a></p>		<script type='text/javascript'>		<!--		function nextpage() {			location.href = "ms-upgrade-network.php?action=upgrade&n=<?php echo ($n + 5) ?>";		}		setTimeout( "nextpage()", 250 );		//-->		</script><?php	break;	case 'show':	default:		?><p><?php _e( 'You can update all the sites on your network through this page. It works by calling the update script of each site automatically. Hit the link below to update.' ); ?></p>		<p><a class="button" href="ms-upgrade-network.php?action=upgrade"><?php _e("Update Network"); ?></a></p><?php		do_action( 'wpmu_upgrade_page' );	break;}?></div><?php include('./admin-footer.php'); ?>
<?php/** * These functions are needed to load Multisite. * * @since 3.0.0 * * @package WordPress * @subpackage Multisite *//** * Whether a subdomain configuration is enabled. * * @since 3.0.0 * * @return bool True if subdomain configuration is enabled, false otherwise. */function is_subdomain_install() {	if ( defined('SUBDOMAIN_INSTALL') )		return SUBDOMAIN_INSTALL;	if ( defined('VHOST') && VHOST == 'yes' )		return true;	return false;}/** * Checks status of current blog. * * Checks if the blog is deleted, inactive, archived, or spammed. * * Dies with a default message if the blog does not pass the check. * * To change the default message when a blog does not pass the check, * use the wp-content/blog-deleted.php, blog-inactive.php and * blog-suspended.php drop-ins. * * @return bool|string Returns true on success, or drop-in file to include. */function ms_site_check() {	global $wpdb, $current_blog;	// Allow short-circuiting	$check = apply_filters('ms_site_check', null);	if ( null !== $check )		return true;	// Allow super admins to see blocked sites	if ( is_super_admin() )		return true;	if ( '1' == $current_blog->deleted ) {		if ( file_exists( WP_CONTENT_DIR . '/blog-deleted.php' ) ) {			return WP_CONTENT_DIR . '/blog-deleted.php';		} else {			header( 'HTTP/1.1 410 Gone' );			wp_die( /*WP_I18N_USER_DELETED_BLOG*/'This user has elected to delete their account and the content is no longer available.'/*/WP_I18N_USER_DELETED_BLOG*/ );		}	}	if ( '2' == $current_blog->deleted ) {		if ( file_exists( WP_CONTENT_DIR . '/blog-inactive.php' ) )			return WP_CONTENT_DIR . '/blog-inactive.php';		else			wp_die( sprintf( /*WP_I18N_BLOG_NOT_ACTIVATED*/'This site has not been activated yet. If you are having problems activating your site, please contact <a href="mailto:%1$s">%1$s</a>.'/*/WP_I18N_BLOG_NOT_ACTIVATED*/, str_replace( '@', ' AT ', get_site_option( 'admin_email', "support@{$current_site->domain}" ) ) ) );	}	if ( $current_blog->archived == '1' || $current_blog->spam == '1' ) {		if ( file_exists( WP_CONTENT_DIR . '/blog-suspended.php' ) ) {			return WP_CONTENT_DIR . '/blog-suspended.php';		} else {			header( 'HTTP/1.1 410 Gone' );			wp_die( /*WP_I18N_ARCHIVED*/'This site has been archived or suspended.'/*/WP_I18N_ARCHIVED*/ );		}	}	return true;}/** * Sets current site name. * * @access private * @since 3.0.0 * @return object $current_site object with site_name */function get_current_site_name( $current_site ) {	global $wpdb;	$current_site->site_name = wp_cache_get( $current_site->id . ':current_site_name', 'site-options' );	if ( ! $current_site->site_name ) {		$current_site->site_name = wp_cache_get( $current_site->id . ':site_name', 'site-options' );		if ( ! $current_site->site_name ) {			$current_site->site_name = $wpdb->get_var( $wpdb->prepare( "SELECT meta_value FROM $wpdb->sitemeta WHERE site_id = %d AND meta_key = 'site_name'", $current_site->id ) );			if ( ! $current_site->site_name )				$current_site->site_name = ucfirst( $current_site->domain );		}		wp_cache_set( $current_site->id . ':current_site_name', $current_site->site_name, 'site-options' );	}	return $current_site;}/** * Sets current_site object. * * @access private * @since 3.0.0 * @return object $current_site object */function wpmu_current_site() {	global $wpdb, $current_site, $domain, $path, $sites, $cookie_domain;	if ( defined( 'DOMAIN_CURRENT_SITE' ) && defined( 'PATH_CURRENT_SITE' ) ) {		$current_site->id = defined( 'SITE_ID_CURRENT_SITE' ) ? SITE_ID_CURRENT_SITE : 1;		$current_site->domain = DOMAIN_CURRENT_SITE;		$current_site->path   = $path = PATH_CURRENT_SITE;		if ( defined( 'BLOG_ID_CURRENT_SITE' ) )			$current_site->blog_id = BLOG_ID_CURRENT_SITE;		elseif ( defined( 'BLOGID_CURRENT_SITE' ) ) // deprecated.			$current_site->blog_id = BLOGID_CURRENT_SITE;		if ( DOMAIN_CURRENT_SITE == $domain )			$current_site->cookie_domain = $cookie_domain;		elseif ( substr( $current_site->domain, 0, 4 ) == 'www.' )			$current_site->cookie_domain = substr( $current_site->domain, 4 );		else			$current_site->cookie_domain = $current_site->domain;		wp_load_core_site_options( $current_site->id );		return $current_site;	}	$current_site = wp_cache_get( 'current_site', 'site-options' );	if ( $current_site )		return $current_site;	$sites = $wpdb->get_results( "SELECT * FROM $wpdb->site" ); // usually only one site	if ( 1 == count( $sites ) ) {		$current_site = $sites[0];		wp_load_core_site_options( $current_site->id );		$path = $current_site->path;		$current_site->blog_id = $wpdb->get_var( $wpdb->prepare( "SELECT blog_id FROM $wpdb->blogs WHERE domain = %s AND path = %s", $current_site->domain, $current_site->path ) );		$current_site = get_current_site_name( $current_site );		if ( substr( $current_site->domain, 0, 4 ) == 'www.' )			$current_site->cookie_domain = substr( $current_site->domain, 4 );		wp_cache_set( 'current_site', $current_site, 'site-options' );		return $current_site;	}	$path = substr( $_SERVER[ 'REQUEST_URI' ], 0, 1 + strpos( $_SERVER[ 'REQUEST_URI' ], '/', 1 ) );	if ( $domain == $cookie_domain )		$current_site = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->site WHERE domain = %s AND path = %s", $domain, $path ) );	else		$current_site = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->site WHERE domain IN ( %s, %s ) AND path = %s ORDER BY CHAR_LENGTH( domain ) DESC LIMIT 1", $domain, $cookie_domain, $path ) );	if ( ! $current_site ) {		if ( $domain == $cookie_domain )			$current_site = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->site WHERE domain = %s AND path='/'", $domain ) );		else			$current_site = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->site WHERE domain IN ( %s, %s ) AND path = '/' ORDER BY CHAR_LENGTH( domain ) DESC LIMIT 1", $domain, $cookie_domain, $path ) );	}	if ( $current_site ) {		$path = $current_site->path;		$current_site->cookie_domain = $cookie_domain;		return $current_site;	}	if ( is_subdomain_install() ) {		$sitedomain = substr( $domain, 1 + strpos( $domain, '.' ) );		$current_site = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->site WHERE domain = %s AND path = %s", $sitedomain, $path) );		if ( $current_site ) {			$current_site->cookie_domain = $current_site->domain;			return $current_site;		}		$current_site = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->site WHERE domain = %s AND path='/'", $sitedomain) );	}	if ( $current_site || defined( 'WP_INSTALLING' ) ) {		$path = '/';		return $current_site;	}	// Still no dice.	// @todo Update or remove WPMU codex link.	if ( 1 == count( $sites ) )		wp_die( sprintf( /*WP_I18N_BLOG_DOESNT_EXIST*/'That site does not exist. Please try <a href="%s">%s</a>.'/*/WP_I18N_BLOG_DOESNT_EXIST*/, $sites[0]->domain . $sites[0]->path ) );	else		wp_die( /*WP_I18N_NO_SITE_DEFINED*/'No site defined on this host. If you are the owner of this site, please check <a href="http://codex.wordpress.org/Debugging_WPMU">Debugging WPMU</a> for help.'/*/WP_I18N_NO_SITE_DEFINED*/ );}/** * Displays a failure message. * * Used when a blog's tables do not exist. Checks for a missing $wpdb->site table as well. * * @todo update Codex link for 3.0.0 * * @access private * @since 3.0.0 */function ms_not_installed() {	global $wpdb, $domain, $path;	$title = /*WP_I18N_FATAL_ERROR*/'Error establishing database connection'/*/WP_I18N_FATAL_ERROR*/;	$msg  = '<h1>' . $title . '</h1>';	if ( ! is_admin() )		die( $msg );	$msg .= '<p>' . /*WP_I18N_CONTACT_OWNER*/'If your site does not display, please contact the owner of this network.'/*/WP_I18N_CONTACT_OWNER*/ . '';	$msg .= ' ' . /*WP_I18N_CHECK_MYSQL*/'If you are the owner of this network please check that MySQL is running properly and all tables are error free.'/*/WP_I18N_CHECK_MYSQL*/ . '</p>';	if ( false && !$wpdb->get_var( "SHOW TABLES LIKE '$wpdb->site'" ) )		$msg .= '<p>' . sprintf( /*WP_I18N_TABLES_MISSING_LONG*/'<strong>Database tables are missing.</strong> This means that MySQL is not running, WordPress was not installed properly, or someone deleted <code>%s</code>. You really should look at your database now.'/*/WP_I18N_TABLES_MISSING_LONG*/, $wpdb->site ) . '</p>';	else		$msg .= '<p>' . sprintf( /*WP_I18N_NO_SITE_FOUND*/'<strong>Could not find site <code>%1$s</code>.</strong> Searched for table <code>%2$s</code> in database <code>%3$s</code>. Is that right?'/*/WP_I18N_NO_SITE_FOUND*/, rtrim( $domain . $path, '/' ), $wpdb->blogs, DB_NAME ) . '</p>';	$msg .= '<p><strong>' . /*WP_I18N_WHAT_DO_I_DO*/'What do I do now?'/*WP_I18N_WHAT_DO_I_DO*/ . '</strong> ';	$msg .= /*WP_I18N_RTFM*/'Read the <a target="_blank" href="http://codex.wordpress.org/Debugging_WPMU">bug report</a> page. Some of the guidelines there may help you figure out what went wrong.'/*/WP_I18N_RTFM*/;	$msg .= ' ' . /*WP_I18N_STUCK*/'If you&#8217;re still stuck with this message, then check that your database contains the following tables:'/*/WP_I18N_STUCK*/ . '</p><ul>';	foreach ( $wpdb->tables('global') as $t => $table ) {		if ( 'sitecategories' == $t )			continue;		$msg .= '<li>' . $table . '</li>';	}	$msg .= '</ul>';	wp_die( $msg, $title );}?>
<?php/** * Class for a set of entries for translation and their associated headers * * @version $Id: translations.php 406 2010-02-07 11:10:24Z nbachiyski $ * @package pomo * @subpackage translations */require_once dirname(__FILE__) . '/entry.php';if ( !class_exists( 'Translations' ) ):class Translations {	var $entries = array();	var $headers = array();	/**	 * Add entry to the PO structure	 *	 * @param object &$entry	 * @return bool true on success, false if the entry doesn't have a key	 */	function add_entry($entry) {		if (is_array($entry)) {			$entry = new Translation_Entry($entry);		}		$key = $entry->key();		if (false === $key) return false;		$this->entries[$key] = &$entry;		return true;	}	/**	 * Sets $header PO header to $value	 *	 * If the header already exists, it will be overwritten	 *	 * TODO: this should be out of this class, it is gettext specific	 *	 * @param string $header header name, without trailing :	 * @param string $value header value, without trailing \n	 */	function set_header($header, $value) {		$this->headers[$header] = $value;	}	function set_headers(&$headers) {		foreach($headers as $header => $value) {			$this->set_header($header, $value);		}	}	function get_header($header) {		return isset($this->headers[$header])? $this->headers[$header] : false;	}	function translate_entry(&$entry) {		$key = $entry->key();		return isset($this->entries[$key])? $this->entries[$key] : false;	}	function translate($singular, $context=null) {		$entry = new Translation_Entry(array('singular' => $singular, 'context' => $context));		$translated = $this->translate_entry($entry);		return ($translated && !empty($translated->translations))? $translated->translations[0] : $singular;	}	/**	 * Given the number of items, returns the 0-based index of the plural form to use	 *	 * Here, in the base Translations class, the commong logic for English is implmented:	 * 	0 if there is one element, 1 otherwise	 *	 * This function should be overrided by the sub-classes. For example MO/PO can derive the logic	 * from their headers.	 *	 * @param integer $count number of items	 */	function select_plural_form($count) {		return 1 == $count? 0 : 1;	}	function get_plural_forms_count() {		return 2;	}	function translate_plural($singular, $plural, $count, $context = null) {		$entry = new Translation_Entry(array('singular' => $singular, 'plural' => $plural, 'context' => $context));		$translated = $this->translate_entry($entry);		$index = $this->select_plural_form($count);		$total_plural_forms = $this->get_plural_forms_count();		if ($translated && 0 <= $index && $index < $total_plural_forms &&				is_array($translated->translations) &&				isset($translated->translations[$index]))			return $translated->translations[$index];		else			return 1 == $count? $singular : $plural;	}	/**	 * Merge $other in the current object.	 *	 * @param Object &$other Another Translation object, whose translations will be merged in this one	 * @return void	 **/	function merge_with(&$other) {		foreach( $other->entries as $entry ) {			$this->entries[$entry->key()] = $entry;		}	}}class Gettext_Translations extends Translations {	/**	 * The gettext implmentation of select_plural_form.	 *	 * It lives in this class, because there are more than one descendand, which will use it and	 * they can't share it effectively.	 *	 */	function gettext_select_plural_form($count) {		if (!isset($this->_gettext_select_plural_form) || is_null($this->_gettext_select_plural_form)) {			list( $nplurals, $expression ) = $this->nplurals_and_expression_from_header($this->get_header('Plural-Forms'));			$this->_nplurals = $nplurals;			$this->_gettext_select_plural_form = $this->make_plural_form_function($nplurals, $expression);		}		return call_user_func($this->_gettext_select_plural_form, $count);	}	function nplurals_and_expression_from_header($header) {		if (preg_match('/^\s*nplurals\s*=\s*(\d+)\s*;\s+plural\s*=\s*(.+)$/', $header, $matches)) {			$nplurals = (int)$matches[1];			$expression = trim($this->parenthesize_plural_exression($matches[2]));			return array($nplurals, $expression);		} else {			return array(2, 'n != 1');		}	}	/**	 * Makes a function, which will return the right translation index, according to the	 * plural forms header	 */	function make_plural_form_function($nplurals, $expression) {		$expression = str_replace('n', '$n', $expression);		$func_body = "			\$index = (int)($expression);			return (\$index < $nplurals)? \$index : $nplurals - 1;";		return create_function('$n', $func_body);	}	/**	 * Adds parantheses to the inner parts of ternary operators in	 * plural expressions, because PHP evaluates ternary oerators from left to right	 *	 * @param string $expression the expression without parentheses	 * @return string the expression with parentheses added	 */	function parenthesize_plural_exression($expression) {		$expression .= ';';		$res = '';		$depth = 0;		for ($i = 0; $i < strlen($expression); ++$i) {			$char = $expression[$i];			switch ($char) {				case '?':					$res .= ' ? (';					$depth++;					break;				case ':':					$res .= ') : (';					break;				case ';':					$res .= str_repeat(')', $depth) . ';';					$depth= 0;					break;				default:					$res .= $char;			}		}		return rtrim($res, ';');	}	function make_headers($translation) {		$headers = array();		// sometimes \ns are used instead of real new lines		$translation = str_replace('\n', "\n", $translation);		$lines = explode("\n", $translation);		foreach($lines as $line) {			$parts = explode(':', $line, 2);			if (!isset($parts[1])) continue;			$headers[trim($parts[0])] = trim($parts[1]);		}		return $headers;	}	function set_header($header, $value) {		parent::set_header($header, $value);		if ('Plural-Forms' == $header) {			list( $nplurals, $expression ) = $this->nplurals_and_expression_from_header($this->get_header('Plural-Forms'));			$this->_nplurals = $nplurals;			$this->_gettext_select_plural_form = $this->make_plural_form_function($nplurals, $expression);		}	}}endif;if ( !class_exists( 'NOOP_Translations' ) ):/** * Provides the same interface as Translations, but doesn't do anything */class NOOP_Translations {	var $entries = array();	var $headers = array();	function add_entry($entry) {		return true;	}	function set_header($header, $value) {	}	function set_headers(&$headers) {	}	function get_header($header) {		return false;	}	function translate_entry(&$entry) {		return false;	}	function translate($singular, $context=null) {		return $singular;	}	function select_plural_form($count) {		return 1 == $count? 0 : 1;	}	function get_plural_forms_count() {		return 2;	}	function translate_plural($singular, $plural, $count, $context = null) {			return 1 == $count? $singular : $plural;	}	function merge_with(&$other) {	}}endif;
<?php/** * Atom Syndication Format PHP Library * * @package AtomLib * @link http://code.google.com/p/phpatomlib/ * * @author Elias Torres <elias@torrez.us> * @version 0.4 * @since 2.3 *//** * Structure that store common Atom Feed Properties * * @package AtomLib */class AtomFeed {	/**	 * Stores Links	 * @var array	 * @access public	 */    var $links = array();    /**     * Stores Categories     * @var array     * @access public     */    var $categories = array();	/**	 * Stores Entries	 *	 * @var array	 * @access public	 */    var $entries = array();}/** * Structure that store Atom Entry Properties * * @package AtomLib */class AtomEntry {	/**	 * Stores Links	 * @var array	 * @access public	 */    var $links = array();    /**     * Stores Categories     * @var array	 * @access public     */    var $categories = array();}/** * AtomLib Atom Parser API * * @package AtomLib */class AtomParser {    var $NS = 'http://www.w3.org/2005/Atom';    var $ATOM_CONTENT_ELEMENTS = array('content','summary','title','subtitle','rights');    var $ATOM_SIMPLE_ELEMENTS = array('id','updated','published','draft');    var $debug = false;    var $depth = 0;    var $indent = 2;    var $in_content;    var $ns_contexts = array();    var $ns_decls = array();    var $content_ns_decls = array();    var $content_ns_contexts = array();    var $is_xhtml = false;    var $is_html = false;    var $is_text = true;    var $skipped_div = false;    var $FILE = "php://input";    var $feed;    var $current;    function AtomParser() {        $this->feed = new AtomFeed();        $this->current = null;        $this->map_attrs_func = create_function('$k,$v', 'return "$k=\"$v\"";');        $this->map_xmlns_func = create_function('$p,$n', '$xd = "xmlns"; if(strlen($n[0])>0) $xd .= ":{$n[0]}"; return "{$xd}=\"{$n[1]}\"";');    }    function _p($msg) {        if($this->debug) {            print str_repeat(" ", $this->depth * $this->indent) . $msg ."\n";        }    }    function error_handler($log_level, $log_text, $error_file, $error_line) {        $this->error = $log_text;    }    function parse() {        set_error_handler(array(&$this, 'error_handler'));        array_unshift($this->ns_contexts, array());        $parser = xml_parser_create_ns();        xml_set_object($parser, $this);        xml_set_element_handler($parser, "start_element", "end_element");        xml_parser_set_option($parser,XML_OPTION_CASE_FOLDING,0);        xml_parser_set_option($parser,XML_OPTION_SKIP_WHITE,0);        xml_set_character_data_handler($parser, "cdata");        xml_set_default_handler($parser, "_default");        xml_set_start_namespace_decl_handler($parser, "start_ns");        xml_set_end_namespace_decl_handler($parser, "end_ns");        $this->content = '';        $ret = true;        $fp = fopen($this->FILE, "r");        while ($data = fread($fp, 4096)) {            if($this->debug) $this->content .= $data;            if(!xml_parse($parser, $data, feof($fp))) {                trigger_error(sprintf(__('XML error: %s at line %d')."\n",                    xml_error_string(xml_get_error_code($xml_parser)),                    xml_get_current_line_number($xml_parser)));                $ret = false;                break;            }        }        fclose($fp);        xml_parser_free($parser);        restore_error_handler();        return $ret;    }    function start_element($parser, $name, $attrs) {        $tag = array_pop(split(":", $name));        switch($name) {            case $this->NS . ':feed':                $this->current = $this->feed;                break;            case $this->NS . ':entry':                $this->current = new AtomEntry();                break;        };        $this->_p("start_element('$name')");        #$this->_p(print_r($this->ns_contexts,true));        #$this->_p('current(' . $this->current . ')');        array_unshift($this->ns_contexts, $this->ns_decls);        $this->depth++;        if(!empty($this->in_content)) {            $this->content_ns_decls = array();            if($this->is_html || $this->is_text)                trigger_error("Invalid content in element found. Content must not be of type text or html if it contains markup.");            $attrs_prefix = array();            // resolve prefixes for attributes            foreach($attrs as $key => $value) {                $with_prefix = $this->ns_to_prefix($key, true);                $attrs_prefix[$with_prefix[1]] = $this->xml_escape($value);            }            $attrs_str = join(' ', array_map($this->map_attrs_func, array_keys($attrs_prefix), array_values($attrs_prefix)));            if(strlen($attrs_str) > 0) {                $attrs_str = " " . $attrs_str;            }            $with_prefix = $this->ns_to_prefix($name);            if(!$this->is_declared_content_ns($with_prefix[0])) {                array_push($this->content_ns_decls, $with_prefix[0]);            }            $xmlns_str = '';            if(count($this->content_ns_decls) > 0) {                array_unshift($this->content_ns_contexts, $this->content_ns_decls);                $xmlns_str .= join(' ', array_map($this->map_xmlns_func, array_keys($this->content_ns_contexts[0]), array_values($this->content_ns_contexts[0])));                if(strlen($xmlns_str) > 0) {                    $xmlns_str = " " . $xmlns_str;                }            }            array_push($this->in_content, array($tag, $this->depth, "<". $with_prefix[1] ."{$xmlns_str}{$attrs_str}" . ">"));        } else if(in_array($tag, $this->ATOM_CONTENT_ELEMENTS) || in_array($tag, $this->ATOM_SIMPLE_ELEMENTS)) {            $this->in_content = array();            $this->is_xhtml = $attrs['type'] == 'xhtml';            $this->is_html = $attrs['type'] == 'html' || $attrs['type'] == 'text/html';            $this->is_text = !in_array('type',array_keys($attrs)) || $attrs['type'] == 'text';            $type = $this->is_xhtml ? 'XHTML' : ($this->is_html ? 'HTML' : ($this->is_text ? 'TEXT' : $attrs['type']));            if(in_array('src',array_keys($attrs))) {                $this->current->$tag = $attrs;            } else {                array_push($this->in_content, array($tag,$this->depth, $type));            }        } else if($tag == 'link') {            array_push($this->current->links, $attrs);        } else if($tag == 'category') {            array_push($this->current->categories, $attrs);        }        $this->ns_decls = array();    }    function end_element($parser, $name) {        $tag = array_pop(split(":", $name));        $ccount = count($this->in_content);        # if we are *in* content, then let's proceed to serialize it        if(!empty($this->in_content)) {            # if we are ending the original content element            # then let's finalize the content            if($this->in_content[0][0] == $tag &&                $this->in_content[0][1] == $this->depth) {                $origtype = $this->in_content[0][2];                array_shift($this->in_content);                $newcontent = array();                foreach($this->in_content as $c) {                    if(count($c) == 3) {                        array_push($newcontent, $c[2]);                    } else {                        if($this->is_xhtml || $this->is_text) {                            array_push($newcontent, $this->xml_escape($c));                        } else {                            array_push($newcontent, $c);                        }                    }                }                if(in_array($tag, $this->ATOM_CONTENT_ELEMENTS)) {                    $this->current->$tag = array($origtype, join('',$newcontent));                } else {                    $this->current->$tag = join('',$newcontent);                }                $this->in_content = array();            } else if($this->in_content[$ccount-1][0] == $tag &&                $this->in_content[$ccount-1][1] == $this->depth) {                $this->in_content[$ccount-1][2] = substr($this->in_content[$ccount-1][2],0,-1) . "/>";            } else {                # else, just finalize the current element's content                $endtag = $this->ns_to_prefix($name);                array_push($this->in_content, array($tag, $this->depth, "</$endtag[1]>"));            }        }        array_shift($this->ns_contexts);        $this->depth--;        if($name == ($this->NS . ':entry')) {            array_push($this->feed->entries, $this->current);            $this->current = null;        }        $this->_p("end_element('$name')");    }    function start_ns($parser, $prefix, $uri) {        $this->_p("starting: " . $prefix . ":" . $uri);        array_push($this->ns_decls, array($prefix,$uri));    }    function end_ns($parser, $prefix) {        $this->_p("ending: #" . $prefix . "#");    }    function cdata($parser, $data) {        $this->_p("data: #" . str_replace(array("\n"), array("\\n"), trim($data)) . "#");        if(!empty($this->in_content)) {            array_push($this->in_content, $data);        }    }    function _default($parser, $data) {        # when does this gets called?    }    function ns_to_prefix($qname, $attr=false) {        # split 'http://www.w3.org/1999/xhtml:div' into ('http','//www.w3.org/1999/xhtml','div')        $components = split(":", $qname);        # grab the last one (e.g 'div')        $name = array_pop($components);        if(!empty($components)) {            # re-join back the namespace component            $ns = join(":",$components);            foreach($this->ns_contexts as $context) {                foreach($context as $mapping) {                    if($mapping[1] == $ns && strlen($mapping[0]) > 0) {                        return array($mapping, "$mapping[0]:$name");                    }                }            }        }        if($attr) {            return array(null, $name);        } else {            foreach($this->ns_contexts as $context) {                foreach($context as $mapping) {                    if(strlen($mapping[0]) == 0) {                        return array($mapping, $name);                    }                }            }        }    }    function is_declared_content_ns($new_mapping) {        foreach($this->content_ns_contexts as $context) {            foreach($context as $mapping) {                if($new_mapping == $mapping) {                    return true;                }            }        }        return false;    }    function xml_escape($string)    {             return str_replace(array('&','"',"'",'<','>'),                array('&amp;','&quot;','&apos;','&lt;','&gt;'),                $string );    }}?>
<?php/** * WordPress Diff bastard child of old MediaWiki Diff Formatter. * * Basically all that remains is the table structure and some method names. * * @package WordPress * @subpackage Diff */if ( !class_exists( 'Text_Diff' ) ) {	/** Text_Diff class */	require( dirname(__FILE__).'/Text/Diff.php' );	/** Text_Diff_Renderer class */	require( dirname(__FILE__).'/Text/Diff/Renderer.php' );	/** Text_Diff_Renderer_inline class */	require( dirname(__FILE__).'/Text/Diff/Renderer/inline.php' );}/** * Table renderer to display the diff lines. * * @since 2.6.0 * @uses Text_Diff_Renderer Extends */class WP_Text_Diff_Renderer_Table extends Text_Diff_Renderer {	/**	 * @see Text_Diff_Renderer::_leading_context_lines	 * @var int	 * @access protected	 * @since 2.6.0	 */	var $_leading_context_lines  = 10000;	/**	 * @see Text_Diff_Renderer::_trailing_context_lines	 * @var int	 * @access protected	 * @since 2.6.0	 */	var $_trailing_context_lines = 10000;	/**	 * {@internal Missing Description}}	 *	 * @var float	 * @access protected	 * @since 2.6.0	 */	var $_diff_threshold = 0.6;	/**	 * Inline display helper object name.	 *	 * @var string	 * @access protected	 * @since 2.6.0	 */	var $inline_diff_renderer = 'WP_Text_Diff_Renderer_inline';	/**	 * PHP4 Constructor - Call parent constructor with params array.	 *	 * This will set class properties based on the key value pairs in the array.	 *	 * @since unknown	 *	 * @param array $params	 */	function Text_Diff_Renderer_Table( $params = array() ) {		$parent = get_parent_class($this);		$this->$parent( $params );	}	/**	 * @ignore	 *	 * @param string $header	 * @return string	 */	function _startBlock( $header ) {		return '';	}	/**	 * @ignore	 *	 * @param array $lines	 * @param string $prefix	 */	function _lines( $lines, $prefix=' ' ) {	}	/**	 * @ignore	 *	 * @param string $line HTML-escape the value.	 * @return string	 */	function addedLine( $line ) {		return "<td>+</td><td class='diff-addedline'>{$line}</td>";	}	/**	 * @ignore	 *	 * @param string $line HTML-escape the value.	 * @return string	 */	function deletedLine( $line ) {		return "<td>-</td><td class='diff-deletedline'>{$line}</td>";	}	/**	 * @ignore	 *	 * @param string $line HTML-escape the value.	 * @return string	 */	function contextLine( $line ) {		return "<td> </td><td class='diff-context'>{$line}</td>";	}	/**	 * @ignore	 *	 * @return string	 */	function emptyLine() {		return '<td colspan="2">&nbsp;</td>';	}	/**	 * @ignore	 * @access private	 *	 * @param array $lines	 * @param bool $encode	 * @return string	 */	function _added( $lines, $encode = true ) {		$r = '';		foreach ($lines as $line) {			if ( $encode )				$line = htmlspecialchars( $line );			$r .= '<tr>' . $this->emptyLine() . $this->addedLine( $line ) . "</tr>\n";		}		return $r;	}	/**	 * @ignore	 * @access private	 *	 * @param array $lines	 * @param bool $encode	 * @return string	 */	function _deleted( $lines, $encode = true ) {		$r = '';		foreach ($lines as $line) {			if ( $encode )				$line = htmlspecialchars( $line );			$r .= '<tr>' . $this->deletedLine( $line ) . $this->emptyLine() . "</tr>\n";		}		return $r;	}	/**	 * @ignore	 * @access private	 *	 * @param array $lines	 * @param bool $encode	 * @return string	 */	function _context( $lines, $encode = true ) {		$r = '';		foreach ($lines as $line) {			if ( $encode )				$line = htmlspecialchars( $line );			$r .= '<tr>' .				$this->contextLine( $line ) . $this->contextLine( $line ) . "</tr>\n";		}		return $r;	}	/**	 * Process changed lines to do word-by-word diffs for extra highlighting.	 *	 * (TRAC style) sometimes these lines can actually be deleted or added rows.	 * We do additional processing to figure that out	 *	 * @access private	 * @since 2.6.0	 *	 * @param array $orig	 * @param array $final	 * @return string	 */	function _changed( $orig, $final ) {		$r = '';		// Does the aforementioned additional processing		// *_matches tell what rows are "the same" in orig and final.  Those pairs will be diffed to get word changes		//	match is numeric: an index in other column		//	match is 'X': no match.  It is a new row		// *_rows are column vectors for the orig column and the final column.		//	row >= 0: an indix of the $orig or $final array		//	row  < 0: a blank row for that column		list($orig_matches, $final_matches, $orig_rows, $final_rows) = $this->interleave_changed_lines( $orig, $final );		// These will hold the word changes as determined by an inline diff		$orig_diffs  = array();		$final_diffs = array();		// Compute word diffs for each matched pair using the inline diff		foreach ( $orig_matches as $o => $f ) {			if ( is_numeric($o) && is_numeric($f) ) {				$text_diff = new Text_Diff( 'auto', array( array($orig[$o]), array($final[$f]) ) );				$renderer = new $this->inline_diff_renderer;				$diff = $renderer->render( $text_diff );				// If they're too different, don't include any <ins> or <dels>				if ( $diff_count = preg_match_all( '!(<ins>.*?</ins>|<del>.*?</del>)!', $diff, $diff_matches ) ) {					// length of all text between <ins> or <del>					$stripped_matches = strlen(strip_tags( join(' ', $diff_matches[0]) ));					// since we count lengith of text between <ins> or <del> (instead of picking just one),					//	we double the length of chars not in those tags.					$stripped_diff = strlen(strip_tags( $diff )) * 2 - $stripped_matches;					$diff_ratio = $stripped_matches / $stripped_diff;					if ( $diff_ratio > $this->_diff_threshold )						continue; // Too different.  Don't save diffs.				}				// Un-inline the diffs by removing del or ins				$orig_diffs[$o]  = preg_replace( '|<ins>.*?</ins>|', '', $diff );				$final_diffs[$f] = preg_replace( '|<del>.*?</del>|', '', $diff );			}		}		foreach ( array_keys($orig_rows) as $row ) {			// Both columns have blanks.  Ignore them.			if ( $orig_rows[$row] < 0 && $final_rows[$row] < 0 )				continue;			// If we have a word based diff, use it.  Otherwise, use the normal line.			if ( isset( $orig_diffs[$orig_rows[$row]] ) )				$orig_line = $orig_diffs[$orig_rows[$row]];			elseif ( isset( $orig[$orig_rows[$row]] ) )				$orig_line = htmlspecialchars($orig[$orig_rows[$row]]);			else				$orig_line = '';			if ( isset( $final_diffs[$final_rows[$row]] ) )				$final_line = $final_diffs[$final_rows[$row]];			elseif ( isset( $final[$final_rows[$row]] ) )				$final_line = htmlspecialchars($final[$final_rows[$row]]);			else				$final_line = '';			if ( $orig_rows[$row] < 0 ) { // Orig is blank.  This is really an added row.				$r .= $this->_added( array($final_line), false );			} elseif ( $final_rows[$row] < 0 ) { // Final is blank.  This is really a deleted row.				$r .= $this->_deleted( array($orig_line), false );			} else { // A true changed row.				$r .= '<tr>' . $this->deletedLine( $orig_line ) . $this->addedLine( $final_line ) . "</tr>\n";			}		}		return $r;	}	/**	 * Takes changed blocks and matches which rows in orig turned into which rows in final.	 *	 * Returns	 *	*_matches ( which rows match with which )	 *	*_rows ( order of rows in each column interleaved with blank rows as	 *		necessary )	 *	 * @since 2.6.0	 *	 * @param unknown_type $orig	 * @param unknown_type $final	 * @return unknown	 */	function interleave_changed_lines( $orig, $final ) {		// Contains all pairwise string comparisons.  Keys are such that this need only be a one dimensional array.		$matches = array();		foreach ( array_keys($orig) as $o ) {			foreach ( array_keys($final) as $f ) {				$matches["$o,$f"] = $this->compute_string_distance( $orig[$o], $final[$f] );			}		}		asort($matches); // Order by string distance.		$orig_matches  = array();		$final_matches = array();		foreach ( $matches as $keys => $difference ) {			list($o, $f) = explode(',', $keys);			$o = (int) $o;			$f = (int) $f;			// Already have better matches for these guys			if ( isset($orig_matches[$o]) && isset($final_matches[$f]) )				continue;			// First match for these guys.  Must be best match			if ( !isset($orig_matches[$o]) && !isset($final_matches[$f]) ) {				$orig_matches[$o] = $f;				$final_matches[$f] = $o;				continue;			}			// Best match of this final is already taken?  Must mean this final is a new row.			if ( isset($orig_matches[$o]) )				$final_matches[$f] = 'x';			// Best match of this orig is already taken?  Must mean this orig is a deleted row.			elseif ( isset($final_matches[$f]) )				$orig_matches[$o] = 'x';		}		// We read the text in this order		ksort($orig_matches);		ksort($final_matches);		// Stores rows and blanks for each column.		$orig_rows = $orig_rows_copy = array_keys($orig_matches);		$final_rows = array_keys($final_matches);		// Interleaves rows with blanks to keep matches aligned.		// We may end up with some extraneous blank rows, but we'll just ignore them later.		foreach ( $orig_rows_copy as $orig_row ) {			$final_pos = array_search($orig_matches[$orig_row], $final_rows, true);			$orig_pos = (int) array_search($orig_row, $orig_rows, true);			if ( false === $final_pos ) { // This orig is paired with a blank final.				array_splice( $final_rows, $orig_pos, 0, -1 );			} elseif ( $final_pos < $orig_pos ) { // This orig's match is up a ways.  Pad final with blank rows.				$diff_pos = $final_pos - $orig_pos;				while ( $diff_pos < 0 )					array_splice( $final_rows, $orig_pos, 0, $diff_pos++ );			} elseif ( $final_pos > $orig_pos ) { // This orig's match is down a ways.  Pad orig with blank rows.				$diff_pos = $orig_pos - $final_pos;				while ( $diff_pos < 0 )					array_splice( $orig_rows, $orig_pos, 0, $diff_pos++ );			}		}		// Pad the ends with blank rows if the columns aren't the same length		$diff_count = count($orig_rows) - count($final_rows);		if ( $diff_count < 0 ) {			while ( $diff_count < 0 )				array_push($orig_rows, $diff_count++);		} elseif ( $diff_count > 0 ) {			$diff_count = -1 * $diff_count;			while ( $diff_count < 0 )				array_push($final_rows, $diff_count++);		}		return array($orig_matches, $final_matches, $orig_rows, $final_rows);/*		// Debug		echo "\n\n\n\n\n";		echo "-- DEBUG Matches: Orig -> Final --";		foreach ( $orig_matches as $o => $f ) {			echo "\n\n\n\n\n";			echo "ORIG: $o, FINAL: $f\n";			var_dump($orig[$o],$final[$f]);		}		echo "\n\n\n\n\n";		echo "-- DEBUG Matches: Final -> Orig --";		foreach ( $final_matches as $f => $o ) {			echo "\n\n\n\n\n";			echo "FINAL: $f, ORIG: $o\n";			var_dump($final[$f],$orig[$o]);		}		echo "\n\n\n\n\n";		echo "-- DEBUG Rows: Orig -- Final --";		echo "\n\n\n\n\n";		foreach ( $orig_rows as $row => $o ) {			if ( $o < 0 )				$o = 'X';			$f = $final_rows[$row];			if ( $f < 0 )				$f = 'X';			echo "$o -- $f\n";		}		echo "\n\n\n\n\n";		echo "-- END DEBUG --";		echo "\n\n\n\n\n";		return array($orig_matches, $final_matches, $orig_rows, $final_rows);*/	}	/**	 * Computes a number that is intended to reflect the "distance" between two strings.	 *	 * @since 2.6.0	 *	 * @param string $string1	 * @param string $string2	 * @return int	 */	function compute_string_distance( $string1, $string2 ) {		// Vectors containing character frequency for all chars in each string		$chars1 = count_chars($string1);		$chars2 = count_chars($string2);		// L1-norm of difference vector.		$difference = array_sum( array_map( array(&$this, 'difference'), $chars1, $chars2 ) );		// $string1 has zero length? Odd.  Give huge penalty by not dividing.		if ( !$string1 )			return $difference;		// Return distance per charcter (of string1)		return $difference / strlen($string1);	}	/**	 * @ignore	 * @since 2.6.0	 *	 * @param int $a	 * @param int $b	 * @return int	 */	function difference( $a, $b ) {		return abs( $a - $b );	}}/** * Better word splitting than the PEAR package provides. * * @since 2.6.0 * @uses Text_Diff_Renderer_inline Extends */class WP_Text_Diff_Renderer_inline extends Text_Diff_Renderer_inline {	/**	 * @ignore	 * @since 2.6.0	 *	 * @param string $string	 * @param string $newlineEscape	 * @return string	 */	function _splitOnWords($string, $newlineEscape = "\n") {		$string = str_replace("\0", '', $string);		$words  = preg_split( '/([^\w])/u', $string, -1, PREG_SPLIT_DELIM_CAPTURE );		$words  = str_replace( "\n", $newlineEscape, $words );		return $words;	}}?>
<?php/** * API for creating dynamic sidebar without hardcoding functionality into * themes. Includes both internal WordPress routines and theme use routines. * * This functionality was found in a plugin before WordPress 2.2 release which * included it in the core from that point on. * * @link http://codex.wordpress.org/Plugins/WordPress_Widgets WordPress Widgets * @link http://codex.wordpress.org/Plugins/WordPress_Widgets_Api Widgets API * * @package WordPress * @subpackage Widgets *//** * This class must be extended for each widget and WP_Widget::widget(), WP_Widget::update() * and WP_Widget::form() need to be over-ridden. * * @package WordPress * @subpackage Widgets * @since 2.8 */class WP_Widget {	var $id_base;			// Root id for all widgets of this type.	var $name;				// Name for this widget type.	var $widget_options;	// Option array passed to wp_register_sidebar_widget()	var $control_options;	// Option array passed to wp_register_widget_control()	var $number = false;	// Unique ID number of the current instance.	var $id = false;		// Unique ID string of the current instance (id_base-number)	var $updated = false;	// Set true when we update the data after a POST submit - makes sure we don't do it twice.	// Member functions that you must over-ride.	/** Echo the widget content.	 *	 * Subclasses should over-ride this function to generate their widget code.	 *	 * @param array $args Display arguments including before_title, after_title, before_widget, and after_widget.	 * @param array $instance The settings for the particular instance of the widget	 */	function widget($args, $instance) {		die('function WP_Widget::widget() must be over-ridden in a sub-class.');	}	/** Update a particular instance.	 *	 * This function should check that $new_instance is set correctly.	 * The newly calculated value of $instance should be returned.	 * If "false" is returned, the instance won't be saved/updated.	 *	 * @param array $new_instance New settings for this instance as input by the user via form()	 * @param array $old_instance Old settings for this instance	 * @return array Settings to save or bool false to cancel saving	 */	function update($new_instance, $old_instance) {		return $new_instance;	}	/** Echo the settings update form	 *	 * @param array $instance Current settings	 */	function form($instance) {		echo '<p class="no-options-widget">' . __('There are no options for this widget.') . '</p>';		return 'noform';	}	// Functions you'll need to call.	/**	 * PHP4 constructor	 */	function WP_Widget( $id_base = false, $name, $widget_options = array(), $control_options = array() ) {		$this->__construct( $id_base, $name, $widget_options, $control_options );	}	/**	 * PHP5 constructor	 *	 * @param string $id_base Optional Base ID for the widget, lower case,	 * if left empty a portion of the widget's class name will be used. Has to be unique.	 * @param string $name Name for the widget displayed on the configuration page.	 * @param array $widget_options Optional Passed to wp_register_sidebar_widget()	 *	 - description: shown on the configuration page	 *	 - classname	 * @param array $control_options Optional Passed to wp_register_widget_control()	 *	 - width: required if more than 250px	 *	 - height: currently not used but may be needed in the future	 */	function __construct( $id_base = false, $name, $widget_options = array(), $control_options = array() ) {		$this->id_base = empty($id_base) ? preg_replace( '/(wp_)?widget_/', '', strtolower(get_class($this)) ) : strtolower($id_base);		$this->name = $name;		$this->option_name = 'widget_' . $this->id_base;		$this->widget_options = wp_parse_args( $widget_options, array('classname' => $this->option_name) );		$this->control_options = wp_parse_args( $control_options, array('id_base' => $this->id_base) );	}	/**	 * Constructs name attributes for use in form() fields	 *	 * This function should be used in form() methods to create name attributes for fields to be saved by update()	 *	 * @param string $field_name Field name	 * @return string Name attribute for $field_name	 */	function get_field_name($field_name) {		return 'widget-' . $this->id_base . '[' . $this->number . '][' . $field_name . ']';	}	/**	 * Constructs id attributes for use in form() fields	 *	 * This function should be used in form() methods to create id attributes for fields to be saved by update()	 *	 * @param string $field_name Field name	 * @return string ID attribute for $field_name	 */	function get_field_id($field_name) {		return 'widget-' . $this->id_base . '-' . $this->number . '-' . $field_name;	}	// Private Functions. Don't worry about these.	function _register() {		$settings = $this->get_settings();		$empty = true;		if ( is_array($settings) ) {			foreach ( array_keys($settings) as $number ) {				if ( is_numeric($number) ) {					$this->_set($number);					$this->_register_one($number);					$empty = false;				}			}		}		if ( $empty ) {			// If there are none, we register the widget's existance with a			// generic template			$this->_set(1);			$this->_register_one();		}	}	function _set($number) {		$this->number = $number;		$this->id = $this->id_base . '-' . $number;	}	function _get_display_callback() {		return array(&$this, 'display_callback');	}	function _get_update_callback() {		return array(&$this, 'update_callback');	}	function _get_form_callback() {		return array(&$this, 'form_callback');	}	/** Generate the actual widget content.	 *	Just finds the instance and calls widget().	 *	Do NOT over-ride this function. */	function display_callback( $args, $widget_args = 1 ) {		if ( is_numeric($widget_args) )			$widget_args = array( 'number' => $widget_args );		$widget_args = wp_parse_args( $widget_args, array( 'number' => -1 ) );		$this->_set( $widget_args['number'] );		$instance = $this->get_settings();		if ( array_key_exists( $this->number, $instance ) ) {			$instance = $instance[$this->number];			// filters the widget's settings, return false to stop displaying the widget			$instance = apply_filters('widget_display_callback', $instance, $this, $args);			if ( false !== $instance )				$this->widget($args, $instance);		}	}	/** Deal with changed settings.	 *	Do NOT over-ride this function. */	function update_callback( $widget_args = 1 ) {		global $wp_registered_widgets;		if ( is_numeric($widget_args) )			$widget_args = array( 'number' => $widget_args );		$widget_args = wp_parse_args( $widget_args, array( 'number' => -1 ) );		$all_instances = $this->get_settings();		// We need to update the data		if ( $this->updated )			return;		$sidebars_widgets = wp_get_sidebars_widgets();		if ( isset($_POST['delete_widget']) && $_POST['delete_widget'] ) {			// Delete the settings for this instance of the widget			if ( isset($_POST['the-widget-id']) )				$del_id = $_POST['the-widget-id'];			else				return;			if ( isset($wp_registered_widgets[$del_id]['params'][0]['number']) ) {				$number = $wp_registered_widgets[$del_id]['params'][0]['number'];				if ( $this->id_base . '-' . $number == $del_id )					unset($all_instances[$number]);			}		} else {			if ( isset($_POST['widget-' . $this->id_base]) && is_array($_POST['widget-' . $this->id_base]) ) {				$settings = $_POST['widget-' . $this->id_base];			} elseif ( isset($_POST['id_base']) && $_POST['id_base'] == $this->id_base ) {				$num = $_POST['multi_number'] ? (int) $_POST['multi_number'] : (int) $_POST['widget_number'];				$settings = array( $num => array() );			} else {				return;			}			foreach ( $settings as $number => $new_instance ) {				$new_instance = stripslashes_deep($new_instance);				$this->_set($number);				$old_instance = isset($all_instances[$number]) ? $all_instances[$number] : array();				$instance = $this->update($new_instance, $old_instance);				// filters the widget's settings before saving, return false to cancel saving (keep the old settings if updating)				$instance = apply_filters('widget_update_callback', $instance, $new_instance, $old_instance, $this);				if ( false !== $instance )					$all_instances[$number] = $instance;				break; // run only once			}		}		$this->save_settings($all_instances);		$this->updated = true;	}	/** Generate the control form.	 *	Do NOT over-ride this function. */	function form_callback( $widget_args = 1 ) {		if ( is_numeric($widget_args) )			$widget_args = array( 'number' => $widget_args );		$widget_args = wp_parse_args( $widget_args, array( 'number' => -1 ) );		$all_instances = $this->get_settings();		if ( -1 == $widget_args['number'] ) {			// We echo out a form where 'number' can be set later			$this->_set('__i__');			$instance = array();		} else {			$this->_set($widget_args['number']);			$instance = $all_instances[ $widget_args['number'] ];		}		// filters the widget admin form before displaying, return false to stop displaying it		$instance = apply_filters('widget_form_callback', $instance, $this);		$return = null;		if ( false !== $instance ) {			$return = $this->form($instance);			// add extra fields in the widget form - be sure to set $return to null if you add any			// if the widget has no form the text echoed from the default form method can be hidden using css			do_action_ref_array( 'in_widget_form', array(&$this, &$return, $instance) );		}		return $return;	}	/** Helper function: Registers a single instance. */	function _register_one($number = -1) {		wp_register_sidebar_widget(	$this->id, $this->name,	$this->_get_display_callback(), $this->widget_options, array( 'number' => $number ) );		_register_widget_update_callback( $this->id_base, $this->_get_update_callback(), $this->control_options, array( 'number' => -1 ) );		_register_widget_form_callback(	$this->id, $this->name,	$this->_get_form_callback(), $this->control_options, array( 'number' => $number ) );	}	function save_settings($settings) {		$settings['_multiwidget'] = 1;		update_option( $this->option_name, $settings );	}	function get_settings() {		$settings = get_option($this->option_name);		if ( false === $settings && isset($this->alt_option_name) )			$settings = get_option($this->alt_option_name);		if ( !is_array($settings) )			$settings = array();		if ( !array_key_exists('_multiwidget', $settings) ) {			// old format, conver if single widget			$settings = wp_convert_widget_settings($this->id_base, $this->option_name, $settings);		}		unset($settings['_multiwidget'], $settings['__i__']);		return $settings;	}}/** * Singleton that registers and instantiates WP_Widget classes. * * @package WordPress * @subpackage Widgets * @since 2.8 */class WP_Widget_Factory {	var $widgets = array();	function WP_Widget_Factory() {		add_action( 'widgets_init', array( &$this, '_register_widgets' ), 100 );	}	function register($widget_class) {		$this->widgets[$widget_class] = & new $widget_class();	}	function unregister($widget_class) {		if ( isset($this->widgets[$widget_class]) )			unset($this->widgets[$widget_class]);	}	function _register_widgets() {		global $wp_registered_widgets;		$keys = array_keys($this->widgets);		$registered = array_keys($wp_registered_widgets);		$registered = array_map('_get_widget_id_base', $registered);		foreach ( $keys as $key ) {			// don't register new widget if old widget with the same id is already registered			if ( in_array($this->widgets[$key]->id_base, $registered, true) ) {				unset($this->widgets[$key]);				continue;			}			$this->widgets[$key]->_register();		}	}}/* Global Variables *//** @ignore */global $wp_registered_sidebars, $wp_registered_widgets, $wp_registered_widget_controls, $wp_registered_widget_updates;/** * Stores the sidebars, since many themes can have more than one. * * @global array $wp_registered_sidebars * @since 2.2.0 */$wp_registered_sidebars = array();/** * Stores the registered widgets. * * @global array $wp_registered_widgets * @since 2.2.0 */$wp_registered_widgets = array();/** * Stores the registered widget control (options). * * @global array $wp_registered_widget_controls * @since 2.2.0 */$wp_registered_widget_controls = array();$wp_registered_widget_updates = array();/** * Private */$_wp_sidebars_widgets = array();/** * Private */ $_wp_deprecated_widgets_callbacks = array( 	'wp_widget_pages',	'wp_widget_pages_control',	'wp_widget_calendar',	'wp_widget_calendar_control',	'wp_widget_archives',	'wp_widget_archives_control',	'wp_widget_links',	'wp_widget_meta',	'wp_widget_meta_control',	'wp_widget_search',	'wp_widget_recent_entries',	'wp_widget_recent_entries_control',	'wp_widget_tag_cloud',	'wp_widget_tag_cloud_control',	'wp_widget_categories',	'wp_widget_categories_control',	'wp_widget_text',	'wp_widget_text_control',	'wp_widget_rss',	'wp_widget_rss_control',	'wp_widget_recent_comments',	'wp_widget_recent_comments_control' );/* Template tags & API functions *//** * Register a widget * * Registers a WP_Widget widget * * @since 2.8.0 * * @see WP_Widget * @see WP_Widget_Factory * @uses WP_Widget_Factory * * @param string $widget_class The name of a class that extends WP_Widget */function register_widget($widget_class) {	global $wp_widget_factory;	$wp_widget_factory->register($widget_class);}/** * Unregister a widget * * Unregisters a WP_Widget widget. Useful for unregistering default widgets. * Run within a function hooked to the widgets_init action. * * @since 2.8.0 * * @see WP_Widget * @see WP_Widget_Factory * @uses WP_Widget_Factory * * @param string $widget_class The name of a class that extends WP_Widget */function unregister_widget($widget_class) {	global $wp_widget_factory;	$wp_widget_factory->unregister($widget_class);}/** * Creates multiple sidebars. * * If you wanted to quickly create multiple sidebars for a theme or internally. * This function will allow you to do so. If you don't pass the 'name' and/or * 'id' in $args, then they will be built for you. * * The default for the name is "Sidebar #", with '#' being replaced with the * number the sidebar is currently when greater than one. If first sidebar, the * name will be just "Sidebar". The default for id is "sidebar-" followed by the * number the sidebar creation is currently at. If the id is provided, and mutliple * sidebars are being defined, the id will have "-2" appended, and so on. * * @since 2.2.0 * * @see register_sidebar() The second parameter is documented by register_sidebar() and is the same here. * @uses parse_str() Converts a string to an array to be used in the rest of the function. * @uses register_sidebar() Sends single sidebar information [name, id] to this *	function to handle building the sidebar. * * @param int $number Number of sidebars to create. * @param string|array $args Builds Sidebar based off of 'name' and 'id' values. */function register_sidebars($number = 1, $args = array()) {	global $wp_registered_sidebars;	$number = (int) $number;	if ( is_string($args) )		parse_str($args, $args);	for ( $i = 1; $i <= $number; $i++ ) {		$_args = $args;		if ( $number > 1 )			$_args['name'] = isset($args['name']) ? sprintf($args['name'], $i) : sprintf(__('Sidebar %d'), $i);		else			$_args['name'] = isset($args['name']) ? $args['name'] : __('Sidebar');		// Custom specified ID's are suffixed if they exist already.		// Automatically generated sidebar names need to be suffixed regardless starting at -0		if ( isset($args['id']) ) {			$_args['id'] = $args['id'];			$n = 2; // Start at -2 for conflicting custom ID's			while ( isset($wp_registered_sidebars[$_args['id']]) )				$_args['id'] = $args['id'] . '-' . $n++;		} else {			$n = count($wp_registered_sidebars);			do {				$_args['id'] = 'sidebar-' . ++$n;			} while ( isset($wp_registered_sidebars[$_args['id']]) );		}		register_sidebar($_args);	}}/** * Builds the definition for a single sidebar and returns the ID. * * The $args parameter takes either a string or an array with 'name' and 'id' * contained in either usage. It will be noted that the values will be applied * to all sidebars, so if creating more than one, it will be advised to allow * for WordPress to create the defaults for you. * * Example for string would be <code>'name=whatever;id=whatever1'</code> and for * the array it would be <code>array( *    'name' => 'whatever', *    'id' => 'whatever1')</code>. * * name - The name of the sidebar, which presumably the title which will be *     displayed. * id - The unique identifier by which the sidebar will be called by. * before_widget - The content that will prepended to the widgets when they are *     displayed. * after_widget - The content that will be appended to the widgets when they are *     displayed. * before_title - The content that will be prepended to the title when displayed. * after_title - the content that will be appended to the title when displayed. * * <em>Content</em> is assumed to be HTML and should be formatted as such, but * doesn't have to be. * * @since 2.2.0 * @uses $wp_registered_sidebars Stores the new sidebar in this array by sidebar ID. * * @param string|array $args Builds Sidebar based off of 'name' and 'id' values * @return string The sidebar id that was added. */function register_sidebar($args = array()) {	global $wp_registered_sidebars;	$i = count($wp_registered_sidebars) + 1;	$defaults = array(		'name' => sprintf(__('Sidebar %d'), $i ),		'id' => "sidebar-$i",		'description' => '',		'before_widget' => '<li id="%1$s" class="widget %2$s">',		'after_widget' => "</li>\n",		'before_title' => '<h2 class="widgettitle">',		'after_title' => "</h2>\n",	);	$sidebar = wp_parse_args( $args, $defaults );	$wp_registered_sidebars[$sidebar['id']] = $sidebar;	add_theme_support('widgets');	do_action( 'register_sidebar', $sidebar );	return $sidebar['id'];}/** * Removes a sidebar from the list. * * @since 2.2.0 * * @uses $wp_registered_sidebars Stores the new sidebar in this array by sidebar ID. * * @param string $name The ID of the sidebar when it was added. */function unregister_sidebar( $name ) {	global $wp_registered_sidebars;	if ( isset( $wp_registered_sidebars[$name] ) )		unset( $wp_registered_sidebars[$name] );}/** * Register widget for use in sidebars. * * The default widget option is 'classname' that can be override. * * The function can also be used to unregister widgets when $output_callback * parameter is an empty string. * * @since 2.2.0 * * @uses $wp_registered_widgets Uses stored registered widgets. * @uses $wp_register_widget_defaults Retrieves widget defaults. * * @param int|string $id Widget ID. * @param string $name Widget display title. * @param callback $output_callback Run when widget is called. * @param array|string Optional. $options Widget Options. * @param mixed $params,... Widget parameters to add to widget. * @return null Will return if $output_callback is empty after removing widget. */function wp_register_sidebar_widget($id, $name, $output_callback, $options = array()) {	global $wp_registered_widgets, $wp_registered_widget_controls, $wp_registered_widget_updates, $_wp_deprecated_widgets_callbacks;	$id = strtolower($id);	if ( empty($output_callback) ) {		unset($wp_registered_widgets[$id]);		return;	}	$id_base = _get_widget_id_base($id);	if ( in_array($output_callback, $_wp_deprecated_widgets_callbacks, true) && !is_callable($output_callback) ) {		if ( isset($wp_registered_widget_controls[$id]) )			unset($wp_registered_widget_controls[$id]);		if ( isset($wp_registered_widget_updates[$id_base]) )			unset($wp_registered_widget_updates[$id_base]);		return;	}	$defaults = array('classname' => $output_callback);	$options = wp_parse_args($options, $defaults);	$widget = array(		'name' => $name,		'id' => $id,		'callback' => $output_callback,		'params' => array_slice(func_get_args(), 4)	);	$widget = array_merge($widget, $options);	if ( is_callable($output_callback) && ( !isset($wp_registered_widgets[$id]) || did_action( 'widgets_init' ) ) ) {		do_action( 'wp_register_sidebar_widget', $widget );		$wp_registered_widgets[$id] = $widget;	}}/** * Retrieve description for widget. * * When registering widgets, the options can also include 'description' that * describes the widget for display on the widget administration panel or * in the theme. * * @since 2.5.0 * * @param int|string $id Widget ID. * @return string Widget description, if available. Null on failure to retrieve description. */function wp_widget_description( $id ) {	if ( !is_scalar($id) )		return;	global $wp_registered_widgets;	if ( isset($wp_registered_widgets[$id]['description']) )		return esc_html( $wp_registered_widgets[$id]['description'] );}/** * Retrieve description for a sidebar. * * When registering sidebars a 'description' parameter can be included that * describes the sidebar for display on the widget administration panel. * * @since 2.9.0 * * @param int|string $id sidebar ID. * @return string Sidebar description, if available. Null on failure to retrieve description. */function wp_sidebar_description( $id ) {	if ( !is_scalar($id) )		return;	global $wp_registered_sidebars;	if ( isset($wp_registered_sidebars[$id]['description']) )		return esc_html( $wp_registered_sidebars[$id]['description'] );}/** * Remove widget from sidebar. * * @since 2.2.0 * * @param int|string $id Widget ID. */function wp_unregister_sidebar_widget($id) {	do_action( 'wp_unregister_sidebar_widget', $id );	wp_register_sidebar_widget($id, '', '');	wp_unregister_widget_control($id);}/** * Registers widget control callback for customizing options. * * The options contains the 'height', 'width', and 'id_base' keys. The 'height' * option is never used. The 'width' option is the width of the fully expanded * control form, but try hard to use the default width. The 'id_base' is for * multi-widgets (widgets which allow multiple instances such as the text * widget), an id_base must be provided. The widget id will end up looking like * {$id_base}-{$unique_number}. * * @since 2.2.0 * * @param int|string $id Sidebar ID. * @param string $name Sidebar display name. * @param callback $control_callback Run when sidebar is displayed. * @param array|string $options Optional. Widget options. See above long description. * @param mixed $params,... Optional. Additional parameters to add to widget. */function wp_register_widget_control($id, $name, $control_callback, $options = array()) {	global $wp_registered_widget_controls, $wp_registered_widget_updates, $wp_registered_widgets, $_wp_deprecated_widgets_callbacks;	$id = strtolower($id);	$id_base = _get_widget_id_base($id);	if ( empty($control_callback) ) {		unset($wp_registered_widget_controls[$id]);		unset($wp_registered_widget_updates[$id_base]);		return;	}	if ( in_array($control_callback, $_wp_deprecated_widgets_callbacks, true) && !is_callable($control_callback) ) {		if ( isset($wp_registered_widgets[$id]) )			unset($wp_registered_widgets[$id]);		return;	}	if ( isset($wp_registered_widget_controls[$id]) && !did_action( 'widgets_init' ) )		return;	$defaults = array('width' => 250, 'height' => 200 ); // height is never used	$options = wp_parse_args($options, $defaults);	$options['width'] = (int) $options['width'];	$options['height'] = (int) $options['height'];	$widget = array(		'name' => $name,		'id' => $id,		'callback' => $control_callback,		'params' => array_slice(func_get_args(), 4)	);	$widget = array_merge($widget, $options);	$wp_registered_widget_controls[$id] = $widget;	if ( isset($wp_registered_widget_updates[$id_base]) )		return;	if ( isset($widget['params'][0]['number']) )		$widget['params'][0]['number'] = -1;	unset($widget['width'], $widget['height'], $widget['name'], $widget['id']);	$wp_registered_widget_updates[$id_base] = $widget;}function _register_widget_update_callback($id_base, $update_callback, $options = array()) {	global $wp_registered_widget_updates;	if ( isset($wp_registered_widget_updates[$id_base]) ) {		if ( empty($update_callback) )			unset($wp_registered_widget_updates[$id_base]);		return;	}	$widget = array(		'callback' => $update_callback,		'params' => array_slice(func_get_args(), 3)	);	$widget = array_merge($widget, $options);	$wp_registered_widget_updates[$id_base] = $widget;}function _register_widget_form_callback($id, $name, $form_callback, $options = array()) {	global $wp_registered_widget_controls;	$id = strtolower($id);	if ( empty($form_callback) ) {		unset($wp_registered_widget_controls[$id]);		return;	}	if ( isset($wp_registered_widget_controls[$id]) && !did_action( 'widgets_init' ) )		return;	$defaults = array('width' => 250, 'height' => 200 );	$options = wp_parse_args($options, $defaults);	$options['width'] = (int) $options['width'];	$options['height'] = (int) $options['height'];	$widget = array(		'name' => $name,		'id' => $id,		'callback' => $form_callback,		'params' => array_slice(func_get_args(), 4)	);	$widget = array_merge($widget, $options);	$wp_registered_widget_controls[$id] = $widget;}/** * Remove control callback for widget. * * @since 2.2.0 * @uses wp_register_widget_control() Unregisters by using empty callback. * * @param int|string $id Widget ID. */function wp_unregister_widget_control($id) {	return wp_register_widget_control($id, '', '');}/** * Display dynamic sidebar. * * By default it displays the default sidebar or 'sidebar-1'. The 'sidebar-1' is * not named by the theme, the actual name is '1', but 'sidebar-' is added to * the registered sidebars for the name. If you named your sidebar 'after-post', * then the parameter $index will still be 'after-post', but the lookup will be * for 'sidebar-after-post'. * * It is confusing for the $index parameter, but just know that it should just * work. When you register the sidebar in the theme, you will use the same name * for this function or "Pay no heed to the man behind the curtain." Just accept * it as an oddity of WordPress sidebar register and display. * * @since 2.2.0 * * @param int|string $index Optional, default is 1. Name or ID of dynamic sidebar. * @return bool True, if widget sidebar was found and called. False if not found or not called. */function dynamic_sidebar($index = 1) {	global $wp_registered_sidebars, $wp_registered_widgets;	if ( is_int($index) ) {		$index = "sidebar-$index";	} else {		$index = sanitize_title($index);		foreach ( (array) $wp_registered_sidebars as $key => $value ) {			if ( sanitize_title($value['name']) == $index ) {				$index = $key;				break;			}		}	}	$sidebars_widgets = wp_get_sidebars_widgets();	if ( empty($wp_registered_sidebars[$index]) || !array_key_exists($index, $sidebars_widgets) || !is_array($sidebars_widgets[$index]) || empty($sidebars_widgets[$index]) )		return false;	$sidebar = $wp_registered_sidebars[$index];	$did_one = false;	foreach ( (array) $sidebars_widgets[$index] as $id ) {		if ( !isset($wp_registered_widgets[$id]) ) continue;		$params = array_merge(			array( array_merge( $sidebar, array('widget_id' => $id, 'widget_name' => $wp_registered_widgets[$id]['name']) ) ),			(array) $wp_registered_widgets[$id]['params']		);		// Substitute HTML id and class attributes into before_widget		$classname_ = '';		foreach ( (array) $wp_registered_widgets[$id]['classname'] as $cn ) {			if ( is_string($cn) )				$classname_ .= '_' . $cn;			elseif ( is_object($cn) )				$classname_ .= '_' . get_class($cn);		}		$classname_ = ltrim($classname_, '_');		$params[0]['before_widget'] = sprintf($params[0]['before_widget'], $id, $classname_);		$params = apply_filters( 'dynamic_sidebar_params', $params );		$callback = $wp_registered_widgets[$id]['callback'];		do_action( 'dynamic_sidebar', $wp_registered_widgets[$id] );		if ( is_callable($callback) ) {			call_user_func_array($callback, $params);			$did_one = true;		}	}	return $did_one;}/** * Whether widget is displayied on the front-end. * * Either $callback or $id_base can be used * $id_base is the first argument when extending WP_Widget class * Without the optional $widget_id parameter, returns the ID of the first sidebar * in which the first instance of the widget with the given callback or $id_base is found. * With the $widget_id parameter, returns the ID of the sidebar where * the widget with that callback/$id_base AND that ID is found. * * NOTE: $widget_id and $id_base are the same for single widgets. To be effective * this function has to run after widgets have initialized, at action 'init' or later. * * @since 2.2.0 * * @param callback Optional, Widget callback to check. * @param int $widget_id Optional, but needed for checking. Widget ID. * @param string $id_base Optional, the base ID of a widget created by extending WP_Widget. * @param bool $skip_inactive Optional, whether to check in 'wp_inactive_widgets'. * @return mixed false if widget is not active or id of sidebar in which the widget is active. */function is_active_widget($callback = false, $widget_id = false, $id_base = false, $skip_inactive = true) {	global $wp_registered_widgets;	$sidebars_widgets = wp_get_sidebars_widgets();	if ( is_array($sidebars_widgets) ) {		foreach ( $sidebars_widgets as $sidebar => $widgets ) {			if ( $skip_inactive && 'wp_inactive_widgets' == $sidebar )				continue;			if ( is_array($widgets) ) {				foreach ( $widgets as $widget ) {					if ( ( $callback && isset($wp_registered_widgets[$widget]['callback']) && $wp_registered_widgets[$widget]['callback'] == $callback ) || ( $id_base && _get_widget_id_base($widget) == $id_base ) ) {						if ( !$widget_id || $widget_id == $wp_registered_widgets[$widget]['id'] )							return $sidebar;					}				}			}		}	}	return false;}/** * Whether the dynamic sidebar is enabled and used by theme. * * @since 2.2.0 * * @return bool True, if using widgets. False, if not using widgets. */function is_dynamic_sidebar() {	global $wp_registered_widgets, $wp_registered_sidebars;	$sidebars_widgets = get_option('sidebars_widgets');	foreach ( (array) $wp_registered_sidebars as $index => $sidebar ) {		if ( count($sidebars_widgets[$index]) ) {			foreach ( (array) $sidebars_widgets[$index] as $widget )				if ( array_key_exists($widget, $wp_registered_widgets) )					return true;		}	}	return false;}/** * Whether a sidebar is in use. * * @since 2.8 * * @param mixed $index, sidebar name, id or number to check. * @return bool true if the sidebar is in use, false otherwise. */function is_active_sidebar( $index ) {	$index = ( is_int($index) ) ? "sidebar-$index" : sanitize_title($index);	$sidebars_widgets = wp_get_sidebars_widgets();	if ( !empty($sidebars_widgets[$index]) )		return true;	return false;}/* Internal Functions *//** * Retrieve full list of sidebars and their widgets. * * Will upgrade sidebar widget list, if needed. Will also save updated list, if * needed. * * @since 2.2.0 * @access private * * @param bool $deprecated. Not used. * @return array Upgraded list of widgets to version 3 array format when called from the admin. */function wp_get_sidebars_widgets($deprecated = true) {	if ( $deprecated !== true )		_deprecated_argument( __FUNCTION__, '2.8.1' );	global $wp_registered_widgets, $wp_registered_sidebars, $_wp_sidebars_widgets;	// If loading from front page, consult $_wp_sidebars_widgets rather than options	// to see if wp_convert_widget_settings() has made manipulations in memory.	if ( !is_admin() ) {		if ( empty($_wp_sidebars_widgets) )			$_wp_sidebars_widgets = get_option('sidebars_widgets', array());		$sidebars_widgets = $_wp_sidebars_widgets;	} else {		$sidebars_widgets = get_option('sidebars_widgets', array());		$_sidebars_widgets = array();		if ( isset($sidebars_widgets['wp_inactive_widgets']) || empty($sidebars_widgets) )			$sidebars_widgets['array_version'] = 3;		elseif ( !isset($sidebars_widgets['array_version']) )			$sidebars_widgets['array_version'] = 1;		switch ( $sidebars_widgets['array_version'] ) {			case 1 :				foreach ( (array) $sidebars_widgets as $index => $sidebar )				if ( is_array($sidebar) )				foreach ( (array) $sidebar as $i => $name ) {					$id = strtolower($name);					if ( isset($wp_registered_widgets[$id]) ) {						$_sidebars_widgets[$index][$i] = $id;						continue;					}					$id = sanitize_title($name);					if ( isset($wp_registered_widgets[$id]) ) {						$_sidebars_widgets[$index][$i] = $id;						continue;					}					$found = false;					foreach ( $wp_registered_widgets as $widget_id => $widget ) {						if ( strtolower($widget['name']) == strtolower($name) ) {							$_sidebars_widgets[$index][$i] = $widget['id'];							$found = true;							break;						} elseif ( sanitize_title($widget['name']) == sanitize_title($name) ) {							$_sidebars_widgets[$index][$i] = $widget['id'];							$found = true;							break;						}					}					if ( $found )						continue;					unset($_sidebars_widgets[$index][$i]);				}				$_sidebars_widgets['array_version'] = 2;				$sidebars_widgets = $_sidebars_widgets;				unset($_sidebars_widgets);			case 2 :				$sidebars = array_keys( $wp_registered_sidebars );				if ( !empty( $sidebars ) ) {					// Move the known-good ones first					foreach ( (array) $sidebars as $id ) {						if ( array_key_exists( $id, $sidebars_widgets ) ) {							$_sidebars_widgets[$id] = $sidebars_widgets[$id];							unset($sidebars_widgets[$id], $sidebars[$id]);						}					}					// move the rest to wp_inactive_widgets					if ( !isset($_sidebars_widgets['wp_inactive_widgets']) )						$_sidebars_widgets['wp_inactive_widgets'] = array();					if ( !empty($sidebars_widgets) ) {						foreach ( $sidebars_widgets as $lost => $val ) {							if ( is_array($val) )								$_sidebars_widgets['wp_inactive_widgets'] = array_merge( (array) $_sidebars_widgets['wp_inactive_widgets'], $val );						}					}					$sidebars_widgets = $_sidebars_widgets;					unset($_sidebars_widgets);				}		}	}	if ( is_array( $sidebars_widgets ) && isset($sidebars_widgets['array_version']) )		unset($sidebars_widgets['array_version']);	$sidebars_widgets = apply_filters('sidebars_widgets', $sidebars_widgets);	return $sidebars_widgets;}/** * Set the sidebar widget option to update sidebars. * * @since 2.2.0 * @access private * * @param array $sidebars_widgets Sidebar widgets and their settings. */function wp_set_sidebars_widgets( $sidebars_widgets ) {	if ( !isset( $sidebars_widgets['array_version'] ) )		$sidebars_widgets['array_version'] = 3;	update_option( 'sidebars_widgets', $sidebars_widgets );}/** * Retrieve default registered sidebars list. * * @since 2.2.0 * @access private * * @return array */function wp_get_widget_defaults() {	global $wp_registered_sidebars;	$defaults = array();	foreach ( (array) $wp_registered_sidebars as $index => $sidebar )		$defaults[$index] = array();	return $defaults;}/** * Convert the widget settings from single to multi-widget format. * * @since 2.8.0 * * @return array */function wp_convert_widget_settings($base_name, $option_name, $settings) {	// This test may need expanding.	$single = $changed = false;	if ( empty($settings) ) {		$single = true;	} else {		foreach ( array_keys($settings) as $number ) {			if ( 'number' == $number )				continue;			if ( !is_numeric($number) ) {				$single = true;				break;			}		}	}	if ( $single ) {		$settings = array( 2 => $settings );		// If loading from the front page, update sidebar in memory but don't save to options		if ( is_admin() ) {			$sidebars_widgets = get_option('sidebars_widgets');		} else {			if ( empty($GLOBALS['_wp_sidebars_widgets']) )				$GLOBALS['_wp_sidebars_widgets'] = get_option('sidebars_widgets', array());			$sidebars_widgets = &$GLOBALS['_wp_sidebars_widgets'];		}		foreach ( (array) $sidebars_widgets as $index => $sidebar ) {			if ( is_array($sidebar) ) {				foreach ( $sidebar as $i => $name ) {					if ( $base_name == $name ) {						$sidebars_widgets[$index][$i] = "$name-2";						$changed = true;						break 2;					}				}			}		}		if ( is_admin() && $changed )			update_option('sidebars_widgets', $sidebars_widgets);	}	$settings['_multiwidget'] = 1;	if ( is_admin() )		update_option( $option_name, $settings );	return $settings;}/** * Output an arbitrary widget as a template tag * * @since 2.8 * * @param string $widget the widget's PHP class name (see default-widgets.php) * @param array $instance the widget's instance settings * @param array $args the widget's sidebar args * @return void **/function the_widget($widget, $instance = array(), $args = array()) {	global $wp_widget_factory;	$widget_obj = $wp_widget_factory->widgets[$widget];	if ( !is_a($widget_obj, 'WP_Widget') )		return;	$before_widget = sprintf('<div class="widget %s">', $widget_obj->widget_options['classname']);	$default_args = array('before_widget' => $before_widget, 'after_widget' => "</div>", 'before_title' => '<h2 class="widgettitle">', 'after_title' => '</h2>');	$args = wp_parse_args($args, $default_args);	$instance = wp_parse_args($instance);	do_action( 'the_widget', $widget, $instance, $args );	$widget_obj->_set(-1);	$widget_obj->widget($args, $instance);}/** * Private */function _get_widget_id_base($id) {	return preg_replace( '/-[0-9]+$/', '', $id );}
<?php/** * WP_Importer base class */class WP_Importer {	/**	 * Class Constructor	 *	 * @return void	 */	function __construct() {}	function WP_Importer() {		$this->__construct();	}	/**	 * Returns array with imported permalinks from WordPress database	 *	 * @param string $bid	 * @return array	 */	function get_imported_posts( $importer_name, $bid ) {		global $wpdb;		$hashtable = array();		$limit = 100;		$offset = 0;		// Grab all posts in chunks		do {			$meta_key = $importer_name . '_' . $bid . '_permalink';			$sql = $wpdb->prepare( "SELECT post_id, meta_value FROM $wpdb->postmeta WHERE meta_key = '%s' LIMIT %d,%d", $meta_key, $offset, $limit );			$results = $wpdb->get_results( $sql );			// Increment offset			$offset = ( $limit + $offset );			if ( !empty( $results ) ) {				foreach ( $results as $r ) {					// Set permalinks into array					$hashtable[$r->meta_value] = intval( $r->post_id );				}			}		} while ( count( $results ) == $limit );		// unset to save memory		unset( $results, $r );		return $hashtable;	}	/**	 * Return count of imported permalinks from WordPress database	 *	 * @param string $bid	 * @return int	 */	function count_imported_posts( $importer_name, $bid ) {		global $wpdb;		$count = 0;		// Get count of permalinks		$meta_key = $importer_name . '_' . $bid . '_permalink';		$sql = $wpdb->prepare( "SELECT COUNT( post_id ) AS cnt FROM $wpdb->postmeta WHERE meta_key = '%s'", $meta_key );		$result = $wpdb->get_results( $sql );		if ( !empty( $result ) )			$count = intval( $result[0]->cnt );		// unset to save memory		unset( $results );		return $count;	}	/**	 * Set array with imported comments from WordPress database	 *	 * @param string $bid	 * @return array	 */	function get_imported_comments( $bid ) {		global $wpdb;		$hashtable = array();		$limit = 100;		$offset = 0;		// Grab all comments in chunks		do {			$sql = $wpdb->prepare( "SELECT comment_ID, comment_agent FROM $wpdb->comments LIMIT %d,%d", $offset, $limit );			$results = $wpdb->get_results( $sql );			// Increment offset			$offset = ( $limit + $offset );			if ( !empty( $results ) ) {				foreach ( $results as $r ) {					// Explode comment_agent key					list ( $ca_bid, $source_comment_id ) = explode( '-', $r->comment_agent );					$source_comment_id = intval( $source_comment_id );					// Check if this comment came from this blog					if ( $bid == $ca_bid ) {						$hashtable[$source_comment_id] = intval( $r->comment_ID );					}				}			}		} while ( count( $results ) == $limit );		// unset to save memory		unset( $results, $r );		return $hashtable;	}	function set_blog( $blog_id ) {		if ( is_numeric( $blog_id ) ) {			$blog_id = (int) $blog_id;		} else {			$blog = 'http://' . preg_replace( '#^https?://#', '', $blog_id );			if ( ( !$parsed = parse_url( $blog ) ) || empty( $parsed['host'] ) ) {				fwrite( STDERR, "Error: can not determine blog_id from $blog_id\n" );				exit();			}			if ( empty( $parsed['path'] ) )				$parsed['path'] = '/';			if ( !$blog = get_blog_info( $parsed['host'], $parsed['path'] ) ) {				fwrite( STDERR, "Error: Could not find blog\n" );				exit();			}			$blog_id = (int) $blog->blog_id;			// Restore global $current_blog			global $current_blog;			$current_blog = $blog;		}		if ( function_exists( 'is_multisite' ) ) {			if ( is_multisite() )				switch_to_blog( $blog_id );		}		return $blog_id;	}	function set_user( $user_id ) {		if ( is_numeric( $user_id ) ) {			$user_id = (int) $user_id;		} else {			$user_id = (int) username_exists( $user_id );		}		if ( !$user_id || !wp_set_current_user( $user_id ) ) {			fwrite( STDERR, "Error: can not find user\n" );			exit();		}		return $user_id;	}	/**	 * Sort by strlen, longest string first	 *	 * @param string $a	 * @param string $b	 * @return int	 */	function cmpr_strlen( $a, $b ) {		return strlen( $b ) - strlen( $a );	}	/**	 * GET URL	 *	 * @param string $url	 * @param string $username	 * @param string $password	 * @param bool $head	 * @return array	 */	function get_page( $url, $username = '', $password = '', $head = false ) {		// Increase the timeout		add_filter( 'http_request_timeout', array( &$this, 'bump_request_timeout' ) );		$headers = array();		$args = array();		if ( true === $head )			$args['method'] = 'HEAD';		if ( !empty( $username ) && !empty( $password ) )			$headers['Authorization'] = 'Basic ' . base64_encode( "$username:$password" );		$args['headers'] = $headers;		return wp_remote_request( $url, $args );	}	/**	 * Bump up the request timeout for http requests	 *	 * @param int $val	 * @return int	 */	function bump_request_timeout( $val ) {		return 60;	}	/**	 * Check if user has exceeded disk quota	 *	 * @return bool	 */	function is_user_over_quota() {		global $current_user, $current_blog;		if ( function_exists( 'upload_is_user_over_quota' ) ) {			if ( upload_is_user_over_quota( 1 ) ) {				echo "Sorry, you have used your upload quota.\n";				return true;			}		}		return false;	}	/**	 * Replace newlines, tabs, and multiple spaces with a single space	 *	 * @param string $string	 * @return string	 */	function min_whitespace( $string ) {		return preg_replace( '|[\r\n\t ]+|', ' ', $string );	}	/**	 * Reset global variables that grow out of control during imports	 *	 * @return void	 */	function stop_the_insanity() {		global $wpdb, $wp_actions;		// Or define( 'WP_IMPORTING', true );		$wpdb->queries = array();		// Reset $wp_actions to keep it from growing out of control		$wp_actions = array();	}}/** * Returns value of command line params. * Exits when a required param is not set. * * @param string $param * @param bool $required * @return mixed */function get_cli_args( $param, $required = false ) {	$args = $_SERVER['argv'];	$out = array();	$last_arg = null;	$return = null;	$il = sizeof( $args );	for ( $i = 1, $il; $i < $il; $i++ ) {		if ( (bool) preg_match( "/^--(.+)/", $args[$i], $match ) ) {			$parts = explode( "=", $match[1] );			$key = preg_replace( "/[^a-z0-9]+/", "", $parts[0] );			if ( isset( $parts[1] ) ) {				$out[$key] = $parts[1];			} else {				$out[$key] = true;			}			$last_arg = $key;		} else if ( (bool) preg_match( "/^-([a-zA-Z0-9]+)/", $args[$i], $match ) ) {			for ( $j = 0, $jl = strlen( $match[1] ); $j < $jl; $j++ ) {				$key = $match[1]{$j};				$out[$key] = true;			}			$last_arg = $key;		} else if ( $last_arg !== null ) {			$out[$last_arg] = $args[$i];		}	}	// Check array for specified param	if ( isset( $out[$param] ) ) {		// Set return value		$return = $out[$param];	}	// Check for missing required param	if ( !isset( $out[$param] ) && $required ) {		// Display message and exit		echo "\"$param\" parameter is required but was not specified\n";		exit();	}	return $return;}
<?phpif ( !class_exists('SimplePie') )	require_once (ABSPATH . WPINC . '/class-simplepie.php');class WP_Feed_Cache extends SimplePie_Cache {	/**	 * Don't call the constructor. Please.	 *	 * @access private	 */	function WP_Feed_Cache() {		trigger_error('Please call SimplePie_Cache::create() instead of the constructor', E_USER_ERROR);	}	/**	 * Create a new SimplePie_Cache object	 *	 * @static	 * @access public	 */	function create($location, $filename, $extension) {		return new WP_Feed_Cache_Transient($location, $filename, $extension);	}}class WP_Feed_Cache_Transient {	var $name;	var $mod_name;	var $lifetime = 43200; //Default lifetime in cache of 12 hours	function WP_Feed_Cache_Transient($location, $filename, $extension) {		$this->name = 'feed_' . $filename;		$this->mod_name = 'feed_mod_' . $filename;		$this->lifetime = apply_filters('wp_feed_cache_transient_lifetime', $this->lifetime, $filename);	}	function save($data) {		if ( is_a($data, 'SimplePie') )			$data = $data->data;		set_transient($this->name, $data, $this->lifetime);		set_transient($this->mod_name, time(), $this->lifetime);		return true;	}	function load() {		return get_transient($this->name);	}	function mtime() {		return get_transient($this->mod_name);	}	function touch() {		return set_transient($this->mod_name, time(), $this->lifetime);	}	function unlink() {		delete_transient($this->name);		delete_transient($this->mod_name);		return true;	}}class WP_SimplePie_File extends SimplePie_File {	function WP_SimplePie_File($url, $timeout = 10, $redirects = 5, $headers = null, $useragent = null, $force_fsockopen = false) {		$this->url = $url;		$this->timeout = $timeout;		$this->redirects = $redirects;		$this->headers = $headers;		$this->useragent = $useragent;		$this->method = SIMPLEPIE_FILE_SOURCE_REMOTE;		if ( preg_match('/^http(s)?:\/\//i', $url) ) {			$args = array( 'timeout' => $this->timeout, 'redirection' => $this->redirects);			if ( !empty($this->headers) )				$args['headers'] = $this->headers;			if ( SIMPLEPIE_USERAGENT != $this->useragent ) //Use default WP user agent unless custom has been specified				$args['user-agent'] = $this->useragent;			$res = wp_remote_request($url, $args);			if ( is_wp_error($res) ) {				$this->error = 'WP HTTP Error: ' . $res->get_error_message();				$this->success = false;			} else {				$this->headers = $res['headers'];				$this->body = $res['body'];				$this->status_code = $res['response']['code'];			}		} else {			if ( ! $this->body = file_get_contents($url) ) {				$this->error = 'file_get_contents could not read the file';				$this->success = false;			}		}	}}
<?php/** * Media settings administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can( 'manage_options' ) )	wp_die( __( 'You do not have sufficient permissions to manage options for this site.' ) );$title = __('Media Settings');$parent_file = 'options-general.php';add_contextual_help($current_screen,	'<p>' . __('You can set maximum sizes for images inserted into your written content; you can also insert an image as Full Size.') . '</p>' .	'<p>' . __('The Embed option allows you embed a video, image, or other media content into your content automatically by typing the URL (of the web page where the file lives) on its own line when you create your content.') . '</p>' .	'<p>' . __('Uploading Options gives you folder and path choices for storing your files in your installation&#8217;s directory.') . '</p>' .	'<p>' . __('You must click the Save Changes button at the bottom of the screen for new settings to take effect.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Settings_Media_SubPanel" target="_blank">Documentation on Media Settings</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');include('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><form action="options.php" method="post"><?php settings_fields('media'); ?><h3><?php _e('Image sizes') ?></h3><p><?php _e('The sizes listed below determine the maximum dimensions in pixels to use when inserting an image into the body of a post.'); ?></p><table class="form-table"><tr valign="top"><th scope="row"><?php _e('Thumbnail size') ?></th><td><label for="thumbnail_size_w"><?php _e('Width'); ?></label><input name="thumbnail_size_w" type="text" id="thumbnail_size_w" value="<?php form_option('thumbnail_size_w'); ?>" class="small-text" /><label for="thumbnail_size_h"><?php _e('Height'); ?></label><input name="thumbnail_size_h" type="text" id="thumbnail_size_h" value="<?php form_option('thumbnail_size_h'); ?>" class="small-text" /><br /><input name="thumbnail_crop" type="checkbox" id="thumbnail_crop" value="1" <?php checked('1', get_option('thumbnail_crop')); ?>/><label for="thumbnail_crop"><?php _e('Crop thumbnail to exact dimensions (normally thumbnails are proportional)'); ?></label></td></tr><tr valign="top"><th scope="row"><?php _e('Medium size') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Medium size'); ?></span></legend><label for="medium_size_w"><?php _e('Max Width'); ?></label><input name="medium_size_w" type="text" id="medium_size_w" value="<?php form_option('medium_size_w'); ?>" class="small-text" /><label for="medium_size_h"><?php _e('Max Height'); ?></label><input name="medium_size_h" type="text" id="medium_size_h" value="<?php form_option('medium_size_h'); ?>" class="small-text" /></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('Large size') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Large size'); ?></span></legend><label for="large_size_w"><?php _e('Max Width'); ?></label><input name="large_size_w" type="text" id="large_size_w" value="<?php form_option('large_size_w'); ?>" class="small-text" /><label for="large_size_h"><?php _e('Max Height'); ?></label><input name="large_size_h" type="text" id="large_size_h" value="<?php form_option('large_size_h'); ?>" class="small-text" /></fieldset></td></tr><?php do_settings_fields('media', 'default'); ?></table><h3><?php _e('Embeds') ?></h3><table class="form-table"><tr valign="top"><th scope="row"><?php _e('Auto-embeds'); ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Attempt to automatically embed all plain text URLs'); ?></span></legend><label for="embed_autourls"><input name="embed_autourls" type="checkbox" id="embed_autourls" value="1" <?php checked( '1', get_option('embed_autourls') ); ?>/> <?php _e('Attempt to automatically embed all plain text URLs'); ?></label></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('Maximum embed size') ?></th><td><label for="embed_size_w"><?php _e('Width'); ?></label><input name="embed_size_w" type="text" id="embed_size_w" value="<?php form_option('embed_size_w'); ?>" class="small-text" /><label for="embed_size_h"><?php _e('Height'); ?></label><input name="embed_size_h" type="text" id="embed_size_h" value="<?php form_option('embed_size_h'); ?>" class="small-text" /><?php if ( !empty($content_width) ) echo '<br />' . __("If the width value is left blank, embeds will default to the max width of your theme."); ?></td></tr><?php do_settings_fields('media', 'embeds'); ?></table><?php if ( !is_multisite() ) : ?><h3><?php _e('Uploading Files'); ?></h3><table class="form-table"><tr valign="top"><th scope="row"><label for="upload_path"><?php _e('Store uploads in this folder'); ?></label></th><td><input name="upload_path" type="text" id="upload_path" value="<?php echo esc_attr(get_option('upload_path')); ?>" class="regular-text code" /><span class="description"><?php _e('Default is <code>wp-content/uploads</code>'); ?></span></td></tr><tr valign="top"><th scope="row"><label for="upload_url_path"><?php _e('Full URL path to files'); ?></label></th><td><input name="upload_url_path" type="text" id="upload_url_path" value="<?php echo esc_attr( get_option('upload_url_path')); ?>" class="regular-text code" /><span class="description"><?php _e('Configuring this is optional. By default, it should be blank.'); ?></span></td></tr><tr><th scope="row" colspan="2" class="th-full"><label for="uploads_use_yearmonth_folders"><input name="uploads_use_yearmonth_folders" type="checkbox" id="uploads_use_yearmonth_folders" value="1"<?php checked('1', get_option('uploads_use_yearmonth_folders')); ?> /><?php _e('Organize my uploads into month- and year-based folders'); ?></label></th></tr><?php do_settings_fields('media', 'uploads'); ?></table><?php endif; ?><?php do_settings_sections('media'); ?><p class="submit">	<input type="submit" name="Submit" class="button-primary" value="<?php esc_attr_e('Save Changes') ?>" /></p></form></div><?php include('./admin-footer.php'); ?>
<?php/** * WordPress Administration Generic POST Handler. * * @package WordPress * @subpackage Administration *//** We are located in WordPress Administration Panels */define('WP_ADMIN', true);if ( defined('ABSPATH') )	require_once(ABSPATH . 'wp-load.php');else	require_once('../wp-load.php');require_once(ABSPATH . 'wp-admin/includes/admin.php');nocache_headers();do_action('admin_init');$action = 'admin_post';if ( !wp_validate_auth_cookie() )	$action .= '_nopriv';if ( !empty($_REQUEST['action']) )	$action .= '_' . $_REQUEST['action'];do_action($action);?>
<?php/** * Class for working with MO files * * @version $Id: mo.php 406 2010-02-07 11:10:24Z nbachiyski $ * @package pomo * @subpackage mo */require_once dirname(__FILE__) . '/translations.php';require_once dirname(__FILE__) . '/streams.php';if ( !class_exists( 'MO' ) ):class MO extends Gettext_Translations {	var $_nplurals = 2;	/**	 * Fills up with the entries from MO file $filename	 *	 * @param string $filename MO file to load	 */	function import_from_file($filename) {		$reader = new POMO_FileReader($filename);		if (!$reader->is_resource())			return false;		return $this->import_from_reader($reader);	}	function export_to_file($filename) {		$fh = fopen($filename, 'wb');		if ( !$fh ) return false;		$entries = array_filter($this->entries, create_function('$e', 'return !empty($e->translations);'));		ksort($entries);		$magic = 0x950412de;		$revision = 0;		$total = count($entries) + 1; // all the headers are one entry		$originals_lenghts_addr = 28;		$translations_lenghts_addr = $originals_lenghts_addr + 8 * $total;		$size_of_hash = 0;		$hash_addr = $translations_lenghts_addr + 8 * $total;		$current_addr = $hash_addr;		fwrite($fh, pack('V*', $magic, $revision, $total, $originals_lenghts_addr,			$translations_lenghts_addr, $size_of_hash, $hash_addr));		fseek($fh, $originals_lenghts_addr);		// headers' msgid is an empty string		fwrite($fh, pack('VV', 0, $current_addr));		$current_addr++;		$originals_table = chr(0);		foreach($entries as $entry) {			$originals_table .= $this->export_original($entry) . chr(0);			$length = strlen($this->export_original($entry));			fwrite($fh, pack('VV', $length, $current_addr));			$current_addr += $length + 1; // account for the NULL byte after		}		$exported_headers = $this->export_headers();		fwrite($fh, pack('VV', strlen($exported_headers), $current_addr));		$current_addr += strlen($exported_headers) + 1;		$translations_table = $exported_headers . chr(0);		foreach($entries as $entry) {			$translations_table .= $this->export_translations($entry) . chr(0);			$length = strlen($this->export_translations($entry));			fwrite($fh, pack('VV', $length, $current_addr));			$current_addr += $length + 1;		}		fwrite($fh, $originals_table);		fwrite($fh, $translations_table);		fclose($fh);	}	function export_original($entry) {		//TODO: warnings for control characters		$exported = $entry->singular;		if ($entry->is_plural) $exported .= chr(0).$entry->plural;		if (!is_null($entry->context)) $exported = $entry->context . chr(4) . $exported;		return $exported;	}	function export_translations($entry) {		//TODO: warnings for control characters		return implode(chr(0), $entry->translations);	}	function export_headers() {		$exported = '';		foreach($this->headers as $header => $value) {			$exported.= "$header: $value\n";		}		return $exported;	}	function get_byteorder($magic) {		// The magic is 0x950412de		// bug in PHP 5.0.2, see https://savannah.nongnu.org/bugs/?func=detailitem&item_id=10565		$magic_little = (int) - 1794895138;		$magic_little_64 = (int) 2500072158;		// 0xde120495		$magic_big = ((int) - 569244523) & 0xFFFFFFFF;		if ($magic_little == $magic || $magic_little_64 == $magic) {			return 'little';		} else if ($magic_big == $magic) {			return 'big';		} else {			return false;		}	}	function import_from_reader($reader) {		$endian_string = MO::get_byteorder($reader->readint32());		if (false === $endian_string) {			return false;		}		$reader->setEndian($endian_string);		$endian = ('big' == $endian_string)? 'N' : 'V';		$header = $reader->read(24);		if ($reader->strlen($header) != 24)			return false;		// parse header		$header = unpack("{$endian}revision/{$endian}total/{$endian}originals_lenghts_addr/{$endian}translations_lenghts_addr/{$endian}hash_length/{$endian}hash_addr", $header);		if (!is_array($header))			return false;		extract( $header );		// support revision 0 of MO format specs, only		if ($revision != 0)			return false;		// seek to data blocks		$reader->seekto($originals_lenghts_addr);		// read originals' indices		$originals_lengths_length = $translations_lenghts_addr - $originals_lenghts_addr;		if ( $originals_lengths_length != $total * 8 )			return false;		$originals = $reader->read($originals_lengths_length);		if ( $reader->strlen( $originals ) != $originals_lengths_length )			return false;		// read translations' indices		$translations_lenghts_length = $hash_addr - $translations_lenghts_addr;		if ( $translations_lenghts_length != $total * 8 )			return false;		$translations = $reader->read($translations_lenghts_length);		if ( $reader->strlen( $translations ) != $translations_lenghts_length )			return false;		// transform raw data into set of indices		$originals    = $reader->str_split( $originals, 8 );		$translations = $reader->str_split( $translations, 8 );		// skip hash table		$strings_addr = $hash_addr + $hash_length * 4;		$reader->seekto($strings_addr);		$strings = $reader->read_all();		$reader->close();		for ( $i = 0; $i < $total; $i++ ) {			$o = unpack( "{$endian}length/{$endian}pos", $originals[$i] );			$t = unpack( "{$endian}length/{$endian}pos", $translations[$i] );			if ( !$o || !$t ) return false;			// adjust offset due to reading strings to separate space before			$o['pos'] -= $strings_addr;			$t['pos'] -= $strings_addr;			$original    = $reader->substr( $strings, $o['pos'], $o['length'] );			$translation = $reader->substr( $strings, $t['pos'], $t['length'] );			if ('' === $original) {				$this->set_headers($this->make_headers($translation));			} else {				$entry = &$this->make_entry($original, $translation);				$this->entries[$entry->key()] = &$entry;			}		}		return true;	}	/**	 * Build a Translation_Entry from original string and translation strings,	 * found in a MO file	 *	 * @static	 * @param string $original original string to translate from MO file. Might contain	 * 	0x04 as context separator or 0x00 as singular/plural separator	 * @param string $translation translation string from MO file. Might contain	 * 	0x00 as a plural translations separator	 */	function &make_entry($original, $translation) {		$entry = new Translation_Entry();		// look for context		$parts = explode(chr(4), $original);		if (isset($parts[1])) {			$original = $parts[1];			$entry->context = $parts[0];		}		// look for plural original		$parts = explode(chr(0), $original);		$entry->singular = $parts[0];		if (isset($parts[1])) {			$entry->is_plural = true;			$entry->plural = $parts[1];		}		// plural translations are also separated by \0		$entry->translations = explode(chr(0), $translation);		return $entry;	}	function select_plural_form($count) {		return $this->gettext_select_plural_form($count);	}	function get_plural_forms_count() {		return $this->_nplurals;	}}endif;
<?php/** * Loads the correct template based on the visitor's url * @package WordPress */if ( defined('WP_USE_THEMES') && WP_USE_THEMES )	do_action('template_redirect');// Process feeds and trackbacks even if not using themes.if ( is_robots() ) :	do_action('do_robots');	return;elseif ( is_feed() ) :	do_feed();	return;elseif ( is_trackback() ) :	include( ABSPATH . 'wp-trackback.php' );	return;endif;if ( defined('WP_USE_THEMES') && WP_USE_THEMES ) :	$template = false;	if     ( is_404()            && $template = get_404_template()            ) :	elseif ( is_search()         && $template = get_search_template()         ) :	elseif ( is_tax()            && $template = get_taxonomy_template()       ) :	elseif ( is_front_page()     && $template = get_front_page_template()     ) :	elseif ( is_home()           && $template = get_home_template()           ) :	elseif ( is_attachment()     && $template = get_attachment_template()     ) :		remove_filter('the_content', 'prepend_attachment');	elseif ( is_single()         && $template = get_single_template()         ) :	elseif ( is_page()           && $template = get_page_template()           ) :	elseif ( is_category()       && $template = get_category_template()       ) :	elseif ( is_tag()            && $template = get_tag_template()            ) :	elseif ( is_author()         && $template = get_author_template()         ) :	elseif ( is_date()           && $template = get_date_template()           ) :	elseif ( is_archive()        && $template = get_archive_template()        ) :	elseif ( is_comments_popup() && $template = get_comments_popup_template() ) :	elseif ( is_paged()          && $template = get_paged_template()          ) :	else :		$template = get_index_template();	endif;	if ( $template = apply_filters( 'template_include', $template ) )		include( $template );	return;endif;?>
<?php/** * Edit attachments table for inclusion in administration panels. * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');if ( have_posts() ) { ?><table class="widefat fixed" cellspacing="0">	<thead>	<tr><?php print_column_headers('upload'); ?>	</tr>	</thead>	<tfoot>	<tr><?php print_column_headers('upload', false); ?>	</tr>	</tfoot>	<tbody id="the-list" class="list:post"><?phpadd_filter('the_title','esc_html');$alt = '';$posts_columns = get_column_headers('upload');$hidden = get_hidden_columns('upload');while ( have_posts() ) : the_post();if ( $is_trash && $post->post_status != 'trash' )	continue;elseif ( !$is_trash && $post->post_status == 'trash' )	continue;$alt = ( 'alternate' == $alt ) ? '' : 'alternate';global $current_user;$post_owner = ( $current_user->ID == $post->post_author ? 'self' : 'other' );$att_title = _draft_or_post_title();?>	<tr id='post-<?php echo $id; ?>' class='<?php echo trim( $alt . ' author-' . $post_owner . ' status-' . $post->post_status ); ?>' valign="top"><?phpforeach ($posts_columns as $column_name => $column_display_name ) {	$class = "class=\"$column_name column-$column_name\"";	$style = '';	if ( in_array($column_name, $hidden) )		$style = ' style="display:none;"';	$attributes = "$class$style";	switch($column_name) {	case 'cb':		?>		<th scope="row" class="check-column"><?php if ( current_user_can('edit_post', $post->ID) ) { ?><input type="checkbox" name="media[]" value="<?php the_ID(); ?>" /><?php } ?></th>		<?php		break;	case 'icon':		$attributes = 'class="column-icon media-icon"' . $style;		?>		<td <?php echo $attributes ?>><?php			if ( $thumb = wp_get_attachment_image( $post->ID, array(80, 60), true ) ) {				if ( $is_trash ) echo $thumb;				else {?>				<a href="<?php echo get_edit_post_link( $post->ID, true ); ?>" title="<?php echo esc_attr(sprintf(__('Edit &#8220;%s&#8221;'), $att_title)); ?>">					<?php echo $thumb; ?>				</a><?php			}			}		?></td>		<?php		// TODO		break;	case 'media':		?>		<td <?php echo $attributes ?>><strong><?php if ( $is_trash ) echo $att_title; else { ?><a href="<?php echo get_edit_post_link( $post->ID, true ); ?>" title="<?php echo esc_attr(sprintf(__('Edit &#8220;%s&#8221;'), $att_title)); ?>"><?php echo $att_title; ?></a><?php } ?></strong>		<p>		<?php		if ( preg_match( '/^.*?\.(\w+)$/', get_attached_file( $post->ID ), $matches ) )			echo esc_html( strtoupper( $matches[1] ) );		else			echo strtoupper( str_replace( 'image/', '', get_post_mime_type() ) );		?>		</p>		<?php		$actions = array();		if ( current_user_can('edit_post', $post->ID) && !$is_trash )			$actions['edit'] = '<a href="' . get_edit_post_link($post->ID, true) . '">' . __('Edit') . '</a>';		if ( current_user_can('delete_post', $post->ID) ) {			if ( $is_trash )				$actions['untrash'] = "<a class='submitdelete' href='" . wp_nonce_url("post.php?action=untrash&amp;post=$post->ID", 'untrash-attachment_' . $post->ID) . "'>" . __('Restore') . "</a>";			elseif ( EMPTY_TRASH_DAYS && MEDIA_TRASH )				$actions['trash'] = "<a class='submitdelete' href='" . wp_nonce_url("post.php?action=trash&amp;post=$post->ID", 'trash-attachment_' . $post->ID) . "'>" . __('Trash') . "</a>";			if ( $is_trash || !EMPTY_TRASH_DAYS || !MEDIA_TRASH ) {				$delete_ays = (!$is_trash && !MEDIA_TRASH) ? " onclick='return showNotice.warn();'" : '';				$actions['delete'] = "<a class='submitdelete'$delete_ays href='" . wp_nonce_url("post.php?action=delete&amp;post=$post->ID", 'delete-attachment_' . $post->ID) . "'>" . __('Delete Permanently') . "</a>";			}		}		if ( !$is_trash ) {			$title =_draft_or_post_title($post->post_parent);			$actions['view'] = '<a href="' . get_permalink($post->ID) . '" title="' . esc_attr(sprintf(__('View &#8220;%s&#8221;'), $title)) . '" rel="permalink">' . __('View') . '</a>';		}		$actions = apply_filters( 'media_row_actions', $actions, $post );		$action_count = count($actions);		$i = 0;		echo '<div class="row-actions">';		foreach ( $actions as $action => $link ) {			++$i;			( $i == $action_count ) ? $sep = '' : $sep = ' | ';			echo "<span class='$action'>$link$sep</span>";		}		echo '</div>';		?></td>		<?php		break;	case 'author':		?>		<td <?php echo $attributes ?>><?php the_author() ?></td>		<?php		break;	case 'tags':		?>		<td <?php echo $attributes ?>><?php		$tags = get_the_tags();		if ( !empty( $tags ) ) {			$out = array();			foreach ( $tags as $c )				$out[] = "<a href='edit.php?tag=$c->slug'> " . esc_html(sanitize_term_field('name', $c->name, $c->term_id, 'post_tag', 'display')) . "</a>";			echo join( ', ', $out );		} else {			_e('No Tags');		}		?></td>		<?php		break;	case 'desc':		?>		<td <?php echo $attributes ?>><?php echo has_excerpt() ? $post->post_excerpt : ''; ?></td>		<?php		break;	case 'date':		if ( '0000-00-00 00:00:00' == $post->post_date && 'date' == $column_name ) {			$t_time = $h_time = __('Unpublished');		} else {			$t_time = get_the_time(__('Y/m/d g:i:s A'));			$m_time = $post->post_date;			$time = get_post_time( 'G', true, $post, false );			if ( ( abs($t_diff = time() - $time) ) < 86400 ) {				if ( $t_diff < 0 )					$h_time = sprintf( __('%s from now'), human_time_diff( $time ) );				else					$h_time = sprintf( __('%s ago'), human_time_diff( $time ) );			} else {				$h_time = mysql2date(__('Y/m/d'), $m_time);			}		}		?>		<td <?php echo $attributes ?>><?php echo $h_time ?></td>		<?php		break;	case 'parent':		if ( $post->post_parent > 0 ) {			if ( get_post($post->post_parent) ) {				$title =_draft_or_post_title($post->post_parent);			}			?>			<td <?php echo $attributes ?>><strong><a href="<?php echo get_edit_post_link( $post->post_parent ); ?>"><?php echo $title ?></a></strong>, <?php echo get_the_time(__('Y/m/d')); ?></td>			<?php		} else {			?>			<td <?php echo $attributes ?>><?php _e('(Unattached)'); ?><br />			<a class="hide-if-no-js" onclick="findPosts.open('media[]','<?php echo $post->ID ?>');return false;" href="#the-list"><?php _e('Attach'); ?></a></td>			<?php		}		break;	case 'comments':		$attributes = 'class="comments column-comments num"' . $style;		?>		<td <?php echo $attributes ?>><div class="post-com-count-wrapper">		<?php		$left = get_pending_comments_num( $post->ID );		$pending_phrase = sprintf( __('%s pending'), number_format( $left ) );		if ( $left )			echo '<strong>';		comments_number("<a href='edit-comments.php?p=$id' title='$pending_phrase' class='post-com-count'><span class='comment-count'>" . /* translators: comment count link */ _x('0', 'comment count') . '</span></a>', "<a href='edit-comments.php?p=$id' title='$pending_phrase' class='post-com-count'><span class='comment-count'>" . /* translators: comment count link */ _x('1', 'comment count') . '</span></a>', "<a href='edit-comments.php?p=$id' title='$pending_phrase' class='post-com-count'><span class='comment-count'>" . /* translators: comment count link: % will be substituted by comment count */ _x('%', 'comment count') . '</span></a>');		if ( $left )			echo '</strong>';		?>		</div></td>		<?php		break;	case 'actions':		?>		<td <?php echo $attributes ?>>		<a href="media.php?action=edit&amp;attachment_id=<?php the_ID(); ?>" title="<?php echo esc_attr(sprintf(__('Edit &#8220;%s&#8221;'), $att_title)); ?>"><?php _e('Edit'); ?></a> |		<a href="<?php the_permalink(); ?>"><?php _e('Get permalink'); ?></a>		</td>		<?php		break;	default:		?>		<td <?php echo $attributes ?>><?php do_action('manage_media_custom_column', $column_name, $id); ?></td>		<?php		break;	}}?>	</tr><?php endwhile; ?>	</tbody></table><?php } else { ?><p><?php _e('No media attachments found.') ?></p><?php} // end if ( have_posts() )?>
<?php/** * Disable error reporting * * Set this to error_reporting( E_ALL ) or error_reporting( E_ALL | E_STRICT ) for debugging */error_reporting(0);/** Set ABSPATH for execution */define( 'ABSPATH', dirname(dirname(__FILE__)) . '/' );define( 'WPINC', 'wp-includes' );/** * @ignore */function __() {}/** * @ignore */function _x() {}/** * @ignore */function add_filter() {}/** * @ignore */function esc_attr() {}/** * @ignore */function apply_filters() {}/** * @ignore */function get_option() {}/** * @ignore */function is_lighttpd_before_150() {}/** * @ignore */function add_action() {}/** * @ignore */function do_action_ref_array() {}/** * @ignore */function get_bloginfo() {}/** * @ignore */function is_admin() {return true;}/** * @ignore */function site_url() {}/** * @ignore */function admin_url() {}/** * @ignore */function home_url() {}/** * @ignore */function wp_guess_url() {}function get_file($path) {	if ( function_exists('realpath') )		$path = realpath($path);	if ( ! $path || ! @is_file($path) )		return '';	return @file_get_contents($path);}$load = preg_replace( '/[^a-z0-9,_-]+/i', '', $_GET['load'] );$load = explode(',', $load);if ( empty($load) )	exit;require(ABSPATH . WPINC . '/script-loader.php');require(ABSPATH . WPINC . '/version.php');$compress = ( isset($_GET['c']) && $_GET['c'] );$force_gzip = ( $compress && 'gzip' == $_GET['c'] );$expires_offset = 31536000;$out = '';$wp_scripts = new WP_Scripts();wp_default_scripts($wp_scripts);foreach( $load as $handle ) {	if ( !array_key_exists($handle, $wp_scripts->registered) )		continue;	$path = ABSPATH . $wp_scripts->registered[$handle]->src;	$out .= get_file($path) . "\n";}header('Content-Type: application/x-javascript; charset=UTF-8');header('Expires: ' . gmdate( "D, d M Y H:i:s", time() + $expires_offset ) . ' GMT');header("Cache-Control: public, max-age=$expires_offset");if ( $compress && ! ini_get('zlib.output_compression') && 'ob_gzhandler' != ini_get('output_handler') && isset($_SERVER['HTTP_ACCEPT_ENCODING']) ) {	header('Vary: Accept-Encoding'); // Handle proxies	if ( false !== strpos( strtolower($_SERVER['HTTP_ACCEPT_ENCODING']), 'deflate') && function_exists('gzdeflate') && ! $force_gzip ) {		header('Content-Encoding: deflate');		$out = gzdeflate( $out, 3 );	} elseif ( false !== strpos( strtolower($_SERVER['HTTP_ACCEPT_ENCODING']), 'gzip') && function_exists('gzencode') ) {		header('Content-Encoding: gzip');		$out = gzencode( $out, 3 );	}}echo $out;exit;
<?php/** * WordPress Export Administration API * * @package WordPress * @subpackage Administration *//** * Version number for the export format. * * Bump this when something changes that might affect compatibility. * * @since unknown * @var string */define('WXR_VERSION', '1.0');/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $args */function export_wp( $args = array() ) {	global $wpdb, $post_ids, $post, $wp_taxonomies;	if ( ! is_array( $args ) )		$args = array( 'author' => $args );	$defaults = array( 'author' => null, 'taxonomy' => null, 'post_type' => null, 'post_status' => null, 'start_date' => null, 'end_date' => null );	$args = wp_parse_args( $args, $defaults );	extract($args);	do_action('export_wp');	if( strlen( $start_date ) > 4 && strlen( $end_date ) > 4 )		$filename = 'wordpress.' . $start_date . '.' . $end_date . '.xml';	else		$filename = 'wordpress.' . date( 'Y-m-d' ) . '.xml';	header( 'Content-Description: File Transfer' );	header( 'Content-Disposition: attachment; filename=' . $filename );	header( 'Content-Type: text/xml; charset=' . get_option( 'blog_charset' ), true );	if ( $post_type && $post_type != 'all' )		$where = $wpdb->prepare("WHERE post_type = %s ", $post_type);	else		$where = "WHERE post_type != 'revision' ";	if ( $author && $author != 'all' ) {		$author_id = (int) $author;		$where .= $wpdb->prepare( "AND post_author = %d ", $author_id );	}	if ( $start_date && $start_date != 'all' )		$where .= $wpdb->prepare( "AND post_date >= %s ", $start_date );	if ( $end_date && $end_date != 'all' )		$where .= $wpdb->prepare( "AND post_date < %s ", $end_date );	if ( $taxonomy && is_array( $taxonomy ) ) {		foreach ( $taxonomy as $term_id ) {			if ( $term_id != 'all' )				$where .= $wpdb->prepare( "AND ID IN (SELECT object_id FROM $wpdb->term_relationships WHERE term_taxonomy_id = %d) ", $term_id );		}	}	if ( $post_status && $post_status != 'all' )		$where .= $wpdb->prepare( "AND post_status = %s", $status );	// grab a snapshot of post IDs, just in case it changes during the export	$post_ids = $wpdb->get_col( "SELECT ID FROM $wpdb->posts $where ORDER BY post_date_gmt ASC" );	$categories = (array) get_categories( array( 'get' => 'all' ) );	$tags = (array) get_tags( array( 'get' => 'all' ) );	$custom_taxonomies = $wp_taxonomies;	unset( $custom_taxonomies['category'] );	unset( $custom_taxonomies['post_tag'] );	unset( $custom_taxonomies['link_category'] );	$custom_taxonomies = array_keys( $custom_taxonomies );	$terms = (array) get_terms( $custom_taxonomies, array( 'get' => 'all' ) );	/**	 * {@internal Missing Short Description}}	 *	 * @since unknown	 *	 * @param unknown_type $categories	 */	function wxr_missing_parents( $categories ) {		if ( ! is_array( $categories ) || empty( $categories ) )			return array();		foreach ( $categories as $category ){			$parents[$category->term_id] = $category->parent;		}		$parents = array_unique( array_diff( $parents, array_keys( $parents ) ) );		if ( $zero = array_search( '0', $parents ) )			unset( $parents[$zero] );		return $parents;	}	while ( $parents = wxr_missing_parents( $categories ) ) {		$found_parents = get_categories( array( 'include' => join( ', ', $parents) ) );		if ( is_array( $found_parents ) && count( $found_parents ) )			$categories = array_merge( $categories, $found_parents );		else			break;	}	// Put them in order to be inserted with no child going before its parent	$pass = 0;	$passes = 1000 + count( $categories );	while ( ( $cat = array_shift( $categories ) ) && ++$pass < $passes ) {		if ( $cat->parent == 0 || isset( $cats[$cat->parent] ) )			$cats[$cat->term_id] = $cat;		else			$categories[] = $cat;	}	unset( $categories );	/**	 * Place string in CDATA tag.	 *	 * @since unknown	 *	 * @param string $str String to place in XML CDATA tag.	 */	function wxr_cdata( $str ) {		if ( seems_utf8( $str ) == false )			$str = utf8_encode( $str );		// $str = ent2ncr(esc_html($str));		$str = "<![CDATA[$str" . ( ( substr( $str, -1 ) == ']' ) ? ' ' : '') . "]]>";		return $str;	}	/**	 * {@internal Missing Short Description}}	 *	 * @since unknown	 *	 * @return string Site URL.	 */	function wxr_site_url() {		global $current_site;		// mu: the base url		if ( isset( $current_site->domain ) )			return network_home_url();		// wp: the blog url		else			return get_bloginfo_rss( 'url' );	}	/**	 * {@internal Missing Short Description}}	 *	 * @since unknown	 *	 * @param object $c Category Object	 */	function wxr_cat_name( $c ) {		if ( empty( $c->name ) )			return;		echo '<wp:cat_name>' . wxr_cdata( $c->name ) . '</wp:cat_name>';	}	/**	 * {@internal Missing Short Description}}	 *	 * @since unknown	 *	 * @param object $c Category Object	 */	function wxr_category_description( $c ) {		if ( empty( $c->description ) )			return;		echo '<wp:category_description>' . wxr_cdata($c->description) . '</wp:category_description>';	}	/**	 * {@internal Missing Short Description}}	 *	 * @since unknown	 *	 * @param object $t Tag Object	 */	function wxr_tag_name( $t ) {		if ( empty( $t->name ) )			return;		echo '<wp:tag_name>' . wxr_cdata($t->name) . '</wp:tag_name>';	}	/**	 * {@internal Missing Short Description}}	 *	 * @since unknown	 *	 * @param object $t Tag Object	 */	function wxr_tag_description( $t ) {		if ( empty( $t->description ) )			return;		echo '<wp:tag_description>' . wxr_cdata($t->description) . '</wp:tag_description>';	}	/**	 * {@internal Missing Short Description}}	 *	 * @since unknown	 *	 * @param object $t Term Object	 */	function wxr_term_name( $t ) {		if ( empty( $t->name ) )			return;		echo '<wp:term_name>' . wxr_cdata($t->name) . '</wp:term_name>';	}	/**	 * {@internal Missing Short Description}}	 *	 * @since unknown	 *	 * @param object $t Term Object	 */	function wxr_term_description( $t ) {		if ( empty( $t->description ) )			return;		echo '<wp:term_description>' . wxr_cdata($t->description) . '</wp:term_description>';	}	/**	 * {@internal Missing Short Description}}	 *	 * @since unknown	 */	function wxr_post_taxonomy() {		global $post;		$the_list = '';		$filter = 'rss';		$taxonomies = get_object_taxonomies( 'post' );		$terms = wp_get_post_terms( $post->ID, $taxonomies );		foreach ( (array) $terms as $term ) {			$domain = ( 'post_tag' == $term->taxonomy ) ? 'tag' : $term->taxonomy;			$term_name = sanitize_term_field( 'name', $term->name, $term->term_id, $term->taxonomy, $filter );			// Back compat.			if ( 'category' == $term->taxonomy )				$the_list .= "\n\t\t<category><![CDATA[$term_name]]></category>\n";			elseif ( 'post_tag' == $term->taxonomy )				$the_list .= "\n\t\t<category domain=\"$domain\"><![CDATA[$term_name]]></category>\n";			// forwards compatibility as above			$the_list .= "\n\t\t<category domain=\"$domain\" nicename=\"{$term->slug}\"><![CDATA[$term_name]]></category>\n";		}		echo $the_list;	}	echo '<?xml version="1.0" encoding="' . get_bloginfo('charset') . '"?' . ">\n";	?><!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your blog. --><!-- It contains information about your blog's posts, comments, and categories. --><!-- You may use this file to transfer that content from one site to another. --><!-- This file is not intended to serve as a complete backup of your blog. --><!-- To import this information into a WordPress blog follow these steps. --><!-- 1. Log in to that blog as an administrator. --><!-- 2. Go to Tools: Import in the blog's admin panels (or Manage: Import in older versions of WordPress). --><!-- 3. Choose "WordPress" from the list. --><!-- 4. Upload this file using the form provided on that page. --><!-- 5. You will first be asked to map the authors in this export file to users --><!--    on the blog.  For each author, you may choose to map to an --><!--    existing user on the blog or to create a new user --><!-- 6. WordPress will then import each of the posts, comments, and categories --><!--    contained in this file into your blog --><?php the_generator( 'export' );?><rss version="2.0"	xmlns:excerpt="http://wordpress.org/export/<?php echo WXR_VERSION; ?>/excerpt/"	xmlns:content="http://purl.org/rss/1.0/modules/content/"	xmlns:wfw="http://wellformedweb.org/CommentAPI/"	xmlns:dc="http://purl.org/dc/elements/1.1/"	xmlns:wp="http://wordpress.org/export/<?php echo WXR_VERSION; ?>/"><channel>	<title><?php bloginfo_rss( 'name' ); ?></title>	<link><?php bloginfo_rss( 'url' ) ?></link>	<description><?php bloginfo_rss( 'description' ) ?></description>	<pubDate><?php echo mysql2date( 'D, d M Y H:i:s +0000', get_lastpostmodified( 'GMT' ), false ); ?></pubDate>	<generator>http://wordpress.org/?v=<?php bloginfo_rss( 'version' ); ?></generator>	<language><?php echo get_option( 'rss_language' ); ?></language>	<wp:wxr_version><?php echo WXR_VERSION; ?></wp:wxr_version>	<wp:base_site_url><?php echo wxr_site_url(); ?></wp:base_site_url>	<wp:base_blog_url><?php bloginfo_rss( 'url' ); ?></wp:base_blog_url>	<?php if ( $cats ) : foreach ( $cats as $c ) : ?>	<wp:category><wp:category_nicename><?php echo $c->slug; ?></wp:category_nicename><wp:category_parent><?php echo $c->parent ? $cats[$c->parent]->name : ''; ?></wp:category_parent><?php wxr_cat_name( $c ); ?><?php wxr_category_description( $c ); ?></wp:category>	<?php endforeach; endif; ?>	<?php if ( $tags ) : foreach ( $tags as $t ) : ?>	<wp:tag><wp:tag_slug><?php echo $t->slug; ?></wp:tag_slug><?php wxr_tag_name( $t ); ?><?php wxr_tag_description( $t ); ?></wp:tag>	<?php endforeach; endif; ?>	<?php if ( $terms ) : foreach ( $terms as $t ) : ?>	<wp:term><wp:term_taxonomy><?php echo $t->taxonomy; ?></wp:term_taxonomy><wp:term_slug><?php echo $t->slug; ?></wp:term_slug><wp:term_parent><?php echo $t->parent ? $custom_taxonomies[$t->parent]->name : ''; ?></wp:term_parent><?php wxr_term_name( $t ); ?><?php wxr_term_description( $t ); ?></wp:term>	<?php endforeach; endif; ?>	<?php do_action( 'rss2_head' ); ?>	<?php if ( $post_ids ) {	global $wp_query;	$wp_query->in_the_loop = true;  // Fake being in the loop.	// fetch 20 posts at a time rather than loading the entire table into memory	while ( $next_posts = array_splice( $post_ids, 0, 20 ) ) {	$where = "WHERE ID IN (" . join( ',', $next_posts ) . ")";	$posts = $wpdb->get_results( "SELECT * FROM $wpdb->posts $where ORDER BY post_date_gmt ASC" );	// Begin Loop	foreach ($posts as $post) {	setup_postdata( $post );	$is_sticky = 0;	if ( is_sticky( $post->ID ) )		$is_sticky = 1;	?>	<item>		<title><?php echo apply_filters( 'the_title_rss', $post->post_title ); ?></title>		<link><?php the_permalink_rss() ?></link>		<pubDate><?php echo mysql2date( 'D, d M Y H:i:s +0000', get_post_time( 'Y-m-d H:i:s', true ), false ); ?></pubDate>		<dc:creator><?php echo wxr_cdata( get_the_author() ); ?></dc:creator>		<?php wxr_post_taxonomy() ?>		<guid isPermaLink="false"><?php esc_url( the_guid() ); ?></guid>		<description></description>		<content:encoded><?php echo wxr_cdata( apply_filters( 'the_content_export', $post->post_content ) ); ?></content:encoded>		<excerpt:encoded><?php echo wxr_cdata( apply_filters( 'the_excerpt_export', $post->post_excerpt ) ); ?></excerpt:encoded>		<wp:post_id><?php echo $post->ID; ?></wp:post_id>		<wp:post_date><?php echo $post->post_date; ?></wp:post_date>		<wp:post_date_gmt><?php echo $post->post_date_gmt; ?></wp:post_date_gmt>		<wp:comment_status><?php echo $post->comment_status; ?></wp:comment_status>		<wp:ping_status><?php echo $post->ping_status; ?></wp:ping_status>		<wp:post_name><?php echo $post->post_name; ?></wp:post_name>		<wp:status><?php echo $post->post_status; ?></wp:status>		<wp:post_parent><?php echo $post->post_parent; ?></wp:post_parent>		<wp:menu_order><?php echo $post->menu_order; ?></wp:menu_order>		<wp:post_type><?php echo $post->post_type; ?></wp:post_type>		<wp:post_password><?php echo $post->post_password; ?></wp:post_password>		<wp:is_sticky><?php echo $is_sticky; ?></wp:is_sticky>		<?php		if ( $post->post_type == 'attachment' ) { ?>		<wp:attachment_url><?php echo wp_get_attachment_url( $post->ID ); ?></wp:attachment_url>		<?php } ?>		<?php		$postmeta = $wpdb->get_results( $wpdb->prepare( "SELECT * FROM $wpdb->postmeta WHERE post_id = %d", $post->ID ) );		if ( $postmeta ) {		?>		<?php foreach( $postmeta as $meta ) { ?>		<wp:postmeta>		<wp:meta_key><?php echo $meta->meta_key; ?></wp:meta_key>		<wp:meta_value><?php echo wxr_cdata( $meta->meta_value ); ?></wp:meta_value>		</wp:postmeta>		<?php } ?>		<?php } ?>		<?php		$comments = $wpdb->get_results( $wpdb->prepare( "SELECT * FROM $wpdb->comments WHERE comment_post_ID = %d", $post->ID ) );		if ( $comments ) { foreach ( $comments as $c ) { ?>		<wp:comment>		<wp:comment_id><?php echo $c->comment_ID; ?></wp:comment_id>		<wp:comment_author><?php echo wxr_cdata( $c->comment_author ); ?></wp:comment_author>		<wp:comment_author_email><?php echo $c->comment_author_email; ?></wp:comment_author_email>		<wp:comment_author_url><?php echo esc_url_raw( $c->comment_author_url ); ?></wp:comment_author_url>		<wp:comment_author_IP><?php echo $c->comment_author_IP; ?></wp:comment_author_IP>		<wp:comment_date><?php echo $c->comment_date; ?></wp:comment_date>		<wp:comment_date_gmt><?php echo $c->comment_date_gmt; ?></wp:comment_date_gmt>		<wp:comment_content><?php echo wxr_cdata( $c->comment_content ) ?></wp:comment_content>		<wp:comment_approved><?php echo $c->comment_approved; ?></wp:comment_approved>		<wp:comment_type><?php echo $c->comment_type; ?></wp:comment_type>		<wp:comment_parent><?php echo $c->comment_parent; ?></wp:comment_parent>		<wp:comment_user_id><?php echo $c->user_id; ?></wp:comment_user_id>		</wp:comment>		<?php } } ?>	</item>	<?php	}	}} ?></channel></rss><?php}?>
<?php/** * Classes, which help reading streams of data from files. * Based on the classes from Danilo Segan <danilo@kvota.net> * * @version $Id: streams.php 406 2010-02-07 11:10:24Z nbachiyski $ * @package pomo * @subpackage streams */if ( !class_exists( 'POMO_Reader' ) ):class POMO_Reader {	var $endian = 'little';	var $_post = '';	function POMO_Reader() {		$this->is_overloaded = ((ini_get("mbstring.func_overload") & 2) != 0) && function_exists('mb_substr');		$this->_pos = 0;	}	/**	 * Sets the endianness of the file.	 *	 * @param $endian string 'big' or 'little'	 */	function setEndian($endian) {		$this->endian = $endian;	}	/**	 * Reads a 32bit Integer from the Stream	 *	 * @return mixed The integer, corresponding to the next 32 bits from	 * 	the stream of false if there are not enough bytes or on error	 */	function readint32() {		$bytes = $this->read(4);		if (4 != $this->strlen($bytes))			return false;		$endian_letter = ('big' == $this->endian)? 'N' : 'V';		$int = unpack($endian_letter, $bytes);		return array_shift($int);	}	/**	 * Reads an array of 32-bit Integers from the Stream	 *	 * @param integer count How many elements should be read	 * @return mixed Array of integers or false if there isn't	 * 	enough data or on error	 */	function readint32array($count) {		$bytes = $this->read(4 * $count);		if (4*$count != $this->strlen($bytes))			return false;		$endian_letter = ('big' == $this->endian)? 'N' : 'V';		return unpack($endian_letter.$count, $bytes);	}	function substr($string, $start, $length) {		if ($this->is_overloaded) {			return mb_substr($string, $start, $length, 'ascii');		} else {			return substr($string, $start, $length);		}	}	function strlen($string) {		if ($this->is_overloaded) {			return mb_strlen($string, 'ascii');		} else {			return strlen($string);		}	}	function str_split($string, $chunk_size) {		if (!function_exists('str_split')) {			$length = $this->strlen($string);			$out = array();			for ($i = 0; $i < $length; $i += $chunk_size)				$out[] = $this->substr($string, $i, $chunk_size);			return $out;		} else {			return str_split( $string, $chunk_size );		}	}	function pos() {		return $this->_pos;	}	function is_resource() {		return true;	}	function close() {		return true;	}}endif;if ( !class_exists( 'POMO_FileReader' ) ):class POMO_FileReader extends POMO_Reader {	function POMO_FileReader($filename) {		parent::POMO_Reader();		$this->_f = fopen($filename, 'r');	}	function read($bytes) {		return fread($this->_f, $bytes);	}	function seekto($pos) {		if ( -1 == fseek($this->_f, $pos, SEEK_SET)) {			return false;		}		$this->_pos = $pos;		return true;	}	function is_resource() {		return is_resource($this->_f);	}	function feof() {		return feof($this->_f);	}	function close() {		return fclose($this->_f);	}	function read_all() {		$all = '';		while ( !$this->feof() )			$all .= $this->read(4096);		return $all;	}}endif;if ( !class_exists( 'POMO_StringReader' ) ):/** * Provides file-like methods for manipulating a string instead * of a physical file. */class POMO_StringReader extends POMO_Reader {	var $_str = '';	function POMO_StringReader($str = '') {		parent::POMO_Reader();		$this->_str = $str;		$this->_pos = 0;	}	function read($bytes) {		$data = $this->substr($this->_str, $this->_pos, $bytes);		$this->_pos += $bytes;		if ($this->strlen($this->_str) < $this->_pos) $this->_pos = $this->strlen($this->_str);		return $data;	}	function seekto($pos) {		$this->_pos = $pos;		if ($this->strlen($this->_str) < $this->_pos) $this->_pos = $this->strlen($this->_str);		return $this->_pos;	}	function length() {		return $this->strlen($this->_str);	}	function read_all() {		return $this->substr($this->_str, $this->_pos, $this->strlen($this->_str));	}}endif;if ( !class_exists( 'POMO_CachedFileReader' ) ):/** * Reads the contents of the file in the beginning. */class POMO_CachedFileReader extends POMO_StringReader {	function POMO_CachedFileReader($filename) {		parent::POMO_StringReader();		$this->_str = file_get_contents($filename);		if (false === $this->_str)			return false;		$this->_pos = 0;	}}endif;if ( !class_exists( 'POMO_CachedIntFileReader' ) ):/** * Reads the contents of the file in the beginning. */class POMO_CachedIntFileReader extends POMO_CachedFileReader {	function POMO_CachedIntFileReader($filename) {		parent::POMO_CachedFileReader($filename);	}}endif;
<?php/** * A simple set of functions to check our version 1.0 update service. * * @package WordPress * @since 2.3.0 *//** * Check WordPress version against the newest version. * * The WordPress version, PHP version, and Locale is sent. Checks against the * WordPress server at api.wordpress.org server. Will only check if WordPress * isn't installing. * * @package WordPress * @since 2.3.0 * @uses $wp_version Used to check against the newest WordPress version. * * @return mixed Returns null if update is unsupported. Returns false if check is too soon. */function wp_version_check() {	if ( defined('WP_INSTALLING') )		return;	global $wp_version, $wpdb, $wp_local_package;	$php_version = phpversion();	$current = get_site_transient( 'update_core' );	if ( ! is_object($current) ) {		$current = new stdClass;		$current->updates = array();		$current->version_checked = $wp_version;	}	$locale = apply_filters( 'core_version_check_locale', get_locale() );	// Update last_checked for current to prevent multiple blocking requests if request hangs	$current->last_checked = time();	set_site_transient( 'update_core', $current );	if ( method_exists( $wpdb, 'db_version' ) )		$mysql_version = preg_replace('/[^0-9.].*/', '', $wpdb->db_version());	else		$mysql_version = 'N/A';	$num_blogs = 1;	$wp_install = home_url( '/' );	$multisite_enabled = 0;	$user_count = count_users( );	if ( is_multisite( ) ) {		$num_blogs = get_blog_count( );		$wp_install = network_site_url( );		$multisite_enabled = 1;	}	$local_package = isset( $wp_local_package )? $wp_local_package : '';	$url = "http://api.wordpress.org/core/version-check/1.5/?version=$wp_version&php=$php_version&locale=$locale&mysql=$mysql_version&local_package=$local_package&blogs=$num_blogs&users={$user_count['total_users']}&multisite_enabled=$multisite_enabled";	$options = array(		'timeout' => ( ( defined('DOING_CRON') && DOING_CRON ) ? 30 : 3 ),		'user-agent' => 'WordPress/' . $wp_version . '; ' . home_url( '/' ),		'headers' => array(			'wp_install' => $wp_install,			'wp_blog' => home_url( '/' )		)	);	$response = wp_remote_get($url, $options);	if ( is_wp_error( $response ) )		return false;	if ( 200 != $response['response']['code'] )		return false;	$body = trim( $response['body'] );	$body = str_replace(array("\r\n", "\r"), "\n", $body);	$new_options = array();	foreach ( explode( "\n\n", $body ) as $entry ) {		$returns = explode("\n", $entry);		$new_option = new stdClass();		$new_option->response = esc_attr( $returns[0] );		if ( isset( $returns[1] ) )			$new_option->url = esc_url( $returns[1] );		if ( isset( $returns[2] ) )			$new_option->package = esc_url( $returns[2] );		if ( isset( $returns[3] ) )			$new_option->current = esc_attr( $returns[3] );		if ( isset( $returns[4] ) )			$new_option->locale = esc_attr( $returns[4] );		if ( isset( $returns[5] ) )			$new_option->php_version = esc_attr( $returns[5] );		if ( isset( $returns[6] ) )			$new_option->mysql_version = esc_attr( $returns[6] );		$new_options[] = $new_option;	}	$updates = new stdClass();	$updates->updates = $new_options;	$updates->last_checked = time();	$updates->version_checked = $wp_version;	set_site_transient( 'update_core',  $updates);}/** * Check plugin versions against the latest versions hosted on WordPress.org. * * The WordPress version, PHP version, and Locale is sent along with a list of * all plugins installed. Checks against the WordPress server at * api.wordpress.org. Will only check if WordPress isn't installing. * * @package WordPress * @since 2.3.0 * @uses $wp_version Used to notidy the WordPress version. * * @return mixed Returns null if update is unsupported. Returns false if check is too soon. */function wp_update_plugins() {	global $wp_version;	if ( defined('WP_INSTALLING') )		return false;	// If running blog-side, bail unless we've not checked in the last 12 hours	if ( !function_exists( 'get_plugins' ) )		require_once( ABSPATH . 'wp-admin/includes/plugin.php' );	$plugins = get_plugins();	$active  = get_option( 'active_plugins', array() );	$current = get_site_transient( 'update_plugins' );	if ( ! is_object($current) )		$current = new stdClass;	$new_option = new stdClass;	$new_option->last_checked = time();	$timeout = 'load-plugins.php' == current_filter() ? 3600 : 43200; //Check for updated every 60 minutes if hitting the themes page, Else, check every 12 hours	$time_not_changed = isset( $current->last_checked ) && $timeout > ( time() - $current->last_checked );	$plugin_changed = false;	foreach ( $plugins as $file => $p ) {		$new_option->checked[ $file ] = $p['Version'];		if ( !isset( $current->checked[ $file ] ) || strval($current->checked[ $file ]) !== strval($p['Version']) )			$plugin_changed = true;	}	if ( isset ( $current->response ) && is_array( $current->response ) ) {		foreach ( $current->response as $plugin_file => $update_details ) {			if ( ! isset($plugins[ $plugin_file ]) ) {				$plugin_changed = true;				break;			}		}	}	// Bail if we've checked in the last 12 hours and if nothing has changed	if ( $time_not_changed && !$plugin_changed )		return false;	// Update last_checked for current to prevent multiple blocking requests if request hangs	$current->last_checked = time();	set_site_transient( 'update_plugins', $current );	$to_send = (object) compact('plugins', 'active');	$options = array(		'timeout' => ( ( defined('DOING_CRON') && DOING_CRON ) ? 30 : 3),		'body' => array( 'plugins' => serialize( $to_send ) ),		'user-agent' => 'WordPress/' . $wp_version . '; ' . get_bloginfo( 'url' )	);	$raw_response = wp_remote_post('http://api.wordpress.org/plugins/update-check/1.0/', $options);	if ( is_wp_error( $raw_response ) )		return false;	if ( 200 != $raw_response['response']['code'] )		return false;	$response = unserialize( $raw_response['body'] );	if ( false !== $response )		$new_option->response = $response;	else		$new_option->response = array();	set_site_transient( 'update_plugins', $new_option );}/** * Check theme versions against the latest versions hosted on WordPress.org. * * A list of all themes installed in sent to WP. Checks against the * WordPress server at api.wordpress.org. Will only check if WordPress isn't * installing. * * @package WordPress * @since 2.7.0 * @uses $wp_version Used to notidy the WordPress version. * * @return mixed Returns null if update is unsupported. Returns false if check is too soon. */function wp_update_themes( ) {	global $wp_version;	if ( defined( 'WP_INSTALLING' ) )		return false;	if ( !function_exists( 'get_themes' ) )		require_once( ABSPATH . 'wp-includes/theme.php' );	$installed_themes = get_themes( );	$current_theme = get_site_transient( 'update_themes' );	if ( ! is_object($current_theme) )		$current_theme = new stdClass;	$new_option = new stdClass;	$new_option->last_checked = time( );	$timeout = 'load-themes.php' == current_filter() ? 3600 : 43200; //Check for updated every 60 minutes if hitting the themes page, Else, check every 12 hours	$time_not_changed = isset( $current_theme->last_checked ) && $timeout > ( time( ) - $current_theme->last_checked );	$themes = array();	$checked = array();	$themes['current_theme'] = (array) $current_theme;	foreach ( (array) $installed_themes as $theme_title => $theme ) {		$themes[$theme['Stylesheet']] = array();		$checked[$theme['Stylesheet']] = $theme['Version'];		foreach ( (array) $theme as $key => $value )			$themes[$theme['Stylesheet']][$key] = $value;	}	$theme_changed = false;	foreach ( $checked as $slug => $v ) {		$new_option->checked[ $slug ] = $v;		if ( !isset( $current_theme->checked[ $slug ] ) || strval($current_theme->checked[ $slug ]) !== strval($v) )			$theme_changed = true;	}	if ( isset ( $current_theme->response ) && is_array( $current_theme->response ) ) {		foreach ( $current_theme->response as $slug => $update_details ) {			if ( ! isset($checked[ $slug ]) ) {				$theme_changed = true;				break;			}		}	}	if ( $time_not_changed && !$theme_changed )		return false;	// Update last_checked for current to prevent multiple blocking requests if request hangs	$current_theme->last_checked = time();	set_site_transient( 'update_themes', $current_theme );	$current_theme->template = get_option( 'template' );	$options = array(		'timeout' => ( ( defined('DOING_CRON') && DOING_CRON ) ? 30 : 3),		'body'			=> array( 'themes' => serialize( $themes ) ),		'user-agent'	=> 'WordPress/' . $wp_version . '; ' . get_bloginfo( 'url' )	);	$raw_response = wp_remote_post( 'http://api.wordpress.org/themes/update-check/1.0/', $options );	if ( is_wp_error( $raw_response ) )		return false;	if ( 200 != $raw_response['response']['code'] )		return false;	$response = unserialize( $raw_response['body'] );	if ( $response ) {		$new_option->checked = $checked;		$new_option->response = $response;	}	set_site_transient( 'update_themes', $new_option );}function _maybe_update_core() {	global $wp_version;	$current = get_site_transient( 'update_core' );	if ( isset( $current->last_checked ) &&		43200 > ( time() - $current->last_checked ) &&		isset( $current->version_checked ) &&		$current->version_checked == $wp_version )		return;	wp_version_check();}/** * Check the last time plugins were run before checking plugin versions. * * This might have been backported to WordPress 2.6.1 for performance reasons. * This is used for the wp-admin to check only so often instead of every page * load. * * @since 2.7.0 * @access private */function _maybe_update_plugins() {	$current = get_site_transient( 'update_plugins' );	if ( isset( $current->last_checked ) && 43200 > ( time() - $current->last_checked ) )		return;	wp_update_plugins();}/** * Check themes versions only after a duration of time. * * This is for performance reasons to make sure that on the theme version * checker is not run on every page load. * * @since 2.7.0 * @access private */function _maybe_update_themes( ) {	$current = get_site_transient( 'update_themes' );	if ( isset( $current->last_checked ) && 43200 > ( time( ) - $current->last_checked ) )		return;	wp_update_themes();}add_action( 'admin_init', '_maybe_update_core' );add_action( 'wp_version_check', 'wp_version_check' );add_action( 'load-plugins.php', 'wp_update_plugins' );add_action( 'load-update.php', 'wp_update_plugins' );add_action( 'load-update-core.php', 'wp_update_plugins' );add_action( 'admin_init', '_maybe_update_plugins' );add_action( 'wp_update_plugins', 'wp_update_plugins' );add_action( 'load-themes.php', 'wp_update_themes' );add_action( 'load-update.php', 'wp_update_themes' );add_action( 'load-update-core.php', 'wp_update_themes' );add_action( 'admin_init', '_maybe_update_themes' );add_action( 'wp_update_themes', 'wp_update_themes' );if ( !wp_next_scheduled('wp_version_check') && !defined('WP_INSTALLING') )	wp_schedule_event(time(), 'twicedaily', 'wp_version_check');if ( !wp_next_scheduled('wp_update_plugins') && !defined('WP_INSTALLING') )	wp_schedule_event(time(), 'twicedaily', 'wp_update_plugins');if ( !wp_next_scheduled('wp_update_themes') && !defined('WP_INSTALLING') )	wp_schedule_event(time(), 'twicedaily', 'wp_update_themes');?>
