<?php/** * Edit plugin editor administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( !current_user_can('edit_plugins') )	wp_die( __('You do not have sufficient permissions to edit plugins for this site.') );$title = __("Edit Plugins");$parent_file = 'plugins.php';wp_reset_vars(array('action', 'redirect', 'profile', 'error', 'warning', 'a', 'file', 'plugin'));wp_admin_css( 'theme-editor' );$plugins = get_plugins();if ( empty($plugins) )	wp_die( __('There are no plugins installed on this site.') );if ( isset($_REQUEST['file']) )	$plugin = stripslashes($_REQUEST['file']);if ( empty($plugin) ) {	$plugin = array_keys($plugins);	$plugin = $plugin[0];}$plugin_files = get_plugin_files($plugin);if ( empty($file) )	$file = $plugin_files[0];else	$file = stripslashes($file);$file = validate_file_to_edit($file, $plugin_files);$real_file = WP_PLUGIN_DIR . '/' . $file;$scrollto = isset($_REQUEST['scrollto']) ? (int) $_REQUEST['scrollto'] : 0;switch ( $action ) {case 'update':	check_admin_referer('edit-plugin_' . $file);	$newcontent = stripslashes($_POST['newcontent']);	if ( is_writeable($real_file) ) {		$f = fopen($real_file, 'w+');		fwrite($f, $newcontent);		fclose($f);		$network_wide = is_plugin_active_for_network( $file );		// Deactivate so we can test it.		if ( is_plugin_active($file) || isset($_POST['phperror']) ) {			if ( is_plugin_active($file) )				deactivate_plugins($file, true);			update_option('recently_activated', array($file => time()) + (array)get_option('recently_activated'));			wp_redirect(add_query_arg('_wpnonce', wp_create_nonce('edit-plugin-test_' . $file), "plugin-editor.php?file=$file&liveupdate=1&scrollto=$scrollto&networkwide=" . $network_wide));			exit;		}		wp_redirect("plugin-editor.php?file=$file&a=te&scrollto=$scrollto");	} else {		wp_redirect("plugin-editor.php?file=$file&scrollto=$scrollto");	}	exit;break;default:	if ( isset($_GET['liveupdate']) ) {		check_admin_referer('edit-plugin-test_' . $file);		$error = validate_plugin($file);		if ( is_wp_error($error) )			wp_die( $error );		if ( ! is_plugin_active($file) )			activate_plugin($file, "plugin-editor.php?file=$file&phperror=1", ! empty( $_GET['networkwide'] ) ); // we'll override this later if the plugin can be included without fatal error		wp_redirect("plugin-editor.php?file=$file&a=te&scrollto=$scrollto");		exit;	}	// List of allowable extensions	$editable_extensions = array('php', 'txt', 'text', 'js', 'css', 'html', 'htm', 'xml', 'inc', 'include');	$editable_extensions = (array) apply_filters('editable_extensions', $editable_extensions);	if ( ! is_file($real_file) ) {		wp_die(sprintf('<p>%s</p>', __('No such file exists! Double check the name and try again.')));	} else {		// Get the extension of the file		if ( preg_match('/\.([^.]+)$/', $real_file, $matches) ) {			$ext = strtolower($matches[1]);			// If extension is not in the acceptable list, skip it			if ( !in_array( $ext, $editable_extensions) )				wp_die(sprintf('<p>%s</p>', __('Files of this type are not editable.')));		}	}	add_contextual_help($current_screen,		'<p>' . __('You can use the editor to make changes to any of your plugins&#8217; individual PHP files. Be aware that if you make changes, plugins updates will overwrite your customizations.') . '</p>' .		'<p>' . __('Choose a plugin to edit from the menu in the upper right and click the Select button. Click once on any file name to load it in the editor, and make your changes. Don&#8217;t forget to save your changes (Update File) when you&#8217;re finished.') . '</p>' .		'<p>' . __('The Documentation menu below the editor lists the PHP functions recognized in the plugin file. Clicking Lookup takes you to a web page about that particular function.') . '</p>' .		'<p>' . __('If you want to make changes but don&#8217;t want them to be overwritten when the plugin is updated, you may be ready to think about writing your own plugin. For information on how to edit a plugin or start from scratch, check out the links below.') . '</p>' .		'<p><strong>' . __('For more information:') . '</strong></p>' .		'<p>' . __('<a href="http://codex.wordpress.org/Plugins_Editor_SubPanel" target="_blank">Documentation on Editing Plugins</a>') . '</p>' .		'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>'	);	require_once('./admin-header.php');	update_recently_edited(WP_PLUGIN_DIR . '/' . $file);	$content = file_get_contents( $real_file );	if ( '.php' == substr( $real_file, strrpos( $real_file, '.' ) ) ) {		$functions = wp_doc_link_parse( $content );		if ( !empty($functions) ) {			$docs_select = '<select name="docs-list" id="docs-list">';			$docs_select .= '<option value="">' . __( 'Function Name&hellip;' ) . '</option>';			foreach ( $functions as $function) {				$docs_select .= '<option value="' . esc_attr( $function ) . '">' . esc_html( $function ) . '()</option>';			}			$docs_select .= '</select>';		}	}	$content = htmlspecialchars( $content );	?><?php if (isset($_GET['a'])) : ?> <div id="message" class="updated"><p><?php _e('File edited successfully.') ?></p></div><?php elseif (isset($_GET['phperror'])) : ?> <div id="message" class="updated"><p><?php _e('This plugin has been deactivated because your changes resulted in a <strong>fatal error</strong>.') ?></p>	<?php		if ( wp_verify_nonce($_GET['_error_nonce'], 'plugin-activation-error_' . $file) ) { ?>	<iframe style="border:0" width="100%" height="70px" src="<?php bloginfo('wpurl'); ?>/wp-admin/plugins.php?action=error_scrape&amp;plugin=<?php echo esc_attr($file); ?>&amp;_wpnonce=<?php echo esc_attr($_GET['_error_nonce']); ?>"></iframe>	<?php } ?></div><?php endif; ?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><div class="fileedit-sub"><div class="alignleft"><big><?php	if ( is_plugin_active($plugin) ) {		if ( is_writeable($real_file) )			echo sprintf(__('Editing <strong>%s</strong> (active)'), $file);		else			echo sprintf(__('Browsing <strong>%s</strong> (active)'), $file);	} else {		if ( is_writeable($real_file) )			echo sprintf(__('Editing <strong>%s</strong> (inactive)'), $file);		else			echo sprintf(__('Browsing <strong>%s</strong> (inactive)'), $file);	}	?></big></div><div class="alignright">	<form action="plugin-editor.php" method="post">		<strong><label for="plugin"><?php _e('Select plugin to edit:'); ?> </label></strong>		<select name="plugin" id="plugin"><?php	foreach ( $plugins as $plugin_key => $a_plugin ) {		$plugin_name = $a_plugin['Name'];		if ( $plugin_key == $plugin )			$selected = " selected='selected'";		else			$selected = '';		$plugin_name = esc_attr($plugin_name);		$plugin_key = esc_attr($plugin_key);		echo "\n\t<option value=\"$plugin_key\" $selected>$plugin_name</option>";	}?>		</select>		<input type="submit" name="Submit" value="<?php esc_attr_e('Select') ?>" class="button" />	</form></div><br class="clear" /></div><div id="templateside">	<h3><?php _e('Plugin Files'); ?></h3>	<ul><?phpforeach ( $plugin_files as $plugin_file ) :	// Get the extension of the file	if ( preg_match('/\.([^.]+)$/', $plugin_file, $matches) ) {		$ext = strtolower($matches[1]);		// If extension is not in the acceptable list, skip it		if ( !in_array( $ext, $editable_extensions ) )			continue;	} else {		// No extension found		continue;	}?>		<li<?php echo $file == $plugin_file ? ' class="highlight"' : ''; ?>><a href="plugin-editor.php?file=<?php echo $plugin_file; ?>&amp;plugin=<?php echo $plugin; ?>"><?php echo $plugin_file ?></a></li><?php endforeach; ?>	</ul></div><form name="template" id="template" action="plugin-editor.php" method="post">	<?php wp_nonce_field('edit-plugin_' . $file) ?>		<div><textarea cols="70" rows="25" name="newcontent" id="newcontent" tabindex="1"><?php echo $content ?></textarea>		<input type="hidden" name="action" value="update" />		<input type="hidden" name="file" value="<?php echo esc_attr($file) ?>" />		<input type="hidden" name="plugin" value="<?php echo esc_attr($plugin) ?>" />		<input type="hidden" name="scrollto" id="scrollto" value="<?php echo $scrollto; ?>" />		</div>		<?php if ( !empty( $docs_select ) ) : ?>		<div id="documentation" class="hide-if-no-js"><label for="docs-list"><?php _e('Documentation:') ?></label> <?php echo $docs_select ?> <input type="button" class="button" value="<?php esc_attr_e( 'Lookup' ) ?> " onclick="if ( '' != jQuery('#docs-list').val() ) { window.open( 'http://api.wordpress.org/core/handbook/1.0/?function=' + escape( jQuery( '#docs-list' ).val() ) + '&amp;locale=<?php echo urlencode( get_locale() ) ?>&amp;version=<?php echo urlencode( $wp_version ) ?>&amp;redirect=true'); }" /></div>		<?php endif; ?><?php if ( is_writeable($real_file) ) : ?>	<?php if ( in_array( $file, (array) get_option( 'active_plugins', array() ) ) ) { ?>		<p><?php _e('<strong>Warning:</strong> Making changes to active plugins is not recommended.  If your changes cause a fatal error, the plugin will be automatically deactivated.'); ?></p>	<?php } ?>	<p class="submit">	<?php		if ( isset($_GET['phperror']) )			echo "<input type='hidden' name='phperror' value='1' /><input type='submit' name='submit' class='button-primary' value='" . esc_attr__('Update File and Attempt to Reactivate') . "' tabindex='2' />";		else			echo "<input type='submit' name='submit' class='button-primary' value='" . esc_attr__('Update File') . "' tabindex='2' />";	?>	</p><?php else : ?>	<p><em><?php _e('You need to make this file writable before you can save your changes. See <a href="http://codex.wordpress.org/Changing_File_Permissions">the Codex</a> for more information.'); ?></em></p><?php endif; ?></form><br class="clear" /></div><script type="text/javascript">/* <![CDATA[ */jQuery(document).ready(function($){	$('#template').submit(function(){ $('#scrollto').val( $('#newcontent').scrollTop() ); });	$('#newcontent').scrollTop( $('#scrollto').val() );});/* ]]> */</script><?php	break;}include("./admin-footer.php");
<?php/** * Themes administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( !current_user_can('switch_themes') && !current_user_can('edit_theme_options') )	wp_die( __( 'Cheatin&#8217; uh?' ) );if ( current_user_can('switch_themes') && isset($_GET['action']) ) {	if ( 'activate' == $_GET['action'] ) {		check_admin_referer('switch-theme_' . $_GET['template']);		switch_theme($_GET['template'], $_GET['stylesheet']);		wp_redirect('themes.php?activated=true');		exit;	} else if ( 'delete' == $_GET['action'] ) {		check_admin_referer('delete-theme_' . $_GET['template']);		if ( !current_user_can('delete_themes') )			wp_die( __( 'Cheatin&#8217; uh?' ) );		delete_theme($_GET['template']);		wp_redirect('themes.php?deleted=true');		exit;	}}$title = __('Manage Themes');$parent_file = 'themes.php';if ( current_user_can( 'switch_themes' ) ) :$help = '<p>' . __('Aside from the default theme included with your WordPress installation, themes are designed and developed by third parties.') . '</p>';$help .= '<p>' . __('You can see your active theme at the top of the screen. Below are the other themes you have installed that are not currently in use. You can see what your site would look like with one of these themes by clicking the Preview link. To change themes, click the Activate link.') . '</p>';if ( current_user_can('install_themes') )	$help .= '<p>' . sprintf(__('If you would like to see more themes to choose from, click on the &#8220;Install Themes&#8221; tab and you will be able to browse or search for additional themes from the <a href="%s" target="_blank">WordPress.org Theme Directory</a>. Themes in the WordPress.org Theme Directory are designed and developed by third parties, and are licensed under the GNU General Public License, version 2, just like WordPress. Oh, and they&#8217;re free!'), 'http://wordpress.org/extend/themes/') . '</p>';$help .= '<p><strong>' . __('For more information:') . '</strong></p>';$help .= '<p>' . __('<a href="http://codex.wordpress.org/Using_Themes" target="_blank">Documentation on Using Themes</a>') . '</p>';$help .= '<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>';add_contextual_help($current_screen, $help);add_thickbox();wp_enqueue_script( 'theme-preview' );endif;require_once('./admin-header.php');if ( is_multisite() && current_user_can('edit_themes') ) {	?><div id="message0" class="updated"><p><?php printf( __('Administrator: new themes must be activated in the <a href="%s">Network Themes</a> screen before they appear here.'), admin_url( 'ms-themes.php') ); ?></p></div><?php}?><?php if ( ! validate_current_theme() ) : ?><div id="message1" class="updated"><p><?php _e('The active theme is broken.  Reverting to the default theme.'); ?></p></div><?php elseif ( isset($_GET['activated']) ) :		if ( isset($wp_registered_sidebars) && count( (array) $wp_registered_sidebars ) && current_user_can('edit_theme_options') ) { ?><div id="message2" class="updated"><p><?php printf( __('New theme activated. This theme supports widgets, please visit the <a href="%s">widgets settings</a> screen to configure them.'), admin_url( 'widgets.php' ) ); ?></p></div><?php		} else { ?><div id="message2" class="updated"><p><?php printf( __( 'New theme activated. <a href="%s">Visit site</a>' ), home_url( '/' ) ); ?></p></div><?php		}	elseif ( isset($_GET['deleted']) ) : ?><div id="message3" class="updated"><p><?php _e('Theme deleted.') ?></p></div><?php endif; ?><?php$themes = get_allowed_themes();$ct = current_theme_info();unset($themes[$ct->name]);uksort( $themes, "strnatcasecmp" );$theme_total = count( $themes );$per_page = 15;if ( isset( $_GET['pagenum'] ) )	$page = absint( $_GET['pagenum'] );if ( empty($page) )	$page = 1;$start = $offset = ( $page - 1 ) * $per_page;$page_links = paginate_links( array(	'base' => add_query_arg( 'pagenum', '%#%' ) . '#themenav',	'format' => '',	'prev_text' => __('&laquo;'),	'next_text' => __('&raquo;'),	'total' => ceil($theme_total / $per_page),	'current' => $page));$themes = array_slice( $themes, $start, $per_page );?><div class="wrap"><?php screen_icon(); ?><h2><a href="themes.php" class="nav-tab nav-tab-active"><?php echo esc_html( $title ); ?></a><?php if ( current_user_can('install_themes') ) { ?><a href="theme-install.php" class="nav-tab"><?php echo esc_html_x('Install Themes', 'theme'); ?></a><?php } ?></h2><h3><?php _e('Current Theme'); ?></h3><div id="current-theme"><?php if ( $ct->screenshot ) : ?><img src="<?php echo $ct->theme_root_uri . '/' . $ct->stylesheet . '/' . $ct->screenshot; ?>" alt="<?php _e('Current theme preview'); ?>" /><?php endif; ?><h4><?php	/* translators: 1: theme title, 2: theme version, 3: theme author */	printf(__('%1$s %2$s by %3$s'), $ct->title, $ct->version, $ct->author) ; ?></h4><p class="theme-description"><?php echo $ct->description; ?></p><?php if ( current_user_can('edit_themes') && $ct->parent_theme ) { ?>	<p><?php printf(__('The template files are located in <code>%2$s</code>. The stylesheet files are located in <code>%3$s</code>. <strong>%4$s</strong> uses templates from <strong>%5$s</strong>. Changes made to the templates will affect both themes.'), $ct->title, str_replace( WP_CONTENT_DIR, '', $ct->template_dir ), str_replace( WP_CONTENT_DIR, '', $ct->stylesheet_dir ), $ct->title, $ct->parent_theme); ?></p><?php } else { ?>	<p><?php printf(__('All of this theme&#8217;s files are located in <code>%2$s</code>.'), $ct->title, str_replace( WP_CONTENT_DIR, '', $ct->template_dir ), str_replace( WP_CONTENT_DIR, '', $ct->stylesheet_dir ) ); ?></p><?php } ?><?php if ( $ct->tags ) : ?><p><?php _e('Tags:'); ?> <?php echo join(', ', $ct->tags); ?></p><?php endif; ?><?php theme_update_available($ct); ?></div><div class="clear"></div><?phpif ( ! current_user_can( 'switch_themes' ) ) {	echo '</div>';	require( './admin-footer.php' );	exit;}?><h3><?php _e('Available Themes'); ?></h3><div class="clear"></div><?php if ( $theme_total ) { ?><?php if ( $page_links ) : ?><div class="tablenav"><div class="tablenav-pages"><?php $page_links_text = sprintf( '<span class="displaying-num">' . __( 'Displaying %s&#8211;%s of %s' ) . '</span>%s',	number_format_i18n( $start + 1 ),	number_format_i18n( min( $page * $per_page, $theme_total ) ),	number_format_i18n( $theme_total ),	$page_links); echo $page_links_text; ?></div></div><?php endif; ?><table id="availablethemes" cellspacing="0" cellpadding="0"><?php$style = '';$theme_names = array_keys($themes);natcasesort($theme_names);$table = array();$rows = ceil(count($theme_names) / 3);for ( $row = 1; $row <= $rows; $row++ )	for ( $col = 1; $col <= 3; $col++ )		$table[$row][$col] = array_shift($theme_names);foreach ( $table as $row => $cols ) {?><tr><?phpforeach ( $cols as $col => $theme_name ) {	$class = array('available-theme');	if ( $row == 1 ) $class[] = 'top';	if ( $col == 1 ) $class[] = 'left';	if ( $row == $rows ) $class[] = 'bottom';	if ( $col == 3 ) $class[] = 'right';?>	<td class="<?php echo join(' ', $class); ?>"><?php if ( !empty($theme_name) ) :	$template = $themes[$theme_name]['Template'];	$stylesheet = $themes[$theme_name]['Stylesheet'];	$title = $themes[$theme_name]['Title'];	$version = $themes[$theme_name]['Version'];	$description = $themes[$theme_name]['Description'];	$author = $themes[$theme_name]['Author'];	$screenshot = $themes[$theme_name]['Screenshot'];	$stylesheet_dir = $themes[$theme_name]['Stylesheet Dir'];	$template_dir = $themes[$theme_name]['Template Dir'];	$parent_theme = $themes[$theme_name]['Parent Theme'];	$theme_root = $themes[$theme_name]['Theme Root'];	$theme_root_uri = $themes[$theme_name]['Theme Root URI'];	$preview_link = esc_url(get_option('home') . '/');	if ( is_ssl() )		$preview_link = str_replace( 'http://', 'https://', $preview_link );	$preview_link = htmlspecialchars( add_query_arg( array('preview' => 1, 'template' => $template, 'stylesheet' => $stylesheet, 'TB_iframe' => 'true' ), $preview_link ) );	$preview_text = esc_attr( sprintf( __('Preview of &#8220;%s&#8221;'), $title ) );	$tags = $themes[$theme_name]['Tags'];	$thickbox_class = 'thickbox thickbox-preview';	$activate_link = wp_nonce_url("themes.php?action=activate&amp;template=".urlencode($template)."&amp;stylesheet=".urlencode($stylesheet), 'switch-theme_' . $template);	$activate_text = esc_attr( sprintf( __('Activate &#8220;%s&#8221;'), $title ) );	$actions = array();	$actions[] = '<a href="' . $activate_link .  '" class="activatelink" title="' . $activate_text . '">' . __('Activate') . '</a>';	$actions[] = '<a href="' . $preview_link . '" class="thickbox thickbox-preview" title="' . esc_attr(sprintf(__('Preview &#8220;%s&#8221;'), $theme_name)) . '">' . __('Preview') . '</a>';	if ( current_user_can('delete_themes') )		$actions[] = '<a class="submitdelete deletion" href="' . wp_nonce_url("themes.php?action=delete&amp;template=$stylesheet", 'delete-theme_' . $stylesheet) . '" onclick="' . "return confirm('" . esc_js(sprintf( __("You are about to delete this theme '%s'\n  'Cancel' to stop, 'OK' to delete."), $theme_name )) . "');" . '">' . __('Delete') . '</a>';	$actions = apply_filters('theme_action_links', $actions, $themes[$theme_name]);	$actions = implode ( ' | ', $actions );?>		<a href="<?php echo $preview_link; ?>" class="<?php echo $thickbox_class; ?> screenshot"><?php if ( $screenshot ) : ?>			<img src="<?php echo $theme_root_uri . '/' . $stylesheet . '/' . $screenshot; ?>" alt="" /><?php endif; ?>		</a><h3><?php	/* translators: 1: theme title, 2: theme version, 3: theme author */	printf(__('%1$s %2$s by %3$s'), $title, $version, $author) ; ?></h3><p class="description"><?php echo $description; ?></p><span class='action-links'><?php echo $actions ?></span>	<?php if ( current_user_can('edit_themes') && $parent_theme ) {	/* translators: 1: theme title, 2:  template dir, 3: stylesheet_dir, 4: theme title, 5: parent_theme */ ?>	<p><?php printf(__('The template files are located in <code>%2$s</code>. The stylesheet files are located in <code>%3$s</code>. <strong>%4$s</strong> uses templates from <strong>%5$s</strong>. Changes made to the templates will affect both themes.'), $title, str_replace( WP_CONTENT_DIR, '', $template_dir ), str_replace( WP_CONTENT_DIR, '', $stylesheet_dir ), $title, $parent_theme); ?></p><?php } else { ?>	<p><?php printf(__('All of this theme&#8217;s files are located in <code>%2$s</code>.'), $title, str_replace( WP_CONTENT_DIR, '', $template_dir ), str_replace( WP_CONTENT_DIR, '', $stylesheet_dir ) ); ?></p><?php } ?><?php if ( $tags ) : ?><p><?php _e('Tags:'); ?> <?php echo join(', ', $tags); ?></p><?php endif; ?>		<?php theme_update_available( $themes[$theme_name] ); ?><?php endif; // end if not empty theme_name ?>	</td><?php } // end foreach $cols ?></tr><?php } // end foreach $table ?></table><?php } else { ?><p><?php	if ( current_user_can('install_themes') )		printf(__('You only have one theme installed right now. Live a little! You can choose from over 1,000 free themes in the WordPress.org Theme Directory at any time: just click on the <em><a href="%s">Install Themes</a></em> tab above.'), 'theme-install.php');	else		printf(__('Only the current theme is available to you. Contact the %s administrator for information about accessing additional themes.'), get_site_option('site_name'));	?></p><?php } // end if $theme_total?><br class="clear" /><?php if ( $page_links ) : ?><div class="tablenav"><?php echo "<div class='tablenav-pages'>$page_links_text</div>"; ?><br class="clear" /></div><?php endif; ?><br class="clear" /><?php// List broken themes, if any.$broken_themes = get_broken_themes();if ( current_user_can('edit_themes') && count( $broken_themes ) ) {?><h2><?php _e('Broken Themes'); ?> <?php if ( is_multisite() ) _e( '(Site admin only)' ); ?></h2><p><?php _e('The following themes are installed but incomplete. Themes must have a stylesheet and a template.'); ?></p><table id="broken-themes">	<tr>		<th><?php _e('Name'); ?></th>		<th><?php _e('Description'); ?></th>	</tr><?php	$theme = '';	$theme_names = array_keys($broken_themes);	natcasesort($theme_names);	foreach ($theme_names as $theme_name) {		$title = $broken_themes[$theme_name]['Title'];		$description = $broken_themes[$theme_name]['Description'];		$theme = ('class="alternate"' == $theme) ? '' : 'class="alternate"';		echo "		<tr $theme>			 <td>$title</td>			 <td>$description</td>		</tr>";	}?></table><?php}?></div><?php require('./admin-footer.php'); ?>
<?php/** * Theme, template, and stylesheet functions. * * @package WordPress * @subpackage Template *//** * Whether a child theme is in use. * * @since 3.0.0 * * @return bool true if a child theme is in use, false otherwise. **/function is_child_theme() {	return ( TEMPLATEPATH !== STYLESHEETPATH );}/** * Retrieve name of the current stylesheet. * * The theme name that the administrator has currently set the front end theme * as. * * For all extensive purposes, the template name and the stylesheet name are * going to be the same for most cases. * * @since 1.5.0 * @uses apply_filters() Calls 'stylesheet' filter on stylesheet name. * * @return string Stylesheet name. */function get_stylesheet() {	return apply_filters('stylesheet', get_option('stylesheet'));}/** * Retrieve stylesheet directory path for current theme. * * @since 1.5.0 * @uses apply_filters() Calls 'stylesheet_directory' filter on stylesheet directory and theme name. * * @return string Path to current theme directory. */function get_stylesheet_directory() {	$stylesheet = get_stylesheet();	$theme_root = get_theme_root( $stylesheet );	$stylesheet_dir = "$theme_root/$stylesheet";	return apply_filters( 'stylesheet_directory', $stylesheet_dir, $stylesheet, $theme_root );}/** * Retrieve stylesheet directory URI. * * @since 1.5.0 * * @return string */function get_stylesheet_directory_uri() {	$stylesheet = get_stylesheet();	$theme_root_uri = get_theme_root_uri( $stylesheet );	$stylesheet_dir_uri = "$theme_root_uri/$stylesheet";	return apply_filters( 'stylesheet_directory_uri', $stylesheet_dir_uri, $stylesheet, $theme_root_uri );}/** * Retrieve URI of current theme stylesheet. * * The stylesheet file name is 'style.css' which is appended to {@link * get_stylesheet_directory_uri() stylesheet directory URI} path. * * @since 1.5.0 * @uses apply_filters() Calls 'stylesheet_uri' filter on stylesheet URI path and stylesheet directory URI. * * @return string */function get_stylesheet_uri() {	$stylesheet_dir_uri = get_stylesheet_directory_uri();	$stylesheet_uri = $stylesheet_dir_uri . "/style.css";	return apply_filters('stylesheet_uri', $stylesheet_uri, $stylesheet_dir_uri);}/** * Retrieve localized stylesheet URI. * * The stylesheet directory for the localized stylesheet files are located, by * default, in the base theme directory. The name of the locale file will be the * locale followed by '.css'. If that does not exist, then the text direction * stylesheet will be checked for existence, for example 'ltr.css'. * * The theme may change the location of the stylesheet directory by either using * the 'stylesheet_directory_uri' filter or the 'locale_stylesheet_uri' filter. * If you want to change the location of the stylesheet files for the entire * WordPress workflow, then change the former. If you just have the locale in a * separate folder, then change the latter. * * @since 2.1.0 * @uses apply_filters() Calls 'locale_stylesheet_uri' filter on stylesheet URI path and stylesheet directory URI. * * @return string */function get_locale_stylesheet_uri() {	global $wp_locale;	$stylesheet_dir_uri = get_stylesheet_directory_uri();	$dir = get_stylesheet_directory();	$locale = get_locale();	if ( file_exists("$dir/$locale.css") )		$stylesheet_uri = "$stylesheet_dir_uri/$locale.css";	elseif ( !empty($wp_locale->text_direction) && file_exists("$dir/{$wp_locale->text_direction}.css") )		$stylesheet_uri = "$stylesheet_dir_uri/{$wp_locale->text_direction}.css";	else		$stylesheet_uri = '';	return apply_filters('locale_stylesheet_uri', $stylesheet_uri, $stylesheet_dir_uri);}/** * Retrieve name of the current theme. * * @since 1.5.0 * @uses apply_filters() Calls 'template' filter on template option. * * @return string Template name. */function get_template() {	return apply_filters('template', get_option('template'));}/** * Retrieve current theme directory. * * @since 1.5.0 * @uses apply_filters() Calls 'template_directory' filter on template directory path and template name. * * @return string Template directory path. */function get_template_directory() {	$template = get_template();	$theme_root = get_theme_root( $template );	$template_dir = "$theme_root/$template";	return apply_filters( 'template_directory', $template_dir, $template, $theme_root );}/** * Retrieve theme directory URI. * * @since 1.5.0 * @uses apply_filters() Calls 'template_directory_uri' filter on template directory URI path and template name. * * @return string Template directory URI. */function get_template_directory_uri() {	$template = get_template();	$theme_root_uri = get_theme_root_uri( $template );	$template_dir_uri = "$theme_root_uri/$template";	return apply_filters( 'template_directory_uri', $template_dir_uri, $template, $theme_root_uri );}/** * Retrieve theme data from parsed theme file. * * The description will have the tags filtered with the following HTML elements * whitelisted. The <b>'a'</b> element with the <em>href</em> and <em>title</em> * attributes. The <b>abbr</b> element with the <em>title</em> attribute. The * <b>acronym<b> element with the <em>title</em> attribute allowed. The * <b>code</b>, <b>em</b>, and <b>strong</b> elements also allowed. * * The style.css file must contain theme name, theme URI, and description. The * data can also contain author URI, author, template (parent template), * version, status, and finally tags. Some of these are not used by WordPress * administration panels, but are used by theme directory web sites which list * the theme. * * @since 1.5.0 * * @param string $theme_file Theme file path. * @return array Theme data. */function get_theme_data( $theme_file ) {	$default_headers = array(		'Name' => 'Theme Name',		'URI' => 'Theme URI',		'Description' => 'Description',		'Author' => 'Author',		'AuthorURI' => 'Author URI',		'Version' => 'Version',		'Template' => 'Template',		'Status' => 'Status',		'Tags' => 'Tags'		);	$themes_allowed_tags = array(		'a' => array(			'href' => array(),'title' => array()			),		'abbr' => array(			'title' => array()			),		'acronym' => array(			'title' => array()			),		'code' => array(),		'em' => array(),		'strong' => array()	);	$theme_data = get_file_data( $theme_file, $default_headers, 'theme' );	$theme_data['Name'] = $theme_data['Title'] = wp_kses( $theme_data['Name'], $themes_allowed_tags );	$theme_data['URI'] = esc_url( $theme_data['URI'] );	$theme_data['Description'] = wptexturize( wp_kses( $theme_data['Description'], $themes_allowed_tags ) );	$theme_data['AuthorURI'] = esc_url( $theme_data['AuthorURI'] );	$theme_data['Template'] = wp_kses( $theme_data['Template'], $themes_allowed_tags );	$theme_data['Version'] = wp_kses( $theme_data['Version'], $themes_allowed_tags );	if ( $theme_data['Status'] == '' )		$theme_data['Status'] = 'publish';	else		$theme_data['Status'] = wp_kses( $theme_data['Status'], $themes_allowed_tags );	if ( $theme_data['Tags'] == '' )		$theme_data['Tags'] = array();	else		$theme_data['Tags'] = array_map( 'trim', explode( ',', wp_kses( $theme_data['Tags'], array() ) ) );	if ( $theme_data['Author'] == '' ) {		$theme_data['Author'] = $theme_data['AuthorName'] = __('Anonymous');	} else {		$theme_data['AuthorName'] = wp_kses( $theme_data['Author'], $themes_allowed_tags );		if ( empty( $theme_data['AuthorURI'] ) ) {			$theme_data['Author'] = $theme_data['AuthorName'];		} else {			$theme_data['Author'] = sprintf( '<a href="%1$s" title="%2$s">%3$s</a>', $theme_data['AuthorURI'], __( 'Visit author homepage' ), $theme_data['AuthorName'] );		}	}	return $theme_data;}/** * Retrieve list of themes with theme data in theme directory. * * The theme is broken, if it doesn't have a parent theme and is missing either * style.css and, or index.php. If the theme has a parent theme then it is * broken, if it is missing style.css; index.php is optional. The broken theme * list is saved in the {@link $wp_broken_themes} global, which is displayed on * the theme list in the administration panels. * * @since 1.5.0 * @global array $wp_broken_themes Stores the broken themes. * @global array $wp_themes Stores the working themes. * * @return array Theme list with theme data. */function get_themes() {	global $wp_themes, $wp_broken_themes;	if ( isset($wp_themes) )		return $wp_themes;	/* Register the default root as a theme directory */	register_theme_directory( get_theme_root() );	if ( !$theme_files = search_theme_directories() )		return false;	asort( $theme_files );	$wp_themes = array();	foreach ( (array) $theme_files as $theme_file ) {		$theme_root = $theme_file['theme_root'];		$theme_file = $theme_file['theme_file'];		if ( !is_readable("$theme_root/$theme_file") ) {			$wp_broken_themes[$theme_file] = array('Name' => $theme_file, 'Title' => $theme_file, 'Description' => __('File not readable.'));			continue;		}		$theme_data = get_theme_data("$theme_root/$theme_file");		$name        = $theme_data['Name'];		$title       = $theme_data['Title'];		$description = wptexturize($theme_data['Description']);		$version     = $theme_data['Version'];		$author      = $theme_data['Author'];		$template    = $theme_data['Template'];		$stylesheet  = dirname($theme_file);		$screenshot = false;		foreach ( array('png', 'gif', 'jpg', 'jpeg') as $ext ) {			if (file_exists("$theme_root/$stylesheet/screenshot.$ext")) {				$screenshot = "screenshot.$ext";				break;			}		}		if ( empty($name) ) {			$name = dirname($theme_file);			$title = $name;		}		$parent_template = $template;		if ( empty($template) ) {			if ( file_exists("$theme_root/$stylesheet/index.php") )				$template = $stylesheet;			else				continue;		}		$template = trim( $template );		if ( !file_exists("$theme_root/$template/index.php") ) {			$parent_dir = dirname(dirname($theme_file));			if ( file_exists("$theme_root/$parent_dir/$template/index.php") ) {				$template = "$parent_dir/$template";				$template_directory = "$theme_root/$template";			} else {				/**				 * The parent theme doesn't exist in the current theme's folder or sub folder				 * so lets use the theme root for the parent template.				 */				if ( isset($theme_files[$template]) && file_exists( $theme_files[$template]['theme_root'] . "/$template/index.php" ) ) {					$template_directory = $theme_files[$template]['theme_root'] . "/$template";				} else {					if ( empty( $parent_template) )						$wp_broken_themes[$name] = array('Name' => $name, 'Title' => $title, 'Description' => __('Template is missing.'), 'error' => 'no_template');					else						$wp_broken_themes[$name] = array('Name' => $name, 'Title' => $title, 'Description' => sprintf( __('The parent theme is missing. Please install the "%s" parent theme.'),  $parent_template ), 'error' => 'no_parent', 'parent' => $parent_template );					continue;				}			}		} else {			$template_directory = trim( $theme_root . '/' . $template );		}		$stylesheet_files = array();		$template_files = array();		$stylesheet_dir = @ dir("$theme_root/$stylesheet");		if ( $stylesheet_dir ) {			while ( ($file = $stylesheet_dir->read()) !== false ) {				if ( !preg_match('|^\.+$|', $file) ) {					if ( preg_match('|\.css$|', $file) )						$stylesheet_files[] = "$theme_root/$stylesheet/$file";					elseif ( preg_match('|\.php$|', $file) )						$template_files[] = "$theme_root/$stylesheet/$file";				}			}			@ $stylesheet_dir->close();		}		$template_dir = @ dir("$template_directory");		if ( $template_dir ) {			while ( ($file = $template_dir->read()) !== false ) {				if ( preg_match('|^\.+$|', $file) )					continue;				if ( preg_match('|\.php$|', $file) ) {					$template_files[] = "$template_directory/$file";				} elseif ( is_dir("$template_directory/$file") ) {					$template_subdir = @ dir("$template_directory/$file");					if ( !$template_subdir )						continue;					while ( ($subfile = $template_subdir->read()) !== false ) {						if ( preg_match('|^\.+$|', $subfile) )							continue;						if ( preg_match('|\.php$|', $subfile) )							$template_files[] = "$template_directory/$file/$subfile";					}					@ $template_subdir->close();				}			}			@ $template_dir->close();		}		//Make unique and remove duplicates when stylesheet and template are the same i.e. most themes		$template_files = array_unique($template_files);		$stylesheet_files = array_unique($stylesheet_files);		$template_dir = dirname($template_files[0]);		$stylesheet_dir = dirname($stylesheet_files[0]);		if ( empty($template_dir) )			$template_dir = '/';		if ( empty($stylesheet_dir) )			$stylesheet_dir = '/';		// Check for theme name collision.  This occurs if a theme is copied to		// a new theme directory and the theme header is not updated.  Whichever		// theme is first keeps the name.  Subsequent themes get a suffix applied.		// The Default and Classic themes always trump their pretenders.		if ( isset($wp_themes[$name]) ) {			if ( ('WordPress Default' == $name || 'WordPress Classic' == $name) &&					 ('default' == $stylesheet || 'classic' == $stylesheet) ) {				// If another theme has claimed to be one of our default themes, move				// them aside.				$suffix = $wp_themes[$name]['Stylesheet'];				$new_name = "$name/$suffix";				$wp_themes[$new_name] = $wp_themes[$name];				$wp_themes[$new_name]['Name'] = $new_name;			} else {				$name = "$name/$stylesheet";			}		}		$theme_roots[$stylesheet] = str_replace( WP_CONTENT_DIR, '', $theme_root );		$wp_themes[$name] = array(			'Name' => $name,			'Title' => $title,			'Description' => $description,			'Author' => $author,			'Author Name' => $theme_data['AuthorName'],			'Author URI' => $theme_data['AuthorURI'],			'Version' => $version,			'Template' => $template,			'Stylesheet' => $stylesheet,			'Template Files' => $template_files,			'Stylesheet Files' => $stylesheet_files,			'Template Dir' => $template_dir,			'Stylesheet Dir' => $stylesheet_dir,			'Status' => $theme_data['Status'],			'Screenshot' => $screenshot,			'Tags' => $theme_data['Tags'],			'Theme Root' => $theme_root,			'Theme Root URI' => str_replace( WP_CONTENT_DIR, content_url(), $theme_root ),		);	}	unset($theme_files);	/* Store theme roots in the DB */	if ( get_site_transient( 'theme_roots' ) != $theme_roots )		set_site_transient( 'theme_roots', $theme_roots, 7200 ); // cache for two hours	unset($theme_roots);	/* Resolve theme dependencies. */	$theme_names = array_keys( $wp_themes );	foreach ( (array) $theme_names as $theme_name ) {		$wp_themes[$theme_name]['Parent Theme'] = '';		if ( $wp_themes[$theme_name]['Stylesheet'] != $wp_themes[$theme_name]['Template'] ) {			foreach ( (array) $theme_names as $parent_theme_name ) {				if ( ($wp_themes[$parent_theme_name]['Stylesheet'] == $wp_themes[$parent_theme_name]['Template']) && ($wp_themes[$parent_theme_name]['Template'] == $wp_themes[$theme_name]['Template']) ) {					$wp_themes[$theme_name]['Parent Theme'] = $wp_themes[$parent_theme_name]['Name'];					break;				}			}		}	}	return $wp_themes;}/** * Retrieve theme roots. * * @since 2.9.0 * * @return array Theme roots */function get_theme_roots() {	$theme_roots = get_site_transient( 'theme_roots' );	if ( false === $theme_roots ) {		get_themes();		$theme_roots = get_site_transient( 'theme_roots' ); // this is set in get_theme()	}	return $theme_roots;}/** * Retrieve theme data. * * @since 1.5.0 * * @param string $theme Theme name. * @return array|null Null, if theme name does not exist. Theme data, if exists. */function get_theme($theme) {	$themes = get_themes();	if ( array_key_exists($theme, $themes) )		return $themes[$theme];	return null;}/** * Retrieve current theme display name. * * If the 'current_theme' option has already been set, then it will be returned * instead. If it is not set, then each theme will be iterated over until both * the current stylesheet and current template name. * * @since 1.5.0 * * @return string */function get_current_theme() {	if ( $theme = get_option('current_theme') )		return $theme;	$themes = get_themes();	$theme_names = array_keys($themes);	$current_template = get_option('template');	$current_stylesheet = get_option('stylesheet');	$current_theme = 'WordPress Default';	if ( $themes ) {		foreach ( (array) $theme_names as $theme_name ) {			if ( $themes[$theme_name]['Stylesheet'] == $current_stylesheet &&					$themes[$theme_name]['Template'] == $current_template ) {				$current_theme = $themes[$theme_name]['Name'];				break;			}		}	}	update_option('current_theme', $current_theme);	return $current_theme;}/** * Register a directory that contains themes. * * @since 2.9.0 * * @param string $directory Either the full filesystem path to a theme folder or a folder within WP_CONTENT_DIR * @return bool */function register_theme_directory( $directory) {	global $wp_theme_directories;	/* If this folder does not exist, return and do not register */	if ( !file_exists( $directory ) )			/* Try prepending as the theme directory could be relative to the content directory */		$registered_directory = WP_CONTENT_DIR . '/' . $directory;	else		$registered_directory = $directory;	/* If this folder does not exist, return and do not register */	if ( !file_exists( $registered_directory ) )		return false;	$wp_theme_directories[] = $registered_directory;	return true;}/** * Search all registered theme directories for complete and valid themes. * * @since 2.9.0 * * @return array Valid themes found */function search_theme_directories() {	global $wp_theme_directories, $wp_broken_themes;	if ( empty( $wp_theme_directories ) )		return false;	$theme_files = array();	$wp_broken_themes = array();	/* Loop the registered theme directories and extract all themes */	foreach ( (array) $wp_theme_directories as $theme_root ) {		$theme_loc = $theme_root;		/* We don't want to replace all forward slashes, see Trac #4541 */		if ( '/' != WP_CONTENT_DIR )			$theme_loc = str_replace(WP_CONTENT_DIR, '', $theme_root);		/* Files in the root of the current theme directory and one subdir down */		$themes_dir = @ opendir($theme_root);		if ( !$themes_dir )			return false;		while ( ($theme_dir = readdir($themes_dir)) !== false ) {			if ( is_dir($theme_root . '/' . $theme_dir) && is_readable($theme_root . '/' . $theme_dir) ) {				if ( $theme_dir{0} == '.' || $theme_dir == 'CVS' )					continue;				$stylish_dir = @opendir($theme_root . '/' . $theme_dir);				$found_stylesheet = false;				while ( ($theme_file = readdir($stylish_dir)) !== false ) {					if ( $theme_file == 'style.css' ) {						$theme_files[$theme_dir] = array( 'theme_file' => $theme_dir . '/' . $theme_file, 'theme_root' => $theme_root );						$found_stylesheet = true;						break;					}				}				@closedir($stylish_dir);				if ( !$found_stylesheet ) { // look for themes in that dir					$subdir = "$theme_root/$theme_dir";					$subdir_name = $theme_dir;					$theme_subdirs = @opendir( $subdir );					$found_subdir_themes = false;					while ( ($theme_subdir = readdir($theme_subdirs)) !== false ) {						if ( is_dir( $subdir . '/' . $theme_subdir) && is_readable($subdir . '/' . $theme_subdir) ) {							if ( $theme_subdir{0} == '.' || $theme_subdir == 'CVS' )								continue;							$stylish_dir = @opendir($subdir . '/' . $theme_subdir);							$found_stylesheet = false;							while ( ($theme_file = readdir($stylish_dir)) !== false ) {								if ( $theme_file == 'style.css' ) {									$theme_files["$theme_dir/$theme_subdir"] = array( 'theme_file' => $subdir_name . '/' . $theme_subdir . '/' . $theme_file, 'theme_root' => $theme_root );									$found_stylesheet = true;									$found_subdir_themes = true;									break;								}							}							@closedir($stylish_dir);						}					}					@closedir($theme_subdirs);					if ( !$found_subdir_themes )						$wp_broken_themes[$theme_dir] = array('Name' => $theme_dir, 'Title' => $theme_dir, 'Description' => __('Stylesheet is missing.'));				}			}		}		@closedir( $themes_dir );	}	return $theme_files;}/** * Retrieve path to themes directory. * * Does not have trailing slash. * * @since 1.5.0 * @param $stylesheet_or_template The stylesheet or template name of the theme * @uses apply_filters() Calls 'theme_root' filter on path. * * @return string Theme path. */function get_theme_root( $stylesheet_or_template = false ) {	if ($stylesheet_or_template) {		$theme_roots = get_theme_roots();		if ( ! empty( $theme_roots[$stylesheet_or_template] ) )			$theme_root = WP_CONTENT_DIR . $theme_roots[$stylesheet_or_template];		else			$theme_root = WP_CONTENT_DIR . '/themes';	} else {		$theme_root = WP_CONTENT_DIR . '/themes';	}	return apply_filters( 'theme_root', $theme_root );}/** * Retrieve URI for themes directory. * * Does not have trailing slash. * * @since 1.5.0 * @param $stylesheet_or_template The stylesheet or template name of the theme * * @return string Themes URI. */function get_theme_root_uri( $stylesheet_or_template = false ) {	$theme_roots = get_theme_roots();	if ( isset( $theme_roots[$stylesheet_or_template] ) && $theme_roots[$stylesheet_or_template] )		$theme_root_uri = content_url( $theme_roots[$stylesheet_or_template] );	else		$theme_root_uri = content_url( 'themes' );	return apply_filters( 'theme_root_uri', $theme_root_uri, get_option('siteurl'), $stylesheet_or_template );}/** * Retrieve path to file without the use of extension. * * Used to quickly retrieve the path of file without including the file * extension. It will also check the parent template, if the file exists, with * the use of {@link locate_template()}. Allows for more generic file location * without the use of the other get_*_template() functions. * * Can be used with include() or require() to retrieve path. * <code> * if( '' != get_query_template( '404' ) ) *     include( get_query_template( '404' ) ); * </code> * or the same can be accomplished with * <code> * if( '' != get_404_template() ) *     include( get_404_template() ); * </code> * * @since 1.5.0 * * @param string $type Filename without extension. * @return string Full path to file. */function get_query_template($type) {	$type = preg_replace( '|[^a-z0-9-]+|', '', $type );	return apply_filters("{$type}_template", locate_template(array("{$type}.php")));}/** * Retrieve path of index template in current or parent template. * * @since 3.0.0 * * @return string */function get_index_template() {	return get_query_template('index');}/** * Retrieve path of 404 template in current or parent template. * * @since 1.5.0 * * @return string */function get_404_template() {	return get_query_template('404');}/** * Retrieve path of archive template in current or parent template. * * @since 1.5.0 * * @return string */function get_archive_template() {	return get_query_template('archive');}/** * Retrieve path of author template in current or parent template. * * @since 1.5.0 * * @return string */function get_author_template() {	$author_id = absint( get_query_var( 'author' ) );	$author = get_user_by( 'id', $author_id );	$author = $author->user_nicename;	$templates = array();	if ( $author )		$templates[] = "author-{$author}.php";	if ( $author_id )		$templates[] = "author-{$author_id}.php";	$templates[] = 'author.php';	$template = locate_template( $templates );	return apply_filters( 'author_template', $template );}/** * Retrieve path of category template in current or parent template. * * Works by first retrieving the current slug for example 'category-default.php' and then * trying category ID, for example 'category-1.php' and will finally fallback to category.php * template, if those files don't exist. * * @since 1.5.0 * @uses apply_filters() Calls 'category_template' on file path of category template. * * @return string */function get_category_template() {	$cat_ID = absint( get_query_var('cat') );	$category = get_category( $cat_ID );	$templates = array();	if ( !is_wp_error($category) )		$templates[] = "category-{$category->slug}.php";	$templates[] = "category-$cat_ID.php";	$templates[] = "category.php";	$template = locate_template($templates);	return apply_filters('category_template', $template);}/** * Retrieve path of tag template in current or parent template. * * Works by first retrieving the current tag name, for example 'tag-wordpress.php' and then * trying tag ID, for example 'tag-1.php' and will finally fallback to tag.php * template, if those files don't exist. * * @since 2.3.0 * @uses apply_filters() Calls 'tag_template' on file path of tag template. * * @return string */function get_tag_template() {	$tag_id = absint( get_query_var('tag_id') );	$tag_name = get_query_var('tag');	$templates = array();	if ( $tag_name )		$templates[] = "tag-$tag_name.php";	if ( $tag_id )		$templates[] = "tag-$tag_id.php";	$templates[] = "tag.php";	$template = locate_template($templates);	return apply_filters('tag_template', $template);}/** * Retrieve path of taxonomy template in current or parent template. * * Retrieves the taxonomy and term, if term is available. The template is * prepended with 'taxonomy-' and followed by both the taxonomy string and * the taxonomy string followed by a dash and then followed by the term. * * The taxonomy and term template is checked and used first, if it exists. * Second, just the taxonomy template is checked, and then finally, taxonomy.php * template is used. If none of the files exist, then it will fall back on to * index.php. * * @since unknown (2.6.0 most likely) * @uses apply_filters() Calls 'taxonomy_template' filter on found path. * * @return string */function get_taxonomy_template() {	$taxonomy = get_query_var('taxonomy');	$term = get_query_var('term');	$templates = array();	if ( $taxonomy && $term )		$templates[] = "taxonomy-$taxonomy-$term.php";	if ( $taxonomy )		$templates[] = "taxonomy-$taxonomy.php";	$templates[] = "taxonomy.php";	$template = locate_template($templates);	return apply_filters('taxonomy_template', $template);}/** * Retrieve path of date template in current or parent template. * * @since 1.5.0 * * @return string */function get_date_template() {	return get_query_template('date');}/** * Retrieve path of home template in current or parent template. * * This is the template used for the page containing the blog posts * * Attempts to locate 'home.php' first before falling back to 'index.php'. * * @since 1.5.0 * @uses apply_filters() Calls 'home_template' on file path of home template. * * @return string */function get_home_template() {	$template = locate_template(array('home.php', 'index.php'));	return apply_filters('home_template', $template);}/** * Retrieve path of front-page template in current or parent template. * * Looks for 'front-page.php'. * * @since 3.0.0 * @uses apply_filters() Calls 'front_page_template' on file path of template. * * @return string */function get_front_page_template() {	return apply_filters( 'front_page_template', locate_template( array('front-page.php') ) );}/** * Retrieve path of page template in current or parent template. * * Will first look for the specifically assigned page template * The will search for 'page-{slug}.php' followed by 'page-id.php' * and finally 'page.php' * * @since 1.5.0 * * @return string */function get_page_template() {	global $wp_query;	$id = (int) $wp_query->get_queried_object_id();	$template = get_post_meta($id, '_wp_page_template', true);	$pagename = get_query_var('pagename');	if ( !$pagename && $id > 0 ) {		// If a static page is set as the front page, $pagename will not be set. Retrieve it from the queried object		$post = $wp_query->get_queried_object();		$pagename = $post->post_name;	}	if ( 'default' == $template )		$template = '';	$templates = array();	if ( !empty($template) && !validate_file($template) )		$templates[] = $template;	if ( $pagename )		$templates[] = "page-$pagename.php";	if ( $id )		$templates[] = "page-$id.php";	$templates[] = "page.php";	return apply_filters('page_template', locate_template($templates));}/** * Retrieve path of paged template in current or parent template. * * @since 1.5.0 * * @return string */function get_paged_template() {	return get_query_template('paged');}/** * Retrieve path of search template in current or parent template. * * @since 1.5.0 * * @return string */function get_search_template() {	return get_query_template('search');}/** * Retrieve path of single template in current or parent template. * * @since 1.5.0 * * @return string */function get_single_template() {	global $wp_query;	$object = $wp_query->get_queried_object();	$templates = array('single-' . $object->post_type . '.php', 'single.php');	return apply_filters('single_template', locate_template($templates));}/** * Retrieve path of attachment template in current or parent template. * * The attachment path first checks if the first part of the mime type exists. * The second check is for the second part of the mime type. The last check is * for both types separated by an underscore. If neither are found then the file * 'attachment.php' is checked and returned. * * Some examples for the 'text/plain' mime type are 'text.php', 'plain.php', and * finally 'text_plain.php'. * * @since 2.0.0 * * @return string */function get_attachment_template() {	global $posts;	$type = explode('/', $posts[0]->post_mime_type);	if ( $template = get_query_template($type[0]) )		return $template;	elseif ( $template = get_query_template($type[1]) )		return $template;	elseif ( $template = get_query_template("$type[0]_$type[1]") )		return $template;	else		return get_query_template('attachment');}/** * Retrieve path of comment popup template in current or parent template. * * Checks for comment popup template in current template, if it exists or in the * parent template. * * @since 1.5.0 * @uses apply_filters() Calls 'comments_popup_template' filter on path. * * @return string */function get_comments_popup_template() {	$template = locate_template(array("comments-popup.php"));	// Backward compat code will be removed in a future release	if ('' == $template)		$template = WPINC . '/theme-compat/comments-popup.php';	return apply_filters('comments_popup_template', $template);}/** * Retrieve the name of the highest priority template file that exists. * * Searches in the STYLESHEETPATH before TEMPLATEPATH so that themes which * inherit from a parent theme can just overload one file. * * @since 2.7.0 * * @param array $template_names Array of template files to search for in priority order. * @param bool $load If true the template file will be loaded if it is found. * @param bool $require_once Whether to require_once or require. Default true. Has no effect if $load is false. * @return string The template filename if one is located. */function locate_template($template_names, $load = false, $require_once = true ) {	if ( !is_array($template_names) )		return '';	$located = '';	foreach ( $template_names as $template_name ) {		if ( !$template_name )			continue;		if ( file_exists(STYLESHEETPATH . '/' . $template_name)) {			$located = STYLESHEETPATH . '/' . $template_name;			break;		} else if ( file_exists(TEMPLATEPATH . '/' . $template_name) ) {			$located = TEMPLATEPATH . '/' . $template_name;			break;		}	}	if ( $load && '' != $located )		load_template( $located, $require_once );	return $located;}/** * Require the template file with WordPress environment. * * The globals are set up for the template file to ensure that the WordPress * environment is available from within the function. The query variables are * also available. * * @since 1.5.0 * * @param string $_template_file Path to template file. * @param bool $require_once Whether to require_once or require. Default true. */function load_template( $_template_file, $require_once = true ) {	global $posts, $post, $wp_did_header, $wp_did_template_redirect, $wp_query, $wp_rewrite, $wpdb, $wp_version, $wp, $id, $comment, $user_ID;	if ( is_array( $wp_query->query_vars ) )		extract( $wp_query->query_vars, EXTR_SKIP );	if ( $require_once )		require_once( $_template_file );	else		require( $_template_file );}/** * Display localized stylesheet link element. * * @since 2.1.0 */function locale_stylesheet() {	$stylesheet = get_locale_stylesheet_uri();	if ( empty($stylesheet) )		return;	echo '<link rel="stylesheet" href="' . $stylesheet . '" type="text/css" media="screen" />';}/** * Start preview theme output buffer. * * Will only preform task if the user has permissions and template and preview * query variables exist. * * @since 2.6.0 */function preview_theme() {	if ( ! (isset($_GET['template']) && isset($_GET['preview'])) )		return;	if ( !current_user_can( 'switch_themes' ) )		return;	$_GET['template'] = preg_replace('|[^a-z0-9_./-]|i', '', $_GET['template']);	if ( validate_file($_GET['template']) )		return;	add_filter( 'template', '_preview_theme_template_filter' );	if ( isset($_GET['stylesheet']) ) {		$_GET['stylesheet'] = preg_replace('|[^a-z0-9_./-]|i', '', $_GET['stylesheet']);		if ( validate_file($_GET['stylesheet']) )			return;		add_filter( 'stylesheet', '_preview_theme_stylesheet_filter' );	}	// Prevent theme mods to current theme being used on theme being previewed	add_filter( 'pre_option_mods_' . get_current_theme(), '__return_empty_array' );	ob_start( 'preview_theme_ob_filter' );}add_action('setup_theme', 'preview_theme');/** * Private function to modify the current template when previewing a theme * * @since 2.9.0 * @access private * * @return string */function _preview_theme_template_filter() {	return isset($_GET['template']) ? $_GET['template'] : '';}/** * Private function to modify the current stylesheet when previewing a theme * * @since 2.9.0 * @access private * * @return string */function _preview_theme_stylesheet_filter() {	return isset($_GET['stylesheet']) ? $_GET['stylesheet'] : '';}/** * Callback function for ob_start() to capture all links in the theme. * * @since 2.6.0 * @access private * * @param string $content * @return string */function preview_theme_ob_filter( $content ) {	return preg_replace_callback( "|(<a.*?href=([\"']))(.*?)([\"'].*?>)|", 'preview_theme_ob_filter_callback', $content );}/** * Manipulates preview theme links in order to control and maintain location. * * Callback function for preg_replace_callback() to accept and filter matches. * * @since 2.6.0 * @access private * * @param array $matches * @return string */function preview_theme_ob_filter_callback( $matches ) {	if ( strpos($matches[4], 'onclick') !== false )		$matches[4] = preg_replace('#onclick=([\'"]).*?(?<!\\\)\\1#i', '', $matches[4]); //Strip out any onclicks from rest of <a>. (?<!\\\) means to ignore the '" if its escaped by \  to prevent breaking mid-attribute.	if (		( false !== strpos($matches[3], '/wp-admin/') )	||		( false !== strpos( $matches[3], '://' ) && 0 !== strpos( $matches[3], home_url() ) )	||		( false !== strpos($matches[3], '/feed/') )	||		( false !== strpos($matches[3], '/trackback/') )	)		return $matches[1] . "#$matches[2] onclick=$matches[2]return false;" . $matches[4];	$link = add_query_arg( array('preview' => 1, 'template' => $_GET['template'], 'stylesheet' => @$_GET['stylesheet'] ), $matches[3] );	if ( 0 === strpos($link, 'preview=1') )		$link = "?$link";	return $matches[1] . esc_attr( $link ) . $matches[4];}/** * Switches current theme to new template and stylesheet names. * * @since unknown * @uses do_action() Calls 'switch_theme' action on updated theme display name. * * @param string $template Template name * @param string $stylesheet Stylesheet name. */function switch_theme($template, $stylesheet) {	update_option('template', $template);	update_option('stylesheet', $stylesheet);	delete_option('current_theme');	$theme = get_current_theme();	do_action('switch_theme', $theme);}/** * Checks that current theme files 'index.php' and 'style.css' exists. * * Does not check the default theme, which is the fallback and should always exist. * Will switch theme to the fallback theme if current theme does not validate. * You can use the 'validate_current_theme' filter to return FALSE to * disable this functionality. * * @since 1.5.0 * @see WP_DEFAULT_THEME * * @return bool */function validate_current_theme() {	// Don't validate during an install/upgrade.	if ( defined('WP_INSTALLING') || !apply_filters( 'validate_current_theme', true ) )		return true;	if ( get_template() != WP_DEFAULT_THEME && !file_exists(get_template_directory() . '/index.php') ) {		switch_theme( WP_DEFAULT_THEME, WP_DEFAULT_THEME );		return false;	}	if ( get_stylesheet() != WP_DEFAULT_THEME && !file_exists(get_template_directory() . '/style.css') ) {		switch_theme( WP_DEFAULT_THEME, WP_DEFAULT_THEME );		return false;	}	return true;}/** * Retrieve theme modification value for the current theme. * * If the modification name does not exist, then the $default will be passed * through {@link http://php.net/sprintf sprintf()} PHP function with the first * string the template directory URI and the second string the stylesheet * directory URI. * * @since 2.1.0 * @uses apply_filters() Calls 'theme_mod_$name' filter on the value. * * @param string $name Theme modification name. * @param bool|string $default * @return string */function get_theme_mod($name, $default = false) {	$theme = get_current_theme();	$mods = get_option( "mods_$theme" );	if ( isset($mods[$name]) )		return apply_filters( "theme_mod_$name", $mods[$name] );	return apply_filters( "theme_mod_$name", sprintf($default, get_template_directory_uri(), get_stylesheet_directory_uri()) );}/** * Update theme modification value for the current theme. * * @since 2.1.0 * * @param string $name Theme modification name. * @param string $value theme modification value. */function set_theme_mod($name, $value) {	$theme = get_current_theme();	$mods = get_option("mods_$theme");	$mods[$name] = $value;	update_option("mods_$theme", $mods);	wp_cache_delete("mods_$theme", 'options');}/** * Remove theme modification name from current theme list. * * If removing the name also removes all elements, then the entire option will * be removed. * * @since 2.1.0 * * @param string $name Theme modification name. * @return null */function remove_theme_mod( $name ) {	$theme = get_current_theme();	$mods = get_option("mods_$theme");	if ( !isset($mods[$name]) )		return;	unset($mods[$name]);	if ( empty($mods) )		return remove_theme_mods();	update_option("mods_$theme", $mods);	wp_cache_delete("mods_$theme", 'options');}/** * Remove theme modifications option for current theme. * * @since 2.1.0 */function remove_theme_mods() {	$theme = get_current_theme();	delete_option("mods_$theme");}/** * Retrieve text color for custom header. * * @since 2.1.0 * @uses HEADER_TEXTCOLOR * * @return string */function get_header_textcolor() {	$default = defined('HEADER_TEXTCOLOR') ? HEADER_TEXTCOLOR : '';	return get_theme_mod('header_textcolor', $default);}/** * Display text color for custom header. * * @since 2.1.0 */function header_textcolor() {	echo get_header_textcolor();}/** * Retrieve header image for custom header. * * @since 2.1.0 * @uses HEADER_IMAGE * * @return string */function get_header_image() {	$default = defined('HEADER_IMAGE') ? HEADER_IMAGE : '';	return get_theme_mod('header_image', $default);}/** * Display header image path. * * @since 2.1.0 */function header_image() {	echo get_header_image();}/** * Add callbacks for image header display. * * The parameter $header_callback callback will be required to display the * content for the 'wp_head' action. The parameter $admin_header_callback * callback will be added to Custom_Image_Header class and that will be added * to the 'admin_menu' action. * * @since 2.1.0 * @uses Custom_Image_Header Sets up for $admin_header_callback for administration panel display. * * @param callback $header_callback Call on 'wp_head' action. * @param callback $admin_header_callback Call on custom header administration screen. * @param callback $admin_image_div_callback Output a custom header image div on the custom header administration screen. Optional. */function add_custom_image_header($header_callback, $admin_header_callback, $admin_image_div_callback = '') {	if ( ! empty($header_callback) )		add_action('wp_head', $header_callback);	add_theme_support( 'custom-header' );	if ( ! is_admin() )		return;	require_once(ABSPATH . 'wp-admin/custom-header.php');	$GLOBALS['custom_image_header'] =& new Custom_Image_Header($admin_header_callback, $admin_image_div_callback);	add_action('admin_menu', array(&$GLOBALS['custom_image_header'], 'init'));}/** * Register a selection of default headers to be displayed by the custom header admin UI. * * @since 3.0.0 * * @param array $headers Array of headers keyed by a string id. The ids point to arrays containing 'url', 'thumbnail_url', and 'description' keys. */function register_default_headers( $headers ) {	global $_wp_default_headers;	$_wp_default_headers = array_merge( (array) $_wp_default_headers, (array) $headers );}/** * Unregister default headers. * * This function must be called after register_default_headers() has already added the * header you want to remove. * * @see register_default_headers() * @since 3.0.0 * * @param string|array The header string id (key of array) to remove, or an array thereof. * @return True on success, false on failure. */function unregister_default_headers( $header ) {	global $_wp_default_headers;	if ( is_array( $header ) ) {		array_map( 'unregister_default_headers', $header );	} elseif ( isset( $_wp_default_headers[ $header ] ) ) {		unset( $_wp_default_headers[ $header ] );		return true;	} else {		return false;	}}/** * Retrieve background image for custom background. * * @since 3.0.0 * * @return string */function get_background_image() {	$default = defined('BACKGROUND_IMAGE') ? BACKGROUND_IMAGE : '';	return get_theme_mod('background_image', $default);}/** * Display background image path. * * @since 3.0.0 */function background_image() {	echo get_background_image();}/** * Retrieve value for custom background color. * * @since 3.0.0 * @uses BACKGROUND_COLOR * * @return string */function get_background_color() {	$default = defined('BACKGROUND_COLOR') ? BACKGROUND_COLOR : '';	return get_theme_mod('background_color', $default);}/** * Display background color value. * * @since 3.0.0 */function background_color() {	echo get_background_color();}/** * Add callbacks for background image display. * * The parameter $header_callback callback will be required to display the * content for the 'wp_head' action. The parameter $admin_header_callback * callback will be added to Custom_Background class and that will be added * to the 'admin_menu' action. * * @since 3.0.0 * @uses Custom_Background Sets up for $admin_header_callback for administration panel display. * * @param callback $header_callback Call on 'wp_head' action. * @param callback $admin_header_callback Call on custom background administration screen. * @param callback $admin_image_div_callback Output a custom background image div on the custom background administration screen. Optional. */function add_custom_background($header_callback = '', $admin_header_callback = '', $admin_image_div_callback = '') {	if ( isset($GLOBALS['custom_background']) )		return;	if ( empty($header_callback) )		$header_callback = '_custom_background_cb';	add_action('wp_head', $header_callback);	add_theme_support( 'custom-background' );	if ( ! is_admin() )		return;	require_once(ABSPATH . 'wp-admin/custom-background.php');	$GLOBALS['custom_background'] =& new Custom_Background($admin_header_callback, $admin_image_div_callback);	add_action('admin_menu', array(&$GLOBALS['custom_background'], 'init'));}/** * Default custom background callback. * * @since 3.0.0 * @see add_custom_background() * @access protected */function _custom_background_cb() {	$background = get_background_image();	$color = get_background_color();	if ( ! $background && ! $color )		return;	$style = $color ? "background-color: #$color;" : '';	if ( $background ) {		$image = " background-image: url('$background');";		$repeat = get_theme_mod( 'background_repeat', 'repeat' );		if ( ! in_array( $repeat, array( 'no-repeat', 'repeat-x', 'repeat-y', 'repeat' ) ) )			$repeat = 'repeat';		$repeat = " background-repeat: $repeat;";		$position = get_theme_mod( 'background_position_x', 'left' );		if ( ! in_array( $position, array( 'center', 'right', 'left' ) ) )			$position = 'left';		$position = " background-position: top $position;";		$attachment = get_theme_mod( 'background_attachment', 'scroll' );		if ( ! in_array( $attachment, array( 'fixed', 'scroll' ) ) )			$attachment = 'scroll';		$attachment = " background-attachment: $attachment;";		$style .= $image . $repeat . $position . $attachment;	}?><style type="text/css">body { <?php echo trim( $style ); ?> }</style><?php}/** * Add callback for custom TinyMCE editor stylesheets. * * The parameter $stylesheet is the name of the stylesheet, relative to * the theme root. It also accepts an array of stylesheets. * It is optional and defaults to 'editor-style.css'. * * @since 3.0.0 * * @param mixed $stylesheet Optional. Stylesheet name or array thereof, relative to theme root. * 	Defaults to 'editor-style.css' */function add_editor_style( $stylesheet = 'editor-style.css' ) {	add_theme_support( 'editor-style' );	if ( ! is_admin() )		return;	global $editor_styles;	$editor_styles = (array) $editor_styles;	$stylesheet    = (array) $stylesheet;	if ( is_rtl() ) {		$rtl_stylesheet = str_replace('.css', '-rtl.css', $stylesheet[0]);		$stylesheet[] = $rtl_stylesheet;	}	$editor_styles = array_merge( $editor_styles, $stylesheet );}/** * Allows a theme to register its support of a certain feature * * Must be called in the theme's functions.php file to work. * If attached to a hook, it must be after_setup_theme. * The init hook may be too late for some features. * * @since 2.9.0 * @param string $feature the feature being added */function add_theme_support( $feature ) {	global $_wp_theme_features;	if ( func_num_args() == 1 )		$_wp_theme_features[$feature] = true;	else		$_wp_theme_features[$feature] = array_slice( func_get_args(), 1 );}/** * Allows a theme to de-register its support of a certain feature * * Should be called in the theme's functions.php file. Generally would * be used for child themes to override support from the parent theme. * * @since 3.0.0 * @see add_theme_support() * @param string $feature the feature being added * @return bool Whether feature was removed. */function remove_theme_support( $feature ) {	// Blacklist: for internal registrations not used directly by themes.	if ( in_array( $feature, array( 'custom-background', 'custom-header', 'editor-style', 'widgets' ) ) )		return false;	global $_wp_theme_features;	if ( ! isset( $_wp_theme_features[$feature] ) )		return false;	unset( $_wp_theme_features[$feature] );	return true;}/** * Checks a theme's support for a given feature * * @since 2.9.0 * @param string $feature the feature being checked * @return boolean */function current_theme_supports( $feature ) {	global $_wp_theme_features;	if ( !isset( $_wp_theme_features[$feature] ) )		return false;	// If no args passed then no extra checks need be performed	if ( func_num_args() <= 1 )		return true;	$args = array_slice( func_get_args(), 1 );	// @todo Allow pluggable arg checking	switch ( $feature ) {		case 'post-thumbnails':			// post-thumbnails can be registered for only certain content/post types by passing			// an array of types to add_theme_support().  If no array was passed, then			// any type is accepted			if ( true === $_wp_theme_features[$feature] )  // Registered for all types				return true;			$content_type = $args[0];			if ( in_array($content_type, $_wp_theme_features[$feature][0]) )				return true;			else				return false;			break;	}	return true;}/** * Checks a theme's support for a given feature before loading the functions which implement it. * * @since 2.9.0 * @param string $feature the feature being checked * @param string $include the file containing the functions that implement the feature */function require_if_theme_supports( $feature, $include) {	if ( current_theme_supports( $feature ) )		require ( $include );}/** * Checks an attachment being deleted to see if it's a header or background image. * * If true it removes the theme modification which would be pointing at the deleted * attachment * * @access private * @since 3.0.0 * @param int $id the attachment id */function _delete_attachment_theme_mod( $id ) {	$attachment_image = wp_get_attachment_url( $id );	$header_image = get_header_image();	$background_image = get_background_image();	if ( $header_image && $header_image == $attachment_image )		remove_theme_mod( 'header_image' );	if ( $background_image && $background_image == $attachment_image )		remove_theme_mod( 'background_image' );}add_action( 'delete_attachment', '_delete_attachment_theme_mod' );?>
<?php/** * Deprecated admin functions from past WordPress versions. You shouldn't use these * functions and look for the alternatives instead. The functions will be removed * in a later version. * * @package WordPress * @subpackage Deprecated *//* * Deprecated functions come here to die. *//** * @since 2.1 * @deprecated 2.1 * @deprecated Use wp_tiny_mce(). * @see wp_tiny_mce() */function tinymce_include() {	_deprecated_function( __FUNCTION__, '2.1', 'wp_tiny_mce()' );	wp_tiny_mce();}/** * Unused Admin function. * * @since 2.0 * @deprecated 2.5 * */function documentation_link() {	_deprecated_function( __FUNCTION__, '2.5', '' );	return;}/** * Calculates the new dimentions for a downsampled image. * * @since 2.0.0 * @deprecated 3.0.0 * @deprecated Use wp_constrain_dimensions() * * @param int $width Current width of the image * @param int $height Current height of the image * @param int $wmax Maximum wanted width * @param int $hmax Maximum wanted height * @return mixed Array(height,width) of shrunk dimensions. */function wp_shrink_dimensions( $width, $height, $wmax = 128, $hmax = 96 ) {	_deprecated_function( __FUNCTION__, '3.0', 'wp_constrain_dimensions()' );	return wp_constrain_dimensions( $width, $height, $wmax, $hmax );}/** * {@internal Missing Short Description}} * * @since unknown * @deprecated unknown * @deprecated Use wp_category_checklist() * @see wp_category_checklist() * * @param unknown_type $default * @param unknown_type $parent * @param unknown_type $popular_ids */function dropdown_categories( $default = 0, $parent = 0, $popular_ids = array() ) {	_deprecated_function( __FUNCTION__, '0.0', 'wp_category_checklist()' );	global $post_ID;	wp_category_checklist( $post_ID );}/** * {@internal Missing Short Description}} * * @since unknown * @deprecated unknown * @deprecated Use wp_link_category_checklist() * @see wp_link_category_checklist() * * @param unknown_type $default */function dropdown_link_categories( $default = 0 ) {	_deprecated_function( __FUNCTION__, '0.0', 'wp_link_category_checklist()' );	global $link_id;	wp_link_category_checklist( $link_id );}/** * {@internal Missing Short Description}} * * @since unknown * @deprecated 3.0.0 * @deprecated Use wp_dropdown_categories() * @see wp_dropdown_categories() * * @param unknown_type $currentcat * @param unknown_type $currentparent * @param unknown_type $parent * @param unknown_type $level * @param unknown_type $categories * @return unknown */function wp_dropdown_cats( $currentcat = 0, $currentparent = 0, $parent = 0, $level = 0, $categories = 0 ) {	_deprecated_function( __FUNCTION__, '3.0', 'wp_dropdown_categories()' );	if (!$categories )		$categories = get_categories( array('hide_empty' => 0) );	if ( $categories ) {		foreach ( $categories as $category ) {			if ( $currentcat != $category->term_id && $parent == $category->parent) {				$pad = str_repeat( '&#8211; ', $level );				$category->name = esc_html( $category->name );				echo "\n\t<option value='$category->term_id'";				if ( $currentparent == $category->term_id )					echo " selected='selected'";				echo ">$pad$category->name</option>";				wp_dropdown_cats( $currentcat, $currentparent, $category->term_id, $level +1, $categories );			}		}	} else {		return false;	}}/** * Register a setting and its sanitization callback * * @since 2.7.0 * @deprecated 3.0.0 * @deprecated Use register_setting() * @see register_setting() * * @param string $option_group A settings group name.  Should correspond to a whitelisted option key name. * 	Default whitelisted option key names include "general," "discussion," and "reading," among others. * @param string $option_name The name of an option to sanitize and save. * @param unknown_type $sanitize_callback A callback function that sanitizes the option's value. * @return unknown */function add_option_update_handler( $option_group, $option_name, $sanitize_callback = '' ) {	_deprecated_function( __FUNCTION__, '3.0', 'register_setting()' );	return register_setting( $option_group, $option_name, $sanitize_callback );}/** * Unregister a setting * * @since 2.7.0 * @deprecated 3.0.0 * @deprecated Use unregister_setting() * @see unregister_setting() * * @param unknown_type $option_group * @param unknown_type $option_name * @param unknown_type $sanitize_callback * @return unknown */function remove_option_update_handler( $option_group, $option_name, $sanitize_callback = '' ) {	_deprecated_function( __FUNCTION__, '3.0', 'unregister_setting()' );	return unregister_setting( $option_group, $option_name, $sanitize_callback );}/** * Determines the language to use for CodePress syntax highlighting. * * @since 2.8.0 * @deprecated 3.0.0 * * @param string $filename**/function codepress_get_lang( $filename ) {	_deprecated_function( __FUNCTION__, '3.0' );	return;}/** * Adds Javascript required to make CodePress work on the theme/plugin editors. * * @since 2.8.0 * @deprecated 3.0.0**/function codepress_footer_js() {	_deprecated_function( __FUNCTION__, '3.0' );	return;}/** * Determine whether to use CodePress. * * @since 2.8 * @deprecated 3.0.0**/function use_codepress() {	_deprecated_function( __FUNCTION__, '3.0' );	return;}?>
<?php/** * Install theme administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can('install_themes') )	wp_die(__('You do not have sufficient permissions to install themes on this site.'));include(ABSPATH . 'wp-admin/includes/theme-install.php');$title = __('Install Themes');$parent_file = 'themes.php';$submenu_file = 'themes.php';wp_reset_vars( array('tab', 'paged') );wp_enqueue_style( 'theme-install' );wp_enqueue_script( 'theme-install' );add_thickbox();wp_enqueue_script( 'theme-preview' );//These are the tabs which are shown on the page,$tabs = array();$tabs['dashboard'] = __('Search');if ( 'search' == $tab )	$tabs['search']	= __('Search Results');$tabs['upload'] = __('Upload');$tabs['featured'] = _x('Featured','Theme Installer');//$tabs['popular']  = _x('Popular','Theme Installer');$tabs['new']      = _x('Newest','Theme Installer');$tabs['updated']  = _x('Recently Updated','Theme Installer');$nonmenu_tabs = array('theme-information'); //Valid actions to perform which do not have a Menu item.$tabs = apply_filters('install_themes_tabs', $tabs );$nonmenu_tabs = apply_filters('install_themes_nonmenu_tabs', $nonmenu_tabs);//If a non-valid menu tab has been selected, And its not a non-menu action.if ( empty($tab) || ( ! isset($tabs[ $tab ]) && ! in_array($tab, (array)$nonmenu_tabs) ) ) {	$tab_actions = array_keys($tabs);	$tab = $tab_actions[0];}if ( empty($paged) )	$paged = 1;$body_id = $tab;do_action('install_themes_pre_' . $tab); //Used to override the general interface, Eg, install or theme information.$help = '<p>' . sprintf(__('You can find additional themes for your site by using the Theme Browser/Installer on this screen, which will display themes from the <a href="%s" target="_blank">WordPress.org Theme Directory</a>. These themes are designed and developed by third parties, are available free of charge, and are licensed under the GNU General Public License, version 2, just like WordPress.'), 'http://wordpress.org/extend/themes/') . '</p>';$help .= '<p>' . __('You can Search for themes by keyword, author, or tag, or can get more specific and search by criteria listed in the feature filter. Alternately, you can browse the themes that are Featured, Newest, or Recently Updated. When you find a theme you like, you can preview it or install it.') . '</p>';$help .= '<p>' . __('You can Upload a theme manually if you have already downloaded its ZIP archive onto your computer (make sure it is from a trusted and original source). You can also do it the old-fashioned way and copy a downloaded theme&#8217;s folder via FTP into your <code>/wp-content/themes</code> directory.') . '</p>';$help .= '<p><strong>' . __('For more information:') . '</strong></p>';$help .= '<p>' . __('<a href="http://codex.wordpress.org/Using_Themes#Adding_New_Themes" target="_blank">Documentation on Adding New Themes</a>') . '</p>';$help .= '<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>';add_contextual_help($current_screen, $help);include('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><a href="themes.php" class="nav-tab"><?php echo esc_html_x('Manage Themes', 'theme'); ?></a><a href="theme-install.php" class="nav-tab nav-tab-active"><?php echo esc_html( $title ); ?></a></h2>	<ul class="subsubsub"><?php$display_tabs = array();foreach ( (array)$tabs as $action => $text ) {	$sep = ( end($tabs) != $text ) ? ' | ' : '';	$class = ( $action == $tab ) ? ' class="current"' : '';	$href = admin_url('theme-install.php?tab='. $action);	echo "\t\t<li><a href='$href'$class>$text</a>$sep</li>\n";}?>	</ul>	<br class="clear" />	<?php do_action('install_themes_' . $tab, $paged); ?></div><?phpinclude('./admin-footer.php');
<?php/** * The loop that displays posts. * * The loop displays the posts and the post content.  See * http://codex.wordpress.org/The_Loop to understand it and * http://codex.wordpress.org/Template_Tags to understand * the tags used in it. * * This can be overridden in child themes with loop.php or * loop-template.php, where 'template' is the loop context * requested by a template. For example, loop-index.php would * be used if it exists and we ask for the loop with: * <code>get_template_part( 'loop', 'index' );</code> * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */?><?php /* Display navigation to next/previous pages when applicable */ ?><?php if ( $wp_query->max_num_pages > 1 ) : ?>	<div id="nav-above" class="navigation">		<div class="nav-previous"><?php next_posts_link( __( '<span class="meta-nav">&larr;</span> Older posts', 'twentyten' ) ); ?></div>		<div class="nav-next"><?php previous_posts_link( __( 'Newer posts <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?></div>	</div><!-- #nav-above --><?php endif; ?><?php /* If there are no posts to display, such as an empty archive page */ ?><?php if ( ! have_posts() ) : ?>	<div id="post-0" class="post error404 not-found">		<h1 class="entry-title"><?php _e( 'Not Found', 'twentyten' ); ?></h1>		<div class="entry-content">			<p><?php _e( 'Apologies, but no results were found for the requested archive. Perhaps searching will help find a related post.', 'twentyten' ); ?></p>			<?php get_search_form(); ?>		</div><!-- .entry-content -->	</div><!-- #post-0 --><?php endif; ?><?php	/* Start the Loop.	 *	 * In Twenty Ten we use the same loop in multiple contexts.	 * It is broken into three main parts: when we're displaying	 * posts that are in the gallery category, when we're displaying	 * posts in the asides category, and finally all other posts.	 *	 * Additionally, we sometimes check for whether we are on an	 * archive page, a search page, etc., allowing for small differences	 * in the loop on each template without actually duplicating	 * the rest of the loop that is shared.	 *	 * Without further ado, the loop:	 */ ?><?php while ( have_posts() ) : the_post(); ?><?php /* How to display posts in the Gallery category. */ ?>	<?php if ( in_category( _x('gallery', 'gallery category slug', 'twentyten') ) ) : ?>		<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>			<h2 class="entry-title"><a href="<?php the_permalink(); ?>" title="<?php printf( esc_attr__( 'Permalink to %s', 'twentyten' ), the_title_attribute( 'echo=0' ) ); ?>" rel="bookmark"><?php the_title(); ?></a></h2>			<div class="entry-meta">				<?php twentyten_posted_on(); ?>			</div><!-- .entry-meta -->			<div class="entry-content"><?php if ( post_password_required() ) : ?>				<?php the_content(); ?><?php else : ?>				<div class="gallery-thumb"><?php	$images = get_children( array( 'post_parent' => $post->ID, 'post_type' => 'attachment', 'post_mime_type' => 'image', 'orderby' => 'menu_order', 'order' => 'ASC', 'numberposts' => 999 ) );	$total_images = count( $images );	$image = array_shift( $images );	$image_img_tag = wp_get_attachment_image( $image->ID, 'thumbnail' );?>					<a class="size-thumbnail" href="<?php the_permalink(); ?>"><?php echo $image_img_tag; ?></a>				</div><!-- .gallery-thumb -->				<p><em><?php printf( __( 'This gallery contains <a %1$s>%2$s photos</a>.', 'twentyten' ),						'href="' . get_permalink() . '" title="' . sprintf( esc_attr__( 'Permalink to %s', 'twentyten' ), the_title_attribute( 'echo=0' ) ) . '" rel="bookmark"',						$total_images					); ?></em></p>				<?php the_excerpt(); ?><?php endif; ?>			</div><!-- .entry-content -->			<div class="entry-utility">				<a href="<?php echo get_term_link( _x('gallery', 'gallery category slug', 'twentyten'), 'category' ); ?>" title="<?php esc_attr_e( 'View posts in the Gallery category', 'twentyten' ); ?>"><?php _e( 'More Galleries', 'twentyten' ); ?></a>				<span class="meta-sep">|</span>				<span class="comments-link"><?php comments_popup_link( __( 'Leave a comment', 'twentyten' ), __( '1 Comment', 'twentyten' ), __( '% Comments', 'twentyten' ) ); ?></span>				<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="meta-sep">|</span> <span class="edit-link">', '</span>' ); ?>			</div><!-- .entry-utility -->		</div><!-- #post-## --><?php /* How to display posts in the asides category */ ?>	<?php elseif ( in_category( _x('asides', 'asides category slug', 'twentyten') ) ) : ?>		<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>		<?php if ( is_archive() || is_search() ) : // Display excerpts for archives and search. ?>			<div class="entry-summary">				<?php the_excerpt(); ?>			</div><!-- .entry-summary -->		<?php else : ?>			<div class="entry-content">				<?php the_content( __( 'Continue reading <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?>			</div><!-- .entry-content -->		<?php endif; ?>			<div class="entry-utility">				<?php twentyten_posted_on(); ?>				<span class="meta-sep">|</span>				<span class="comments-link"><?php comments_popup_link( __( 'Leave a comment', 'twentyten' ), __( '1 Comment', 'twentyten' ), __( '% Comments', 'twentyten' ) ); ?></span>				<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="meta-sep">|</span> <span class="edit-link">', '</span>' ); ?>			</div><!-- .entry-utility -->		</div><!-- #post-## --><?php /* How to display all other posts. */ ?>	<?php else : ?>		<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>			<h2 class="entry-title"><a href="<?php the_permalink(); ?>" title="<?php printf( esc_attr__( 'Permalink to %s', 'twentyten' ), the_title_attribute( 'echo=0' ) ); ?>" rel="bookmark"><?php the_title(); ?></a></h2>			<div class="entry-meta">				<?php twentyten_posted_on(); ?>			</div><!-- .entry-meta -->	<?php if ( is_archive() || is_search() ) : // Only display excerpts for archives and search. ?>			<div class="entry-summary">				<?php the_excerpt(); ?>			</div><!-- .entry-summary -->	<?php else : ?>			<div class="entry-content">				<?php the_content( __( 'Continue reading <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?>				<?php wp_link_pages( array( 'before' => '<div class="page-link">' . __( 'Pages:', 'twentyten' ), 'after' => '</div>' ) ); ?>			</div><!-- .entry-content -->	<?php endif; ?>			<div class="entry-utility">				<?php if ( count( get_the_category() ) ) : ?>					<span class="cat-links">						<?php printf( __( '<span class="%1$s">Posted in</span> %2$s', 'twentyten' ), 'entry-utility-prep entry-utility-prep-cat-links', get_the_category_list( ', ' ) ); ?>					</span>					<span class="meta-sep">|</span>				<?php endif; ?>				<?php					$tags_list = get_the_tag_list( '', ', ' );					if ( $tags_list ):				?>					<span class="tag-links">						<?php printf( __( '<span class="%1$s">Tagged</span> %2$s', 'twentyten' ), 'entry-utility-prep entry-utility-prep-tag-links', $tags_list ); ?>					</span>					<span class="meta-sep">|</span>				<?php endif; ?>				<span class="comments-link"><?php comments_popup_link( __( 'Leave a comment', 'twentyten' ), __( '1 Comment', 'twentyten' ), __( '% Comments', 'twentyten' ) ); ?></span>				<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="meta-sep">|</span> <span class="edit-link">', '</span>' ); ?>			</div><!-- .entry-utility -->		</div><!-- #post-## -->		<?php comments_template( '', true ); ?>	<?php endif; // This was the if statement that broke the loop into three parts based on categories. ?><?php endwhile; // End the loop. Whew. ?><?php /* Display navigation to next/previous pages when applicable */ ?><?php if (  $wp_query->max_num_pages > 1 ) : ?>				<div id="nav-below" class="navigation">					<div class="nav-previous"><?php next_posts_link( __( '<span class="meta-nav">&larr;</span> Older posts', 'twentyten' ) ); ?></div>					<div class="nav-next"><?php previous_posts_link( __( 'Newer posts <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?></div>				</div><!-- #nav-below --><?php endif; ?>
<?php/** * Manages WordPress comments * * @package WordPress * @subpackage Comment *//** * Checks whether a comment passes internal checks to be allowed to add. * * If comment moderation is set in the administration, then all comments, * regardless of their type and whitelist will be set to false. If the number of * links exceeds the amount in the administration, then the check fails. If any * of the parameter contents match the blacklist of words, then the check fails. * * If the number of links exceeds the amount in the administration, then the * check fails. If any of the parameter contents match the blacklist of words, * then the check fails. * * If the comment is a trackback and part of the blogroll, then the trackback is * automatically whitelisted. If the comment author was approved before, then * the comment is automatically whitelisted. * * If none of the checks fail, then the failback is to set the check to pass * (return true). * * @since 1.2.0 * @uses $wpdb * * @param string $author Comment Author's name * @param string $email Comment Author's email * @param string $url Comment Author's URL * @param string $comment Comment contents * @param string $user_ip Comment Author's IP address * @param string $user_agent Comment Author's User Agent * @param string $comment_type Comment type, either user submitted comment, *		trackback, or pingback * @return bool Whether the checks passed (true) and the comments should be *		displayed or set to moderated */function check_comment($author, $email, $url, $comment, $user_ip, $user_agent, $comment_type) {	global $wpdb;	if ( 1 == get_option('comment_moderation') )		return false; // If moderation is set to manual	// Check # of external links	if ( $max_links = get_option( 'comment_max_links' ) ) {		$num_links = preg_match_all( '/<a [^>]*href/i', apply_filters( 'comment_text', $comment ), $out );		$num_links = apply_filters( 'comment_max_links_url', $num_links, $url ); // provide for counting of $url as a link		if ( $num_links >= $max_links )			return false;	}	$mod_keys = trim(get_option('moderation_keys'));	if ( !empty($mod_keys) ) {		$words = explode("\n", $mod_keys );		foreach ( (array) $words as $word) {			$word = trim($word);			// Skip empty lines			if ( empty($word) )				continue;			// Do some escaping magic so that '#' chars in the			// spam words don't break things:			$word = preg_quote($word, '#');			$pattern = "#$word#i";			if ( preg_match($pattern, $author) ) return false;			if ( preg_match($pattern, $email) ) return false;			if ( preg_match($pattern, $url) ) return false;			if ( preg_match($pattern, $comment) ) return false;			if ( preg_match($pattern, $user_ip) ) return false;			if ( preg_match($pattern, $user_agent) ) return false;		}	}	// Comment whitelisting:	if ( 1 == get_option('comment_whitelist')) {		if ( 'trackback' == $comment_type || 'pingback' == $comment_type ) { // check if domain is in blogroll			$uri = parse_url($url);			$domain = $uri['host'];			$uri = parse_url( home_url() );			$home_domain = $uri['host'];			if ( $wpdb->get_var($wpdb->prepare("SELECT link_id FROM $wpdb->links WHERE link_url LIKE (%s) LIMIT 1", '%'.$domain.'%')) || $domain == $home_domain )				return true;			else				return false;		} elseif ( $author != '' && $email != '' ) {			// expected_slashed ($author, $email)			$ok_to_comment = $wpdb->get_var("SELECT comment_approved FROM $wpdb->comments WHERE comment_author = '$author' AND comment_author_email = '$email' and comment_approved = '1' LIMIT 1");			if ( ( 1 == $ok_to_comment ) &&				( empty($mod_keys) || false === strpos( $email, $mod_keys) ) )					return true;			else				return false;		} else {			return false;		}	}	return true;}/** * Retrieve the approved comments for post $post_id. * * @since 2.0.0 * @uses $wpdb * * @param int $post_id The ID of the post * @return array $comments The approved comments */function get_approved_comments($post_id) {	global $wpdb;	return $wpdb->get_results($wpdb->prepare("SELECT * FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved = '1' ORDER BY comment_date", $post_id));}/** * Retrieves comment data given a comment ID or comment object. * * If an object is passed then the comment data will be cached and then returned * after being passed through a filter. If the comment is empty, then the global * comment variable will be used, if it is set. * * If the comment is empty, then the global comment variable will be used, if it * is set. * * @since 2.0.0 * @uses $wpdb * * @param object|string|int $comment Comment to retrieve. * @param string $output Optional. OBJECT or ARRAY_A or ARRAY_N constants. * @return object|array|null Depends on $output value. */function &get_comment(&$comment, $output = OBJECT) {	global $wpdb;	$null = null;	if ( empty($comment) ) {		if ( isset($GLOBALS['comment']) )			$_comment = & $GLOBALS['comment'];		else			$_comment = null;	} elseif ( is_object($comment) ) {		wp_cache_add($comment->comment_ID, $comment, 'comment');		$_comment = $comment;	} else {		if ( isset($GLOBALS['comment']) && ($GLOBALS['comment']->comment_ID == $comment) ) {			$_comment = & $GLOBALS['comment'];		} elseif ( ! $_comment = wp_cache_get($comment, 'comment') ) {			$_comment = $wpdb->get_row($wpdb->prepare("SELECT * FROM $wpdb->comments WHERE comment_ID = %d LIMIT 1", $comment));			if ( ! $_comment )				return $null;			wp_cache_add($_comment->comment_ID, $_comment, 'comment');		}	}	$_comment = apply_filters('get_comment', $_comment);	if ( $output == OBJECT ) {		return $_comment;	} elseif ( $output == ARRAY_A ) {		$__comment = get_object_vars($_comment);		return $__comment;	} elseif ( $output == ARRAY_N ) {		$__comment = array_values(get_object_vars($_comment));		return $__comment;	} else {		return $_comment;	}}/** * Retrieve a list of comments. * * The comment list can be for the blog as a whole or for an individual post. * * The list of comment arguments are 'status', 'orderby', 'comment_date_gmt', * 'order', 'number', 'offset', and 'post_id'. * * @since 2.7.0 * @uses $wpdb * * @param mixed $args Optional. Array or string of options to override defaults. * @return array List of comments. */function get_comments( $args = '' ) {	global $wpdb;	$defaults = array(		'author_email' => '',		'ID' => '',		'karma' => '',		'number' => '',		'offset' => '',		'orderby' => '',		'order' => 'DESC',		'parent' => '',		'post_ID' => '',		'post_id' => 0,		'status' => '',		'type' => '',		'user_id' => '',	);	$args = wp_parse_args( $args, $defaults );	extract( $args, EXTR_SKIP );	// $args can be whatever, only use the args defined in defaults to compute the key	$key = md5( serialize( compact(array_keys($defaults)) )  );	$last_changed = wp_cache_get('last_changed', 'comment');	if ( !$last_changed ) {		$last_changed = time();		wp_cache_set('last_changed', $last_changed, 'comment');	}	$cache_key = "get_comments:$key:$last_changed";	if ( $cache = wp_cache_get( $cache_key, 'comment' ) ) {		return $cache;	}	$post_id = absint($post_id);	if ( 'hold' == $status )		$approved = "comment_approved = '0'";	elseif ( 'approve' == $status )		$approved = "comment_approved = '1'";	elseif ( 'spam' == $status )		$approved = "comment_approved = 'spam'";	elseif ( 'trash' == $status )		$approved = "comment_approved = 'trash'";	else		$approved = "( comment_approved = '0' OR comment_approved = '1' )";	$order = ( 'ASC' == $order ) ? 'ASC' : 'DESC';	if ( ! empty( $orderby ) ) {		$ordersby = is_array($orderby) ? $orderby : preg_split('/[,\s]/', $orderby);		$ordersby = array_intersect(			$ordersby,			array(				'comment_agent',				'comment_approved',				'comment_author',				'comment_author_email',				'comment_author_IP',				'comment_author_url',				'comment_content',				'comment_date',				'comment_date_gmt',				'comment_ID',				'comment_karma',				'comment_parent',				'comment_post_ID',				'comment_type',				'user_id',			)		);		$orderby = empty( $ordersby ) ? 'comment_date_gmt' : implode(', ', $ordersby);	} else {		$orderby = 'comment_date_gmt';	}	$number = absint($number);	$offset = absint($offset);	if ( !empty($number) ) {		if ( $offset )			$number = 'LIMIT ' . $offset . ',' . $number;		else			$number = 'LIMIT ' . $number;	} else {		$number = '';	}	$post_where = '';	if ( ! empty($post_id) )		$post_where .= $wpdb->prepare( 'comment_post_ID = %d AND ', $post_id );	if ( '' !== $author_email )		$post_where .= $wpdb->prepare( 'comment_author_email = %s AND ', $author_email );	if ( '' !== $karma )		$post_where .= $wpdb->prepare( 'comment_karma = %d AND ', $karma );	if ( 'comment' == $type )		$post_where .= "comment_type = '' AND ";	elseif ( ! empty( $type ) )		$post_where .= $wpdb->prepare( 'comment_type = %s AND ', $type );	if ( '' !== $parent )		$post_where .= $wpdb->prepare( 'comment_parent = %d AND ', $parent );	if ( '' !== $user_id )		$post_where .= $wpdb->prepare( 'user_id = %d AND ', $user_id );	$comments = $wpdb->get_results( "SELECT * FROM $wpdb->comments WHERE $post_where $approved ORDER BY $orderby $order $number" );	wp_cache_add( $cache_key, $comments, 'comment' );	return $comments;}/** * Retrieve all of the WordPress supported comment statuses. * * Comments have a limited set of valid status values, this provides the comment * status values and descriptions. * * @package WordPress * @subpackage Post * @since 2.7.0 * * @return array List of comment statuses. */function get_comment_statuses( ) {	$status = array(		'hold'		=> __('Unapproved'),		/* translators: comment status  */		'approve'	=> _x('Approved', 'adjective'),		/* translators: comment status */		'spam'		=> _x('Spam', 'adjective'),	);	return $status;}/** * The date the last comment was modified. * * @since 1.5.0 * @uses $wpdb * @global array $cache_lastcommentmodified * * @param string $timezone Which timezone to use in reference to 'gmt', 'blog', *		or 'server' locations. * @return string Last comment modified date. */function get_lastcommentmodified($timezone = 'server') {	global $cache_lastcommentmodified, $wpdb;	if ( isset($cache_lastcommentmodified[$timezone]) )		return $cache_lastcommentmodified[$timezone];	$add_seconds_server = date('Z');	switch ( strtolower($timezone)) {		case 'gmt':			$lastcommentmodified = $wpdb->get_var("SELECT comment_date_gmt FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1");			break;		case 'blog':			$lastcommentmodified = $wpdb->get_var("SELECT comment_date FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1");			break;		case 'server':			$lastcommentmodified = $wpdb->get_var($wpdb->prepare("SELECT DATE_ADD(comment_date_gmt, INTERVAL %s SECOND) FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1", $add_seconds_server));			break;	}	$cache_lastcommentmodified[$timezone] = $lastcommentmodified;	return $lastcommentmodified;}/** * The amount of comments in a post or total comments. * * A lot like {@link wp_count_comments()}, in that they both return comment * stats (albeit with different types). The {@link wp_count_comments()} actual * caches, but this function does not. * * @since 2.0.0 * @uses $wpdb * * @param int $post_id Optional. Comment amount in post if > 0, else total comments blog wide. * @return array The amount of spam, approved, awaiting moderation, and total comments. */function get_comment_count( $post_id = 0 ) {	global $wpdb;	$post_id = (int) $post_id;	$where = '';	if ( $post_id > 0 ) {		$where = $wpdb->prepare("WHERE comment_post_ID = %d", $post_id);	}	$totals = (array) $wpdb->get_results("		SELECT comment_approved, COUNT( * ) AS total		FROM {$wpdb->comments}		{$where}		GROUP BY comment_approved	", ARRAY_A);	$comment_count = array(		"approved"              => 0,		"awaiting_moderation"   => 0,		"spam"                  => 0,		"total_comments"        => 0	);	foreach ( $totals as $row ) {		switch ( $row['comment_approved'] ) {			case 'spam':				$comment_count['spam'] = $row['total'];				$comment_count["total_comments"] += $row['total'];				break;			case 1:				$comment_count['approved'] = $row['total'];				$comment_count['total_comments'] += $row['total'];				break;			case 0:				$comment_count['awaiting_moderation'] = $row['total'];				$comment_count['total_comments'] += $row['total'];				break;			default:				break;		}	}	return $comment_count;}//// Comment meta functions///** * Add meta data field to a comment. * * @since 2.9.0 * @uses add_metadata * @link http://codex.wordpress.org/Function_Reference/add_comment_meta * * @param int $comment_id Comment ID. * @param string $key Metadata name. * @param mixed $value Metadata value. * @param bool $unique Optional, default is false. Whether the same key should not be added. * @return bool False for failure. True for success. */function add_comment_meta($comment_id, $meta_key, $meta_value, $unique = false) {	return add_metadata('comment', $comment_id, $meta_key, $meta_value, $unique);}/** * Remove metadata matching criteria from a comment. * * You can match based on the key, or key and value. Removing based on key and * value, will keep from removing duplicate metadata with the same key. It also * allows removing all metadata matching key, if needed. * * @since 2.9.0 * @uses delete_metadata * @link http://codex.wordpress.org/Function_Reference/delete_comment_meta * * @param int $comment_id comment ID * @param string $meta_key Metadata name. * @param mixed $meta_value Optional. Metadata value. * @return bool False for failure. True for success. */function delete_comment_meta($comment_id, $meta_key, $meta_value = '') {	return delete_metadata('comment', $comment_id, $meta_key, $meta_value);}/** * Retrieve comment meta field for a comment. * * @since 2.9.0 * @uses get_metadata * @link http://codex.wordpress.org/Function_Reference/get_comment_meta * * @param int $comment_id Comment ID. * @param string $key The meta key to retrieve. * @param bool $single Whether to return a single value. * @return mixed Will be an array if $single is false. Will be value of meta data field if $single *  is true. */function get_comment_meta($comment_id, $key, $single = false) {	return get_metadata('comment', $comment_id, $key, $single);}/** * Update comment meta field based on comment ID. * * Use the $prev_value parameter to differentiate between meta fields with the * same key and comment ID. * * If the meta field for the comment does not exist, it will be added. * * @since 2.9.0 * @uses update_metadata * @link http://codex.wordpress.org/Function_Reference/update_comment_meta * * @param int $comment_id Comment ID. * @param string $key Metadata key. * @param mixed $value Metadata value. * @param mixed $prev_value Optional. Previous value to check before removing. * @return bool False on failure, true if success. */function update_comment_meta($comment_id, $meta_key, $meta_value, $prev_value = '') {	return update_metadata('comment', $comment_id, $meta_key, $meta_value, $prev_value);}/** * Sanitizes the cookies sent to the user already. * * Will only do anything if the cookies have already been created for the user. * Mostly used after cookies had been sent to use elsewhere. * * @since 2.0.4 */function sanitize_comment_cookies() {	if ( isset($_COOKIE['comment_author_'.COOKIEHASH]) ) {		$comment_author = apply_filters('pre_comment_author_name', $_COOKIE['comment_author_'.COOKIEHASH]);		$comment_author = stripslashes($comment_author);		$comment_author = esc_attr($comment_author);		$_COOKIE['comment_author_'.COOKIEHASH] = $comment_author;	}	if ( isset($_COOKIE['comment_author_email_'.COOKIEHASH]) ) {		$comment_author_email = apply_filters('pre_comment_author_email', $_COOKIE['comment_author_email_'.COOKIEHASH]);		$comment_author_email = stripslashes($comment_author_email);		$comment_author_email = esc_attr($comment_author_email);		$_COOKIE['comment_author_email_'.COOKIEHASH] = $comment_author_email;	}	if ( isset($_COOKIE['comment_author_url_'.COOKIEHASH]) ) {		$comment_author_url = apply_filters('pre_comment_author_url', $_COOKIE['comment_author_url_'.COOKIEHASH]);		$comment_author_url = stripslashes($comment_author_url);		$_COOKIE['comment_author_url_'.COOKIEHASH] = $comment_author_url;	}}/** * Validates whether this comment is allowed to be made. * * @since 2.0.0 * @uses $wpdb * @uses apply_filters() Calls 'pre_comment_approved' hook on the type of comment * @uses apply_filters() Calls 'comment_duplicate_trigger' hook on commentdata. * @uses do_action() Calls 'check_comment_flood' hook on $comment_author_IP, $comment_author_email, and $comment_date_gmt * * @param array $commentdata Contains information on the comment * @return mixed Signifies the approval status (0|1|'spam') */function wp_allow_comment($commentdata) {	global $wpdb;	extract($commentdata, EXTR_SKIP);	// Simple duplicate check	// expected_slashed ($comment_post_ID, $comment_author, $comment_author_email, $comment_content)	$dupe = "SELECT comment_ID FROM $wpdb->comments WHERE comment_post_ID = '$comment_post_ID' AND comment_approved != 'trash' AND ( comment_author = '$comment_author' ";	if ( $comment_author_email )		$dupe .= "OR comment_author_email = '$comment_author_email' ";	$dupe .= ") AND comment_content = '$comment_content' LIMIT 1";	if ( $wpdb->get_var($dupe) ) {		do_action( 'comment_duplicate_trigger', $commentdata );		if ( defined('DOING_AJAX') )			die( __('Duplicate comment detected; it looks as though you&#8217;ve already said that!') );		wp_die( __('Duplicate comment detected; it looks as though you&#8217;ve already said that!') );	}	do_action( 'check_comment_flood', $comment_author_IP, $comment_author_email, $comment_date_gmt );	if ( isset($user_id) && $user_id) {		$userdata = get_userdata($user_id);		$user = new WP_User($user_id);		$post_author = $wpdb->get_var($wpdb->prepare("SELECT post_author FROM $wpdb->posts WHERE ID = %d LIMIT 1", $comment_post_ID));	}	if ( isset($userdata) && ( $user_id == $post_author || $user->has_cap('moderate_comments') ) ) {		// The author and the admins get respect.		$approved = 1;	 } else {		// Everyone else's comments will be checked.		if ( check_comment($comment_author, $comment_author_email, $comment_author_url, $comment_content, $comment_author_IP, $comment_agent, $comment_type) )			$approved = 1;		else			$approved = 0;		if ( wp_blacklist_check($comment_author, $comment_author_email, $comment_author_url, $comment_content, $comment_author_IP, $comment_agent) )			$approved = 'spam';	}	$approved = apply_filters('pre_comment_approved', $approved);	return $approved;}/** * Check whether comment flooding is occurring. * * Won't run, if current user can manage options, so to not block * administrators. * * @since 2.3.0 * @uses $wpdb * @uses apply_filters() Calls 'comment_flood_filter' filter with first *		parameter false, last comment timestamp, new comment timestamp. * @uses do_action() Calls 'comment_flood_trigger' action with parameters with *		last comment timestamp and new comment timestamp. * * @param string $ip Comment IP. * @param string $email Comment author email address. * @param string $date MySQL time string. */function check_comment_flood_db( $ip, $email, $date ) {	global $wpdb;	if ( current_user_can( 'manage_options' ) )		return; // don't throttle admins	$hour_ago = gmdate( 'Y-m-d H:i:s', time() - 3600 );	if ( $lasttime = $wpdb->get_var( $wpdb->prepare( "SELECT `comment_date_gmt` FROM `$wpdb->comments` WHERE `comment_date_gmt` >= %s AND ( `comment_author_IP` = %s OR `comment_author_email` = %s ) ORDER BY `comment_date_gmt` DESC LIMIT 1", $hour_ago, $ip, $email ) ) ) {		$time_lastcomment = mysql2date('U', $lasttime, false);		$time_newcomment  = mysql2date('U', $date, false);		$flood_die = apply_filters('comment_flood_filter', false, $time_lastcomment, $time_newcomment);		if ( $flood_die ) {			do_action('comment_flood_trigger', $time_lastcomment, $time_newcomment);			if ( defined('DOING_AJAX') )				die( __('You are posting comments too quickly.  Slow down.') );			wp_die( __('You are posting comments too quickly.  Slow down.'), '', array('response' => 403) );		}	}}/** * Separates an array of comments into an array keyed by comment_type. * * @since 2.7.0 * * @param array $comments Array of comments * @return array Array of comments keyed by comment_type. */function &separate_comments(&$comments) {	$comments_by_type = array('comment' => array(), 'trackback' => array(), 'pingback' => array(), 'pings' => array());	$count = count($comments);	for ( $i = 0; $i < $count; $i++ ) {		$type = $comments[$i]->comment_type;		if ( empty($type) )			$type = 'comment';		$comments_by_type[$type][] = &$comments[$i];		if ( 'trackback' == $type || 'pingback' == $type )			$comments_by_type['pings'][] = &$comments[$i];	}	return $comments_by_type;}/** * Calculate the total number of comment pages. * * @since 2.7.0 * @uses get_query_var() Used to fill in the default for $per_page parameter. * @uses get_option() Used to fill in defaults for parameters. * @uses Walker_Comment * * @param array $comments Optional array of comment objects.  Defaults to $wp_query->comments * @param int $per_page Optional comments per page. * @param boolean $threaded Optional control over flat or threaded comments. * @return int Number of comment pages. */function get_comment_pages_count( $comments = null, $per_page = null, $threaded = null ) {	global $wp_query;	if ( null === $comments && null === $per_page && null === $threaded && !empty($wp_query->max_num_comment_pages) )		return $wp_query->max_num_comment_pages;	if ( !$comments || !is_array($comments) )		$comments = $wp_query->comments;	if ( empty($comments) )		return 0;	if ( !isset($per_page) )		$per_page = (int) get_query_var('comments_per_page');	if ( 0 === $per_page )		$per_page = (int) get_option('comments_per_page');	if ( 0 === $per_page )		return 1;	if ( !isset($threaded) )		$threaded = get_option('thread_comments');	if ( $threaded ) {		$walker = new Walker_Comment;		$count = ceil( $walker->get_number_of_root_elements( $comments ) / $per_page );	} else {		$count = ceil( count( $comments ) / $per_page );	}	return $count;}/** * Calculate what page number a comment will appear on for comment paging. * * @since 2.7.0 * @uses get_comment() Gets the full comment of the $comment_ID parameter. * @uses get_option() Get various settings to control function and defaults. * @uses get_page_of_comment() Used to loop up to top level comment. * * @param int $comment_ID Comment ID. * @param array $args Optional args. * @return int|null Comment page number or null on error. */function get_page_of_comment( $comment_ID, $args = array() ) {	global $wpdb;	if ( !$comment = get_comment( $comment_ID ) )		return;	$defaults = array( 'type' => 'all', 'page' => '', 'per_page' => '', 'max_depth' => '' );	$args = wp_parse_args( $args, $defaults );	if ( '' === $args['per_page'] && get_option('page_comments') )		$args['per_page'] = get_query_var('comments_per_page');	if ( empty($args['per_page']) ) {		$args['per_page'] = 0;		$args['page'] = 0;	}	if ( $args['per_page'] < 1 )		return 1;	if ( '' === $args['max_depth'] ) {		if ( get_option('thread_comments') )			$args['max_depth'] = get_option('thread_comments_depth');		else			$args['max_depth'] = -1;	}	// Find this comment's top level parent if threading is enabled	if ( $args['max_depth'] > 1 && 0 != $comment->comment_parent )		return get_page_of_comment( $comment->comment_parent, $args );	$allowedtypes = array(		'comment' => '',		'pingback' => 'pingback',		'trackback' => 'trackback',	);	$comtypewhere = ( 'all' != $args['type'] && isset($allowedtypes[$args['type']]) ) ? " AND comment_type = '" . $allowedtypes[$args['type']] . "'" : '';	// Count comments older than this one	$oldercoms = $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(comment_ID) FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_parent = 0 AND comment_approved = '1' AND comment_date_gmt < '%s'" . $comtypewhere, $comment->comment_post_ID, $comment->comment_date_gmt ) );	// No older comments? Then it's page #1.	if ( 0 == $oldercoms )		return 1;	// Divide comments older than this one by comments per page to get this comment's page number	return ceil( ( $oldercoms + 1 ) / $args['per_page'] );}/** * Does comment contain blacklisted characters or words. * * @since 1.5.0 * @uses do_action() Calls 'wp_blacklist_check' hook for all parameters. * * @param string $author The author of the comment * @param string $email The email of the comment * @param string $url The url used in the comment * @param string $comment The comment content * @param string $user_ip The comment author IP address * @param string $user_agent The author's browser user agent * @return bool True if comment contains blacklisted content, false if comment does not */function wp_blacklist_check($author, $email, $url, $comment, $user_ip, $user_agent) {	do_action('wp_blacklist_check', $author, $email, $url, $comment, $user_ip, $user_agent);	$mod_keys = trim( get_option('blacklist_keys') );	if ( '' == $mod_keys )		return false; // If moderation keys are empty	$words = explode("\n", $mod_keys );	foreach ( (array) $words as $word ) {		$word = trim($word);		// Skip empty lines		if ( empty($word) ) { continue; }		// Do some escaping magic so that '#' chars in the		// spam words don't break things:		$word = preg_quote($word, '#');		$pattern = "#$word#i";		if (			   preg_match($pattern, $author)			|| preg_match($pattern, $email)			|| preg_match($pattern, $url)			|| preg_match($pattern, $comment)			|| preg_match($pattern, $user_ip)			|| preg_match($pattern, $user_agent)		 )			return true;	}	return false;}/** * Retrieve total comments for blog or single post. * * The properties of the returned object contain the 'moderated', 'approved', * and spam comments for either the entire blog or single post. Those properties * contain the amount of comments that match the status. The 'total_comments' * property contains the integer of total comments. * * The comment stats are cached and then retrieved, if they already exist in the * cache. * * @since 2.5.0 * * @param int $post_id Optional. Post ID. * @return object Comment stats. */function wp_count_comments( $post_id = 0 ) {	global $wpdb;	$post_id = (int) $post_id;	$stats = apply_filters('wp_count_comments', array(), $post_id);	if ( !empty($stats) )		return $stats;	$count = wp_cache_get("comments-{$post_id}", 'counts');	if ( false !== $count )		return $count;	$where = '';	if ( $post_id > 0 )		$where = $wpdb->prepare( "WHERE comment_post_ID = %d", $post_id );	$count = $wpdb->get_results( "SELECT comment_approved, COUNT( * ) AS num_comments FROM {$wpdb->comments} {$where} GROUP BY comment_approved", ARRAY_A );	$total = 0;	$approved = array('0' => 'moderated', '1' => 'approved', 'spam' => 'spam', 'trash' => 'trash', 'post-trashed' => 'post-trashed');	$known_types = array_keys( $approved );	foreach ( (array) $count as $row ) {		// Don't count post-trashed toward totals		if ( 'post-trashed' != $row['comment_approved'] && 'trash' != $row['comment_approved'] )			$total += $row['num_comments'];		if ( in_array( $row['comment_approved'], $known_types ) )			$stats[$approved[$row['comment_approved']]] = $row['num_comments'];	}	$stats['total_comments'] = $total;	foreach ( $approved as $key ) {		if ( empty($stats[$key]) )			$stats[$key] = 0;	}	$stats = (object) $stats;	wp_cache_set("comments-{$post_id}", $stats, 'counts');	return $stats;}/** * Trashes or deletes a comment. * * The comment is moved to trash instead of permanently deleted unless trash is * disabled, item is already in the trash, or $force_delete is true. * * The post comment count will be updated if the comment was approved and has a * post ID available. * * @since 2.0.0 * @uses $wpdb * @uses do_action() Calls 'delete_comment' hook on comment ID * @uses do_action() Calls 'deleted_comment' hook on comment ID after deletion, on success * @uses do_action() Calls 'wp_set_comment_status' hook on comment ID with 'delete' set for the second parameter * @uses wp_transition_comment_status() Passes new and old comment status along with $comment object * * @param int $comment_id Comment ID * @param bool $force_delete Whether to bypass trash and force deletion. Default is false. * @return bool False if delete comment query failure, true on success. */function wp_delete_comment($comment_id, $force_delete = false) {	global $wpdb;	if (!$comment = get_comment($comment_id))		return false;	if ( !$force_delete && EMPTY_TRASH_DAYS && !in_array( wp_get_comment_status($comment_id), array( 'trash', 'spam' ) ) )		return wp_trash_comment($comment_id);	do_action('delete_comment', $comment_id);	// Move children up a level.	$children = $wpdb->get_col( $wpdb->prepare("SELECT comment_ID FROM $wpdb->comments WHERE comment_parent = %d", $comment_id) );	if ( !empty($children) ) {		$wpdb->update($wpdb->comments, array('comment_parent' => $comment->comment_parent), array('comment_parent' => $comment_id));		clean_comment_cache($children);	}	// Delete metadata	$meta_ids = $wpdb->get_col( $wpdb->prepare( "SELECT meta_id FROM $wpdb->commentmeta WHERE comment_id = %d ", $comment_id ) );	if ( !empty($meta_ids) ) {		do_action( 'delete_commentmeta', $meta_ids );		$in_meta_ids = "'" . implode("', '", $meta_ids) . "'";		$wpdb->query( "DELETE FROM $wpdb->commentmeta WHERE meta_id IN ($in_meta_ids)" );		do_action( 'deleted_commentmeta', $meta_ids );	}	if ( ! $wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->comments WHERE comment_ID = %d LIMIT 1", $comment_id) ) )		return false;	do_action('deleted_comment', $comment_id);	$post_id = $comment->comment_post_ID;	if ( $post_id && $comment->comment_approved == 1 )		wp_update_comment_count($post_id);	clean_comment_cache($comment_id);	do_action('wp_set_comment_status', $comment_id, 'delete');	wp_transition_comment_status('delete', $comment->comment_approved, $comment);	return true;}/** * Moves a comment to the Trash * * If trash is disabled, comment is permanently deleted. * * @since 2.9.0 * @uses do_action() on 'trash_comment' before trashing * @uses do_action() on 'trashed_comment' after trashing * @uses wp_delete_comment() if trash is disabled * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_trash_comment($comment_id) {	if ( !EMPTY_TRASH_DAYS )		return wp_delete_comment($comment_id, true);	if ( !$comment = get_comment($comment_id) )		return false;	do_action('trash_comment', $comment_id);	if ( wp_set_comment_status($comment_id, 'trash') ) {		add_comment_meta($comment_id, '_wp_trash_meta_status', $comment->comment_approved);		add_comment_meta($comment_id, '_wp_trash_meta_time', time() );		do_action('trashed_comment', $comment_id);		return true;	}	return false;}/** * Removes a comment from the Trash * * @since 2.9.0 * @uses do_action() on 'untrash_comment' before untrashing * @uses do_action() on 'untrashed_comment' after untrashing * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_untrash_comment($comment_id) {	if ( ! (int)$comment_id )		return false;	do_action('untrash_comment', $comment_id);	$status = (string) get_comment_meta($comment_id, '_wp_trash_meta_status', true);	if ( empty($status) )		$status = '0';	if ( wp_set_comment_status($comment_id, $status) ) {		delete_comment_meta($comment_id, '_wp_trash_meta_time');		delete_comment_meta($comment_id, '_wp_trash_meta_status');		do_action('untrashed_comment', $comment_id);		return true;	}	return false;}/** * Marks a comment as Spam * * @since 2.9.0 * @uses do_action() on 'spam_comment' before spamming * @uses do_action() on 'spammed_comment' after spamming * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_spam_comment($comment_id) {	if ( !$comment = get_comment($comment_id) )		return false;	do_action('spam_comment', $comment_id);	if ( wp_set_comment_status($comment_id, 'spam') ) {		add_comment_meta($comment_id, '_wp_trash_meta_status', $comment->comment_approved);		do_action('spammed_comment', $comment_id);		return true;	}	return false;}/** * Removes a comment from the Spam * * @since 2.9.0 * @uses do_action() on 'unspam_comment' before unspamming * @uses do_action() on 'unspammed_comment' after unspamming * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_unspam_comment($comment_id) {	if ( ! (int)$comment_id )		return false;	do_action('unspam_comment', $comment_id);	$status = (string) get_comment_meta($comment_id, '_wp_trash_meta_status', true);	if ( empty($status) )		$status = '0';	if ( wp_set_comment_status($comment_id, $status) ) {		delete_comment_meta($comment_id, '_wp_trash_meta_status');		do_action('unspammed_comment', $comment_id);		return true;	}	return false;}/** * The status of a comment by ID. * * @since 1.0.0 * * @param int $comment_id Comment ID * @return string|bool Status might be 'trash', 'approved', 'unapproved', 'spam'. False on failure. */function wp_get_comment_status($comment_id) {	$comment = get_comment($comment_id);	if ( !$comment )		return false;	$approved = $comment->comment_approved;	if ( $approved == NULL )		return false;	elseif ( $approved == '1' )		return 'approved';	elseif ( $approved == '0' )		return 'unapproved';	elseif ( $approved == 'spam' )		return 'spam';	elseif ( $approved == 'trash' )		return 'trash';	else		return false;}/** * Call hooks for when a comment status transition occurs. * * Calls hooks for comment status transitions. If the new comment status is not the same * as the previous comment status, then two hooks will be ran, the first is * 'transition_comment_status' with new status, old status, and comment data. The * next action called is 'comment_OLDSTATUS_to_NEWSTATUS' the NEWSTATUS is the * $new_status parameter and the OLDSTATUS is $old_status parameter; it has the * comment data. * * The final action will run whether or not the comment statuses are the same. The * action is named 'comment_NEWSTATUS_COMMENTTYPE', NEWSTATUS is from the $new_status * parameter and COMMENTTYPE is comment_type comment data. * * @since 2.7.0 * * @param string $new_status New comment status. * @param string $old_status Previous comment status. * @param object $comment Comment data. */function wp_transition_comment_status($new_status, $old_status, $comment) {	// Translate raw statuses to human readable formats for the hooks	// This is not a complete list of comment status, it's only the ones that need to be renamed	$comment_statuses = array(		0         => 'unapproved',		'hold'    => 'unapproved', // wp_set_comment_status() uses "hold"		1         => 'approved',		'approve' => 'approved', // wp_set_comment_status() uses "approve"	);	if ( isset($comment_statuses[$new_status]) ) $new_status = $comment_statuses[$new_status];	if ( isset($comment_statuses[$old_status]) ) $old_status = $comment_statuses[$old_status];	// Call the hooks	if ( $new_status != $old_status ) {		do_action('transition_comment_status', $new_status, $old_status, $comment);		do_action("comment_${old_status}_to_$new_status", $comment);	}	do_action("comment_${new_status}_$comment->comment_type", $comment->comment_ID, $comment);}/** * Get current commenter's name, email, and URL. * * Expects cookies content to already be sanitized. User of this function might * wish to recheck the returned array for validity. * * @see sanitize_comment_cookies() Use to sanitize cookies * * @since 2.0.4 * * @return array Comment author, email, url respectively. */function wp_get_current_commenter() {	// Cookies should already be sanitized.	$comment_author = '';	if ( isset($_COOKIE['comment_author_'.COOKIEHASH]) )		$comment_author = $_COOKIE['comment_author_'.COOKIEHASH];	$comment_author_email = '';	if ( isset($_COOKIE['comment_author_email_'.COOKIEHASH]) )		$comment_author_email = $_COOKIE['comment_author_email_'.COOKIEHASH];	$comment_author_url = '';	if ( isset($_COOKIE['comment_author_url_'.COOKIEHASH]) )		$comment_author_url = $_COOKIE['comment_author_url_'.COOKIEHASH];	return compact('comment_author', 'comment_author_email', 'comment_author_url');}/** * Inserts a comment to the database. * * The available comment data key names are 'comment_author_IP', 'comment_date', * 'comment_date_gmt', 'comment_parent', 'comment_approved', and 'user_id'. * * @since 2.0.0 * @uses $wpdb * * @param array $commentdata Contains information on the comment. * @return int The new comment's ID. */function wp_insert_comment($commentdata) {	global $wpdb;	extract(stripslashes_deep($commentdata), EXTR_SKIP);	if ( ! isset($comment_author_IP) )		$comment_author_IP = '';	if ( ! isset($comment_date) )		$comment_date = current_time('mysql');	if ( ! isset($comment_date_gmt) )		$comment_date_gmt = get_gmt_from_date($comment_date);	if ( ! isset($comment_parent) )		$comment_parent = 0;	if ( ! isset($comment_approved) )		$comment_approved = 1;	if ( ! isset($comment_karma) )		$comment_karma = 0;	if ( ! isset($user_id) )		$user_id = 0;	if ( ! isset($comment_type) )		$comment_type = '';	$data = compact('comment_post_ID', 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_author_IP', 'comment_date', 'comment_date_gmt', 'comment_content', 'comment_karma', 'comment_approved', 'comment_agent', 'comment_type', 'comment_parent', 'user_id');	$wpdb->insert($wpdb->comments, $data);	$id = (int) $wpdb->insert_id;	if ( $comment_approved == 1 )		wp_update_comment_count($comment_post_ID);	$comment = get_comment($id);	do_action('wp_insert_comment', $id, $comment);	return $id;}/** * Filters and sanitizes comment data. * * Sets the comment data 'filtered' field to true when finished. This can be * checked as to whether the comment should be filtered and to keep from * filtering the same comment more than once. * * @since 2.0.0 * @uses apply_filters() Calls 'pre_user_id' hook on comment author's user ID * @uses apply_filters() Calls 'pre_comment_user_agent' hook on comment author's user agent * @uses apply_filters() Calls 'pre_comment_author_name' hook on comment author's name * @uses apply_filters() Calls 'pre_comment_content' hook on the comment's content * @uses apply_filters() Calls 'pre_comment_user_ip' hook on comment author's IP * @uses apply_filters() Calls 'pre_comment_author_url' hook on comment author's URL * @uses apply_filters() Calls 'pre_comment_author_email' hook on comment author's email address * * @param array $commentdata Contains information on the comment. * @return array Parsed comment information. */function wp_filter_comment($commentdata) {	if ( isset($commentdata['user_ID']) )		$commentdata['user_id'] = apply_filters('pre_user_id', $commentdata['user_ID']);	elseif ( isset($commentdata['user_id']) )		$commentdata['user_id'] = apply_filters('pre_user_id', $commentdata['user_id']);	$commentdata['comment_agent']        = apply_filters('pre_comment_user_agent', ( isset( $commentdata['comment_agent'] ) ? $commentdata['comment_agent'] : '' ) );	$commentdata['comment_author']       = apply_filters('pre_comment_author_name', $commentdata['comment_author']);	$commentdata['comment_content']      = apply_filters('pre_comment_content', $commentdata['comment_content']);	$commentdata['comment_author_IP']    = apply_filters('pre_comment_user_ip', $commentdata['comment_author_IP']);	$commentdata['comment_author_url']   = apply_filters('pre_comment_author_url', $commentdata['comment_author_url']);	$commentdata['comment_author_email'] = apply_filters('pre_comment_author_email', $commentdata['comment_author_email']);	$commentdata['filtered'] = true;	return $commentdata;}/** * Whether comment should be blocked because of comment flood. * * @since 2.1.0 * * @param bool $block Whether plugin has already blocked comment. * @param int $time_lastcomment Timestamp for last comment. * @param int $time_newcomment Timestamp for new comment. * @return bool Whether comment should be blocked. */function wp_throttle_comment_flood($block, $time_lastcomment, $time_newcomment) {	if ( $block ) // a plugin has already blocked... we'll let that decision stand		return $block;	if ( ($time_newcomment - $time_lastcomment) < 15 )		return true;	return false;}/** * Adds a new comment to the database. * * Filters new comment to ensure that the fields are sanitized and valid before * inserting comment into database. Calls 'comment_post' action with comment ID * and whether comment is approved by WordPress. Also has 'preprocess_comment' * filter for processing the comment data before the function handles it. * * @since 1.5.0 * @uses apply_filters() Calls 'preprocess_comment' hook on $commentdata parameter array before processing * @uses do_action() Calls 'comment_post' hook on $comment_ID returned from adding the comment and if the comment was approved. * @uses wp_filter_comment() Used to filter comment before adding comment. * @uses wp_allow_comment() checks to see if comment is approved. * @uses wp_insert_comment() Does the actual comment insertion to the database. * * @param array $commentdata Contains information on the comment. * @return int The ID of the comment after adding. */function wp_new_comment( $commentdata ) {	$commentdata = apply_filters('preprocess_comment', $commentdata);	$commentdata['comment_post_ID'] = (int) $commentdata['comment_post_ID'];	if ( isset($commentdata['user_ID']) )		$commentdata['user_id'] = $commentdata['user_ID'] = (int) $commentdata['user_ID'];	elseif ( isset($commentdata['user_id']) )		$commentdata['user_id'] = (int) $commentdata['user_id'];	$commentdata['comment_parent'] = isset($commentdata['comment_parent']) ? absint($commentdata['comment_parent']) : 0;	$parent_status = ( 0 < $commentdata['comment_parent'] ) ? wp_get_comment_status($commentdata['comment_parent']) : '';	$commentdata['comment_parent'] = ( 'approved' == $parent_status || 'unapproved' == $parent_status ) ? $commentdata['comment_parent'] : 0;	$commentdata['comment_author_IP'] = preg_replace( '/[^0-9a-fA-F:., ]/', '',$_SERVER['REMOTE_ADDR'] );	$commentdata['comment_agent']     = substr($_SERVER['HTTP_USER_AGENT'], 0, 254);	$commentdata['comment_date']     = current_time('mysql');	$commentdata['comment_date_gmt'] = current_time('mysql', 1);	$commentdata = wp_filter_comment($commentdata);	$commentdata['comment_approved'] = wp_allow_comment($commentdata);	$comment_ID = wp_insert_comment($commentdata);	do_action('comment_post', $comment_ID, $commentdata['comment_approved']);	if ( 'spam' !== $commentdata['comment_approved'] ) { // If it's spam save it silently for later crunching		if ( '0' == $commentdata['comment_approved'] )			wp_notify_moderator($comment_ID);		$post = &get_post($commentdata['comment_post_ID']); // Don't notify if it's your own comment		if ( get_option('comments_notify') && $commentdata['comment_approved'] && ( ! isset( $commentdata['user_id'] ) || $post->post_author != $commentdata['user_id'] ) )			wp_notify_postauthor($comment_ID, empty( $commentdata['comment_type'] ) ? $commentdata['comment_type'] : '' );	}	return $comment_ID;}/** * Sets the status of a comment. * * The 'wp_set_comment_status' action is called after the comment is handled and * will only be called, if the comment status is either 'hold', 'approve', or * 'spam'. If the comment status is not in the list, then false is returned and * if the status is 'delete', then the comment is deleted without calling the * action. * * @since 1.0.0 * @uses wp_transition_comment_status() Passes new and old comment status along with $comment object * * @param int $comment_id Comment ID. * @param string $comment_status New comment status, either 'hold', 'approve', 'spam', or 'delete'. * @param bool $wp_error Whether to return a WP_Error object if there is a failure. Default is false. * @return bool False on failure or deletion and true on success. */function wp_set_comment_status($comment_id, $comment_status, $wp_error = false) {	global $wpdb;	$status = '0';	switch ( $comment_status ) {		case 'hold':		case '0':			$status = '0';			break;		case 'approve':		case '1':			$status = '1';			if ( get_option('comments_notify') ) {				$comment = get_comment($comment_id);				wp_notify_postauthor($comment_id, $comment->comment_type);			}			break;		case 'spam':			$status = 'spam';			break;		case 'trash':			$status = 'trash';			break;		default:			return false;	}	$comment_old = wp_clone(get_comment($comment_id));	if ( !$wpdb->update( $wpdb->comments, array('comment_approved' => $status), array('comment_ID' => $comment_id) ) ) {		if ( $wp_error )			return new WP_Error('db_update_error', __('Could not update comment status'), $wpdb->last_error);		else			return false;	}	clean_comment_cache($comment_id);	$comment = get_comment($comment_id);	do_action('wp_set_comment_status', $comment_id, $comment_status);	wp_transition_comment_status($comment_status, $comment_old->comment_approved, $comment);	wp_update_comment_count($comment->comment_post_ID);	return true;}/** * Updates an existing comment in the database. * * Filters the comment and makes sure certain fields are valid before updating. * * @since 2.0.0 * @uses $wpdb * @uses wp_transition_comment_status() Passes new and old comment status along with $comment object * * @param array $commentarr Contains information on the comment. * @return int Comment was updated if value is 1, or was not updated if value is 0. */function wp_update_comment($commentarr) {	global $wpdb;	// First, get all of the original fields	$comment = get_comment($commentarr['comment_ID'], ARRAY_A);	// Escape data pulled from DB.	$comment = esc_sql($comment);	$old_status = $comment['comment_approved'];	// Merge old and new fields with new fields overwriting old ones.	$commentarr = array_merge($comment, $commentarr);	$commentarr = wp_filter_comment( $commentarr );	// Now extract the merged array.	extract(stripslashes_deep($commentarr), EXTR_SKIP);	$comment_content = apply_filters('comment_save_pre', $comment_content);	$comment_date_gmt = get_gmt_from_date($comment_date);	if ( !isset($comment_approved) )		$comment_approved = 1;	else if ( 'hold' == $comment_approved )		$comment_approved = 0;	else if ( 'approve' == $comment_approved )		$comment_approved = 1;	$data = compact('comment_content', 'comment_author', 'comment_author_email', 'comment_approved', 'comment_karma', 'comment_author_url', 'comment_date', 'comment_date_gmt');	$rval = $wpdb->update( $wpdb->comments, $data, compact( 'comment_ID' ) );	clean_comment_cache($comment_ID);	wp_update_comment_count($comment_post_ID);	do_action('edit_comment', $comment_ID);	$comment = get_comment($comment_ID);	wp_transition_comment_status($comment->comment_approved, $old_status, $comment);	return $rval;}/** * Whether to defer comment counting. * * When setting $defer to true, all post comment counts will not be updated * until $defer is set to false. When $defer is set to false, then all * previously deferred updated post comment counts will then be automatically * updated without having to call wp_update_comment_count() after. * * @since 2.5.0 * @staticvar bool $_defer * * @param bool $defer * @return unknown */function wp_defer_comment_counting($defer=null) {	static $_defer = false;	if ( is_bool($defer) ) {		$_defer = $defer;		// flush any deferred counts		if ( !$defer )			wp_update_comment_count( null, true );	}	return $_defer;}/** * Updates the comment count for post(s). * * When $do_deferred is false (is by default) and the comments have been set to * be deferred, the post_id will be added to a queue, which will be updated at a * later date and only updated once per post ID. * * If the comments have not be set up to be deferred, then the post will be * updated. When $do_deferred is set to true, then all previous deferred post * IDs will be updated along with the current $post_id. * * @since 2.1.0 * @see wp_update_comment_count_now() For what could cause a false return value * * @param int $post_id Post ID * @param bool $do_deferred Whether to process previously deferred post comment counts * @return bool True on success, false on failure */function wp_update_comment_count($post_id, $do_deferred=false) {	static $_deferred = array();	if ( $do_deferred ) {		$_deferred = array_unique($_deferred);		foreach ( $_deferred as $i => $_post_id ) {			wp_update_comment_count_now($_post_id);			unset( $_deferred[$i] ); /** @todo Move this outside of the foreach and reset $_deferred to an array instead */		}	}	if ( wp_defer_comment_counting() ) {		$_deferred[] = $post_id;		return true;	}	elseif ( $post_id ) {		return wp_update_comment_count_now($post_id);	}}/** * Updates the comment count for the post. * * @since 2.5.0 * @uses $wpdb * @uses do_action() Calls 'wp_update_comment_count' hook on $post_id, $new, and $old * @uses do_action() Calls 'edit_posts' hook on $post_id and $post * * @param int $post_id Post ID * @return bool False on '0' $post_id or if post with ID does not exist. True on success. */function wp_update_comment_count_now($post_id) {	global $wpdb;	$post_id = (int) $post_id;	if ( !$post_id )		return false;	if ( !$post = get_post($post_id) )		return false;	$old = (int) $post->comment_count;	$new = (int) $wpdb->get_var( $wpdb->prepare("SELECT COUNT(*) FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved = '1'", $post_id) );	$wpdb->update( $wpdb->posts, array('comment_count' => $new), array('ID' => $post_id) );	if ( 'page' == $post->post_type )		clean_page_cache( $post_id );	else		clean_post_cache( $post_id );	do_action('wp_update_comment_count', $post_id, $new, $old);	do_action('edit_post', $post_id, $post);	return true;}//// Ping and trackback functions.///** * Finds a pingback server URI based on the given URL. * * Checks the HTML for the rel="pingback" link and x-pingback headers. It does * a check for the x-pingback headers first and returns that, if available. The * check for the rel="pingback" has more overhead than just the header. * * @since 1.5.0 * * @param string $url URL to ping. * @param int $deprecated Not Used. * @return bool|string False on failure, string containing URI on success. */function discover_pingback_server_uri( $url, $deprecated = '' ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.7' );	$pingback_str_dquote = 'rel="pingback"';	$pingback_str_squote = 'rel=\'pingback\'';	/** @todo Should use Filter Extension or custom preg_match instead. */	$parsed_url = parse_url($url);	if ( ! isset( $parsed_url['host'] ) ) // Not an URL. This should never happen.		return false;	//Do not search for a pingback server on our own uploads	$uploads_dir = wp_upload_dir();	if ( 0 === strpos($url, $uploads_dir['baseurl']) )		return false;	$response = wp_remote_head( $url, array( 'timeout' => 2, 'httpversion' => '1.0' ) );	if ( is_wp_error( $response ) )		return false;	if ( isset( $response['headers']['x-pingback'] ) )		return $response['headers']['x-pingback'];	// Not an (x)html, sgml, or xml page, no use going further.	if ( isset( $response['headers']['content-type'] ) && preg_match('#(image|audio|video|model)/#is', $response['headers']['content-type']) )		return false;	// Now do a GET since we're going to look in the html headers (and we're sure its not a binary file)	$response = wp_remote_get( $url, array( 'timeout' => 2, 'httpversion' => '1.0' ) );	if ( is_wp_error( $response ) )		return false;	$contents = $response['body'];	$pingback_link_offset_dquote = strpos($contents, $pingback_str_dquote);	$pingback_link_offset_squote = strpos($contents, $pingback_str_squote);	if ( $pingback_link_offset_dquote || $pingback_link_offset_squote ) {		$quote = ($pingback_link_offset_dquote) ? '"' : '\'';		$pingback_link_offset = ($quote=='"') ? $pingback_link_offset_dquote : $pingback_link_offset_squote;		$pingback_href_pos = @strpos($contents, 'href=', $pingback_link_offset);		$pingback_href_start = $pingback_href_pos+6;		$pingback_href_end = @strpos($contents, $quote, $pingback_href_start);		$pingback_server_url_len = $pingback_href_end - $pingback_href_start;		$pingback_server_url = substr($contents, $pingback_href_start, $pingback_server_url_len);		// We may find rel="pingback" but an incomplete pingback URL		if ( $pingback_server_url_len > 0 ) { // We got it!			return $pingback_server_url;		}	}	return false;}/** * Perform all pingbacks, enclosures, trackbacks, and send to pingback services. * * @since 2.1.0 * @uses $wpdb */function do_all_pings() {	global $wpdb;	// Do pingbacks	while ($ping = $wpdb->get_row("SELECT * FROM {$wpdb->posts}, {$wpdb->postmeta} WHERE {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id AND {$wpdb->postmeta}.meta_key = '_pingme' LIMIT 1")) {		$mid = $wpdb->get_var( "SELECT meta_id FROM {$wpdb->postmeta} WHERE post_id = {$ping->ID} AND meta_key = '_pingme' LIMIT 1");		do_action( 'delete_postmeta', $mid );		$wpdb->query( $wpdb->prepare( "DELETE FROM {$wpdb->postmeta} WHERE meta_id = %d", $mid ) );		do_action( 'deleted_postmeta', $mid );		pingback($ping->post_content, $ping->ID);	}	// Do Enclosures	while ($enclosure = $wpdb->get_row("SELECT * FROM {$wpdb->posts}, {$wpdb->postmeta} WHERE {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id AND {$wpdb->postmeta}.meta_key = '_encloseme' LIMIT 1")) {		$mid = $wpdb->get_var( $wpdb->prepare("SELECT meta_id FROM {$wpdb->postmeta} WHERE post_id = %d AND meta_key = '_encloseme'", $enclosure->ID) );		do_action( 'delete_postmeta', $mid );		$wpdb->query( $wpdb->prepare("DELETE FROM {$wpdb->postmeta} WHERE meta_id =  %d", $mid) );		do_action( 'deleted_postmeta', $mid );		do_enclose($enclosure->post_content, $enclosure->ID);	}	// Do Trackbacks	$trackbacks = $wpdb->get_col("SELECT ID FROM $wpdb->posts WHERE to_ping <> '' AND post_status = 'publish'");	if ( is_array($trackbacks) )		foreach ( $trackbacks as $trackback )			do_trackbacks($trackback);	//Do Update Services/Generic Pings	generic_ping();}/** * Perform trackbacks. * * @since 1.5.0 * @uses $wpdb * * @param int $post_id Post ID to do trackbacks on. */function do_trackbacks($post_id) {	global $wpdb;	$post = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->posts WHERE ID = %d", $post_id) );	$to_ping = get_to_ping($post_id);	$pinged  = get_pung($post_id);	if ( empty($to_ping) ) {		$wpdb->update($wpdb->posts, array('to_ping' => ''), array('ID' => $post_id) );		return;	}	if ( empty($post->post_excerpt) )		$excerpt = apply_filters('the_content', $post->post_content);	else		$excerpt = apply_filters('the_excerpt', $post->post_excerpt);	$excerpt = str_replace(']]>', ']]&gt;', $excerpt);	$excerpt = wp_html_excerpt($excerpt, 252) . '...';	$post_title = apply_filters('the_title', $post->post_title);	$post_title = strip_tags($post_title);	if ( $to_ping ) {		foreach ( (array) $to_ping as $tb_ping ) {			$tb_ping = trim($tb_ping);			if ( !in_array($tb_ping, $pinged) ) {				trackback($tb_ping, $post_title, $excerpt, $post_id);				$pinged[] = $tb_ping;			} else {				$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET to_ping = TRIM(REPLACE(to_ping, '$tb_ping', '')) WHERE ID = %d", $post_id) );			}		}	}}/** * Sends pings to all of the ping site services. * * @since 1.2.0 * * @param int $post_id Post ID. Not actually used. * @return int Same as Post ID from parameter */function generic_ping($post_id = 0) {	$services = get_option('ping_sites');	$services = explode("\n", $services);	foreach ( (array) $services as $service ) {		$service = trim($service);		if ( '' != $service )			weblog_ping($service);	}	return $post_id;}/** * Pings back the links found in a post. * * @since 0.71 * @uses $wp_version * @uses IXR_Client * * @param string $content Post content to check for links. * @param int $post_ID Post ID. */function pingback($content, $post_ID) {	global $wp_version;	include_once(ABSPATH . WPINC . '/class-IXR.php');	// original code by Mort (http://mort.mine.nu:8080)	$post_links = array();	$pung = get_pung($post_ID);	// Variables	$ltrs = '\w';	$gunk = '/#~:.?+=&%@!\-';	$punc = '.:?\-';	$any = $ltrs . $gunk . $punc;	// Step 1	// Parsing the post, external links (if any) are stored in the $post_links array	// This regexp comes straight from phpfreaks.com	// http://www.phpfreaks.com/quickcode/Extract_All_URLs_on_a_Page/15.php	preg_match_all("{\b http : [$any] +? (?= [$punc] * [^$any] | $)}x", $content, $post_links_temp);	// Step 2.	// Walking thru the links array	// first we get rid of links pointing to sites, not to specific files	// Example:	// http://dummy-weblog.org	// http://dummy-weblog.org/	// http://dummy-weblog.org/post.php	// We don't wanna ping first and second types, even if they have a valid <link/>	foreach ( (array) $post_links_temp[0] as $link_test ) :		if ( !in_array($link_test, $pung) && (url_to_postid($link_test) != $post_ID) // If we haven't pung it already and it isn't a link to itself				&& !is_local_attachment($link_test) ) : // Also, let's never ping local attachments.			if ( $test = @parse_url($link_test) ) {				if ( isset($test['query']) )					$post_links[] = $link_test;				elseif ( ($test['path'] != '/') && ($test['path'] != '') )					$post_links[] = $link_test;			}		endif;	endforeach;	do_action_ref_array('pre_ping', array(&$post_links, &$pung));	foreach ( (array) $post_links as $pagelinkedto ) {		$pingback_server_url = discover_pingback_server_uri($pagelinkedto, 2048);		if ( $pingback_server_url ) {			@ set_time_limit( 60 );			 // Now, the RPC call			$pagelinkedfrom = get_permalink($post_ID);			// using a timeout of 3 seconds should be enough to cover slow servers			$client = new IXR_Client($pingback_server_url);			$client->timeout = 3;			$client->useragent = apply_filters( 'pingback_useragent', $client->useragent . ' -- WordPress/' . $wp_version, $client->useragent, $pingback_server_url, $pagelinkedto, $pagelinkedfrom);			// when set to true, this outputs debug messages by itself			$client->debug = false;			if ( $client->query('pingback.ping', $pagelinkedfrom, $pagelinkedto) || ( isset($client->error->code) && 48 == $client->error->code ) ) // Already registered				add_ping( $post_ID, $pagelinkedto );		}	}}/** * Check whether blog is public before returning sites. * * @since 2.1.0 * * @param mixed $sites Will return if blog is public, will not return if not public. * @return mixed Empty string if blog is not public, returns $sites, if site is public. */function privacy_ping_filter($sites) {	if ( '0' != get_option('blog_public') )		return $sites;	else		return '';}/** * Send a Trackback. * * Updates database when sending trackback to prevent duplicates. * * @since 0.71 * @uses $wpdb * * @param string $trackback_url URL to send trackbacks. * @param string $title Title of post. * @param string $excerpt Excerpt of post. * @param int $ID Post ID. * @return mixed Database query from update. */function trackback($trackback_url, $title, $excerpt, $ID) {	global $wpdb;	if ( empty($trackback_url) )		return;	$options = array();	$options['timeout'] = 4;	$options['body'] = array(		'title' => $title,		'url' => get_permalink($ID),		'blog_name' => get_option('blogname'),		'excerpt' => $excerpt	);	$response = wp_remote_post($trackback_url, $options);	if ( is_wp_error( $response ) )		return;	$tb_url = addslashes( $trackback_url );	$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET pinged = CONCAT(pinged, '\n', '$tb_url') WHERE ID = %d", $ID) );	return $wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET to_ping = TRIM(REPLACE(to_ping, '$tb_url', '')) WHERE ID = %d", $ID) );}/** * Send a pingback. * * @since 1.2.0 * @uses $wp_version * @uses IXR_Client * * @param string $server Host of blog to connect to. * @param string $path Path to send the ping. */function weblog_ping($server = '', $path = '') {	global $wp_version;	include_once(ABSPATH . WPINC . '/class-IXR.php');	// using a timeout of 3 seconds should be enough to cover slow servers	$client = new IXR_Client($server, ((!strlen(trim($path)) || ('/' == $path)) ? false : $path));	$client->timeout = 3;	$client->useragent .= ' -- WordPress/'.$wp_version;	// when set to true, this outputs debug messages by itself	$client->debug = false;	$home = trailingslashit( home_url() );	if ( !$client->query('weblogUpdates.extendedPing', get_option('blogname'), $home, get_bloginfo('rss2_url') ) ) // then try a normal ping		$client->query('weblogUpdates.ping', get_option('blogname'), $home);}//// Cache///** * Removes comment ID from the comment cache. * * @since 2.3.0 * @package WordPress * @subpackage Cache * * @param int|array $id Comment ID or array of comment IDs to remove from cache */function clean_comment_cache($ids) {	foreach ( (array) $ids as $id )		wp_cache_delete($id, 'comment');}/** * Updates the comment cache of given comments. * * Will add the comments in $comments to the cache. If comment ID already exists * in the comment cache then it will not be updated. The comment is added to the * cache using the comment group with the key using the ID of the comments. * * @since 2.3.0 * @package WordPress * @subpackage Cache * * @param array $comments Array of comment row objects */function update_comment_cache($comments) {	foreach ( (array) $comments as $comment )		wp_cache_add($comment->comment_ID, $comment, 'comment');}//// Internal///** * Close comments on old posts on the fly, without any extra DB queries.  Hooked to the_posts. * * @access private * @since 2.7.0 * * @param object $posts Post data object. * @return object */function _close_comments_for_old_posts( $posts ) {	if ( empty($posts) || !is_singular() || !get_option('close_comments_for_old_posts') )		return $posts;	$days_old = (int) get_option('close_comments_days_old');	if ( !$days_old )		return $posts;	if ( time() - strtotime( $posts[0]->post_date_gmt ) > ( $days_old * 24 * 60 * 60 ) ) {		$posts[0]->comment_status = 'closed';		$posts[0]->ping_status = 'closed';	}	return $posts;}/** * Close comments on an old post.  Hooked to comments_open and pings_open. * * @access private * @since 2.7.0 * * @param bool $open Comments open or closed * @param int $post_id Post ID * @return bool $open */function _close_comments_for_old_post( $open, $post_id ) {	if ( ! $open )		return $open;	if ( !get_option('close_comments_for_old_posts') )		return $open;	$days_old = (int) get_option('close_comments_days_old');	if ( !$days_old )		return $open;	$post = get_post($post_id);	if ( time() - strtotime( $post->post_date_gmt ) > ( $days_old * 24 * 60 * 60 ) )		return false;	return $open;}?>
<?php/** * Edit Tags Administration Panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');wp_reset_vars( array('action', 'tag', 'taxonomy', 'post_type') );if ( empty($taxonomy) )	$taxonomy = 'post_tag';if ( !taxonomy_exists($taxonomy) )	wp_die(__('Invalid taxonomy'));$tax = get_taxonomy($taxonomy);$title = $tax->labels->name;if ( empty($post_type) || !in_array( $post_type, get_post_types( array('public' => true) ) ) )	$post_type = 'post';if ( 'post' != $post_type ) {	$parent_file = "edit.php?post_type=$post_type";	$submenu_file = "edit-tags.php?taxonomy=$taxonomy&amp;post_type=$post_type";} else {	$parent_file = 'edit.php';	$submenu_file = "edit-tags.php?taxonomy=$taxonomy";}if ( isset( $_GET['action'] ) && isset($_GET['delete_tags']) && ( 'delete' == $_GET['action'] || 'delete' == $_GET['action2'] ) )	$action = 'bulk-delete';switch($action) {case 'add-tag':	check_admin_referer('add-tag');	if ( !current_user_can($tax->cap->edit_terms) )		wp_die(__('Cheatin&#8217; uh?'));	$ret = wp_insert_term($_POST['tag-name'], $taxonomy, $_POST);	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_original_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	if ( $ret && !is_wp_error( $ret ) )		$location = add_query_arg('message', 1, $location);	else		$location = add_query_arg('message', 4, $location);	wp_redirect($location);	exit;break;case 'delete':	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	if ( !isset( $_GET['tag_ID'] ) ) {		wp_redirect($location);		exit;	}	$tag_ID = (int) $_GET['tag_ID'];	check_admin_referer('delete-tag_' .  $tag_ID);	if ( !current_user_can($tax->cap->delete_terms) )		wp_die(__('Cheatin&#8217; uh?'));	wp_delete_term( $tag_ID, $taxonomy);	$location = add_query_arg('message', 2, $location);	wp_redirect($location);	exit;break;case 'bulk-delete':	check_admin_referer('bulk-tags');	if ( !current_user_can($tax->cap->delete_terms) )		wp_die(__('Cheatin&#8217; uh?'));	$tags = (array) $_GET['delete_tags'];	foreach( $tags as $tag_ID ) {		wp_delete_term( $tag_ID, $taxonomy);	}	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	$location = add_query_arg('message', 6, $location);	wp_redirect($location);	exit;break;case 'edit':	$title = $tax->labels->edit_item;	require_once ('admin-header.php');	$tag_ID = (int) $_GET['tag_ID'];	$tag = get_term($tag_ID, $taxonomy, OBJECT, 'edit');	include('./edit-tag-form.php');break;case 'editedtag':	$tag_ID = (int) $_POST['tag_ID'];	check_admin_referer('update-tag_' . $tag_ID);	if ( !current_user_can($tax->cap->edit_terms) )		wp_die(__('Cheatin&#8217; uh?'));	$ret = wp_update_term($tag_ID, $taxonomy, $_POST);	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_original_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	if ( $ret && !is_wp_error( $ret ) )		$location = add_query_arg('message', 3, $location);	else		$location = add_query_arg('message', 5, $location);	wp_redirect($location);	exit;break;default:if ( ! empty($_GET['_wp_http_referer']) ) {	 wp_redirect( remove_query_arg( array('_wp_http_referer', '_wpnonce'), stripslashes($_SERVER['REQUEST_URI']) ) );	 exit;}wp_enqueue_script('admin-tags');if ( current_user_can($tax->cap->edit_terms) )	wp_enqueue_script('inline-edit-tax');if ( 'category' == $taxonomy || 'post_tag' == $taxonomy ) {	if ( 'category' == $taxonomy )		$help = '<p>' . sprintf(__('You can use categories to define sections of your site and group related posts. The default category is &#8220;Uncategorized&#8221; until you change it in your <a href="%s">writing settings</a>.'), 'options-writing.php') . '</p>';	else		$help = '<p>' . __('You can assign keywords to your posts using Post Tags. Unlike categories, tags have no hierarchy, meaning there&#8217;s no relationship from one tag to another.') . '</p>';	$help .='<p>' . __('What&#8217;s the difference between categories and tags? Normally, tags are ad-hoc keywords that identify important information in your post (names, subjects, etc) that may or may not recur in other posts, while categories are pre-determined sections. If you think of your site like a book, the categories are like the Table of Contents and the tags are like the terms in the index.') . '</p>';	if ( 'category' == $taxonomy )		$help .= '<p>' . __('When adding a new category on this screen, you&#8217;ll fill in the following fields:') . '</p>';	else		$help .= '<p>' . __('When adding a new tag on this screen, you&#8217;ll fill in the following fields:') . '</p>';	$help .= '<ul>' .		'<li>' . __('<strong>Name</strong> - The name is how it appears on your site.') . '</li>';	if ( ! global_terms_enabled() )		$help .= '<li>' . __('<strong>Slug</strong> - The &#8220;slug&#8221; is the URL-friendly version of the name. It is usually all lowercase and contains only letters, numbers, and hyphens.') . '</li>';	if ( 'category' == $taxonomy )		$help .= '<li>' . __('<strong>Parent</strong> - Categories, unlike tags, can have a hierarchy. You might have a Jazz category, and under that have children categories for Bebop and Big Band. Totally optional. To create a subcategory, just choose another category from the Parent dropdown.') . '</li>';	$help .= '<li>' . __('<strong>Description</strong> - The description is not prominent by default; however, some themes may display it.') . '</li>' .		'</ul>' .		'<p>' . __('You can change the display of this screen using the Screen Options tab to set how many items are displayed per screen and to display/hide columns in the table.') . '</p>' .		'<p><strong>' . __('For more information:') . '</strong></p>';	if ( 'category' == $taxonomy )		$help .= '<p>' . __('<a href="http://codex.wordpress.org/Manage_Categories_SubPanel" target="_blank">Categories Documentation</a>') . '</p>';	else		$help .= '<p>' . __('<a href="http://codex.wordpress.org/Post_Tags_SubPanel" target="_blank">Tags Documentation</a>') . '</p>';	$help .= '<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>';	add_contextual_help($current_screen, $help);	unset($help);}require_once ('admin-header.php');$messages[1] = __('Item added.');$messages[2] = __('Item deleted.');$messages[3] = __('Item updated.');$messages[4] = __('Item not added.');$messages[5] = __('Item not updated.');$messages[6] = __('Items deleted.');?><div class="wrap nosubsub"><?php screen_icon(); ?><h2><?php echo esc_html( $title );if ( !empty($_GET['s']) )	printf( '<span class="subtitle">' . __('Search results for &#8220;%s&#8221;') . '</span>', esc_html( stripslashes($_GET['s']) ) ); ?></h2><?php if ( isset($_GET['message']) && ( $msg = (int) $_GET['message'] ) ) : ?><div id="message" class="updated"><p><?php echo $messages[$msg]; ?></p></div><?php $_SERVER['REQUEST_URI'] = remove_query_arg(array('message'), $_SERVER['REQUEST_URI']);endif; ?><div id="ajax-response"></div><form class="search-form" action="" method="get"><input type="hidden" name="taxonomy" value="<?php echo esc_attr($taxonomy); ?>" /><input type="hidden" name="post_type" value="<?php echo esc_attr($post_type); ?>" /><p class="search-box">	<label class="screen-reader-text" for="tag-search-input"><?php echo $tax->labels->search_items; ?>:</label>	<input type="text" id="tag-search-input" name="s" value="<?php _admin_search_query(); ?>" />	<input type="submit" value="<?php echo esc_attr( $tax->labels->search_items );  ?>" class="button" /></p></form><br class="clear" /><div id="col-container"><div id="col-right"><div class="col-wrap"><form id="posts-filter" action="" method="get"><input type="hidden" name="taxonomy" value="<?php echo esc_attr($taxonomy); ?>" /><input type="hidden" name="post_type" value="<?php echo esc_attr($post_type); ?>" /><div class="tablenav"><?php$pagenum = isset( $_GET['pagenum'] ) ? absint( $_GET['pagenum'] ) : 0;if ( empty($pagenum) )	$pagenum = 1;$tags_per_page = (int) get_user_option( 'edit_' .  $taxonomy . '_per_page' );if ( empty($tags_per_page) || $tags_per_page < 1 )	$tags_per_page = 20;if ( 'post_tag' == $taxonomy ) {	$tags_per_page = apply_filters( 'edit_tags_per_page', $tags_per_page );	$tags_per_page = apply_filters( 'tagsperpage', $tags_per_page ); // Old filter} elseif ( 'category' == $taxonomy ) {	$tags_per_page = apply_filters( 'edit_categories_per_page', $tags_per_page ); // Old filter} else {	$tags_per_page = apply_filters( 'edit_' . $taxonomy . '_per_page', $tags_per_page );}$searchterms = !empty($_GET['s']) ? trim(stripslashes($_GET['s'])) : '';$page_links = paginate_links( array(	'base' => add_query_arg( 'pagenum', '%#%' ),	'format' => '',	'prev_text' => __('&laquo;'),	'next_text' => __('&raquo;'),	'total' => ceil(wp_count_terms($taxonomy, array('search' => $searchterms)) / $tags_per_page),	'current' => $pagenum));if ( $page_links )	echo "<div class='tablenav-pages'>$page_links</div>";?><div class="alignleft actions"><select name="action"><option value="" selected="selected"><?php _e('Bulk Actions'); ?></option><option value="delete"><?php _e('Delete'); ?></option></select><input type="submit" value="<?php esc_attr_e('Apply'); ?>" name="doaction" id="doaction" class="button-secondary action" /><?php wp_nonce_field('bulk-tags'); ?></div><br class="clear" /></div><div class="clear"></div><table class="widefat tag fixed" cellspacing="0">	<thead>	<tr><?php print_column_headers($current_screen); ?>	</tr>	</thead>	<tfoot>	<tr><?php print_column_headers($current_screen, false); ?>	</tr>	</tfoot>	<tbody id="the-list" class="list:tag"><?php tag_rows( $pagenum, $tags_per_page, $searchterms, $taxonomy ); ?>	</tbody></table><div class="tablenav"><?phpif ( $page_links )	echo "<div class='tablenav-pages'>$page_links</div>";?><div class="alignleft actions"><select name="action2"><option value="" selected="selected"><?php _e('Bulk Actions'); ?></option><option value="delete"><?php _e('Delete'); ?></option></select><input type="submit" value="<?php esc_attr_e('Apply'); ?>" name="doaction2" id="doaction2" class="button-secondary action" /></div><br class="clear" /></div><br class="clear" /></form><?php if ( 'category' == $taxonomy ) : ?><div class="form-wrap"><p><?php printf(__('<strong>Note:</strong><br />Deleting a category does not delete the posts in that category. Instead, posts that were only assigned to the deleted category are set to the category <strong>%s</strong>.'), apply_filters('the_category', get_cat_name(get_option('default_category')))) ?></p><?php if ( current_user_can( 'import' ) ) : ?><p><?php printf(__('Categories can be selectively converted to tags using the <a href="%s">category to tag converter</a>.'), 'import.php') ?></p><?php endif; ?></div><?php elseif ( 'post_tag' == $taxonomy && current_user_can( 'import' ) ) : ?><div class="form-wrap"><p><?php printf(__('Tags can be selectively converted to categories using the <a href="%s">tag to category converter</a>'), 'import.php') ;?>.</p></div><?php endif;do_action('after-' . $taxonomy . '-table', $taxonomy);?></div></div><!-- /col-right --><div id="col-left"><div class="col-wrap"><?phpif ( !is_taxonomy_hierarchical($taxonomy) ) {	if ( current_user_can( $tax->cap->edit_terms ) )		$tag_cloud = wp_tag_cloud( array( 'taxonomy' => $taxonomy, 'echo' => false, 'link' => 'edit' ) );	else		$tag_cloud = wp_tag_cloud( array( 'taxonomy' => $taxonomy, 'echo' => false ) );	if ( $tag_cloud ) :	?><div class="tagcloud"><h3><?php echo $tax->labels->popular_items; ?></h3><?php echo $tag_cloud; unset( $tag_cloud ); ?></div><?phpendif;}if ( current_user_can($tax->cap->edit_terms) ) {	if ( 'category' == $taxonomy )		do_action('add_category_form_pre', (object)array('parent' => 0) );  // Back compat hook. Deprecated in preference to $taxonomy_pre_add_form	else		do_action('add_tag_form_pre', $taxonomy); // Back compat hook. Applies to all Taxonomies -not- categories	do_action($taxonomy . '_pre_add_form', $taxonomy);?><div class="form-wrap"><h3><?php echo $tax->labels->add_new_item; ?></h3><form id="addtag" method="post" action="edit-tags.php" class="validate"><input type="hidden" name="action" value="add-tag" /><input type="hidden" name="screen" value="<?php echo esc_attr($current_screen->id); ?>" /><input type="hidden" name="taxonomy" value="<?php echo esc_attr($taxonomy); ?>" /><?php wp_nonce_field('add-tag'); ?><div class="form-field form-required">	<label for="tag-name"><?php _ex('Name', 'Taxonomy Name'); ?></label>	<input name="tag-name" id="tag-name" type="text" value="" size="40" aria-required="true" />	<p><?php _e('The name is how it appears on your site.'); ?></p></div><?php if ( ! global_terms_enabled() ) : ?><div class="form-field">	<label for="tag-slug"><?php _ex('Slug', 'Taxonomy Slug'); ?></label>	<input name="slug" id="tag-slug" type="text" value="" size="40" />	<p><?php _e('The &#8220;slug&#8221; is the URL-friendly version of the name. It is usually all lowercase and contains only letters, numbers, and hyphens.'); ?></p></div><?php endif; // is_multisite() ?><?php if ( is_taxonomy_hierarchical($taxonomy) ) : ?><div class="form-field">	<label for="parent"><?php _ex('Parent', 'Taxonomy Parent'); ?></label>	<?php wp_dropdown_categories(array('hide_empty' => 0, 'hide_if_empty' => false, 'taxonomy' => $taxonomy, 'name' => 'parent', 'orderby' => 'name', 'hierarchical' => true, 'show_option_none' => __('None'))); ?>	<?php if ( 'category' == $taxonomy ) : // @todo: Generic text for hierarchical taxonomies ?>		<p><?php _e('Categories, unlike tags, can have a hierarchy. You might have a Jazz category, and under that have children categories for Bebop and Big Band. Totally optional.'); ?></p>	<?php endif; ?></div><?php endif; // is_taxonomy_hierarchical() ?><div class="form-field">	<label for="tag-description"><?php _ex('Description', 'Taxonomy Description'); ?></label>	<textarea name="description" id="tag-description" rows="5" cols="40"></textarea>	<p><?php _e('The description is not prominent by default; however, some themes may show it.'); ?></p></div><?phpif ( ! is_taxonomy_hierarchical($taxonomy) )	do_action('add_tag_form_fields', $taxonomy);do_action($taxonomy . '_add_form_fields', $taxonomy);?><p class="submit"><input type="submit" class="button" name="submit" id="submit" value="<?php echo esc_attr( $tax->labels->add_new_item ); ?>" /></p><?phpif ( 'category' == $taxonomy )	do_action('edit_category_form',	(object)array('parent' => 0) );  // Back compat hook. Deprecated in preference to $taxonomy_add_formelse	do_action('add_tag_form', $taxonomy); // Back compat hook. Applies to all Taxonomies -not- categoriesdo_action($taxonomy . '_add_form', $taxonomy);?></form></div><?php } ?></div></div><!-- /col-left --></div><!-- /col-container --></div><!-- /wrap --><?php inline_edit_term_row('edit-tags', $taxonomy); ?><?phpbreak;}include('./admin-footer.php');?>
<?php/** * WordPress Feed API * * Many of the functions used in here belong in The Loop, or The Loop for the * Feeds. * * @package WordPress * @subpackage Feed *//** * RSS container for the bloginfo function. * * You can retrieve anything that you can using the get_bloginfo() function. * Everything will be stripped of tags and characters converted, when the values * are retrieved for use in the feeds. * * @package WordPress * @subpackage Feed * @since 1.5.1 * @uses apply_filters() Calls 'get_bloginfo_rss' hook with two parameters. * @see get_bloginfo() For the list of possible values to display. * * @param string $show See get_bloginfo() for possible values. * @return string */function get_bloginfo_rss($show = '') {	$info = strip_tags(get_bloginfo($show));	return apply_filters('get_bloginfo_rss', convert_chars($info), $show);}/** * Display RSS container for the bloginfo function. * * You can retrieve anything that you can using the get_bloginfo() function. * Everything will be stripped of tags and characters converted, when the values * are retrieved for use in the feeds. * * @package WordPress * @subpackage Feed * @since 0.71 * @uses apply_filters() Calls 'bloginfo_rss' hook with two parameters. * @see get_bloginfo() For the list of possible values to display. * * @param string $show See get_bloginfo() for possible values. */function bloginfo_rss($show = '') {	echo apply_filters('bloginfo_rss', get_bloginfo_rss($show), $show);}/** * Retrieve the default feed. * * The default feed is 'rss2', unless a plugin changes it through the * 'default_feed' filter. * * @package WordPress * @subpackage Feed * @since 2.5 * @uses apply_filters() Calls 'default_feed' hook on the default feed string. * * @return string Default feed, or for example 'rss2', 'atom', etc. */function get_default_feed() {	return apply_filters('default_feed', 'rss2');}/** * Retrieve the blog title for the feed title. * * @package WordPress * @subpackage Feed * @since 2.2.0 * @uses apply_filters() Calls 'get_wp_title_rss' hook on title. * @uses wp_title() See function for $sep parameter usage. * * @param string $sep Optional.How to separate the title. See wp_title() for more info. * @return string Error message on failure or blog title on success. */function get_wp_title_rss($sep = '&#187;') {	$title = wp_title($sep, false);	if ( is_wp_error( $title ) )		return $title->get_error_message();	$title = apply_filters('get_wp_title_rss', $title);	return $title;}/** * Display the blog title for display of the feed title. * * @package WordPress * @subpackage Feed * @since 2.2.0 * @uses apply_filters() Calls 'wp_title_rss' on the blog title. * @see wp_title() $sep parameter usage. * * @param string $sep Optional. */function wp_title_rss($sep = '&#187;') {	echo apply_filters('wp_title_rss', get_wp_title_rss($sep));}/** * Retrieve the current post title for the feed. * * @package WordPress * @subpackage Feed * @since 2.0.0 * @uses apply_filters() Calls 'the_title_rss' on the post title. * * @return string Current post title. */function get_the_title_rss() {	$title = get_the_title();	$title = apply_filters('the_title_rss', $title);	return $title;}/** * Display the post title in the feed. * * @package WordPress * @subpackage Feed * @since 0.71 * @uses get_the_title_rss() Used to retrieve current post title. */function the_title_rss() {	echo get_the_title_rss();}/** * Retrieve the post content for feeds. * * @package WordPress * @subpackage Feed * @since 2.9.0 * @uses apply_filters() Calls 'the_content_feed' on the content before processing. * @see get_the_content() * * @param string $feed_type The type of feed. rss2 | atom | rss | rdf */function get_the_content_feed($feed_type = null) {	if ( !$feed_type )		$feed_type = get_default_feed();	$content = apply_filters('the_content', get_the_content());	$content = str_replace(']]>', ']]&gt;', $content);	return apply_filters('the_content_feed', $content, $feed_type);}/** * Display the post content for feeds. * * @package WordPress * @subpackage Feed * @since 2.9.0 * @uses apply_filters() Calls 'the_content_feed' on the content before processing. * @see get_the_content() * * @param string $feed_type The type of feed. rss2 | atom | rss | rdf */function the_content_feed($feed_type = null) {	echo get_the_content_feed();}/** * Display the post excerpt for the feed. * * @package WordPress * @subpackage Feed * @since 0.71 * @uses apply_filters() Calls 'the_excerpt_rss' hook on the excerpt. */function the_excerpt_rss() {	$output = get_the_excerpt();	echo apply_filters('the_excerpt_rss', $output);}/** * Display the permalink to the post for use in feeds. * * @package WordPress * @subpackage Feed * @since 2.3.0 * @uses apply_filters() Call 'the_permalink_rss' on the post permalink */function the_permalink_rss() {	echo esc_url( apply_filters('the_permalink_rss', get_permalink() ));}/** * Outputs the link to the comments for the current post in an xml safe way * * @since 3.0.0 * @return none */function comments_link_feed() {	echo esc_url( get_comments_link() );}/** * Display the feed GUID for the current comment. * * @package WordPress * @subpackage Feed * @since unknown * * @param int|object $comment_id Optional comment object or id. Defaults to global comment object. */function comment_guid($comment_id = null) {	echo esc_url( get_comment_guid($comment_id) );}/** * Retrieve the feed GUID for the current comment. * * @package WordPress * @subpackage Feed * @since unknown * * @param int|object $comment_id Optional comment object or id. Defaults to global comment object. * @return bool|string false on failure or guid for comment on success. */function get_comment_guid($comment_id = null) {	$comment = get_comment($comment_id);	if ( !is_object($comment) )		return false;	return get_the_guid($comment->comment_post_ID) . '#comment-' . $comment->comment_ID;}/** * Display the link to the comments. * * @since 1.5.0 */function comment_link() {	echo esc_url( get_comment_link() );}/** * Retrieve the current comment author for use in the feeds. * * @package WordPress * @subpackage Feed * @since 2.0.0 * @uses apply_filters() Calls 'comment_author_rss' hook on comment author. * @uses get_comment_author() * * @return string Comment Author */function get_comment_author_rss() {	return apply_filters('comment_author_rss', get_comment_author() );}/** * Display the current comment author in the feed. * * @package WordPress * @subpackage Feed * @since 1.0.0 */function comment_author_rss() {	echo get_comment_author_rss();}/** * Display the current comment content for use in the feeds. * * @package WordPress * @subpackage Feed * @since 1.0.0 * @uses apply_filters() Calls 'comment_text_rss' filter on comment content. * @uses get_comment_text() */function comment_text_rss() {	$comment_text = get_comment_text();	$comment_text = apply_filters('comment_text_rss', $comment_text);	echo $comment_text;}/** * Retrieve all of the post categories, formatted for use in feeds. * * All of the categories for the current post in the feed loop, will be * retrieved and have feed markup added, so that they can easily be added to the * RSS2, Atom, or RSS1 and RSS0.91 RDF feeds. * * @package WordPress * @subpackage Feed * @since 2.1.0 * @uses apply_filters() * * @param string $type Optional, default is the type returned by get_default_feed(). * @return string All of the post categories for displaying in the feed. */function get_the_category_rss($type = null) {	if ( empty($type) )		$type = get_default_feed();	$categories = get_the_category();	$tags = get_the_tags();	$the_list = '';	$cat_names = array();	$filter = 'rss';	if ( 'atom' == $type )		$filter = 'raw';	if ( !empty($categories) ) foreach ( (array) $categories as $category ) {		$cat_names[] = sanitize_term_field('name', $category->name, $category->term_id, 'category', $filter);	}	if ( !empty($tags) ) foreach ( (array) $tags as $tag ) {		$cat_names[] = sanitize_term_field('name', $tag->name, $tag->term_id, 'post_tag', $filter);	}	$cat_names = array_unique($cat_names);	foreach ( $cat_names as $cat_name ) {		if ( 'rdf' == $type )			$the_list .= "\t\t<dc:subject><![CDATA[$cat_name]]></dc:subject>\n";		elseif ( 'atom' == $type )			$the_list .= sprintf( '<category scheme="%1$s" term="%2$s" />', esc_attr( apply_filters( 'get_bloginfo_rss', get_bloginfo( 'url' ) ) ), esc_attr( $cat_name ) );		else			$the_list .= "\t\t<category><![CDATA[" . @html_entity_decode( $cat_name, ENT_COMPAT, get_option('blog_charset') ) . "]]></category>\n";	}	return apply_filters('the_category_rss', $the_list, $type);}/** * Display the post categories in the feed. * * @package WordPress * @subpackage Feed * @since 0.71 * @see get_the_category_rss() For better explanation. * * @param string $type Optional, default is the type returned by get_default_feed(). */function the_category_rss($type = null) {	echo get_the_category_rss($type);}/** * Display the HTML type based on the blog setting. * * The two possible values are either 'xhtml' or 'html'. * * @package WordPress * @subpackage Feed * @since 2.2.0 */function html_type_rss() {	$type = get_bloginfo('html_type');	if (strpos($type, 'xhtml') !== false)		$type = 'xhtml';	else		$type = 'html';	echo $type;}/** * Display the rss enclosure for the current post. * * Uses the global $post to check whether the post requires a password and if * the user has the password for the post. If not then it will return before * displaying. * * Also uses the function get_post_custom() to get the post's 'enclosure' * metadata field and parses the value to display the enclosure(s). The * enclosure(s) consist of enclosure HTML tag(s) with a URI and other * attributes. * * @package WordPress * @subpackage Template * @since 1.5.0 * @uses apply_filters() Calls 'rss_enclosure' hook on rss enclosure. * @uses get_post_custom() To get the current post enclosure metadata. */function rss_enclosure() {	if ( post_password_required() )		return;	foreach ( (array) get_post_custom() as $key => $val) {		if ($key == 'enclosure') {			foreach ( (array) $val as $enc ) {				$enclosure = explode("\n", $enc);				//only get the the first element eg, audio/mpeg from 'audio/mpeg mpga mp2 mp3'				$t = preg_split('/[ \t]/', trim($enclosure[2]) );				$type = $t[0];				echo apply_filters('rss_enclosure', '<enclosure url="' . trim(htmlspecialchars($enclosure[0])) . '" length="' . trim($enclosure[1]) . '" type="' . $type . '" />' . "\n");			}		}	}}/** * Display the atom enclosure for the current post. * * Uses the global $post to check whether the post requires a password and if * the user has the password for the post. If not then it will return before * displaying. * * Also uses the function get_post_custom() to get the post's 'enclosure' * metadata field and parses the value to display the enclosure(s). The * enclosure(s) consist of link HTML tag(s) with a URI and other attributes. * * @package WordPress * @subpackage Template * @since 2.2.0 * @uses apply_filters() Calls 'atom_enclosure' hook on atom enclosure. * @uses get_post_custom() To get the current post enclosure metadata. */function atom_enclosure() {	if ( post_password_required() )		return;	foreach ( (array) get_post_custom() as $key => $val ) {		if ($key == 'enclosure') {			foreach ( (array) $val as $enc ) {				$enclosure = split("\n", $enc);				echo apply_filters('atom_enclosure', '<link href="' . trim(htmlspecialchars($enclosure[0])) . '" rel="enclosure" length="' . trim($enclosure[1]) . '" type="' . trim($enclosure[2]) . '" />' . "\n");			}		}	}}/** * Determine the type of a string of data with the data formatted. * * Tell whether the type is text, html, or xhtml, per RFC 4287 section 3.1. * * In the case of WordPress, text is defined as containing no markup, * xhtml is defined as "well formed", and html as tag soup (i.e., the rest). * * Container div tags are added to xhtml values, per section 3.1.1.3. * * @link http://www.atomenabled.org/developers/syndication/atom-format-spec.php#rfc.section.3.1 * * @package WordPress * @subpackage Feed * @since 2.5 * * @param string $data Input string * @return array array(type, value) */function prep_atom_text_construct($data) {	if (strpos($data, '<') === false && strpos($data, '&') === false) {		return array('text', $data);	}	$parser = xml_parser_create();	xml_parse($parser, '<div>' . $data . '</div>', true);	$code = xml_get_error_code($parser);	xml_parser_free($parser);	if (!$code) {		if (strpos($data, '<') === false) {			return array('text', $data);		} else {			$data = "<div xmlns='http://www.w3.org/1999/xhtml'>$data</div>";			return array('xhtml', $data);		}	}	if (strpos($data, ']]>') == false) {		return array('html', "<![CDATA[$data]]>");	} else {		return array('html', htmlspecialchars($data));	}}/** * Display the link for the currently displayed feed in a XSS safe way. * * Generate a correct link for the atom:self element. * * @package WordPress * @subpackage Feed * @since 2.5 */function self_link() {	$host = @parse_url(home_url());	$host = $host['host'];	echo esc_url(		'http'		. ( (isset($_SERVER['https']) && $_SERVER['https'] == 'on') ? 's' : '' ) . '://'		. $host		. stripslashes($_SERVER['REQUEST_URI'])		);}/** * Return the content type for specified feed type. * * @package WordPress * @subpackage Feed * @since 2.8.0 */function feed_content_type( $type = '' ) {	if ( empty($type) )		$type = get_default_feed();	$types = array(		'rss'  => 'application/rss+xml',		'rss2' => 'application/rss+xml',		'rss-http'  => 'text/xml',		'atom' => 'application/atom+xml',		'rdf'  => 'application/rdf+xml'	);	$content_type = ( !empty($types[$type]) ) ? $types[$type] : 'application/octet-stream';	return apply_filters( 'feed_content_type', $content_type, $type );}/** * Build SimplePie object based on RSS or Atom feed from URL. * * @since 2.8 * * @param string $url URL to retrieve feed * @return WP_Error|SimplePie WP_Error object on failure or SimplePie object on success */function fetch_feed($url) {	require_once (ABSPATH . WPINC . '/class-feed.php');	$feed = new SimplePie();	$feed->set_feed_url($url);	$feed->set_cache_class('WP_Feed_Cache');	$feed->set_file_class('WP_SimplePie_File');	$feed->set_cache_duration(apply_filters('wp_feed_cache_transient_lifetime', 43200, $url));	do_action_ref_array( 'wp_feed_options', array( &$feed, $url ) );	$feed->init();	$feed->handle_content_type();	if ( $feed->error() )		return new WP_Error('simplepie-error', $feed->error());	return $feed;}
<?php/** * WordPress User Page * * Handles authentication, registering, resetting passwords, forgot password, * and other user handling. * * @package WordPress *//** Make sure that the WordPress bootstrap has run before continuing. */require( dirname(__FILE__) . '/wp-load.php' );// Redirect to https login if forced to use SSLif ( force_ssl_admin() && !is_ssl() ) {	if ( 0 === strpos($_SERVER['REQUEST_URI'], 'http') ) {		wp_redirect(preg_replace('|^http://|', 'https://', $_SERVER['REQUEST_URI']));		exit();	} else {		wp_redirect('https://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI']);		exit();	}}/** * Outputs the header for the login page. * * @uses do_action() Calls the 'login_head' for outputting HTML in the Log In *		header. * @uses apply_filters() Calls 'login_headerurl' for the top login link. * @uses apply_filters() Calls 'login_headertitle' for the top login title. * @uses apply_filters() Calls 'login_message' on the message to display in the *		header. * @uses $error The error global, which is checked for displaying errors. * * @param string $title Optional. WordPress Log In Page title to display in *		<title/> element. * @param string $message Optional. Message to display in header. * @param WP_Error $wp_error Optional. WordPress Error Object */function login_header($title = 'Log In', $message = '', $wp_error = '') {	global $error, $is_iphone, $interim_login, $current_site;	// Don't index any of these forms	add_filter( 'pre_option_blog_public', '__return_zero' );	add_action( 'login_head', 'noindex' );	if ( empty($wp_error) )		$wp_error = new WP_Error();	// Shake it!	$shake_error_codes = array( 'empty_password', 'empty_email', 'invalid_email', 'invalidcombo', 'empty_username', 'invalid_username', 'incorrect_password' );	$shake_error_codes = apply_filters( 'shake_error_codes', $shake_error_codes );	if ( $shake_error_codes && $wp_error->get_error_code() && in_array( $wp_error->get_error_code(), $shake_error_codes ) )		add_action( 'login_head', 'wp_shake_js', 12 );	?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" <?php language_attributes(); ?>><head>	<title><?php bloginfo('name'); ?> &rsaquo; <?php echo $title; ?></title>	<meta http-equiv="Content-Type" content="<?php bloginfo('html_type'); ?>; charset=<?php bloginfo('charset'); ?>" /><?php	wp_admin_css( 'login', true );	wp_admin_css( 'colors-fresh', true );	if ( $is_iphone ) { ?>	<meta name="viewport" content="width=320; initial-scale=0.9; maximum-scale=1.0; user-scalable=0;" />	<style type="text/css" media="screen">	form { margin-left: 0px; }	#login { margin-top: 20px; }	</style><?php	} elseif ( isset($interim_login) && $interim_login ) { ?>	<style type="text/css" media="all">	.login #login { margin: 20px auto; }	</style><?php	}	do_action('login_head'); ?></head><body class="login"><?php   if ( !is_multisite() ) { ?><div id="login"><h1><a href="<?php echo apply_filters('login_headerurl', 'http://wordpress.org/'); ?>" title="<?php echo apply_filters('login_headertitle', __('Powered by WordPress')); ?>"><?php bloginfo('name'); ?></a></h1><?php   } else { ?><div id="login"><h1><a href="<?php echo apply_filters('login_headerurl', network_home_url() ); ?>" title="<?php echo apply_filters('login_headertitle', $current_site->site_name ); ?>"><span class="hide"><?php bloginfo('name'); ?></span></a></h1><?php   }	$message = apply_filters('login_message', $message);	if ( !empty( $message ) ) echo $message . "\n";	// Incase a plugin uses $error rather than the $errors object	if ( !empty( $error ) ) {		$wp_error->add('error', $error);		unset($error);	}	if ( $wp_error->get_error_code() ) {		$errors = '';		$messages = '';		foreach ( $wp_error->get_error_codes() as $code ) {			$severity = $wp_error->get_error_data($code);			foreach ( $wp_error->get_error_messages($code) as $error ) {				if ( 'message' == $severity )					$messages .= '	' . $error . "<br />\n";				else					$errors .= '	' . $error . "<br />\n";			}		}		if ( !empty($errors) )			echo '<div id="login_error">' . apply_filters('login_errors', $errors) . "</div>\n";		if ( !empty($messages) )			echo '<p class="message">' . apply_filters('login_messages', $messages) . "</p>\n";	}} // End of login_header()function wp_shake_js() {	global $is_iphone;	if ( $is_iphone )		return;?><script type="text/javascript">addLoadEvent = function(func){if(typeof jQuery!="undefined")jQuery(document).ready(func);else if(typeof wpOnload!='function'){wpOnload=func;}else{var oldonload=wpOnload;wpOnload=function(){oldonload();func();}}};function s(id,pos){g(id).left=pos+'px';}function g(id){return document.getElementById(id).style;}function shake(id,a,d){c=a.shift();s(id,c);if(a.length>0){setTimeout(function(){shake(id,a,d);},d);}else{try{g(id).position='static';wp_attempt_focus();}catch(e){}}}addLoadEvent(function(){ var p=new Array(15,30,15,0,-15,-30,-15,0);p=p.concat(p.concat(p));var i=document.forms[0].id;g(i).position='relative';shake(i,p,20);});</script><?php}/** * Handles sending password retrieval email to user. * * @uses $wpdb WordPress Database object * * @return bool|WP_Error True: when finish. WP_Error on error */function retrieve_password() {	global $wpdb, $current_site;	$errors = new WP_Error();	if ( empty( $_POST['user_login'] ) && empty( $_POST['user_email'] ) )		$errors->add('empty_username', __('<strong>ERROR</strong>: Enter a username or e-mail address.'));	if ( strpos($_POST['user_login'], '@') ) {		$user_data = get_user_by_email(trim($_POST['user_login']));		if ( empty($user_data) )			$errors->add('invalid_email', __('<strong>ERROR</strong>: There is no user registered with that email address.'));	} else {		$login = trim($_POST['user_login']);		$user_data = get_userdatabylogin($login);	}	do_action('lostpassword_post');	if ( $errors->get_error_code() )		return $errors;	if ( !$user_data ) {		$errors->add('invalidcombo', __('<strong>ERROR</strong>: Invalid username or e-mail.'));		return $errors;	}	// redefining user_login ensures we return the right case in the email	$user_login = $user_data->user_login;	$user_email = $user_data->user_email;	do_action('retreive_password', $user_login);  // Misspelled and deprecated	do_action('retrieve_password', $user_login);	$allow = apply_filters('allow_password_reset', true, $user_data->ID);	if ( ! $allow )		return new WP_Error('no_password_reset', __('Password reset is not allowed for this user'));	else if ( is_wp_error($allow) )		return $allow;	$key = $wpdb->get_var($wpdb->prepare("SELECT user_activation_key FROM $wpdb->users WHERE user_login = %s", $user_login));	if ( empty($key) ) {		// Generate something random for a key...		$key = wp_generate_password(20, false);		do_action('retrieve_password_key', $user_login, $key);		// Now insert the new md5 key into the db		$wpdb->update($wpdb->users, array('user_activation_key' => $key), array('user_login' => $user_login));	}	$message = __('Someone has asked to reset the password for the following site and username.') . "\r\n\r\n";	$message .= network_site_url() . "\r\n\r\n";	$message .= sprintf(__('Username: %s'), $user_login) . "\r\n\r\n";	$message .= __('To reset your password visit the following address, otherwise just ignore this email and nothing will happen.') . "\r\n\r\n";	$message .= network_site_url("wp-login.php?action=rp&key=$key&login=" . rawurlencode($user_login), 'login') . "\r\n";	if ( is_multisite() )		$blogname = $GLOBALS['current_site']->site_name;	else		// The blogname option is escaped with esc_html on the way into the database in sanitize_option		// we want to reverse this for the plain text arena of emails.		$blogname = wp_specialchars_decode(get_option('blogname'), ENT_QUOTES);	$title = sprintf( __('[%s] Password Reset'), $blogname );	$title = apply_filters('retrieve_password_title', $title);	$message = apply_filters('retrieve_password_message', $message, $key);	if ( $message && !wp_mail($user_email, $title, $message) )		wp_die( __('The e-mail could not be sent.') . "<br />\n" . __('Possible reason: your host may have disabled the mail() function...') );	return true;}/** * Handles resetting the user's password. * * @uses $wpdb WordPress Database object * * @param string $key Hash to validate sending user's password * @return bool|WP_Error */function reset_password($key, $login) {	global $wpdb;	$key = preg_replace('/[^a-z0-9]/i', '', $key);	if ( empty( $key ) || !is_string( $key ) )		return new WP_Error('invalid_key', __('Invalid key'));	if ( empty($login) || !is_string($login) )		return new WP_Error('invalid_key', __('Invalid key'));	$user = $wpdb->get_row($wpdb->prepare("SELECT * FROM $wpdb->users WHERE user_activation_key = %s AND user_login = %s", $key, $login));	if ( empty( $user ) )		return new WP_Error('invalid_key', __('Invalid key'));	// Generate something random for a password...	$new_pass = wp_generate_password();	do_action('password_reset', $user, $new_pass);	wp_set_password($new_pass, $user->ID);	update_user_option($user->ID, 'default_password_nag', true, true); //Set up the Password change nag.	$message  = sprintf(__('Username: %s'), $user->user_login) . "\r\n";	$message .= sprintf(__('Password: %s'), $new_pass) . "\r\n";	$message .= site_url('wp-login.php', 'login') . "\r\n";	if ( is_multisite() )		$blogname = $GLOBALS['current_site']->site_name;	else		// The blogname option is escaped with esc_html on the way into the database in sanitize_option		// we want to reverse this for the plain text arena of emails.		$blogname = wp_specialchars_decode(get_option('blogname'), ENT_QUOTES);	$title = sprintf( __('[%s] Your new password'), $blogname );	$title = apply_filters('password_reset_title', $title);	$message = apply_filters('password_reset_message', $message, $new_pass);	if ( $message && !wp_mail($user->user_email, $title, $message) )  		wp_die( __('The e-mail could not be sent.') . "<br />\n" . __('Possible reason: your host may have disabled the mail() function...') );	wp_password_change_notification($user);	return true;}/** * Handles registering a new user. * * @param string $user_login User's username for logging in * @param string $user_email User's email address to send password and add * @return int|WP_Error Either user's ID or error on failure. */function register_new_user( $user_login, $user_email ) {	$errors = new WP_Error();	$sanitized_user_login = sanitize_user( $user_login );	$user_email = apply_filters( 'user_registration_email', $user_email );	// Check the username	if ( $sanitized_user_login == '' ) {		$errors->add( 'empty_username', __( '<strong>ERROR</strong>: Please enter a username.' ) );	} elseif ( ! validate_username( $user_login ) ) {		$errors->add( 'invalid_username', __( '<strong>ERROR</strong>: This username is invalid because it uses illegal characters. Please enter a valid username.' ) );		$sanitized_user_login = '';	} elseif ( username_exists( $sanitized_user_login ) ) {		$errors->add( 'username_exists', __( '<strong>ERROR</strong>: This username is already registered, please choose another one.' ) );	}	// Check the e-mail address	if ( $user_email == '' ) {		$errors->add( 'empty_email', __( '<strong>ERROR</strong>: Please type your e-mail address.' ) );	} elseif ( ! is_email( $user_email ) ) {		$errors->add( 'invalid_email', __( '<strong>ERROR</strong>: The email address isn&#8217;t correct.' ) );		$user_email = '';	} elseif ( email_exists( $user_email ) ) {		$errors->add( 'email_exists', __( '<strong>ERROR</strong>: This email is already registered, please choose another one.' ) );	}	do_action( 'register_post', $sanitized_user_login, $user_email, $errors );	$errors = apply_filters( 'registration_errors', $errors, $sanitized_user_login, $user_email );	if ( $errors->get_error_code() )		return $errors;	$user_pass = wp_generate_password();	$user_id = wp_create_user( $sanitized_user_login, $user_pass, $user_email );	if ( ! $user_id ) {		$errors->add( 'registerfail', sprintf( __( '<strong>ERROR</strong>: Couldn&#8217;t register you... please contact the <a href="mailto:%s">webmaster</a> !' ), get_option( 'admin_email' ) ) );		return $errors;	}	update_user_option( $user_id, 'default_password_nag', true, true ); //Set up the Password change nag.	wp_new_user_notification( $user_id, $user_pass );	return $user_id;}//// Main//$action = isset($_REQUEST['action']) ? $_REQUEST['action'] : 'login';$errors = new WP_Error();if ( isset($_GET['key']) )	$action = 'resetpass';// validate action so as to default to the login screenif ( !in_array($action, array('logout', 'lostpassword', 'retrievepassword', 'resetpass', 'rp', 'register', 'login'), true) && false === has_filter('login_form_' . $action) )	$action = 'login';nocache_headers();header('Content-Type: '.get_bloginfo('html_type').'; charset='.get_bloginfo('charset'));if ( defined('RELOCATE') ) { // Move flag is set	if ( isset( $_SERVER['PATH_INFO'] ) && ($_SERVER['PATH_INFO'] != $_SERVER['PHP_SELF']) )		$_SERVER['PHP_SELF'] = str_replace( $_SERVER['PATH_INFO'], '', $_SERVER['PHP_SELF'] );	$schema = is_ssl() ? 'https://' : 'http://';	if ( dirname($schema . $_SERVER['HTTP_HOST'] . $_SERVER['PHP_SELF']) != get_option('siteurl') )		update_option('siteurl', dirname($schema . $_SERVER['HTTP_HOST'] . $_SERVER['PHP_SELF']) );}//Set a cookie now to see if they are supported by the browser.setcookie(TEST_COOKIE, 'WP Cookie check', 0, COOKIEPATH, COOKIE_DOMAIN);if ( SITECOOKIEPATH != COOKIEPATH )	setcookie(TEST_COOKIE, 'WP Cookie check', 0, SITECOOKIEPATH, COOKIE_DOMAIN);// allow plugins to override the default actions, and to add extra actions if they wantdo_action('login_form_' . $action);$http_post = ('POST' == $_SERVER['REQUEST_METHOD']);switch ($action) {case 'logout' :	check_admin_referer('log-out');	wp_logout();	$redirect_to = !empty( $_REQUEST['redirect_to'] ) ? $_REQUEST['redirect_to'] : 'wp-login.php?loggedout=true';	wp_safe_redirect( $redirect_to );	exit();break;case 'lostpassword' :case 'retrievepassword' :	if ( $http_post ) {		$errors = retrieve_password();		if ( !is_wp_error($errors) ) {			$redirect_to = !empty( $_REQUEST['redirect_to'] ) ? $_REQUEST['redirect_to'] : 'wp-login.php?checkemail=confirm';			wp_safe_redirect( $redirect_to );			exit();		}	}	if ( isset($_GET['error']) && 'invalidkey' == $_GET['error'] ) $errors->add('invalidkey', __('Sorry, that key does not appear to be valid.'));	$redirect_to = apply_filters( 'lostpassword_redirect', !empty( $_REQUEST['redirect_to'] ) ? $_REQUEST['redirect_to'] : '' );	do_action('lost_password');	login_header(__('Lost Password'), '<p class="message">' . __('Please enter your username or e-mail address. You will receive a new password via e-mail.') . '</p>', $errors);	$user_login = isset($_POST['user_login']) ? stripslashes($_POST['user_login']) : '';?><form name="lostpasswordform" id="lostpasswordform" action="<?php echo site_url('wp-login.php?action=lostpassword', 'login_post') ?>" method="post">	<p>		<label><?php _e('Username or E-mail:') ?><br />		<input type="text" name="user_login" id="user_login" class="input" value="<?php echo esc_attr($user_login); ?>" size="20" tabindex="10" /></label>	</p><?php do_action('lostpassword_form'); ?>	<input type="hidden" name="redirect_to" value="<?php echo esc_attr( $redirect_to ); ?>" />	<p class="submit"><input type="submit" name="wp-submit" id="wp-submit" class="button-primary" value="<?php esc_attr_e('Get New Password'); ?>" tabindex="100" /></p></form><p id="nav"><?php if (get_option('users_can_register')) : ?><a href="<?php echo site_url('wp-login.php', 'login') ?>"><?php _e('Log in') ?></a> |<a href="<?php echo site_url('wp-login.php?action=register', 'login') ?>"><?php _e('Register') ?></a><?php else : ?><a href="<?php echo site_url('wp-login.php', 'login') ?>"><?php _e('Log in') ?></a><?php endif; ?></p></div><p id="backtoblog"><a href="<?php bloginfo('url'); ?>/" title="<?php _e('Are you lost?') ?>"><?php printf(__('&larr; Back to %s'), get_bloginfo('title', 'display' )); ?></a></p><script type="text/javascript">try{document.getElementById('user_login').focus();}catch(e){}if(typeof wpOnload=='function')wpOnload();</script></body></html><?phpbreak;case 'resetpass' :case 'rp' :	$errors = reset_password($_GET['key'], $_GET['login']);	if ( ! is_wp_error($errors) ) {		wp_redirect('wp-login.php?checkemail=newpass');		exit();	}	wp_redirect('wp-login.php?action=lostpassword&error=invalidkey');	exit();break;case 'register' :	if ( is_multisite() ) {		// Multisite uses wp-signup.php		wp_redirect( apply_filters( 'wp_signup_location', get_bloginfo('wpurl') . '/wp-signup.php' ) );		exit;	}	if ( !get_option('users_can_register') ) {		wp_redirect('wp-login.php?registration=disabled');		exit();	}	$user_login = '';	$user_email = '';	if ( $http_post ) {		require_once( ABSPATH . WPINC . '/registration.php');		$user_login = $_POST['user_login'];		$user_email = $_POST['user_email'];		$errors = register_new_user($user_login, $user_email);		if ( !is_wp_error($errors) ) {			$redirect_to = !empty( $_POST['redirect_to'] ) ? $_POST['redirect_to'] : 'wp-login.php?checkemail=registered';			wp_safe_redirect( $redirect_to );			exit();		}	}	$redirect_to = apply_filters( 'registration_redirect', !empty( $_REQUEST['redirect_to'] ) ? $_REQUEST['redirect_to'] : '' );	login_header(__('Registration Form'), '<p class="message register">' . __('Register For This Site') . '</p>', $errors);?><form name="registerform" id="registerform" action="<?php echo site_url('wp-login.php?action=register', 'login_post') ?>" method="post">	<p>		<label><?php _e('Username') ?><br />		<input type="text" name="user_login" id="user_login" class="input" value="<?php echo esc_attr(stripslashes($user_login)); ?>" size="20" tabindex="10" /></label>	</p>	<p>		<label><?php _e('E-mail') ?><br />		<input type="text" name="user_email" id="user_email" class="input" value="<?php echo esc_attr(stripslashes($user_email)); ?>" size="25" tabindex="20" /></label>	</p><?php do_action('register_form'); ?>	<p id="reg_passmail"><?php _e('A password will be e-mailed to you.') ?></p>	<br class="clear" />	<input type="hidden" name="redirect_to" value="<?php echo esc_attr( $redirect_to ); ?>" />	<p class="submit"><input type="submit" name="wp-submit" id="wp-submit" class="button-primary" value="<?php esc_attr_e('Register'); ?>" tabindex="100" /></p></form><p id="nav"><a href="<?php echo site_url('wp-login.php', 'login') ?>"><?php _e('Log in') ?></a> |<a href="<?php echo site_url('wp-login.php?action=lostpassword', 'login') ?>" title="<?php _e('Password Lost and Found') ?>"><?php _e('Lost your password?') ?></a></p></div><p id="backtoblog"><a href="<?php bloginfo('url'); ?>/" title="<?php _e('Are you lost?') ?>"><?php printf(__('&larr; Back to %s'), get_bloginfo('title', 'display' )); ?></a></p><script type="text/javascript">try{document.getElementById('user_login').focus();}catch(e){}if(typeof wpOnload=='function')wpOnload();</script></body></html><?phpbreak;case 'login' :default:	$secure_cookie = '';	$interim_login = isset($_REQUEST['interim-login']);	// If the user wants ssl but the session is not ssl, force a secure cookie.	if ( !empty($_POST['log']) && !force_ssl_admin() ) {		$user_name = sanitize_user($_POST['log']);		if ( $user = get_userdatabylogin($user_name) ) {			if ( get_user_option('use_ssl', $user->ID) ) {				$secure_cookie = true;				force_ssl_admin(true);			}		}	}	if ( isset( $_REQUEST['redirect_to'] ) ) {		$redirect_to = $_REQUEST['redirect_to'];		// Redirect to https if user wants ssl		if ( $secure_cookie && false !== strpos($redirect_to, 'wp-admin') )			$redirect_to = preg_replace('|^http://|', 'https://', $redirect_to);	} else {		$redirect_to = admin_url();	}	$reauth = empty($_REQUEST['reauth']) ? false : true;	// If the user was redirected to a secure login form from a non-secure admin page, and secure login is required but secure admin is not, then don't use a secure	// cookie and redirect back to the referring non-secure admin page.  This allows logins to always be POSTed over SSL while allowing the user to choose visiting	// the admin via http or https.	if ( !$secure_cookie && is_ssl() && force_ssl_login() && !force_ssl_admin() && ( 0 !== strpos($redirect_to, 'https') ) && ( 0 === strpos($redirect_to, 'http') ) )		$secure_cookie = false;	$user = wp_signon('', $secure_cookie);	$redirect_to = apply_filters('login_redirect', $redirect_to, isset( $_REQUEST['redirect_to'] ) ? $_REQUEST['redirect_to'] : '', $user);	if ( !is_wp_error($user) && !$reauth ) {		if ( $interim_login ) {			$message = '<p class="message">' . __('You have logged in successfully.') . '</p>';			login_header( '', $message ); ?>			<script type="text/javascript">setTimeout( function(){window.close()}, 8000);</script>			<p class="alignright">			<input type="button" class="button-primary" value="<?php esc_attr_e('Close'); ?>" onclick="window.close()" /></p>			</div></body></html><?php		exit;		}		// If the user can't edit posts, send them to their profile.		if ( !$user->has_cap('edit_posts') && ( empty( $redirect_to ) || $redirect_to == 'wp-admin/' || $redirect_to == admin_url() ) )			$redirect_to = admin_url('profile.php');		wp_safe_redirect($redirect_to);		exit();	}	$errors = $user;	// Clear errors if loggedout is set.	if ( !empty($_GET['loggedout']) || $reauth )		$errors = new WP_Error();	// If cookies are disabled we can't log in even with a valid user+pass	if ( isset($_POST['testcookie']) && empty($_COOKIE[TEST_COOKIE]) )		$errors->add('test_cookie', __("<strong>ERROR</strong>: Cookies are blocked or not supported by your browser. You must <a href='http://www.google.com/cookies.html'>enable cookies</a> to use WordPress."));	// Some parts of this script use the main login form to display a message	if		( isset($_GET['loggedout']) && TRUE == $_GET['loggedout'] )		$errors->add('loggedout', __('You are now logged out.'), 'message');	elseif	( isset($_GET['registration']) && 'disabled' == $_GET['registration'] )		$errors->add('registerdisabled', __('User registration is currently not allowed.'));	elseif	( isset($_GET['checkemail']) && 'confirm' == $_GET['checkemail'] )		$errors->add('confirm', __('Check your e-mail for the confirmation link.'), 'message');	elseif	( isset($_GET['checkemail']) && 'newpass' == $_GET['checkemail'] )		$errors->add('newpass', __('Check your e-mail for your new password.'), 'message');	elseif	( isset($_GET['checkemail']) && 'registered' == $_GET['checkemail'] )		$errors->add('registered', __('Registration complete. Please check your e-mail.'), 'message');	elseif	( $interim_login )		$errors->add('expired', __('Your session has expired. Please log-in again.'), 'message');	// Clear any stale cookies.	if ( $reauth )		wp_clear_auth_cookie();	login_header(__('Log In'), '', $errors);	if ( isset($_POST['log']) )		$user_login = ( 'incorrect_password' == $errors->get_error_code() || 'empty_password' == $errors->get_error_code() ) ? esc_attr(stripslashes($_POST['log'])) : '';	$rememberme = ! empty( $_POST['rememberme'] );?><form name="loginform" id="loginform" action="<?php echo site_url('wp-login.php', 'login_post') ?>" method="post">	<p>		<label><?php _e('Username') ?><br />		<input type="text" name="log" id="user_login" class="input" value="<?php echo esc_attr($user_login); ?>" size="20" tabindex="10" /></label>	</p>	<p>		<label><?php _e('Password') ?><br />		<input type="password" name="pwd" id="user_pass" class="input" value="" size="20" tabindex="20" /></label>	</p><?php do_action('login_form'); ?>	<p class="forgetmenot"><label><input name="rememberme" type="checkbox" id="rememberme" value="forever" tabindex="90"<?php checked( $rememberme ); ?> /> <?php esc_attr_e('Remember Me'); ?></label></p>	<p class="submit">		<input type="submit" name="wp-submit" id="wp-submit" class="button-primary" value="<?php esc_attr_e('Log In'); ?>" tabindex="100" /><?php	if ( $interim_login ) { ?>		<input type="hidden" name="interim-login" value="1" /><?php	} else { ?>		<input type="hidden" name="redirect_to" value="<?php echo esc_attr($redirect_to); ?>" /><?php 	} ?>		<input type="hidden" name="testcookie" value="1" />	</p></form><?php if ( !$interim_login ) { ?><p id="nav"><?php if ( isset($_GET['checkemail']) && in_array( $_GET['checkemail'], array('confirm', 'newpass') ) ) : ?><?php elseif ( get_option('users_can_register') ) : ?><a href="<?php echo site_url('wp-login.php?action=register', 'login') ?>"><?php _e('Register') ?></a> |<a href="<?php echo site_url('wp-login.php?action=lostpassword', 'login') ?>" title="<?php _e('Password Lost and Found') ?>"><?php _e('Lost your password?') ?></a><?php else : ?><a href="<?php echo site_url('wp-login.php?action=lostpassword', 'login') ?>" title="<?php _e('Password Lost and Found') ?>"><?php _e('Lost your password?') ?></a><?php endif; ?></p></div><p id="backtoblog"><a href="<?php bloginfo('url'); ?>/" title="<?php _e('Are you lost?') ?>"><?php printf(__('&larr; Back to %s'), get_bloginfo('title', 'display' )); ?></a></p><?php } else { ?></div><?php } ?><script type="text/javascript">function wp_attempt_focus(){setTimeout( function(){ try{<?php if ( $user_login || $interim_login ) { ?>d = document.getElementById('user_pass');<?php } else { ?>d = document.getElementById('user_login');<?php } ?>d.value = '';d.focus();} catch(e){}}, 200);}<?php if ( !$error ) { ?>wp_attempt_focus();<?php } ?>if(typeof wpOnload=='function')wpOnload();</script></body></html><?phpbreak;} // end action switch?>
<?php/** * Category Template Tags and API. * * @package WordPress * @subpackage Template *//** * Retrieve category link URL. * * @since 1.0.0 * @uses apply_filters() Calls 'category_link' filter on category link and category ID. * * @param int $category_id Category ID. * @return string */function get_category_link( $category_id ) {	global $wp_rewrite;	$catlink = $wp_rewrite->get_category_permastruct();	if ( empty( $catlink ) ) {		$catlink = home_url('?cat=' . $category_id);	} else {		$category = &get_category( $category_id );		if ( is_wp_error( $category ) )			return $category;		$category_nicename = $category->slug;		if ( $category->parent == $category_id ) // recursive recursion			$category->parent = 0;		elseif ($category->parent != 0 )			$category_nicename = get_category_parents( $category->parent, false, '/', true ) . $category_nicename;		$catlink = str_replace( '%category%', $category_nicename, $catlink );		$catlink = home_url( user_trailingslashit( $catlink, 'category' ) );	}	return apply_filters( 'category_link', $catlink, $category_id );}/** * Retrieve category parents with separator. * * @since 1.2.0 * * @param int $id Category ID. * @param bool $link Optional, default is false. Whether to format with link. * @param string $separator Optional, default is '/'. How to separate categories. * @param bool $nicename Optional, default is false. Whether to use nice name for display. * @param array $visited Optional. Already linked to categories to prevent duplicates. * @return string */function get_category_parents( $id, $link = false, $separator = '/', $nicename = false, $visited = array() ) {	$chain = '';	$parent = &get_category( $id );	if ( is_wp_error( $parent ) )		return $parent;	if ( $nicename )		$name = $parent->slug;	else		$name = $parent->cat_name;	if ( $parent->parent && ( $parent->parent != $parent->term_id ) && !in_array( $parent->parent, $visited ) ) {		$visited[] = $parent->parent;		$chain .= get_category_parents( $parent->parent, $link, $separator, $nicename, $visited );	}	if ( $link )		$chain .= '<a href="' . get_category_link( $parent->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $parent->cat_name ) ) . '">'.$name.'</a>' . $separator;	else		$chain .= $name.$separator;	return $chain;}/** * Retrieve post categories. * * @since 0.71 * @uses $post * * @param int $id Optional, default to current post ID. The post ID. * @return array */function get_the_category( $id = false ) {	global $post;	$id = (int) $id;	if ( !$id )		$id = (int) $post->ID;	$categories = get_object_term_cache( $id, 'category' );	if ( false === $categories ) {		$categories = wp_get_object_terms( $id, 'category' );		wp_cache_add($id, $categories, 'category_relationships');	}	if ( !empty( $categories ) )		usort( $categories, '_usort_terms_by_name' );	else		$categories = array();	foreach ( (array) array_keys( $categories ) as $key ) {		_make_cat_compat( $categories[$key] );	}	return $categories;}/** * Sort categories by name. * * Used by usort() as a callback, should not be used directly. Can actually be * used to sort any term object. * * @since 2.3.0 * @access private * * @param object $a * @param object $b * @return int */function _usort_terms_by_name( $a, $b ) {	return strcmp( $a->name, $b->name );}/** * Sort categories by ID. * * Used by usort() as a callback, should not be used directly. Can actually be * used to sort any term object. * * @since 2.3.0 * @access private * * @param object $a * @param object $b * @return int */function _usort_terms_by_ID( $a, $b ) {	if ( $a->term_id > $b->term_id )		return 1;	elseif ( $a->term_id < $b->term_id )		return -1;	else		return 0;}/** * Retrieve category name based on category ID. * * @since 0.71 * * @param int $cat_ID Category ID. * @return string Category name. */function get_the_category_by_ID( $cat_ID ) {	$cat_ID = (int) $cat_ID;	$category = &get_category( $cat_ID );	if ( is_wp_error( $category ) )		return $category;	return $category->name;}/** * Retrieve category list in either HTML list or custom format. * * @since 1.5.1 * * @param string $separator Optional, default is empty string. Separator for between the categories. * @param string $parents Optional. How to display the parents. * @param int $post_id Optional. Post ID to retrieve categories. * @return string */function get_the_category_list( $separator = '', $parents='', $post_id = false ) {	global $wp_rewrite;	$categories = get_the_category( $post_id );	if ( !is_object_in_taxonomy( get_post_type( $post_id ), 'category' ) )		return apply_filters( 'the_category', '', $separator, $parents );	if ( empty( $categories ) )		return apply_filters( 'the_category', __( 'Uncategorized' ), $separator, $parents );	$rel = ( is_object( $wp_rewrite ) && $wp_rewrite->using_permalinks() ) ? 'rel="category tag"' : 'rel="category"';	$thelist = '';	if ( '' == $separator ) {		$thelist .= '<ul class="post-categories">';		foreach ( $categories as $category ) {			$thelist .= "\n\t<li>";			switch ( strtolower( $parents ) ) {				case 'multiple':					if ( $category->parent )						$thelist .= get_category_parents( $category->parent, true, $separator );					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>' . $category->name.'</a></li>';					break;				case 'single':					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>';					if ( $category->parent )						$thelist .= get_category_parents( $category->parent, false, $separator );					$thelist .= $category->name.'</a></li>';					break;				case '':				default:					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>' . $category->cat_name.'</a></li>';			}		}		$thelist .= '</ul>';	} else {		$i = 0;		foreach ( $categories as $category ) {			if ( 0 < $i )				$thelist .= $separator;			switch ( strtolower( $parents ) ) {				case 'multiple':					if ( $category->parent )						$thelist .= get_category_parents( $category->parent, true, $separator );					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>' . $category->cat_name.'</a>';					break;				case 'single':					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>';					if ( $category->parent )						$thelist .= get_category_parents( $category->parent, false, $separator );					$thelist .= "$category->cat_name</a>";					break;				case '':				default:					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>' . $category->name.'</a>';			}			++$i;		}	}	return apply_filters( 'the_category', $thelist, $separator, $parents );}/** * Check if the current post in within any of the given categories. * * The given categories are checked against the post's categories' term_ids, names and slugs. * Categories given as integers will only be checked against the post's categories' term_ids. * * Prior to v2.5 of WordPress, category names were not supported. * Prior to v2.7, category slugs were not supported. * Prior to v2.7, only one category could be compared: in_category( $single_category ). * Prior to v2.7, this function could only be used in the WordPress Loop. * As of 2.7, the function can be used anywhere if it is provided a post ID or post object. * * @since 1.2.0 * * @uses is_object_in_term() * * @param int|string|array $category. Category ID, name or slug, or array of said. * @param int|post object Optional.  Post to check instead of the current post. @since 2.7.0 * @return bool True if the current post is in any of the given categories. */function in_category( $category, $_post = null ) {	if ( empty( $category ) )		return false;	if ( $_post ) {		$_post = get_post( $_post );	} else {		$_post =& $GLOBALS['post'];	}	if ( !$_post )		return false;	$r = is_object_in_term( $_post->ID, 'category', $category );	if ( is_wp_error( $r ) )		return false;	return $r;}/** * Display the category list for the post. * * @since 0.71 * * @param string $separator Optional, default is empty string. Separator for between the categories. * @param string $parents Optional. How to display the parents. * @param int $post_id Optional. Post ID to retrieve categories. */function the_category( $separator = '', $parents='', $post_id = false ) {	echo get_the_category_list( $separator, $parents, $post_id );}/** * Retrieve category description. * * @since 1.0.0 * * @param int $category Optional. Category ID. Will use global category ID by default. * @return string Category description, available. */function category_description( $category = 0 ) {	return term_description( $category, 'category' );}/** * Display or retrieve the HTML dropdown list of categories. * * The list of arguments is below: *     'show_option_all' (string) - Text to display for showing all categories. *     'show_option_none' (string) - Text to display for showing no categories. *     'orderby' (string) default is 'ID' - What column to use for ordering the * categories. *     'order' (string) default is 'ASC' - What direction to order categories. *     'show_last_update' (bool|int) default is 0 - See {@link get_categories()} *     'show_count' (bool|int) default is 0 - Whether to show how many posts are * in the category. *     'hide_empty' (bool|int) default is 1 - Whether to hide categories that * don't have any posts attached to them. *     'child_of' (int) default is 0 - See {@link get_categories()}. *     'exclude' (string) - See {@link get_categories()}. *     'echo' (bool|int) default is 1 - Whether to display or retrieve content. *     'depth' (int) - The max depth. *     'tab_index' (int) - Tab index for select element. *     'name' (string) - The name attribute value for select element. *     'id' (string) - The ID attribute value for select element. Defaults to name if omitted. *     'class' (string) - The class attribute value for select element. *     'selected' (int) - Which category ID is selected. *     'taxonomy' (string) - The name of the taxonomy to retrieve. Defaults to category. * * The 'hierarchical' argument, which is disabled by default, will override the * depth argument, unless it is true. When the argument is false, it will * display all of the categories. When it is enabled it will use the value in * the 'depth' argument. * * @since 2.1.0 * * @param string|array $args Optional. Override default arguments. * @return string HTML content only if 'echo' argument is 0. */function wp_dropdown_categories( $args = '' ) {	$defaults = array(		'show_option_all' => '', 'show_option_none' => '',		'orderby' => 'id', 'order' => 'ASC',		'show_last_update' => 0, 'show_count' => 0,		'hide_empty' => 1, 'child_of' => 0,		'exclude' => '', 'echo' => 1,		'selected' => 0, 'hierarchical' => 0,		'name' => 'cat', 'id' => '',		'class' => 'postform', 'depth' => 0,		'tab_index' => 0, 'taxonomy' => 'category',		'hide_if_empty' => false	);	$defaults['selected'] = ( is_category() ) ? get_query_var( 'cat' ) : 0;	// Back compat.	if ( isset( $args['type'] ) && 'link' == $args['type'] ) {		_deprecated_argument( __FUNCTION__, '3.0', '' );		$args['taxonomy'] = 'link_category';	}	$r = wp_parse_args( $args, $defaults );	if ( !isset( $r['pad_counts'] ) && $r['show_count'] && $r['hierarchical'] ) {		$r['pad_counts'] = true;	}	$r['include_last_update_time'] = $r['show_last_update'];	extract( $r );	$tab_index_attribute = '';	if ( (int) $tab_index > 0 )		$tab_index_attribute = " tabindex=\"$tab_index\"";	$categories = get_terms( $taxonomy, $r );	$name = esc_attr( $name );	$class = esc_attr( $class );	$id = $id ? esc_attr( $id ) : $name;	if ( ! $r['hide_if_empty'] || ! empty($categories) )		$output = "<select name='$name' id='$id' class='$class' $tab_index_attribute>\n";	else		$output = '';	if ( empty($categories) && ! $r['hide_if_empty'] && !empty($show_option_none) ) {		$show_option_none = apply_filters( 'list_cats', $show_option_none );		$output .= "\t<option value='-1' selected='selected'>$show_option_none</option>\n";	}	if ( ! empty( $categories ) ) {		if ( $show_option_all ) {			$show_option_all = apply_filters( 'list_cats', $show_option_all );			$selected = ( '0' === strval($r['selected']) ) ? " selected='selected'" : '';			$output .= "\t<option value='0'$selected>$show_option_all</option>\n";		}		if ( $show_option_none ) {			$show_option_none = apply_filters( 'list_cats', $show_option_none );			$selected = ( '-1' === strval($r['selected']) ) ? " selected='selected'" : '';			$output .= "\t<option value='-1'$selected>$show_option_none</option>\n";		}		if ( $hierarchical )			$depth = $r['depth'];  // Walk the full depth.		else			$depth = -1; // Flat.		$output .= walk_category_dropdown_tree( $categories, $depth, $r );	}	if ( ! $r['hide_if_empty'] || ! empty($categories) )		$output .= "</select>\n";	$output = apply_filters( 'wp_dropdown_cats', $output );	if ( $echo )		echo $output;	return $output;}/** * Display or retrieve the HTML list of categories. * * The list of arguments is below: *     'show_option_all' (string) - Text to display for showing all categories. *     'orderby' (string) default is 'ID' - What column to use for ordering the * categories. *     'order' (string) default is 'ASC' - What direction to order categories. *     'show_last_update' (bool|int) default is 0 - See {@link * walk_category_dropdown_tree()} *     'show_count' (bool|int) default is 0 - Whether to show how many posts are * in the category. *     'hide_empty' (bool|int) default is 1 - Whether to hide categories that * don't have any posts attached to them. *     'use_desc_for_title' (bool|int) default is 1 - Whether to use the * description instead of the category title. *     'feed' - See {@link get_categories()}. *     'feed_type' - See {@link get_categories()}. *     'feed_image' - See {@link get_categories()}. *     'child_of' (int) default is 0 - See {@link get_categories()}. *     'exclude' (string) - See {@link get_categories()}. *     'exclude_tree' (string) - See {@link get_categories()}. *     'echo' (bool|int) default is 1 - Whether to display or retrieve content. *     'current_category' (int) - See {@link get_categories()}. *     'hierarchical' (bool) - See {@link get_categories()}. *     'title_li' (string) - See {@link get_categories()}. *     'depth' (int) - The max depth. * * @since 2.1.0 * * @param string|array $args Optional. Override default arguments. * @return string HTML content only if 'echo' argument is 0. */function wp_list_categories( $args = '' ) {	$defaults = array(		'show_option_all' => '', 'show_option_none' => __('No categories'),		'orderby' => 'name', 'order' => 'ASC',		'show_last_update' => 0, 'style' => 'list',		'show_count' => 0, 'hide_empty' => 1,		'use_desc_for_title' => 1, 'child_of' => 0,		'feed' => '', 'feed_type' => '',		'feed_image' => '', 'exclude' => '',		'exclude_tree' => '', 'current_category' => 0,		'hierarchical' => true, 'title_li' => __( 'Categories' ),		'echo' => 1, 'depth' => 0,		'taxonomy' => 'category'	);	$r = wp_parse_args( $args, $defaults );	if ( !isset( $r['pad_counts'] ) && $r['show_count'] && $r['hierarchical'] )		$r['pad_counts'] = true;	if ( isset( $r['show_date'] ) )		$r['include_last_update_time'] = $r['show_date'];	if ( true == $r['hierarchical'] ) {		$r['exclude_tree'] = $r['exclude'];		$r['exclude'] = '';	}	if ( !isset( $r['class'] ) )		$r['class'] = ( 'category' == $r['taxonomy'] ) ? 'categories' : $r['taxonomy'];	extract( $r );	if ( !taxonomy_exists($taxonomy) )		return false;	$categories = get_categories( $r );	$output = '';	if ( $title_li && 'list' == $style )			$output = '<li class="' . $class . '">' . $title_li . '<ul>';	if ( empty( $categories ) ) {		if ( ! empty( $show_option_none ) ) {			if ( 'list' == $style )				$output .= '<li>' . $show_option_none . '</li>';			else				$output .= $show_option_none;		}	} else {		global $wp_query;		if( !empty( $show_option_all ) )			if ( 'list' == $style )				$output .= '<li><a href="' .  get_bloginfo( 'url' )  . '">' . $show_option_all . '</a></li>';			else				$output .= '<a href="' .  get_bloginfo( 'url' )  . '">' . $show_option_all . '</a>';		if ( empty( $r['current_category'] ) && ( is_category() || is_tax() ) )			$r['current_category'] = $wp_query->get_queried_object_id();		if ( $hierarchical )			$depth = $r['depth'];		else			$depth = -1; // Flat.		$output .= walk_category_tree( $categories, $depth, $r );	}	if ( $title_li && 'list' == $style )		$output .= '</ul></li>';	$output = apply_filters( 'wp_list_categories', $output, $args );	if ( $echo )		echo $output;	else		return $output;}/** * Display tag cloud. * * The text size is set by the 'smallest' and 'largest' arguments, which will * use the 'unit' argument value for the CSS text size unit. The 'format' * argument can be 'flat' (default), 'list', or 'array'. The flat value for the * 'format' argument will separate tags with spaces. The list value for the * 'format' argument will format the tags in a UL HTML list. The array value for * the 'format' argument will return in PHP array type format. * * The 'orderby' argument will accept 'name' or 'count' and defaults to 'name'. * The 'order' is the direction to sort, defaults to 'ASC' and can be 'DESC'. * * The 'number' argument is how many tags to return. By default, the limit will * be to return the top 45 tags in the tag cloud list. * * The 'topic_count_text_callback' argument is a function, which, given the count * of the posts  with that tag, returns a text for the tooltip of the tag link. * * The 'exclude' and 'include' arguments are used for the {@link get_tags()} * function. Only one should be used, because only one will be used and the * other ignored, if they are both set. * * @since 2.3.0 * * @param array|string $args Optional. Override default arguments. * @return array Generated tag cloud, only if no failures and 'array' is set for the 'format' argument. */function wp_tag_cloud( $args = '' ) {	$defaults = array(		'smallest' => 8, 'largest' => 22, 'unit' => 'pt', 'number' => 45,		'format' => 'flat', 'separator' => "\n", 'orderby' => 'name', 'order' => 'ASC',		'exclude' => '', 'include' => '', 'link' => 'view', 'taxonomy' => 'post_tag', 'echo' => true	);	$args = wp_parse_args( $args, $defaults );	$tags = get_terms( $args['taxonomy'], array_merge( $args, array( 'orderby' => 'count', 'order' => 'DESC' ) ) ); // Always query top tags	if ( empty( $tags ) )		return;	foreach ( $tags as $key => $tag ) {		if ( 'edit' == $args['link'] )			$link = get_edit_tag_link( $tag->term_id, $args['taxonomy'] );		else			$link = get_term_link( intval($tag->term_id), $args['taxonomy'] );		if ( is_wp_error( $link ) )			return false;		$tags[ $key ]->link = $link;		$tags[ $key ]->id = $tag->term_id;	}	$return = wp_generate_tag_cloud( $tags, $args ); // Here's where those top tags get sorted according to $args	$return = apply_filters( 'wp_tag_cloud', $return, $args );	if ( 'array' == $args['format'] || empty($args['echo']) )		return $return;	echo $return;}/** * Default text for tooltip for tag links * * @param integer $count number of posts with that tag * @return string text for the tooltip of a tag link. */function default_topic_count_text( $count ) {	return sprintf( _n('%s topic', '%s topics', $count), number_format_i18n( $count ) );}/** * Default topic count scaling for tag links * * @param integer $count number of posts with that tag * @return integer scaled count */function default_topic_count_scale( $count ) {	return round(log10($count + 1) * 100);}/** * Generates a tag cloud (heatmap) from provided data. * * The text size is set by the 'smallest' and 'largest' arguments, which will * use the 'unit' argument value for the CSS text size unit. The 'format' * argument can be 'flat' (default), 'list', or 'array'. The flat value for the * 'format' argument will separate tags with spaces. The list value for the * 'format' argument will format the tags in a UL HTML list. The array value for * the 'format' argument will return in PHP array type format. * * The 'tag_cloud_sort' filter allows you to override the sorting. * Passed to the filter: $tags array and $args array, has to return the $tags array * after sorting it. * * The 'orderby' argument will accept 'name' or 'count' and defaults to 'name'. * The 'order' is the direction to sort, defaults to 'ASC' and can be 'DESC' or * 'RAND'. * * The 'number' argument is how many tags to return. By default, the limit will * be to return the entire tag cloud list. * * The 'topic_count_text_callback' argument is a function, which given the count * of the posts  with that tag returns a text for the tooltip of the tag link. * * @todo Complete functionality. * @since 2.3.0 * * @param array $tags List of tags. * @param string|array $args Optional, override default arguments. * @return string */function wp_generate_tag_cloud( $tags, $args = '' ) {	global $wp_rewrite;	$defaults = array(		'smallest' => 8, 'largest' => 22, 'unit' => 'pt', 'number' => 0,		'format' => 'flat', 'separator' => "\n", 'orderby' => 'name', 'order' => 'ASC',		'topic_count_text_callback' => 'default_topic_count_text',		'topic_count_scale_callback' => 'default_topic_count_scale', 'filter' => 1,	);	if ( !isset( $args['topic_count_text_callback'] ) && isset( $args['single_text'] ) && isset( $args['multiple_text'] ) ) {		$body = 'return sprintf (			_n(' . var_export($args['single_text'], true) . ', ' . var_export($args['multiple_text'], true) . ', $count),			number_format_i18n( $count ));';		$args['topic_count_text_callback'] = create_function('$count', $body);	}	$args = wp_parse_args( $args, $defaults );	extract( $args );	if ( empty( $tags ) )		return;	$tags_sorted = apply_filters( 'tag_cloud_sort', $tags, $args );	if ( $tags_sorted != $tags  ) { // the tags have been sorted by a plugin		$tags = $tags_sorted;		unset($tags_sorted);	} else {		if ( 'RAND' == $order ) {			shuffle($tags);		} else {			// SQL cannot save you; this is a second (potentially different) sort on a subset of data.			if ( 'name' == $orderby )				uasort( $tags, create_function('$a, $b', 'return strnatcasecmp($a->name, $b->name);') );			else				uasort( $tags, create_function('$a, $b', 'return ($a->count > $b->count);') );			if ( 'DESC' == $order )				$tags = array_reverse( $tags, true );		}	}	if ( $number > 0 )		$tags = array_slice($tags, 0, $number);	$counts = array();	$real_counts = array(); // For the alt tag	foreach ( (array) $tags as $key => $tag ) {		$real_counts[ $key ] = $tag->count;		$counts[ $key ] = $topic_count_scale_callback($tag->count);	}	$min_count = min( $counts );	$spread = max( $counts ) - $min_count;	if ( $spread <= 0 )		$spread = 1;	$font_spread = $largest - $smallest;	if ( $font_spread < 0 )		$font_spread = 1;	$font_step = $font_spread / $spread;	$a = array();	foreach ( $tags as $key => $tag ) {		$count = $counts[ $key ];		$real_count = $real_counts[ $key ];		$tag_link = '#' != $tag->link ? esc_url( $tag->link ) : '#';		$tag_id = isset($tags[ $key ]->id) ? $tags[ $key ]->id : $key;		$tag_name = $tags[ $key ]->name;		$a[] = "<a href='$tag_link' class='tag-link-$tag_id' title='" . esc_attr( $topic_count_text_callback( $real_count ) ) . "' style='font-size: " .			( $smallest + ( ( $count - $min_count ) * $font_step ) )			. "$unit;'>$tag_name</a>";	}	switch ( $format ) :	case 'array' :		$return =& $a;		break;	case 'list' :		$return = "<ul class='wp-tag-cloud'>\n\t<li>";		$return .= join( "</li>\n\t<li>", $a );		$return .= "</li>\n</ul>\n";		break;	default :		$return = join( $separator, $a );		break;	endswitch;    if ( $filter )		return apply_filters( 'wp_generate_tag_cloud', $return, $tags, $args );    else		return $return;}//// Helper functions///** * Retrieve HTML list content for category list. * * @uses Walker_Category to create HTML list content. * @since 2.1.0 * @see Walker_Category::walk() for parameters and return description. */function walk_category_tree() {	$args = func_get_args();	// the user's options are the third parameter	if ( empty($args[2]['walker']) || !is_a($args[2]['walker'], 'Walker') )		$walker = new Walker_Category;	else		$walker = $args[2]['walker'];	return call_user_func_array(array( &$walker, 'walk' ), $args );}/** * Retrieve HTML dropdown (select) content for category list. * * @uses Walker_CategoryDropdown to create HTML dropdown content. * @since 2.1.0 * @see Walker_CategoryDropdown::walk() for parameters and return description. */function walk_category_dropdown_tree() {	$args = func_get_args();	// the user's options are the third parameter	if ( empty($args[2]['walker']) || !is_a($args[2]['walker'], 'Walker') )		$walker = new Walker_CategoryDropdown;	else		$walker = $args[2]['walker'];	return call_user_func_array(array( &$walker, 'walk' ), $args );}//// Tags///** * Retrieve the link to the tag. * * @since 2.3.0 * @uses apply_filters() Calls 'tag_link' with tag link and tag ID as parameters. * * @param int $tag_id Tag (term) ID. * @return string */function get_tag_link( $tag_id ) {	global $wp_rewrite;	$taglink = $wp_rewrite->get_tag_permastruct();	$tag = &get_term( $tag_id, 'post_tag' );	if ( is_wp_error( $tag ) )		return $tag;	$slug = $tag->slug;	if ( empty( $taglink ) ) {		$file = get_option( 'home' ) . '/';		$taglink = $file . '?tag=' . $slug;	} else {		$taglink = str_replace( '%tag%', $slug, $taglink );		$taglink = get_option( 'home' ) . user_trailingslashit( $taglink, 'category' );	}	return apply_filters( 'tag_link', $taglink, $tag_id );}/** * Retrieve the tags for a post. * * @since 2.3.0 * @uses apply_filters() Calls 'get_the_tags' filter on the list of post tags. * * @param int $id Post ID. * @return array */function get_the_tags( $id = 0 ) {	return apply_filters( 'get_the_tags', get_the_terms( $id, 'post_tag' ) );}/** * Retrieve the tags for a post formatted as a string. * * @since 2.3.0 * @uses apply_filters() Calls 'the_tags' filter on string list of tags. * * @param string $before Optional. Before tags. * @param string $sep Optional. Between tags. * @param string $after Optional. After tags. * @return string */function get_the_tag_list( $before = '', $sep = '', $after = '' ) {	return apply_filters( 'the_tags', get_the_term_list( 0, 'post_tag', $before, $sep, $after ), $before, $sep, $after);}/** * Retrieve the tags for a post. * * @since 2.3.0 * * @param string $before Optional. Before list. * @param string $sep Optional. Separate items using this. * @param string $after Optional. After list. * @return string */function the_tags( $before = null, $sep = ', ', $after = '' ) {	if ( null === $before )		$before = __('Tags: ');	echo get_the_tag_list($before, $sep, $after);}/** * Retrieve tag description. * * @since 2.8 * * @param int $tag Optional. Tag ID. Will use global tag ID by default. * @return string Tag description, available. */function tag_description( $tag = 0 ) {	return term_description( $tag );}/** * Retrieve term description. * * @since 2.8 * * @param int $term Optional. Term ID. Will use global term ID by default. * @return string Term description, available. */function term_description( $term = 0, $taxonomy = 'post_tag' ) {	if ( !$term && ( is_tax() || is_tag() || is_category() ) ) {		global $wp_query;		$term = $wp_query->get_queried_object();		$taxonomy = $term->taxonomy;		$term = $term->term_id;	}	$description = get_term_field( 'description', $term, $taxonomy );	return is_wp_error( $description ) ? '' : $description;}/** * Retrieve the terms of the taxonomy that are attached to the post. * * This function can only be used within the loop. * * @since 2.5.0 * * @param int $id Post ID. Is not optional. * @param string $taxonomy Taxonomy name. * @return array|bool False on failure. Array of term objects on success. */function get_the_terms( $id = 0, $taxonomy ) {	global $post; 	$id = (int) $id;	if ( !$id ) {		if ( !$post->ID )			return false;		else			$id = (int) $post->ID;	}	$terms = get_object_term_cache( $id, $taxonomy );	if ( false === $terms )		$terms = wp_get_object_terms( $id, $taxonomy );	if ( empty( $terms ) )		return false;	return $terms;}/** * Retrieve a post's terms as a list with specified format. * * @since 2.5.0 * * @param int $id Post ID. * @param string $taxonomy Taxonomy name. * @param string $before Optional. Before list. * @param string $sep Optional. Separate items using this. * @param string $after Optional. After list. * @return string */function get_the_term_list( $id = 0, $taxonomy, $before = '', $sep = '', $after = '' ) {	$terms = get_the_terms( $id, $taxonomy );	if ( is_wp_error( $terms ) )		return $terms;	if ( empty( $terms ) )		return false;	foreach ( $terms as $term ) {		$link = get_term_link( $term, $taxonomy );		if ( is_wp_error( $link ) )			return $link;		$term_links[] = '<a href="' . $link . '" rel="tag">' . $term->name . '</a>';	}	$term_links = apply_filters( "term_links-$taxonomy", $term_links );	return $before . join( $sep, $term_links ) . $after;}/** * Display the terms in a list. * * @since 2.5.0 * * @param int $id Term ID. * @param string $taxonomy Taxonomy name. * @param string $before Optional. Before list. * @param string $sep Optional. Separate items using this. * @param string $after Optional. After list. * @return null|bool False on WordPress error. Returns null when displaying. */function the_terms( $id, $taxonomy, $before = '', $sep = ', ', $after = '' ) {	$term_list = get_the_term_list( $id, $taxonomy, $before, $sep, $after );	if ( is_wp_error( $term_list ) )		return false;	echo apply_filters('the_terms', $term_list, $taxonomy, $before, $sep, $after);}/** * Check if the current post has any of given tags. * * The given tags are checked against the post's tags' term_ids, names and slugs. * Tags given as integers will only be checked against the post's tags' term_ids. * If no tags are given, determines if post has any tags. * * Prior to v2.7 of WordPress, tags given as integers would also be checked against the post's tags' names and slugs (in addition to term_ids) * Prior to v2.7, this function could only be used in the WordPress Loop. * As of 2.7, the function can be used anywhere if it is provided a post ID or post object. * * @since 2.6.0 * * @uses is_object_in_term() * * @param string|int|array $tag Optional. The tag name/term_id/slug or array of them to check for. * @param int|post object Optional.  Post to check instead of the current post. @since 2.7.0 * @return bool True if the current post has any of the the given tags (or any tag, if no tag specified). */function has_tag( $tag = '', $_post = null ) {	if ( $_post ) {		$_post = get_post( $_post );	} else {		$_post =& $GLOBALS['post'];	}	if ( !$_post )		return false;	$r = is_object_in_term( $_post->ID, 'post_tag', $tag );	if ( is_wp_error( $r ) )		return false;	return $r;}?>
<?php/** * Taxonomy API * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 *///// Taxonomy Registration///** * Creates the initial taxonomies when 'init' action is fired. */function create_initial_taxonomies() {	register_taxonomy( 'category', 'post', array(		'hierarchical' => true,	 	'update_count_callback' => '_update_post_term_count',		'query_var' => false,		'rewrite' => false,		'public' => true,		'show_ui' => true,		'_builtin' => true,	) ) ;	register_taxonomy( 'post_tag', 'post', array(	 	'hierarchical' => false,		'update_count_callback' => '_update_post_term_count',		'query_var' => false,		'rewrite' => false,		'public' => true,		'show_ui' => true,		'_builtin' => true,	) );	register_taxonomy( 'nav_menu', 'nav_menu_item', array(		'hierarchical' => false,		'labels' => array(			'name' => __( 'Navigation Menus' ),			'singular_name' => __( 'Navigation Menu' ),		),		'query_var' => false,		'rewrite' => false,		'show_ui' => false,		'_builtin' => true,		'show_in_nav_menus' => false,	) ) ;	register_taxonomy( 'link_category', 'link', array(		'hierarchical' => false,		'labels' => array(			'name' => __( 'Categories' ),			'singular_name' => __( 'Category' ),			'update_item' => __( 'Update Category' ),		),		'query_var' => false,		'rewrite' => false,		'public' => false,		'show_ui' => false,		'_builtin' => true,	) ) ;}add_action( 'init', 'create_initial_taxonomies', 0 ); // highest priority/** * Get a list of registered taxonomy objects. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * @uses $wp_taxonomies * @see register_taxonomy * * @param array $args An array of key => value arguments to match against the taxonomy objects. * @param string $output The type of output to return, either taxonomy 'names' or 'objects'. 'names' is the default. * @param string $operator The logical operation to perform. 'or' means only one element *  from the array needs to match; 'and' means all elements must match. The default is 'and'. * @return array A list of taxonomy names or objects */function get_taxonomies( $args = array(), $output = 'names', $operator = 'and' ) {	global $wp_taxonomies;	$field = ('names' == $output) ? 'name' : false;	return wp_filter_object_list($wp_taxonomies, $args, $operator, $field);}/** * Return all of the taxonomy names that are of $object_type. * * It appears that this function can be used to find all of the names inside of * $wp_taxonomies global variable. * * <code><?php $taxonomies = get_object_taxonomies('post'); ?></code> Should * result in <code>Array('category', 'post_tag')</code> * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wp_taxonomies * * @param array|string|object $object Name of the type of taxonomy object, or an object (row from posts) * @param string $output The type of output to return, either taxonomy 'names' or 'objects'. 'names' is the default. * @return array The names of all taxonomy of $object_type. */function get_object_taxonomies($object, $output = 'names') {	global $wp_taxonomies;	if ( is_object($object) ) {		if ( $object->post_type == 'attachment' )			return get_attachment_taxonomies($object);		$object = $object->post_type;	}	$object = (array) $object;	$taxonomies = array();	foreach ( (array) $wp_taxonomies as $tax_name => $tax_obj ) {		if ( array_intersect($object, (array) $tax_obj->object_type) ) {			if ( 'names' == $output )				$taxonomies[] = $tax_name;			else				$taxonomies[ $tax_name ] = $tax_obj;		}	}	return $taxonomies;}/** * Retrieves the taxonomy object of $taxonomy. * * The get_taxonomy function will first check that the parameter string given * is a taxonomy object and if it is, it will return it. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wp_taxonomies * @uses taxonomy_exists() Checks whether taxonomy exists * * @param string $taxonomy Name of taxonomy object to return * @return object|bool The Taxonomy Object or false if $taxonomy doesn't exist */function get_taxonomy( $taxonomy ) {	global $wp_taxonomies;	if ( ! taxonomy_exists( $taxonomy ) )		return false;	return $wp_taxonomies[$taxonomy];}/** * Checks that the taxonomy name exists. * * Formerly is_taxonomy(), introduced in 2.3.0. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * * @uses $wp_taxonomies * * @param string $taxonomy Name of taxonomy object * @return bool Whether the taxonomy exists. */function taxonomy_exists( $taxonomy ) {	global $wp_taxonomies;	return isset( $wp_taxonomies[$taxonomy] );}/** * Whether the taxonomy object is hierarchical. * * Checks to make sure that the taxonomy is an object first. Then Gets the * object, and finally returns the hierarchical value in the object. * * A false return value might also mean that the taxonomy does not exist. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses taxonomy_exists() Checks whether taxonomy exists * @uses get_taxonomy() Used to get the taxonomy object * * @param string $taxonomy Name of taxonomy object * @return bool Whether the taxonomy is hierarchical */function is_taxonomy_hierarchical($taxonomy) {	if ( ! taxonomy_exists($taxonomy) )		return false;	$taxonomy = get_taxonomy($taxonomy);	return $taxonomy->hierarchical;}/** * Create or modify a taxonomy object. Do not use before init. * * A simple function for creating or modifying a taxonomy object based on the * parameters given. The function will accept an array (third optional * parameter), along with strings for the taxonomy name and another string for * the object type. * * Nothing is returned, so expect error maybe or use taxonomy_exists() to check * whether taxonomy exists. * * Optional $args contents: * * label - Name of the taxonomy shown in the menu. Usually plural. If not set, labels['name'] will be used. * * hierarchical - has some defined purpose at other parts of the API and is a * boolean value. * * update_count_callback - works much like a hook, in that it will be called * when the count is updated. * * rewrite - false to prevent rewrite, or array('slug'=>$slug) to customize * permastruct; default will use $taxonomy as slug. * * query_var - false to prevent queries, or string to customize query var * (?$query_var=$term); default will use $taxonomy as query var. * * public - If the taxonomy should be publically queryable; //@TODO not implemented. * defaults to true. * * show_ui - If the WordPress UI admin tags UI should apply to this taxonomy; * defaults to public. * * show_in_nav_menus - true makes this taxonomy available for selection in navigation menus. * Defaults to public. * * show_tagcloud - false to prevent the taxonomy being listed in the Tag Cloud Widget; * defaults to show_ui which defalts to public. * * labels - An array of labels for this taxonomy. You can see accepted values in {@link get_taxonomy_labels()}. By default tag labels are used for non-hierarchical types and category labels for hierarchical ones. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wp_taxonomies Inserts new taxonomy object into the list * @uses $wp_rewrite Adds rewrite tags and permastructs * @uses $wp Adds query vars * * @param string $taxonomy Name of taxonomy object * @param array|string $object_type Name of the object type for the taxonomy object. * @param array|string $args See above description for the two keys values. */function register_taxonomy( $taxonomy, $object_type, $args = array() ) {	global $wp_taxonomies, $wp_rewrite, $wp;	if ( ! is_array($wp_taxonomies) )		$wp_taxonomies = array();	$defaults = array(	'hierarchical' => false,						'update_count_callback' => '',						'rewrite' => true,						'query_var' => $taxonomy,						'public' => true,						'show_ui' => null,						'show_tagcloud' => null,						'_builtin' => false,						'labels' => array(),						'capabilities' => array(),						'show_in_nav_menus' => null,					);	$args = wp_parse_args($args, $defaults);	if ( false !== $args['query_var'] && !empty($wp) ) {		if ( true === $args['query_var'] )			$args['query_var'] = $taxonomy;		$args['query_var'] = sanitize_title_with_dashes($args['query_var']);		$wp->add_query_var($args['query_var']);	}	if ( false !== $args['rewrite'] && '' != get_option('permalink_structure') ) {		$args['rewrite'] = wp_parse_args($args['rewrite'], array(			'slug' => sanitize_title_with_dashes($taxonomy),			'with_front' => true,		));		$wp_rewrite->add_rewrite_tag("%$taxonomy%", '([^/]+)', $args['query_var'] ? "{$args['query_var']}=" : "taxonomy=$taxonomy&term=");		$wp_rewrite->add_permastruct($taxonomy, "{$args['rewrite']['slug']}/%$taxonomy%", $args['rewrite']['with_front']);	}	if ( is_null($args['show_ui']) )		$args['show_ui'] = $args['public'];	// Whether to show this type in nav-menus.php. Defaults to the setting for public.	if ( null === $args['show_in_nav_menus'] )		$args['show_in_nav_menus'] = $args['public'];	if ( is_null($args['show_tagcloud']) )		$args['show_tagcloud'] = $args['show_ui'];	$default_caps = array(		'manage_terms' => 'manage_categories',		'edit_terms'   => 'manage_categories',		'delete_terms' => 'manage_categories',		'assign_terms' => 'edit_posts',	);	$args['cap'] = (object) array_merge( $default_caps, $args['capabilities'] );	unset( $args['capabilities'] );	$args['name'] = $taxonomy;	$args['object_type'] = (array) $object_type;	$args['labels'] = get_taxonomy_labels( (object) $args );	$args['label'] = $args['labels']->name;	$wp_taxonomies[$taxonomy] = (object) $args;	// register callback handling for metabox 	add_filter('wp_ajax_add-'.$taxonomy, '_wp_ajax_add_hierarchical_term');}/** * Builds an object with all taxonomy labels out of a taxonomy object * * Accepted keys of the label array in the taxonomy object: * - name - general name for the taxonomy, usually plural. The same as and overriden by $tax->label. Default is Post Tags/Categories * - singular_name - name for one object of this taxonomy. Default is Post Tag/Category * - search_items - Default is Search Tags/Search Categories * - popular_items - This string isn't used on hierarchical taxonomies. Default is Popular Tags * - all_items - Default is All Tags/All Categories * - parent_item - This string isn't used on non-hierarchical taxonomies. In hierarchical ones the default is Parent Category * - parent_item_colon - The same as <code>parent_item</code>, but with colon <code>:</code> in the end * - edit_item - Default is Edit Tag/Edit Category * - update_item - Default is Update Tag/Update Category * - add_new_item - Default is Add New Tag/Add New Category * - new_item_name - Default is New Tag Name/New Category Name * - separate_items_with_commas - This string isn't used on hierarchical taxonomies. Default is "Separate tags with commas," used in the meta box. * - add_or_remove_items - This string isn't used on hierarchical taxonomies. Default is "Add or remove tags," used in the meta box when JavaScript is disabled. * - choose_from_most_used - This string isn't used on hierarchical taxonomies. Default is "Choose from the most used tags," used in the meta box. * * Above, the first default value is for non-hierarchical taxonomies (like tags) and the second one is for hierarchical taxonomies (like categories.) * * @since 3.0.0 * @param object $tax Taxonomy object * @return object object with all the labels as member variables */function get_taxonomy_labels( $tax ) {	if ( isset( $tax->helps ) && empty( $tax->labels['separate_items_with_commas'] ) )		$tax->labels['separate_items_with_commas'] = $tax->helps;	$nohier_vs_hier_defaults = array(		'name' => array( _x( 'Post Tags', 'taxonomy general name' ), _x( 'Categories', 'taxonomy general name' ) ),		'singular_name' => array( _x( 'Post Tag', 'taxonomy singular name' ), _x( 'Category', 'taxonomy singular name' ) ),		'search_items' => array( __( 'Search Tags' ), __( 'Search Categories' ) ),		'popular_items' => array( __( 'Popular Tags' ), null ),		'all_items' => array( __( 'All Tags' ), __( 'All Categories' ) ),		'parent_item' => array( null, __( 'Parent Category' ) ),		'parent_item_colon' => array( null, __( 'Parent Category:' ) ),		'edit_item' => array( __( 'Edit Tag' ), __( 'Edit Category' ) ),		'update_item' => array( __( 'Update Tag' ), __( 'Update Category' ) ),		'add_new_item' => array( __( 'Add New Tag' ), __( 'Add New Category' ) ),		'new_item_name' => array( __( 'New Tag Name' ), __( 'New Category Name' ) ),		'separate_items_with_commas' => array( __( 'Separate tags with commas' ), null ),		'add_or_remove_items' => array( __( 'Add or remove tags' ), null ),		'choose_from_most_used' => array( __( 'Choose from the most used tags' ), null ),	);	return _get_custom_object_labels( $tax, $nohier_vs_hier_defaults );}/** * Add an already registered taxonomy to an object type. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * @uses $wp_taxonomies Modifies taxonomy object * * @param string $taxonomy Name of taxonomy object * @param array|string $object_type Name of the object type * @return bool True if successful, false if not */function register_taxonomy_for_object_type( $taxonomy, $object_type) {	global $wp_taxonomies;	if ( !isset($wp_taxonomies[$taxonomy]) )		return false;	if ( ! get_post_type_object($object_type) )		return false;	$wp_taxonomies[$taxonomy]->object_type[] = $object_type;	return true;}//// Term API///** * Retrieve object_ids of valid taxonomy and term. * * The strings of $taxonomies must exist before this function will continue. On * failure of finding a valid taxonomy, it will return an WP_Error class, kind * of like Exceptions in PHP 5, except you can't catch them. Even so, you can * still test for the WP_Error class and get the error message. * * The $terms aren't checked the same as $taxonomies, but still need to exist * for $object_ids to be returned. * * It is possible to change the order that object_ids is returned by either * using PHP sort family functions or using the database by using $args with * either ASC or DESC array. The value should be in the key named 'order'. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses wp_parse_args() Creates an array from string $args. * * @param int|array $term_ids Term id or array of term ids of terms that will be used * @param string|array $taxonomies String of taxonomy name or Array of string values of taxonomy names * @param array|string $args Change the order of the object_ids, either ASC or DESC * @return WP_Error|array If the taxonomy does not exist, then WP_Error will be returned. On success *	the array can be empty meaning that there are no $object_ids found or it will return the $object_ids found. */function get_objects_in_term( $term_ids, $taxonomies, $args = array() ) {	global $wpdb;	if ( ! is_array( $term_ids ) )		$term_ids = array( $term_ids );	if ( ! is_array( $taxonomies ) )		$taxonomies = array( $taxonomies );	foreach ( (array) $taxonomies as $taxonomy ) {		if ( ! taxonomy_exists( $taxonomy ) )			return new WP_Error( 'invalid_taxonomy', __( 'Invalid Taxonomy' ) );	}	$defaults = array( 'order' => 'ASC' );	$args = wp_parse_args( $args, $defaults );	extract( $args, EXTR_SKIP );	$order = ( 'desc' == strtolower( $order ) ) ? 'DESC' : 'ASC';	$term_ids = array_map('intval', $term_ids );	$taxonomies = "'" . implode( "', '", $taxonomies ) . "'";	$term_ids = "'" . implode( "', '", $term_ids ) . "'";	$object_ids = $wpdb->get_col("SELECT tr.object_id FROM $wpdb->term_relationships AS tr INNER JOIN $wpdb->term_taxonomy AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy IN ($taxonomies) AND tt.term_id IN ($term_ids) ORDER BY tr.object_id $order");	if ( ! $object_ids )		return array();	return $object_ids;}/** * Get all Term data from database by Term ID. * * The usage of the get_term function is to apply filters to a term object. It * is possible to get a term object from the database before applying the * filters. * * $term ID must be part of $taxonomy, to get from the database. Failure, might * be able to be captured by the hooks. Failure would be the same value as $wpdb * returns for the get_row method. * * There are two hooks, one is specifically for each term, named 'get_term', and * the second is for the taxonomy name, 'term_$taxonomy'. Both hooks gets the * term object, and the taxonomy name as parameters. Both hooks are expected to * return a Term object. * * 'get_term' hook - Takes two parameters the term Object and the taxonomy name. * Must return term object. Used in get_term() as a catch-all filter for every * $term. * * 'get_$taxonomy' hook - Takes two parameters the term Object and the taxonomy * name. Must return term object. $taxonomy will be the taxonomy name, so for * example, if 'category', it would be 'get_category' as the filter name. Useful * for custom taxonomies or plugging into default taxonomies. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses sanitize_term() Cleanses the term based on $filter context before returning. * @see sanitize_term_field() The $context param lists the available values for get_term_by() $filter param. * * @param int|object $term If integer, will get from database. If object will apply filters and return $term. * @param string $taxonomy Taxonomy name that $term is part of. * @param string $output Constant OBJECT, ARRAY_A, or ARRAY_N * @param string $filter Optional, default is raw or no WordPress defined filter will applied. * @return mixed|null|WP_Error Term Row from database. Will return null if $term is empty. If taxonomy does not * exist then WP_Error will be returned. */function &get_term($term, $taxonomy, $output = OBJECT, $filter = 'raw') {	global $wpdb;	$null = null;	if ( empty($term) ) {		$error = new WP_Error('invalid_term', __('Empty Term'));		return $error;	}	if ( ! taxonomy_exists($taxonomy) ) {		$error = new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));		return $error;	}	if ( is_object($term) && empty($term->filter) ) {		wp_cache_add($term->term_id, $term, $taxonomy);		$_term = $term;	} else {		if ( is_object($term) )			$term = $term->term_id;		$term = (int) $term;		if ( ! $_term = wp_cache_get($term, $taxonomy) ) {			$_term = $wpdb->get_row( $wpdb->prepare( "SELECT t.*, tt.* FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy = %s AND t.term_id = %s LIMIT 1", $taxonomy, $term) );			if ( ! $_term )				return $null;			wp_cache_add($term, $_term, $taxonomy);		}	}	$_term = apply_filters('get_term', $_term, $taxonomy);	$_term = apply_filters("get_$taxonomy", $_term, $taxonomy);	$_term = sanitize_term($_term, $taxonomy, $filter);	if ( $output == OBJECT ) {		return $_term;	} elseif ( $output == ARRAY_A ) {		$__term = get_object_vars($_term);		return $__term;	} elseif ( $output == ARRAY_N ) {		$__term = array_values(get_object_vars($_term));		return $__term;	} else {		return $_term;	}}/** * Get all Term data from database by Term field and data. * * Warning: $value is not escaped for 'name' $field. You must do it yourself, if * required. * * The default $field is 'id', therefore it is possible to also use null for * field, but not recommended that you do so. * * If $value does not exist, the return value will be false. If $taxonomy exists * and $field and $value combinations exist, the Term will be returned. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses sanitize_term() Cleanses the term based on $filter context before returning. * @see sanitize_term_field() The $context param lists the available values for get_term_by() $filter param. * * @param string $field Either 'slug', 'name', or 'id' * @param string|int $value Search for this term value * @param string $taxonomy Taxonomy Name * @param string $output Constant OBJECT, ARRAY_A, or ARRAY_N * @param string $filter Optional, default is raw or no WordPress defined filter will applied. * @return mixed Term Row from database. Will return false if $taxonomy does not exist or $term was not found. */function get_term_by($field, $value, $taxonomy, $output = OBJECT, $filter = 'raw') {	global $wpdb;	if ( ! taxonomy_exists($taxonomy) )		return false;	if ( 'slug' == $field ) {		$field = 't.slug';		$value = sanitize_title($value);		if ( empty($value) )			return false;	} else if ( 'name' == $field ) {		// Assume already escaped		$value = stripslashes($value);		$field = 't.name';	} else {		return get_term( (int) $value, $taxonomy, $output, $filter);	}	$term = $wpdb->get_row( $wpdb->prepare( "SELECT t.*, tt.* FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy = %s AND $field = %s LIMIT 1", $taxonomy, $value) );	if ( !$term )		return false;	wp_cache_add($term->term_id, $term, $taxonomy);	$term = apply_filters('get_term', $term, $taxonomy);	$term = apply_filters("get_$taxonomy", $term, $taxonomy);	$term = sanitize_term($term, $taxonomy, $filter);	if ( $output == OBJECT ) {		return $term;	} elseif ( $output == ARRAY_A ) {		return get_object_vars($term);	} elseif ( $output == ARRAY_N ) {		return array_values(get_object_vars($term));	} else {		return $term;	}}/** * Merge all term children into a single array of their IDs. * * This recursive function will merge all of the children of $term into the same * array of term IDs. Only useful for taxonomies which are hierarchical. * * Will return an empty array if $term does not exist in $taxonomy. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses _get_term_hierarchy() * @uses get_term_children() Used to get the children of both $taxonomy and the parent $term * * @param string $term ID of Term to get children * @param string $taxonomy Taxonomy Name * @return array|WP_Error List of Term Objects. WP_Error returned if $taxonomy does not exist */function get_term_children( $term_id, $taxonomy ) {	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));	$term_id = intval( $term_id );	$terms = _get_term_hierarchy($taxonomy);	if ( ! isset($terms[$term_id]) )		return array();	$children = $terms[$term_id];	foreach ( (array) $terms[$term_id] as $child ) {		if ( isset($terms[$child]) )			$children = array_merge($children, get_term_children($child, $taxonomy));	}	return $children;}/** * Get sanitized Term field. * * Does checks for $term, based on the $taxonomy. The function is for contextual * reasons and for simplicity of usage. See sanitize_term_field() for more * information. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses sanitize_term_field() Passes the return value in sanitize_term_field on success. * * @param string $field Term field to fetch * @param int $term Term ID * @param string $taxonomy Taxonomy Name * @param string $context Optional, default is display. Look at sanitize_term_field() for available options. * @return mixed Will return an empty string if $term is not an object or if $field is not set in $term. */function get_term_field( $field, $term, $taxonomy, $context = 'display' ) {	$term = (int) $term;	$term = get_term( $term, $taxonomy );	if ( is_wp_error($term) )		return $term;	if ( !is_object($term) )		return '';	if ( !isset($term->$field) )		return '';	return sanitize_term_field($field, $term->$field, $term->term_id, $taxonomy, $context);}/** * Sanitizes Term for editing. * * Return value is sanitize_term() and usage is for sanitizing the term for * editing. Function is for contextual and simplicity. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses sanitize_term() Passes the return value on success * * @param int|object $id Term ID or Object * @param string $taxonomy Taxonomy Name * @return mixed|null|WP_Error Will return empty string if $term is not an object. */function get_term_to_edit( $id, $taxonomy ) {	$term = get_term( $id, $taxonomy );	if ( is_wp_error($term) )		return $term;	if ( !is_object($term) )		return '';	return sanitize_term($term, $taxonomy, 'edit');}/** * Retrieve the terms in a given taxonomy or list of taxonomies. * * You can fully inject any customizations to the query before it is sent, as * well as control the output with a filter. * * The 'get_terms' filter will be called when the cache has the term and will * pass the found term along with the array of $taxonomies and array of $args. * This filter is also called before the array of terms is passed and will pass * the array of terms, along with the $taxonomies and $args. * * The 'list_terms_exclusions' filter passes the compiled exclusions along with * the $args. * * The 'get_terms_orderby' filter passes the ORDER BY clause for the query * along with the $args array. * * The 'get_terms_fields' filter passes the fields for the SELECT query * along with the $args array. * * The list of arguments that $args can contain, which will overwrite the defaults: * * orderby - Default is 'name'. Can be name, count, term_group, slug or nothing * (will use term_id), Passing a custom value other than these will cause it to * order based on the custom value. * * order - Default is ASC. Can use DESC. * * hide_empty - Default is true. Will not return empty terms, which means * terms whose count is 0 according to the given taxonomy. * * exclude - Default is an empty array.  An array, comma- or space-delimited string * of term ids to exclude from the return array.  If 'include' is non-empty, * 'exclude' is ignored. * * exclude_tree - Default is an empty array.  An array, comma- or space-delimited * string of term ids to exclude from the return array, along with all of their * descendant terms according to the primary taxonomy.  If 'include' is non-empty, * 'exclude_tree' is ignored. * * include - Default is an empty array.  An array, comma- or space-delimited string * of term ids to include in the return array. * * number - The maximum number of terms to return.  Default is to return them all. * * offset - The number by which to offset the terms query. * * fields - Default is 'all', which returns an array of term objects. * If 'fields' is 'ids' or 'names', returns an array of * integers or strings, respectively. * * slug - Returns terms whose "slug" matches this value. Default is empty string. * * hierarchical - Whether to include terms that have non-empty descendants * (even if 'hide_empty' is set to true). * * search - Returned terms' names will contain the value of 'search', * case-insensitive.  Default is an empty string. * * name__like - Returned terms' names will begin with the value of 'name__like', * case-insensitive. Default is empty string. * * The argument 'pad_counts', if set to true will include the quantity of a term's * children in the quantity of each term's "count" object variable. * * The 'get' argument, if set to 'all' instead of its default empty string, * returns terms regardless of ancestry or whether the terms are empty. * * The 'child_of' argument, when used, should be set to the integer of a term ID.  Its default * is 0.  If set to a non-zero value, all returned terms will be descendants * of that term according to the given taxonomy.  Hence 'child_of' is set to 0 * if more than one taxonomy is passed in $taxonomies, because multiple taxonomies * make term ancestry ambiguous. * * The 'parent' argument, when used, should be set to the integer of a term ID.  Its default is * the empty string '', which has a different meaning from the integer 0. * If set to an integer value, all returned terms will have as an immediate * ancestor the term whose ID is specified by that integer according to the given taxonomy. * The 'parent' argument is different from 'child_of' in that a term X is considered a 'parent' * of term Y only if term X is the father of term Y, not its grandfather or great-grandfather, etc. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses wp_parse_args() Merges the defaults with those defined by $args and allows for strings. * * @param string|array Taxonomy name or list of Taxonomy names * @param string|array $args The values of what to search for when returning terms * @return array|WP_Error List of Term Objects and their children. Will return WP_Error, if any of $taxonomies do not exist. */function &get_terms($taxonomies, $args = '') {	global $wpdb;	$empty_array = array();	$single_taxonomy = false;	if ( !is_array($taxonomies) ) {		$single_taxonomy = true;		$taxonomies = array($taxonomies);	}	foreach ( (array) $taxonomies as $taxonomy ) {		if ( ! taxonomy_exists($taxonomy) ) {			$error = & new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));			return $error;		}	}	$in_taxonomies = "'" . implode("', '", $taxonomies) . "'";	$defaults = array('orderby' => 'name', 'order' => 'ASC',		'hide_empty' => true, 'exclude' => array(), 'exclude_tree' => array(), 'include' => array(),		'number' => '', 'fields' => 'all', 'slug' => '', 'parent' => '',		'hierarchical' => true, 'child_of' => 0, 'get' => '', 'name__like' => '',		'pad_counts' => false, 'offset' => '', 'search' => '');	$args = wp_parse_args( $args, $defaults );	$args['number'] = absint( $args['number'] );	$args['offset'] = absint( $args['offset'] );	if ( !$single_taxonomy || !is_taxonomy_hierarchical($taxonomies[0]) ||		'' !== $args['parent'] ) {		$args['child_of'] = 0;		$args['hierarchical'] = false;		$args['pad_counts'] = false;	}	if ( 'all' == $args['get'] ) {		$args['child_of'] = 0;		$args['hide_empty'] = 0;		$args['hierarchical'] = false;		$args['pad_counts'] = false;	}	extract($args, EXTR_SKIP);	if ( $child_of ) {		$hierarchy = _get_term_hierarchy($taxonomies[0]);		if ( !isset($hierarchy[$child_of]) )			return $empty_array;	}	if ( $parent ) {		$hierarchy = _get_term_hierarchy($taxonomies[0]);		if ( !isset($hierarchy[$parent]) )			return $empty_array;	}	// $args can be whatever, only use the args defined in defaults to compute the key	$filter_key = ( has_filter('list_terms_exclusions') ) ? serialize($GLOBALS['wp_filter']['list_terms_exclusions']) : '';	$key = md5( serialize( compact(array_keys($defaults)) ) . serialize( $taxonomies ) . $filter_key );	$last_changed = wp_cache_get('last_changed', 'terms');	if ( !$last_changed ) {		$last_changed = time();		wp_cache_set('last_changed', $last_changed, 'terms');	}	$cache_key = "get_terms:$key:$last_changed";	$cache = wp_cache_get( $cache_key, 'terms' );	if ( false !== $cache ) {		$cache = apply_filters('get_terms', $cache, $taxonomies, $args);		return $cache;	}	$_orderby = strtolower($orderby);	if ( 'count' == $_orderby )		$orderby = 'tt.count';	else if ( 'name' == $_orderby )		$orderby = 't.name';	else if ( 'slug' == $_orderby )		$orderby = 't.slug';	else if ( 'term_group' == $_orderby )		$orderby = 't.term_group';	else if ( 'none' == $_orderby )		$orderby = '';	elseif ( empty($_orderby) || 'id' == $_orderby )		$orderby = 't.term_id';	$orderby = apply_filters( 'get_terms_orderby', $orderby, $args );	if ( !empty($orderby) )		$orderby = "ORDER BY $orderby";	else		$order = '';	$where = '';	$inclusions = '';	if ( !empty($include) ) {		$exclude = '';		$exclude_tree = '';		$interms = wp_parse_id_list($include);		foreach ( $interms as $interm ) {			if ( empty($inclusions) )				$inclusions = ' AND ( t.term_id = ' . intval($interm) . ' ';			else				$inclusions .= ' OR t.term_id = ' . intval($interm) . ' ';		}	}	if ( !empty($inclusions) )		$inclusions .= ')';	$where .= $inclusions;	$exclusions = '';	if ( !empty( $exclude_tree ) ) {		$excluded_trunks = wp_parse_id_list($exclude_tree);		foreach ( $excluded_trunks as $extrunk ) {			$excluded_children = (array) get_terms($taxonomies[0], array('child_of' => intval($extrunk), 'fields' => 'ids'));			$excluded_children[] = $extrunk;			foreach( $excluded_children as $exterm ) {				if ( empty($exclusions) )					$exclusions = ' AND ( t.term_id <> ' . intval($exterm) . ' ';				else					$exclusions .= ' AND t.term_id <> ' . intval($exterm) . ' ';			}		}	}	if ( !empty($exclude) ) {		$exterms = wp_parse_id_list($exclude);		foreach ( $exterms as $exterm ) {			if ( empty($exclusions) )				$exclusions = ' AND ( t.term_id <> ' . intval($exterm) . ' ';			else				$exclusions .= ' AND t.term_id <> ' . intval($exterm) . ' ';		}	}	if ( !empty($exclusions) )		$exclusions .= ')';	$exclusions = apply_filters('list_terms_exclusions', $exclusions, $args );	$where .= $exclusions;	if ( !empty($slug) ) {		$slug = sanitize_title($slug);		$where .= " AND t.slug = '$slug'";	}	if ( !empty($name__like) )		$where .= " AND t.name LIKE '{$name__like}%'";	if ( '' !== $parent ) {		$parent = (int) $parent;		$where .= " AND tt.parent = '$parent'";	}	if ( $hide_empty && !$hierarchical )		$where .= ' AND tt.count > 0';	// don't limit the query results when we have to descend the family tree	if ( ! empty($number) && ! $hierarchical && empty( $child_of ) && '' === $parent ) {		if ( $offset )			$limit = 'LIMIT ' . $offset . ',' . $number;		else			$limit = 'LIMIT ' . $number;	} else {		$limit = '';	}	if ( !empty($search) ) {		$search = like_escape($search);		$where .= " AND (t.name LIKE '%$search%')";	}	$selects = array();	switch ( $fields ) { 		case 'all': 			$selects = array('t.*', 'tt.*'); 			break; 		case 'ids':		case 'id=>parent': 			$selects = array('t.term_id', 'tt.parent', 'tt.count'); 			break; 		case 'names': 			$selects = array('t.term_id', 'tt.parent', 'tt.count', 't.name'); 			break; 		case 'count':			$orderby = '';			$order = ''; 			$selects = array('COUNT(*)'); 	}    $select_this = implode(', ', apply_filters( 'get_terms_fields', $selects, $args ));	$query = "SELECT $select_this FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy IN ($in_taxonomies) $where $orderby $order $limit";	if ( 'count' == $fields ) {		$term_count = $wpdb->get_var($query);		return $term_count;	}	$terms = $wpdb->get_results($query);	if ( 'all' == $fields ) {		update_term_cache($terms);	}	if ( empty($terms) ) {		wp_cache_add( $cache_key, array(), 'terms' );		$terms = apply_filters('get_terms', array(), $taxonomies, $args);		return $terms;	}	if ( $child_of ) {		$children = _get_term_hierarchy($taxonomies[0]);		if ( ! empty($children) )			$terms = & _get_term_children($child_of, $terms, $taxonomies[0]);	}	// Update term counts to include children.	if ( $pad_counts && 'all' == $fields )		_pad_term_counts($terms, $taxonomies[0]);	// Make sure we show empty categories that have children.	if ( $hierarchical && $hide_empty && is_array($terms) ) {		foreach ( $terms as $k => $term ) {			if ( ! $term->count ) {				$children = _get_term_children($term->term_id, $terms, $taxonomies[0]);				if ( is_array($children) )					foreach ( $children as $child )						if ( $child->count )							continue 2;				// It really is empty				unset($terms[$k]);			}		}	}	reset ( $terms );	$_terms = array();	if ( 'id=>parent' == $fields ) {		while ( $term = array_shift($terms) )			$_terms[$term->term_id] = $term->parent;		$terms = $_terms;	} elseif ( 'ids' == $fields ) {		while ( $term = array_shift($terms) )			$_terms[] = $term->term_id;		$terms = $_terms;	} elseif ( 'names' == $fields ) {		while ( $term = array_shift($terms) )			$_terms[] = $term->name;		$terms = $_terms;	}	if ( 0 < $number && intval(@count($terms)) > $number ) {		$terms = array_slice($terms, $offset, $number);	}	wp_cache_add( $cache_key, $terms, 'terms' );	$terms = apply_filters('get_terms', $terms, $taxonomies, $args);	return $terms;}/** * Check if Term exists. * * Returns the index of a defined term, or 0 (false) if the term doesn't exist. * * Formerly is_term(), introduced in 2.3.0. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * * @uses $wpdb * * @param int|string $term The term to check * @param string $taxonomy The taxonomy name to use * @param int $parent ID of parent term under which to confine the exists search. * @return mixed Get the term id or Term Object, if exists. */function term_exists($term, $taxonomy = '', $parent = 0) {	global $wpdb;	$select = "SELECT term_id FROM $wpdb->terms as t WHERE ";	$tax_select = "SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy as tt ON tt.term_id = t.term_id WHERE ";	if ( is_int($term) ) {		if ( 0 == $term )			return 0;		$where = 't.term_id = %d';		if ( !empty($taxonomy) )			return $wpdb->get_row( $wpdb->prepare( $tax_select . $where . " AND tt.taxonomy = %s", $term, $taxonomy ), ARRAY_A );		else			return $wpdb->get_var( $wpdb->prepare( $select . $where, $term ) );	}	$term = trim( stripslashes( $term ) );	if ( '' === $slug = sanitize_title($term) )		return 0;	$where = 't.slug = %s';	$else_where = 't.name = %s';	$where_fields = array($slug);	$else_where_fields = array($term);	if ( !empty($taxonomy) ) {		$parent = (int) $parent;		if ( $parent > 0 ) {			$where_fields[] = $parent;			$else_where_fields[] = $parent;			$where .= ' AND tt.parent = %d';			$else_where .= ' AND tt.parent = %d';		}		$where_fields[] = $taxonomy;		$else_where_fields[] = $taxonomy;		if ( $result = $wpdb->get_row( $wpdb->prepare("SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy as tt ON tt.term_id = t.term_id WHERE $where AND tt.taxonomy = %s", $where_fields), ARRAY_A) )			return $result;		return $wpdb->get_row( $wpdb->prepare("SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy as tt ON tt.term_id = t.term_id WHERE $else_where AND tt.taxonomy = %s", $else_where_fields), ARRAY_A);	}	if ( $result = $wpdb->get_var( $wpdb->prepare("SELECT term_id FROM $wpdb->terms as t WHERE $where", $where_fields) ) )		return $result;	return $wpdb->get_var( $wpdb->prepare("SELECT term_id FROM $wpdb->terms as t WHERE $else_where", $else_where_fields) );}/** * Sanitize Term all fields. * * Relys on sanitize_term_field() to sanitize the term. The difference is that * this function will sanitize <strong>all</strong> fields. The context is based * on sanitize_term_field(). * * The $term is expected to be either an array or an object. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses sanitize_term_field Used to sanitize all fields in a term * * @param array|object $term The term to check * @param string $taxonomy The taxonomy name to use * @param string $context Default is 'display'. * @return array|object Term with all fields sanitized */function sanitize_term($term, $taxonomy, $context = 'display') {	if ( 'raw' == $context )		return $term;	$fields = array('term_id', 'name', 'description', 'slug', 'count', 'parent', 'term_group');	$do_object = false;	if ( is_object($term) )		$do_object = true;	$term_id = $do_object ? $term->term_id : (isset($term['term_id']) ? $term['term_id'] : 0);	foreach ( (array) $fields as $field ) {		if ( $do_object ) {			if ( isset($term->$field) )				$term->$field = sanitize_term_field($field, $term->$field, $term_id, $taxonomy, $context);		} else {			if ( isset($term[$field]) )				$term[$field] = sanitize_term_field($field, $term[$field], $term_id, $taxonomy, $context);		}	}	if ( $do_object )		$term->filter = $context;	else		$term['filter'] = $context;	return $term;}/** * Cleanse the field value in the term based on the context. * * Passing a term field value through the function should be assumed to have * cleansed the value for whatever context the term field is going to be used. * * If no context or an unsupported context is given, then default filters will * be applied. * * There are enough filters for each context to support a custom filtering * without creating your own filter function. Simply create a function that * hooks into the filter you need. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * * @param string $field Term field to sanitize * @param string $value Search for this term value * @param int $term_id Term ID * @param string $taxonomy Taxonomy Name * @param string $context Either edit, db, display, attribute, or js. * @return mixed sanitized field */function sanitize_term_field($field, $value, $term_id, $taxonomy, $context) {	if ( 'parent' == $field  || 'term_id' == $field || 'count' == $field || 'term_group' == $field ) {		$value = (int) $value;		if ( $value < 0 )			$value = 0;	}	if ( 'raw' == $context )		return $value;	if ( 'edit' == $context ) {		$value = apply_filters("edit_term_$field", $value, $term_id, $taxonomy);		$value = apply_filters("edit_${taxonomy}_$field", $value, $term_id);		if ( 'description' == $field )			$value = format_to_edit($value);		else			$value = esc_attr($value);	} else if ( 'db' == $context ) {		$value = apply_filters("pre_term_$field", $value, $taxonomy);		$value = apply_filters("pre_${taxonomy}_$field", $value);		// Back compat filters		if ( 'slug' == $field )			$value = apply_filters('pre_category_nicename', $value);	} else if ( 'rss' == $context ) {		$value = apply_filters("term_${field}_rss", $value, $taxonomy);		$value = apply_filters("${taxonomy}_${field}_rss", $value);	} else {		// Use display filters by default.		$value = apply_filters("term_$field", $value, $term_id, $taxonomy, $context);		$value = apply_filters("${taxonomy}_$field", $value, $term_id, $context);	}	if ( 'attribute' == $context )		$value = esc_attr($value);	else if ( 'js' == $context )		$value = esc_js($value);	return $value;}/** * Count how many terms are in Taxonomy. * * Default $args is 'hide_empty' which can be 'hide_empty=true' or array('hide_empty' => true). * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses get_terms() * @uses wp_parse_args() Turns strings into arrays and merges defaults into an array. * * @param string $taxonomy Taxonomy name * @param array|string $args Overwrite defaults. See get_terms() * @return int How many terms are in $taxonomy */function wp_count_terms( $taxonomy, $args = array() ) {	$defaults = array('hide_empty' => false);	$args = wp_parse_args($args, $defaults);	// backwards compatibility	if ( isset($args['ignore_empty']) ) {		$args['hide_empty'] = $args['ignore_empty'];		unset($args['ignore_empty']);	}	$args['fields'] = 'count';	return get_terms($taxonomy, $args);}/** * Will unlink the term from the taxonomy. * * Will remove the term's relationship to the taxonomy, not the term or taxonomy * itself. The term and taxonomy will still exist. Will require the term's * object ID to perform the operation. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int $object_id The term Object Id that refers to the term * @param string|array $taxonomy List of Taxonomy Names or single Taxonomy name. */function wp_delete_object_term_relationships( $object_id, $taxonomies ) {	global $wpdb;	$object_id = (int) $object_id;	if ( !is_array($taxonomies) )		$taxonomies = array($taxonomies);	foreach ( (array) $taxonomies as $taxonomy ) {		$tt_ids = wp_get_object_terms($object_id, $taxonomy, array('fields' => 'tt_ids'));		$in_tt_ids = "'" . implode("', '", $tt_ids) . "'";		do_action( 'delete_term_relationships', $object_id, $tt_ids );		$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->term_relationships WHERE object_id = %d AND term_taxonomy_id IN ($in_tt_ids)", $object_id) );		do_action( 'deleted_term_relationships', $object_id, $tt_ids );		wp_update_term_count($tt_ids, $taxonomy);	}}/** * Removes a term from the database. * * If the term is a parent of other terms, then the children will be updated to * that term's parent. * * The $args 'default' will only override the terms found, if there is only one * term found. Any other and the found terms are used. * * The $args 'force_default' will force the term supplied as default to be * assigned even if the object was not going to be termless * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses do_action() Calls both 'delete_term' and 'delete_$taxonomy' action *	hooks, passing term object, term id. 'delete_term' gets an additional *	parameter with the $taxonomy parameter. * * @param int $term Term ID * @param string $taxonomy Taxonomy Name * @param array|string $args Optional. Change 'default' term id and override found term ids. * @return bool|WP_Error Returns false if not term; true if completes delete action. */function wp_delete_term( $term, $taxonomy, $args = array() ) {	global $wpdb;	$term = (int) $term;	if ( ! $ids = term_exists($term, $taxonomy) )		return false;	if ( is_wp_error( $ids ) )		return $ids;	$tt_id = $ids['term_taxonomy_id'];	$defaults = array();	$args = wp_parse_args($args, $defaults);	extract($args, EXTR_SKIP);	if ( isset($default) ) {		$default = (int) $default;		if ( ! term_exists($default, $taxonomy) )			unset($default);	}	// Update children to point to new parent	if ( is_taxonomy_hierarchical($taxonomy) ) {		$term_obj = get_term($term, $taxonomy);		if ( is_wp_error( $term_obj ) )			return $term_obj;		$parent = $term_obj->parent;		$edit_tt_ids = $wpdb->get_col( "SELECT `term_taxonomy_id` FROM $wpdb->term_taxonomy WHERE `parent` = " . (int)$term_obj->term_id );		do_action( 'edit_term_taxonomies', $edit_tt_ids );		$wpdb->update( $wpdb->term_taxonomy, compact( 'parent' ), array( 'parent' => $term_obj->term_id) + compact( 'taxonomy' ) );		do_action( 'edited_term_taxonomies', $edit_tt_ids );	}	$objects = $wpdb->get_col( $wpdb->prepare( "SELECT object_id FROM $wpdb->term_relationships WHERE term_taxonomy_id = %d", $tt_id ) );	foreach ( (array) $objects as $object ) {		$terms = wp_get_object_terms($object, $taxonomy, array('fields' => 'ids', 'orderby' => 'none'));		if ( 1 == count($terms) && isset($default) ) {			$terms = array($default);		} else {			$terms = array_diff($terms, array($term));			if (isset($default) && isset($force_default) && $force_default)				$terms = array_merge($terms, array($default));		}		$terms = array_map('intval', $terms);		wp_set_object_terms($object, $terms, $taxonomy);	}	do_action( 'delete_term_taxonomy', $tt_id );	$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->term_taxonomy WHERE term_taxonomy_id = %d", $tt_id ) );	do_action( 'deleted_term_taxonomy', $tt_id );	// Delete the term if no taxonomies use it.	if ( !$wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM $wpdb->term_taxonomy WHERE term_id = %d", $term) ) )		$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->terms WHERE term_id = %d", $term) );	clean_term_cache($term, $taxonomy);	do_action('delete_term', $term, $tt_id, $taxonomy);	do_action("delete_$taxonomy", $term, $tt_id);	return true;}/** * Retrieves the terms associated with the given object(s), in the supplied taxonomies. * * The following information has to do the $args parameter and for what can be * contained in the string or array of that parameter, if it exists. * * The first argument is called, 'orderby' and has the default value of 'name'. * The other value that is supported is 'count'. * * The second argument is called, 'order' and has the default value of 'ASC'. * The only other value that will be acceptable is 'DESC'. * * The final argument supported is called, 'fields' and has the default value of * 'all'. There are multiple other options that can be used instead. Supported * values are as follows: 'all', 'ids', 'names', and finally * 'all_with_object_id'. * * The fields argument also decides what will be returned. If 'all' or * 'all_with_object_id' is choosen or the default kept intact, then all matching * terms objects will be returned. If either 'ids' or 'names' is used, then an * array of all matching term ids or term names will be returned respectively. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int|array $object_id The id of the object(s) to retrieve. * @param string|array $taxonomies The taxonomies to retrieve terms from. * @param array|string $args Change what is returned * @return array|WP_Error The requested term data or empty array if no terms found. WP_Error if $taxonomy does not exist. */function wp_get_object_terms($object_ids, $taxonomies, $args = array()) {	global $wpdb;	if ( !is_array($taxonomies) )		$taxonomies = array($taxonomies);	foreach ( (array) $taxonomies as $taxonomy ) {		if ( ! taxonomy_exists($taxonomy) )			return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));	}	if ( !is_array($object_ids) )		$object_ids = array($object_ids);	$object_ids = array_map('intval', $object_ids);	$defaults = array('orderby' => 'name', 'order' => 'ASC', 'fields' => 'all');	$args = wp_parse_args( $args, $defaults );	$terms = array();	if ( count($taxonomies) > 1 ) {		foreach ( $taxonomies as $index => $taxonomy ) {			$t = get_taxonomy($taxonomy);			if ( isset($t->args) && is_array($t->args) && $args != array_merge($args, $t->args) ) {				unset($taxonomies[$index]);				$terms = array_merge($terms, wp_get_object_terms($object_ids, $taxonomy, array_merge($args, $t->args)));			}		}	} else {		$t = get_taxonomy($taxonomies[0]);		if ( isset($t->args) && is_array($t->args) )			$args = array_merge($args, $t->args);	}	extract($args, EXTR_SKIP);	if ( 'count' == $orderby )		$orderby = 'tt.count';	else if ( 'name' == $orderby )		$orderby = 't.name';	else if ( 'slug' == $orderby )		$orderby = 't.slug';	else if ( 'term_group' == $orderby )		$orderby = 't.term_group';	else if ( 'term_order' == $orderby )		$orderby = 'tr.term_order';	else if ( 'none' == $orderby ) {		$orderby = '';		$order = '';	} else {		$orderby = 't.term_id';	}	// tt_ids queries can only be none or tr.term_taxonomy_id	if ( ('tt_ids' == $fields) && !empty($orderby) )		$orderby = 'tr.term_taxonomy_id';	if ( !empty($orderby) )		$orderby = "ORDER BY $orderby";	$taxonomies = "'" . implode("', '", $taxonomies) . "'";	$object_ids = implode(', ', $object_ids);	$select_this = '';	if ( 'all' == $fields )		$select_this = 't.*, tt.*';	else if ( 'ids' == $fields )		$select_this = 't.term_id';	else if ( 'names' == $fields )		$select_this = 't.name';	else if ( 'all_with_object_id' == $fields )		$select_this = 't.*, tt.*, tr.object_id';	$query = "SELECT $select_this FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON tt.term_id = t.term_id INNER JOIN $wpdb->term_relationships AS tr ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy IN ($taxonomies) AND tr.object_id IN ($object_ids) $orderby $order";	if ( 'all' == $fields || 'all_with_object_id' == $fields ) {		$terms = array_merge($terms, $wpdb->get_results($query));		update_term_cache($terms);	} else if ( 'ids' == $fields || 'names' == $fields ) {		$terms = array_merge($terms, $wpdb->get_col($query));	} else if ( 'tt_ids' == $fields ) {		$terms = $wpdb->get_col("SELECT tr.term_taxonomy_id FROM $wpdb->term_relationships AS tr INNER JOIN $wpdb->term_taxonomy AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tr.object_id IN ($object_ids) AND tt.taxonomy IN ($taxonomies) $orderby $order");	}	if ( ! $terms )		$terms = array();	return apply_filters('wp_get_object_terms', $terms, $object_ids, $taxonomies, $args);}/** * Adds a new term to the database. Optionally marks it as an alias of an existing term. * * Error handling is assigned for the nonexistance of the $taxonomy and $term * parameters before inserting. If both the term id and taxonomy exist * previously, then an array will be returned that contains the term id and the * contents of what is returned. The keys of the array are 'term_id' and * 'term_taxonomy_id' containing numeric values. * * It is assumed that the term does not yet exist or the above will apply. The * term will be first added to the term table and then related to the taxonomy * if everything is well. If everything is correct, then several actions will be * run prior to a filter and then several actions will be run after the filter * is run. * * The arguments decide how the term is handled based on the $args parameter. * The following is a list of the available overrides and the defaults. * * 'alias_of'. There is no default, but if added, expected is the slug that the * term will be an alias of. Expected to be a string. * * 'description'. There is no default. If exists, will be added to the database * along with the term. Expected to be a string. * * 'parent'. Expected to be numeric and default is 0 (zero). Will assign value * of 'parent' to the term. * * 'slug'. Expected to be a string. There is no default. * * If 'slug' argument exists then the slug will be checked to see if it is not * a valid term. If that check succeeds (it is not a valid term), then it is * added and the term id is given. If it fails, then a check is made to whether * the taxonomy is hierarchical and the parent argument is not empty. If the * second check succeeds, the term will be inserted and the term id will be * given. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @uses apply_filters() Calls 'pre_insert_term' hook with term and taxonomy as parameters. * @uses do_action() Calls 'create_term' hook with the term id and taxonomy id as parameters. * @uses do_action() Calls 'create_$taxonomy' hook with term id and taxonomy id as parameters. * @uses apply_filters() Calls 'term_id_filter' hook with term id and taxonomy id as parameters. * @uses do_action() Calls 'created_term' hook with the term id and taxonomy id as parameters. * @uses do_action() Calls 'created_$taxonomy' hook with term id and taxonomy id as parameters. * * @param string $term The term to add or update. * @param string $taxonomy The taxonomy to which to add the term * @param array|string $args Change the values of the inserted term * @return array|WP_Error The Term ID and Term Taxonomy ID */function wp_insert_term( $term, $taxonomy, $args = array() ) {	global $wpdb;	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid taxonomy'));	$term = apply_filters( 'pre_insert_term', $term, $taxonomy );		if ( is_wp_error( $term ) )			return $term;	if ( is_int($term) && 0 == $term )		return new WP_Error('invalid_term_id', __('Invalid term ID'));	if ( '' == trim($term) )		return new WP_Error('empty_term_name', __('A name is required for this term'));	$defaults = array( 'alias_of' => '', 'description' => '', 'parent' => 0, 'slug' => '');	$args = wp_parse_args($args, $defaults);	$args['name'] = $term;	$args['taxonomy'] = $taxonomy;	$args = sanitize_term($args, $taxonomy, 'db');	extract($args, EXTR_SKIP);	// expected_slashed ($name)	$name = stripslashes($name);	$description = stripslashes($description);	if ( empty($slug) )		$slug = sanitize_title($name);	$term_group = 0;	if ( $alias_of ) {		$alias = $wpdb->get_row( $wpdb->prepare( "SELECT term_id, term_group FROM $wpdb->terms WHERE slug = %s", $alias_of) );		if ( $alias->term_group ) {			// The alias we want is already in a group, so let's use that one.			$term_group = $alias->term_group;		} else {			// The alias isn't in a group, so let's create a new one and firstly add the alias term to it.			$term_group = $wpdb->get_var("SELECT MAX(term_group) FROM $wpdb->terms") + 1;			do_action( 'edit_terms', $alias->term_id );			$wpdb->update($wpdb->terms, compact('term_group'), array('term_id' => $alias->term_id) );			do_action( 'edited_terms', $alias->term_id );		}	}	if ( $term_id = term_exists($slug) ) {		$existing_term = $wpdb->get_row( $wpdb->prepare( "SELECT name FROM $wpdb->terms WHERE term_id = %d", $term_id), ARRAY_A );		// We've got an existing term in the same taxonomy, which matches the name of the new term:		if ( is_taxonomy_hierarchical($taxonomy) && $existing_term['name'] == $name && term_exists( (int) $term_id, $taxonomy ) ) {			// Hierarchical, and it matches an existing term, Do not allow same "name" in the same level.			$siblings = get_terms($taxonomy, array('fields' => 'names', 'get' => 'all', 'parent' => (int)$parent) );			if ( in_array($name, $siblings) ) {				return new WP_Error('term_exists', __('A term with the name provided already exists with this parent.'));			} else {				$slug = wp_unique_term_slug($slug, (object) $args);				if ( false === $wpdb->insert( $wpdb->terms, compact( 'name', 'slug', 'term_group' ) ) )					return new WP_Error('db_insert_error', __('Could not insert term into the database'), $wpdb->last_error);				$term_id = (int) $wpdb->insert_id;			}		} elseif ( $existing_term['name'] != $name ) {			// We've got an existing term, with a different name, Create the new term.			$slug = wp_unique_term_slug($slug, (object) $args);			if ( false === $wpdb->insert( $wpdb->terms, compact( 'name', 'slug', 'term_group' ) ) )				return new WP_Error('db_insert_error', __('Could not insert term into the database'), $wpdb->last_error);			$term_id = (int) $wpdb->insert_id;		} elseif ( term_exists( (int) $term_id, $taxonomy ) )  {			// Same name, same slug.			return new WP_Error('term_exists', __('A term with the name provided already exists.'));		}	} else {		// This term does not exist at all in the database, Create it.		$slug = wp_unique_term_slug($slug, (object) $args);		if ( false === $wpdb->insert( $wpdb->terms, compact( 'name', 'slug', 'term_group' ) ) )			return new WP_Error('db_insert_error', __('Could not insert term into the database'), $wpdb->last_error);		$term_id = (int) $wpdb->insert_id;	}	// Seems unreachable, However, Is used in the case that a term name is provided, which sanitizes to an empty string.	if ( empty($slug) ) {		$slug = sanitize_title($slug, $term_id);		do_action( 'edit_terms', $term_id );		$wpdb->update( $wpdb->terms, compact( 'slug' ), compact( 'term_id' ) );		do_action( 'edited_terms', $term_id );	}	$tt_id = $wpdb->get_var( $wpdb->prepare( "SELECT tt.term_taxonomy_id FROM $wpdb->term_taxonomy AS tt INNER JOIN $wpdb->terms AS t ON tt.term_id = t.term_id WHERE tt.taxonomy = %s AND t.term_id = %d", $taxonomy, $term_id ) );	if ( !empty($tt_id) )		return array('term_id' => $term_id, 'term_taxonomy_id' => $tt_id);	$wpdb->insert( $wpdb->term_taxonomy, compact( 'term_id', 'taxonomy', 'description', 'parent') + array( 'count' => 0 ) );	$tt_id = (int) $wpdb->insert_id;	do_action("create_term", $term_id, $tt_id, $taxonomy);	do_action("create_$taxonomy", $term_id, $tt_id);	$term_id = apply_filters('term_id_filter', $term_id, $tt_id);	clean_term_cache($term_id, $taxonomy);	do_action("created_term", $term_id, $tt_id, $taxonomy);	do_action("created_$taxonomy", $term_id, $tt_id);	return array('term_id' => $term_id, 'term_taxonomy_id' => $tt_id);}/** * Create Term and Taxonomy Relationships. * * Relates an object (post, link etc) to a term and taxonomy type. Creates the * term and taxonomy relationship if it doesn't already exist. Creates a term if * it doesn't exist (using the slug). * * A relationship means that the term is grouped in or belongs to the taxonomy. * A term has no meaning until it is given context by defining which taxonomy it * exists under. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int $object_id The object to relate to. * @param array|int|string $term The slug or id of the term, will replace all existing * related terms in this taxonomy. * @param array|string $taxonomy The context in which to relate the term to the object. * @param bool $append If false will delete difference of terms. * @return array|WP_Error Affected Term IDs */function wp_set_object_terms($object_id, $terms, $taxonomy, $append = false) {	global $wpdb;	$object_id = (int) $object_id;	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));	if ( !is_array($terms) )		$terms = array($terms);	if ( ! $append )		$old_tt_ids =  wp_get_object_terms($object_id, $taxonomy, array('fields' => 'tt_ids', 'orderby' => 'none'));	else		$old_tt_ids = array();	$tt_ids = array();	$term_ids = array();	foreach ( (array) $terms as $term) {		if ( !strlen(trim($term)) )			continue;		if ( !$term_info = term_exists($term, $taxonomy) ) {			// Skip if a non-existent term ID is passed.			if ( is_int($term) )				continue;			$term_info = wp_insert_term($term, $taxonomy);		}		if ( is_wp_error($term_info) )			return $term_info;		$term_ids[] = $term_info['term_id'];		$tt_id = $term_info['term_taxonomy_id'];		$tt_ids[] = $tt_id;		if ( $wpdb->get_var( $wpdb->prepare( "SELECT term_taxonomy_id FROM $wpdb->term_relationships WHERE object_id = %d AND term_taxonomy_id = %d", $object_id, $tt_id ) ) )			continue;		do_action( 'add_term_relationship', $object_id, $tt_id );		$wpdb->insert( $wpdb->term_relationships, array( 'object_id' => $object_id, 'term_taxonomy_id' => $tt_id ) );		do_action( 'added_term_relationship', $object_id, $tt_id );	}	wp_update_term_count($tt_ids, $taxonomy);	if ( ! $append ) {		$delete_terms = array_diff($old_tt_ids, $tt_ids);		if ( $delete_terms ) {			$in_delete_terms = "'" . implode("', '", $delete_terms) . "'";			do_action( 'delete_term_relationships', $object_id, $delete_terms );			$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->term_relationships WHERE object_id = %d AND term_taxonomy_id IN ($in_delete_terms)", $object_id) );			do_action( 'deleted_term_relationships', $object_id, $delete_terms );			wp_update_term_count($delete_terms, $taxonomy);		}	}	$t = get_taxonomy($taxonomy);	if ( ! $append && isset($t->sort) && $t->sort ) {		$values = array();		$term_order = 0;		$final_tt_ids = wp_get_object_terms($object_id, $taxonomy, array('fields' => 'tt_ids'));		foreach ( $tt_ids as $tt_id )			if ( in_array($tt_id, $final_tt_ids) )				$values[] = $wpdb->prepare( "(%d, %d, %d)", $object_id, $tt_id, ++$term_order);		if ( $values )			$wpdb->query("INSERT INTO $wpdb->term_relationships (object_id, term_taxonomy_id, term_order) VALUES " . join(',', $values) . " ON DUPLICATE KEY UPDATE term_order = VALUES(term_order)");	}	do_action('set_object_terms', $object_id, $terms, $tt_ids, $taxonomy, $append, $old_tt_ids);	return $tt_ids;}/** * Will make slug unique, if it isn't already. * * The $slug has to be unique global to every taxonomy, meaning that one * taxonomy term can't have a matching slug with another taxonomy term. Each * slug has to be globally unique for every taxonomy. * * The way this works is that if the taxonomy that the term belongs to is * hierarchical and has a parent, it will append that parent to the $slug. * * If that still doesn't return an unique slug, then it try to append a number * until it finds a number that is truely unique. * * The only purpose for $term is for appending a parent, if one exists. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param string $slug The string that will be tried for a unique slug * @param object $term The term object that the $slug will belong too * @return string Will return a true unique slug. */function wp_unique_term_slug($slug, $term) {	global $wpdb;	if ( ! term_exists( $slug ) )		return $slug;	// If the taxonomy supports hierarchy and the term has a parent, make the slug unique	// by incorporating parent slugs.	if ( is_taxonomy_hierarchical($term->taxonomy) && !empty($term->parent) ) {		$the_parent = $term->parent;		while ( ! empty($the_parent) ) {			$parent_term = get_term($the_parent, $term->taxonomy);			if ( is_wp_error($parent_term) || empty($parent_term) )				break;			$slug .= '-' . $parent_term->slug;			if ( ! term_exists( $slug ) )				return $slug;			if ( empty($parent_term->parent) )				break;			$the_parent = $parent_term->parent;		}	}	// If we didn't get a unique slug, try appending a number to make it unique.	if ( !empty($args['term_id']) )		$query = $wpdb->prepare( "SELECT slug FROM $wpdb->terms WHERE slug = %s AND term_id != %d", $slug, $args['term_id'] );	else		$query = $wpdb->prepare( "SELECT slug FROM $wpdb->terms WHERE slug = %s", $slug );	if ( $wpdb->get_var( $query ) ) {		$num = 2;		do {			$alt_slug = $slug . "-$num";			$num++;			$slug_check = $wpdb->get_var( $wpdb->prepare( "SELECT slug FROM $wpdb->terms WHERE slug = %s", $alt_slug ) );		} while ( $slug_check );		$slug = $alt_slug;	}	return $slug;}/** * Update term based on arguments provided. * * The $args will indiscriminately override all values with the same field name. * Care must be taken to not override important information need to update or * update will fail (or perhaps create a new term, neither would be acceptable). * * Defaults will set 'alias_of', 'description', 'parent', and 'slug' if not * defined in $args already. * * 'alias_of' will create a term group, if it doesn't already exist, and update * it for the $term. * * If the 'slug' argument in $args is missing, then the 'name' in $args will be * used. It should also be noted that if you set 'slug' and it isn't unique then * a WP_Error will be passed back. If you don't pass any slug, then a unique one * will be created for you. * * For what can be overrode in $args, check the term scheme can contain and stay * away from the term keys. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses do_action() Will call both 'edit_term' and 'edit_$taxonomy' twice. * @uses apply_filters() Will call the 'term_id_filter' filter and pass the term *	id and taxonomy id. * * @param int $term_id The ID of the term * @param string $taxonomy The context in which to relate the term to the object. * @param array|string $args Overwrite term field values * @return array|WP_Error Returns Term ID and Taxonomy Term ID */function wp_update_term( $term_id, $taxonomy, $args = array() ) {	global $wpdb;	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid taxonomy'));	$term_id = (int) $term_id;	// First, get all of the original args	$term = get_term ($term_id, $taxonomy, ARRAY_A);	if ( is_wp_error( $term ) )		return $term;	// Escape data pulled from DB.	$term = add_magic_quotes($term);	// Merge old and new args with new args overwriting old ones.	$args = array_merge($term, $args);	$defaults = array( 'alias_of' => '', 'description' => '', 'parent' => 0, 'slug' => '');	$args = wp_parse_args($args, $defaults);	$args = sanitize_term($args, $taxonomy, 'db');	extract($args, EXTR_SKIP);	// expected_slashed ($name)	$name = stripslashes($name);	$description = stripslashes($description);	if ( '' == trim($name) )		return new WP_Error('empty_term_name', __('A name is required for this term'));	$empty_slug = false;	if ( empty($slug) ) {		$empty_slug = true;		$slug = sanitize_title($name);	}	if ( $alias_of ) {		$alias = $wpdb->get_row( $wpdb->prepare( "SELECT term_id, term_group FROM $wpdb->terms WHERE slug = %s", $alias_of) );		if ( $alias->term_group ) {			// The alias we want is already in a group, so let's use that one.			$term_group = $alias->term_group;		} else {			// The alias isn't in a group, so let's create a new one and firstly add the alias term to it.			$term_group = $wpdb->get_var("SELECT MAX(term_group) FROM $wpdb->terms") + 1;			do_action( 'edit_terms', $alias->term_id );			$wpdb->update( $wpdb->terms, compact('term_group'), array( 'term_id' => $alias->term_id ) );			do_action( 'edited_terms', $alias->term_id );		}	}	// Check for duplicate slug	$id = $wpdb->get_var( $wpdb->prepare( "SELECT term_id FROM $wpdb->terms WHERE slug = %s", $slug ) );	if ( $id && ($id != $term_id) ) {		// If an empty slug was passed or the parent changed, reset the slug to something unique.		// Otherwise, bail.		if ( $empty_slug || ( $parent != $term['parent']) )			$slug = wp_unique_term_slug($slug, (object) $args);		else			return new WP_Error('duplicate_term_slug', sprintf(__('The slug &#8220;%s&#8221; is already in use by another term'), $slug));	}	do_action( 'edit_terms', $term_id );	$wpdb->update($wpdb->terms, compact( 'name', 'slug', 'term_group' ), compact( 'term_id' ) );	if ( empty($slug) ) {		$slug = sanitize_title($name, $term_id);		$wpdb->update( $wpdb->terms, compact( 'slug' ), compact( 'term_id' ) );	}	do_action( 'edited_terms', $term_id );	$tt_id = $wpdb->get_var( $wpdb->prepare( "SELECT tt.term_taxonomy_id FROM $wpdb->term_taxonomy AS tt INNER JOIN $wpdb->terms AS t ON tt.term_id = t.term_id WHERE tt.taxonomy = %s AND t.term_id = %d", $taxonomy, $term_id) );	do_action( 'edit_term_taxonomy', $tt_id, $taxonomy );	$wpdb->update( $wpdb->term_taxonomy, compact( 'term_id', 'taxonomy', 'description', 'parent' ), array( 'term_taxonomy_id' => $tt_id ) );	do_action( 'edited_term_taxonomy', $tt_id, $taxonomy );	do_action("edit_term", $term_id, $tt_id, $taxonomy);	do_action("edit_$taxonomy", $term_id, $tt_id);	$term_id = apply_filters('term_id_filter', $term_id, $tt_id);	clean_term_cache($term_id, $taxonomy);	do_action("edited_term", $term_id, $tt_id, $taxonomy);	do_action("edited_$taxonomy", $term_id, $tt_id);	return array('term_id' => $term_id, 'term_taxonomy_id' => $tt_id);}/** * Enable or disable term counting. * * @since 2.5.0 * * @param bool $defer Optional. Enable if true, disable if false. * @return bool Whether term counting is enabled or disabled. */function wp_defer_term_counting($defer=null) {	static $_defer = false;	if ( is_bool($defer) ) {		$_defer = $defer;		// flush any deferred counts		if ( !$defer )			wp_update_term_count( null, null, true );	}	return $_defer;}/** * Updates the amount of terms in taxonomy. * * If there is a taxonomy callback applyed, then it will be called for updating * the count. * * The default action is to count what the amount of terms have the relationship * of term ID. Once that is done, then update the database. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int|array $terms The term_taxonomy_id of the terms * @param string $taxonomy The context of the term. * @return bool If no terms will return false, and if successful will return true. */function wp_update_term_count( $terms, $taxonomy, $do_deferred=false ) {	static $_deferred = array();	if ( $do_deferred ) {		foreach ( (array) array_keys($_deferred) as $tax ) {			wp_update_term_count_now( $_deferred[$tax], $tax );			unset( $_deferred[$tax] );		}	}	if ( empty($terms) )		return false;	if ( !is_array($terms) )		$terms = array($terms);	if ( wp_defer_term_counting() ) {		if ( !isset($_deferred[$taxonomy]) )			$_deferred[$taxonomy] = array();		$_deferred[$taxonomy] = array_unique( array_merge($_deferred[$taxonomy], $terms) );		return true;	}	return wp_update_term_count_now( $terms, $taxonomy );}/** * Perform term count update immediately. * * @since 2.5.0 * * @param array $terms The term_taxonomy_id of terms to update. * @param string $taxonomy The context of the term. * @return bool Always true when complete. */function wp_update_term_count_now( $terms, $taxonomy ) {	global $wpdb;	$terms = array_map('intval', $terms);	$taxonomy = get_taxonomy($taxonomy);	if ( !empty($taxonomy->update_count_callback) ) {		call_user_func($taxonomy->update_count_callback, $terms, $taxonomy);	} else {		// Default count updater		foreach ( (array) $terms as $term) {			$count = $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM $wpdb->term_relationships WHERE term_taxonomy_id = %d", $term) );			do_action( 'edit_term_taxonomy', $term, $taxonomy );			$wpdb->update( $wpdb->term_taxonomy, compact( 'count' ), array( 'term_taxonomy_id' => $term ) );			do_action( 'edited_term_taxonomy', $term, $taxonomy );		}	}	clean_term_cache($terms, '', false);	return true;}//// Cache///** * Removes the taxonomy relationship to terms from the cache. * * Will remove the entire taxonomy relationship containing term $object_id. The * term IDs have to exist within the taxonomy $object_type for the deletion to * take place. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @see get_object_taxonomies() for more on $object_type * @uses do_action() Will call action hook named, 'clean_object_term_cache' after completion. *	Passes, function params in same order. * * @param int|array $object_ids Single or list of term object ID(s) * @param array|string $object_type The taxonomy object type */function clean_object_term_cache($object_ids, $object_type) {	if ( !is_array($object_ids) )		$object_ids = array($object_ids);	foreach ( $object_ids as $id )		foreach ( get_object_taxonomies($object_type) as $taxonomy )			wp_cache_delete($id, "{$taxonomy}_relationships");	do_action('clean_object_term_cache', $object_ids, $object_type);}/** * Will remove all of the term ids from the cache. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int|array $ids Single or list of Term IDs * @param string $taxonomy Can be empty and will assume tt_ids, else will use for context. * @param bool $clean_taxonomy Whether to clean taxonomy wide caches (true), or just individual term object caches (false). Default is true. */function clean_term_cache($ids, $taxonomy = '', $clean_taxonomy = true) {	global $wpdb;	static $cleaned = array();	if ( !is_array($ids) )		$ids = array($ids);	$taxonomies = array();	// If no taxonomy, assume tt_ids.	if ( empty($taxonomy) ) {		$tt_ids = array_map('intval', $ids);		$tt_ids = implode(', ', $tt_ids);		$terms = $wpdb->get_results("SELECT term_id, taxonomy FROM $wpdb->term_taxonomy WHERE term_taxonomy_id IN ($tt_ids)");		$ids = array();		foreach ( (array) $terms as $term ) {			$taxonomies[] = $term->taxonomy;			$ids[] = $term->term_id;			wp_cache_delete($term->term_id, $term->taxonomy);		}		$taxonomies = array_unique($taxonomies);	} else {		$taxonomies = array($taxonomy);		foreach ( $taxonomies as $taxonomy ) {			foreach ( $ids as $id ) {				wp_cache_delete($id, $taxonomy);			}		}	}	foreach ( $taxonomies as $taxonomy ) {		if ( isset($cleaned[$taxonomy]) )			continue;		$cleaned[$taxonomy] = true;		if ( $clean_taxonomy ) {			wp_cache_delete('all_ids', $taxonomy);			wp_cache_delete('get', $taxonomy);			delete_option("{$taxonomy}_children");			// Regenerate {$taxonomy}_children			_get_term_hierarchy($taxonomy);		}		do_action('clean_term_cache', $ids, $taxonomy);	}	wp_cache_set('last_changed', time(), 'terms');}/** * Retrieves the taxonomy relationship to the term object id. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses wp_cache_get() Retrieves taxonomy relationship from cache * * @param int|array $id Term object ID * @param string $taxonomy Taxonomy Name * @return bool|array Empty array if $terms found, but not $taxonomy. False if nothing is in cache for $taxonomy and $id. */function &get_object_term_cache($id, $taxonomy) {	$cache = wp_cache_get($id, "{$taxonomy}_relationships");	return $cache;}/** * Updates the cache for Term ID(s). * * Will only update the cache for terms not already cached. * * The $object_ids expects that the ids be separated by commas, if it is a * string. * * It should be noted that update_object_term_cache() is very time extensive. It * is advised that the function is not called very often or at least not for a * lot of terms that exist in a lot of taxonomies. The amount of time increases * for each term and it also increases for each taxonomy the term belongs to. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses wp_get_object_terms() Used to get terms from the database to update * * @param string|array $object_ids Single or list of term object ID(s) * @param array|string $object_type The taxonomy object type * @return null|bool Null value is given with empty $object_ids. False if */function update_object_term_cache($object_ids, $object_type) {	if ( empty($object_ids) )		return;	if ( !is_array($object_ids) )		$object_ids = explode(',', $object_ids);	$object_ids = array_map('intval', $object_ids);	$taxonomies = get_object_taxonomies($object_type);	$ids = array();	foreach ( (array) $object_ids as $id ) {		foreach ( $taxonomies as $taxonomy ) {			if ( false === wp_cache_get($id, "{$taxonomy}_relationships") ) {				$ids[] = $id;				break;			}		}	}	if ( empty( $ids ) )		return false;	$terms = wp_get_object_terms($ids, $taxonomies, array('fields' => 'all_with_object_id'));	$object_terms = array();	foreach ( (array) $terms as $term )		$object_terms[$term->object_id][$term->taxonomy][$term->term_id] = $term;	foreach ( $ids as $id ) {		foreach ( $taxonomies  as $taxonomy ) {			if ( ! isset($object_terms[$id][$taxonomy]) ) {				if ( !isset($object_terms[$id]) )					$object_terms[$id] = array();				$object_terms[$id][$taxonomy] = array();			}		}	}	foreach ( $object_terms as $id => $value ) {		foreach ( $value as $taxonomy => $terms ) {			wp_cache_set($id, $terms, "{$taxonomy}_relationships");		}	}}/** * Updates Terms to Taxonomy in cache. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @param array $terms List of Term objects to change * @param string $taxonomy Optional. Update Term to this taxonomy in cache */function update_term_cache($terms, $taxonomy = '') {	foreach ( (array) $terms as $term ) {		$term_taxonomy = $taxonomy;		if ( empty($term_taxonomy) )			$term_taxonomy = $term->taxonomy;		wp_cache_add($term->term_id, $term, $term_taxonomy);	}}//// Private///** * Retrieves children of taxonomy as Term IDs. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * * @uses update_option() Stores all of the children in "$taxonomy_children" *	 option. That is the name of the taxonomy, immediately followed by '_children'. * * @param string $taxonomy Taxonomy Name * @return array Empty if $taxonomy isn't hierarchical or returns children as Term IDs. */function _get_term_hierarchy($taxonomy) {	if ( !is_taxonomy_hierarchical($taxonomy) )		return array();	$children = get_option("{$taxonomy}_children");	if ( is_array($children) )		return $children;	$children = array();	$terms = get_terms($taxonomy, array('get' => 'all', 'orderby' => 'id', 'fields' => 'id=>parent'));	foreach ( $terms as $term_id => $parent ) {		if ( $parent > 0 )			$children[$parent][] = $term_id;	}	update_option("{$taxonomy}_children", $children);	return $children;}/** * Get the subset of $terms that are descendants of $term_id. * * If $terms is an array of objects, then _get_term_children returns an array of objects. * If $terms is an array of IDs, then _get_term_children returns an array of IDs. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * * @param int $term_id The ancestor term: all returned terms should be descendants of $term_id. * @param array $terms The set of terms---either an array of term objects or term IDs---from which those that are descendants of $term_id will be chosen. * @param string $taxonomy The taxonomy which determines the hierarchy of the terms. * @return array The subset of $terms that are descendants of $term_id. */function &_get_term_children($term_id, $terms, $taxonomy) {	$empty_array = array();	if ( empty($terms) )		return $empty_array;	$term_list = array();	$has_children = _get_term_hierarchy($taxonomy);	if  ( ( 0 != $term_id ) && ! isset($has_children[$term_id]) )		return $empty_array;	foreach ( (array) $terms as $term ) {		$use_id = false;		if ( !is_object($term) ) {			$term = get_term($term, $taxonomy);			if ( is_wp_error( $term ) )				return $term;			$use_id = true;		}		if ( $term->term_id == $term_id )			continue;		if ( $term->parent == $term_id ) {			if ( $use_id )				$term_list[] = $term->term_id;			else				$term_list[] = $term;			if ( !isset($has_children[$term->term_id]) )				continue;			if ( $children = _get_term_children($term->term_id, $terms, $taxonomy) )				$term_list = array_merge($term_list, $children);		}	}	return $term_list;}/** * Add count of children to parent count. * * Recalculates term counts by including items from child terms. Assumes all * relevant children are already in the $terms argument. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * @uses $wpdb * * @param array $terms List of Term IDs * @param string $taxonomy Term Context * @return null Will break from function if conditions are not met. */function _pad_term_counts(&$terms, $taxonomy) {	global $wpdb;	// This function only works for hierarchical taxonomies like post categories.	if ( !is_taxonomy_hierarchical( $taxonomy ) )		return;	$term_hier = _get_term_hierarchy($taxonomy);	if ( empty($term_hier) )		return;	$term_items = array();	foreach ( (array) $terms as $key => $term ) {		$terms_by_id[$term->term_id] = & $terms[$key];		$term_ids[$term->term_taxonomy_id] = $term->term_id;	}	// Get the object and term ids and stick them in a lookup table	$tax_obj = get_taxonomy($taxonomy);	$object_types = esc_sql($tax_obj->object_type);	$results = $wpdb->get_results("SELECT object_id, term_taxonomy_id FROM $wpdb->term_relationships INNER JOIN $wpdb->posts ON object_id = ID WHERE term_taxonomy_id IN (" . implode(',', array_keys($term_ids)) . ") AND post_type IN ('" . implode("', '", $object_types) . "') AND post_status = 'publish'");	foreach ( $results as $row ) {		$id = $term_ids[$row->term_taxonomy_id];		$term_items[$id][$row->object_id] = isset($term_items[$id][$row->object_id]) ? ++$term_items[$id][$row->object_id] : 1;	}	// Touch every ancestor's lookup row for each post in each term	foreach ( $term_ids as $term_id ) {		$child = $term_id;		while ( $parent = $terms_by_id[$child]->parent ) {			if ( !empty($term_items[$term_id]) )				foreach ( $term_items[$term_id] as $item_id => $touches ) {					$term_items[$parent][$item_id] = isset($term_items[$parent][$item_id]) ? ++$term_items[$parent][$item_id]: 1;				}			$child = $parent;		}	}	// Transfer the touched cells	foreach ( (array) $term_items as $id => $items )		if ( isset($terms_by_id[$id]) )			$terms_by_id[$id]->count = count($items);}//// Default callbacks///** * Will update term count based on object types of the current taxonomy. * * Private function for the default callback for post_tag and category * taxonomies. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * @uses $wpdb * * @param array $terms List of Term taxonomy IDs * @param object $taxonomy Current taxonomy object of terms */function _update_post_term_count( $terms, $taxonomy ) {	global $wpdb;	$object_types = is_array($taxonomy->object_type) ? $taxonomy->object_type : array($taxonomy->object_type);	$object_types = esc_sql($object_types);	foreach ( (array) $terms as $term ) {		$count = $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM $wpdb->term_relationships, $wpdb->posts WHERE $wpdb->posts.ID = $wpdb->term_relationships.object_id AND post_status = 'publish' AND post_type IN ('" . implode("', '", $object_types) . "') AND term_taxonomy_id = %d", $term ) );		do_action( 'edit_term_taxonomy', $term, $taxonomy );		$wpdb->update( $wpdb->term_taxonomy, compact( 'count' ), array( 'term_taxonomy_id' => $term ) );		do_action( 'edited_term_taxonomy', $term, $taxonomy );	}}/** * Generates a permalink for a taxonomy term archive. * * @since 2.5.0 * * @param object|int|string $term * @param string $taxonomy * @return string HTML link to taxonomy term archive */function get_term_link( $term, $taxonomy ) {	global $wp_rewrite;	if ( !is_object($term) ) {		if ( is_int($term) ) {			$term = &get_term($term, $taxonomy);		} else {			$term = &get_term_by('slug', $term, $taxonomy);		}	}	if ( !is_object($term) )		$term = new WP_Error('invalid_term', __('Empty Term'));	if ( is_wp_error( $term ) )		return $term;	// use legacy functions for core taxonomies until they are fully plugged in	if ( $taxonomy == 'category' )		return get_category_link((int) $term->term_id);	if ( $taxonomy == 'post_tag' )		return get_tag_link((int) $term->term_id);	$termlink = $wp_rewrite->get_extra_permastruct($taxonomy);	$slug = $term->slug;	if ( empty($termlink) ) {		$t = get_taxonomy($taxonomy);		if ( $t->query_var )			$termlink = "?$t->query_var=$slug";		else			$termlink = "?taxonomy=$taxonomy&term=$slug";		$termlink = home_url($termlink);	} else {		$termlink = str_replace("%$taxonomy%", $slug, $termlink);		$termlink = home_url( user_trailingslashit($termlink, 'category') );	}	return apply_filters('term_link', $termlink, $term, $taxonomy);}/** * Display the taxonomies of a post with available options. * * This function can be used within the loop to display the taxonomies for a * post without specifying the Post ID. You can also use it outside the Loop to * display the taxonomies for a specific post. * * The available defaults are: * 'post' : default is 0. The post ID to get taxonomies of. * 'before' : default is empty string. Display before taxonomies list. * 'sep' : default is empty string. Separate every taxonomy with value in this. * 'after' : default is empty string. Display this after the taxonomies list. * * @since 2.5.0 * @uses get_the_taxonomies() * * @param array $args Override the defaults. */function the_taxonomies($args = array()) {	$defaults = array(		'post' => 0,		'before' => '',		'sep' => ' ',		'after' => '',	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	echo $before . join($sep, get_the_taxonomies($post)) . $after;}/** * Retrieve all taxonomies associated with a post. * * This function can be used within the loop. It will also return an array of * the taxonomies with links to the taxonomy and name. * * @since 2.5.0 * * @param int $post Optional. Post ID or will use Global Post ID (in loop). * @return array */function get_the_taxonomies($post = 0) {	if ( is_int($post) )		$post =& get_post($post);	elseif ( !is_object($post) )		$post =& $GLOBALS['post'];	$taxonomies = array();	if ( !$post )		return $taxonomies;	$template = apply_filters('taxonomy_template', '%s: %l.');	foreach ( get_object_taxonomies($post) as $taxonomy ) {		$t = (array) get_taxonomy($taxonomy);		if ( empty($t['label']) )			$t['label'] = $taxonomy;		if ( empty($t['args']) )			$t['args'] = array();		if ( empty($t['template']) )			$t['template'] = $template;		$terms = get_object_term_cache($post->ID, $taxonomy);		if ( empty($terms) )			$terms = wp_get_object_terms($post->ID, $taxonomy, $t['args']);		$links = array();		foreach ( $terms as $term )			$links[] = "<a href='" . esc_attr(get_term_link($term, $taxonomy)) . "'>$term->name</a>";		if ( $links )			$taxonomies[$taxonomy] = wp_sprintf($t['template'], $t['label'], $links, $terms);	}	return $taxonomies;}/** * Retrieve all taxonomies of a post with just the names. * * @since 2.5.0 * @uses get_object_taxonomies() * * @param int $post Optional. Post ID * @return array */function get_post_taxonomies($post = 0) {	$post =& get_post($post);	return get_object_taxonomies($post);}/** * Determine if the given object is associated with any of the given terms. * * The given terms are checked against the object's terms' term_ids, names and slugs. * Terms given as integers will only be checked against the object's terms' term_ids. * If no terms are given, determines if object is associated with any terms in the given taxonomy. * * @since 2.7.0 * @uses get_object_term_cache() * @uses wp_get_object_terms() * * @param int $object_id.  ID of the object (post ID, link ID, ...) * @param string $taxonomy.  Single taxonomy name * @param int|string|array $terms Optional.  Term term_id, name, slug or array of said * @return bool|WP_Error. WP_Error on input error. */function is_object_in_term( $object_id, $taxonomy, $terms = null ) {	if ( !$object_id = (int) $object_id )		return new WP_Error( 'invalid_object', __( 'Invalid object ID' ) );	$object_terms = get_object_term_cache( $object_id, $taxonomy );	if ( empty( $object_terms ) )		 $object_terms = wp_get_object_terms( $object_id, $taxonomy );	if ( is_wp_error( $object_terms ) )		return $object_terms;	if ( empty( $object_terms ) )		return false;	if ( empty( $terms ) )		return ( !empty( $object_terms ) );	$terms = (array) $terms;	if ( $ints = array_filter( $terms, 'is_int' ) )		$strs = array_diff( $terms, $ints );	else		$strs =& $terms;	foreach ( $object_terms as $object_term ) {		if ( $ints && in_array( $object_term->term_id, $ints ) ) return true; // If int, check against term_id		if ( $strs ) {			if ( in_array( $object_term->term_id, $strs ) ) return true;			if ( in_array( $object_term->name, $strs ) )    return true;			if ( in_array( $object_term->slug, $strs ) )    return true;		}	}	return false;}/** * Determine if the given object type is associated with the given taxonomy. * * @since 3.0.0 * @uses get_object_taxonomies() * * @param string $object_type Object type string * @param string $taxonomy.  Single taxonomy name * @return bool True if object is associated with the taxonomy, otherwise false. */function is_object_in_taxonomy($object_type, $taxonomy) {	$taxonomies = get_object_taxonomies($object_type);	if ( empty($taxonomies) )		return false;	if ( in_array($taxonomy, $taxonomies) )		return true;	return false;}
<?php/** * Edit Comments Administration Panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( !current_user_can('edit_posts') )	wp_die(__('Cheatin&#8217; uh?'));wp_enqueue_script('admin-comments');enqueue_comment_hotkeys_js();$post_id = isset($_REQUEST['p']) ? (int) $_REQUEST['p'] : 0;if ( isset($_REQUEST['doaction']) ||  isset($_REQUEST['doaction2']) || isset($_REQUEST['delete_all']) || isset($_REQUEST['delete_all2']) ) {	check_admin_referer('bulk-comments');	if ( (isset($_REQUEST['delete_all']) || isset($_REQUEST['delete_all2'])) && !empty($_REQUEST['pagegen_timestamp']) ) {		$comment_status = $wpdb->escape($_REQUEST['comment_status']);		$delete_time = $wpdb->escape($_REQUEST['pagegen_timestamp']);		$comment_ids = $wpdb->get_col( "SELECT comment_ID FROM $wpdb->comments WHERE comment_approved = '$comment_status' AND '$delete_time' > comment_date_gmt" );		$doaction = 'delete';	} elseif ( ($_REQUEST['action'] != -1 || $_REQUEST['action2'] != -1) && isset($_REQUEST['delete_comments']) ) {		$comment_ids = $_REQUEST['delete_comments'];		$doaction = ($_REQUEST['action'] != -1) ? $_REQUEST['action'] : $_REQUEST['action2'];	} elseif ( $_REQUEST['doaction'] == 'undo' && isset($_REQUEST['ids']) ) {		$comment_ids = array_map( 'absint', explode(',', $_REQUEST['ids']) );		$doaction = $_REQUEST['action'];	} else {		wp_redirect( wp_get_referer() );	}	$approved = $unapproved = $spammed = $unspammed = $trashed = $untrashed = $deleted = 0;	$redirect_to = remove_query_arg( array('trashed', 'untrashed', 'deleted', 'spammed', 'unspammed', 'approved', 'unapproved', 'ids'), wp_get_referer() );	foreach ($comment_ids as $comment_id) { // Check the permissions on each		$_post_id = (int) $wpdb->get_var( $wpdb->prepare( "SELECT comment_post_ID FROM $wpdb->comments WHERE comment_ID = %d", $comment_id) );		if ( !current_user_can('edit_post', $_post_id) )			continue;		switch( $doaction ) {			case 'approve' :				wp_set_comment_status($comment_id, 'approve');				$approved++;				break;			case 'unapprove' :				wp_set_comment_status($comment_id, 'hold');				$unapproved++;				break;			case 'spam' :				wp_spam_comment($comment_id);				$spammed++;				break;			case 'unspam' :				wp_unspam_comment($comment_id);				$unspammed++;				break;			case 'trash' :				wp_trash_comment($comment_id);				$trashed++;				break;			case 'untrash' :				wp_untrash_comment($comment_id);				$untrashed++;				break;			case 'delete' :				wp_delete_comment($comment_id);				$deleted++;				break;		}	}	if ( $approved )		$redirect_to = add_query_arg( 'approved', $approved, $redirect_to );	if ( $unapproved )		$redirect_to = add_query_arg( 'unapproved', $unapproved, $redirect_to );	if ( $spammed )		$redirect_to = add_query_arg( 'spammed', $spammed, $redirect_to );	if ( $unspammed )		$redirect_to = add_query_arg( 'unspammed', $unspammed, $redirect_to );	if ( $trashed )		$redirect_to = add_query_arg( 'trashed', $trashed, $redirect_to );	if ( $untrashed )		$redirect_to = add_query_arg( 'untrashed', $untrashed, $redirect_to );	if ( $deleted )		$redirect_to = add_query_arg( 'deleted', $deleted, $redirect_to );	if ( $trashed || $spammed )		$redirect_to = add_query_arg( 'ids', join(',', $comment_ids), $redirect_to );	wp_redirect( $redirect_to );	exit;} elseif ( ! empty($_GET['_wp_http_referer']) ) {	 wp_redirect( remove_query_arg( array('_wp_http_referer', '_wpnonce'), stripslashes($_SERVER['REQUEST_URI']) ) );	 exit;}if ( $post_id )	$title = sprintf(__('Comments on &#8220;%s&#8221;'), wp_html_excerpt(_draft_or_post_title($post_id), 50));else	$title = __('Comments');add_contextual_help( $current_screen, '<p>' . __('You can manage comments made on your site similar to the way you manage Posts and other content. This screen is customizable in the same ways as other management screens, and you can act on comments using the on-hover action links or the Bulk Actions.') . '</p>' .	'<p>' . __('A yellow row means the comment is waiting for you to moderate it.') . '</p>' .	'<p>' . __('In the Author column, in addition to the author&#8217;s name, email address, and blog URL, the commenter&#8217;s IP address is shown. Clicking on this link will show you all the comments made from this IP address.') . '</p>' .	'<p>' . __('In the Comment column, above each comment it says &#8220;Submitted on,&#8221; followed by the date and time the comment was left on your site. Clicking on the date/time link will take you to that comment on your live site.') . '</p>' .	'<p>' . __('In the In Response To column, there are three elements. The text is the name of the post that inspired the comment, and links to the post editor for that entry. The &#8220;#&#8221; permalink symbol below leads to that post on your live site. The small bubble with the number in it shows how many comments that post has received. If the bubble is gray, you have moderated all comments for that post. If it is blue, there are pending comments. Clicking the bubble will filter the comments screen to show only comments on that post.') . '</p>' .	'<p>' . __('Many people take advantage of keyboard shortcuts to moderate their comments more quickly. Use the link below to learn more.') . '</p>' .	'<p><strong>' . __( 'For more information:' ) . '</strong></p>' .	'<p>' . __( '<a href="http://codex.wordpress.org/Administration_Panels#Comments" target="_blank">Comments Documentation</a>' ) . '</p>' .	'<p>' . __( '<a href="http://codex.wordpress.org/Comment_Spam" target="_blank">Comment Spam Documentation</a>') . '</p>' .	'<p>' . __( '<a href="http://codex.wordpress.org/Keyboard_Shortcuts" target="_blank">Keyboard Shortcuts Documentation</a>') . '</p>' .	'<p>' . __( '<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once('./admin-header.php');$mode = ( empty($_GET['mode']) ) ? 'detail' : esc_attr($_GET['mode']);$comment_status = isset($_REQUEST['comment_status']) ? $_REQUEST['comment_status'] : 'all';if ( !in_array($comment_status, array('all', 'moderated', 'approved', 'spam', 'trash')) )	$comment_status = 'all';$comment_type = !empty($_GET['comment_type']) ? esc_attr($_GET['comment_type']) : '';$search_dirty = ( isset($_GET['s']) ) ? $_GET['s'] : '';$search = esc_attr( $search_dirty ); ?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title );if ( isset($_GET['s']) && $_GET['s'] )	printf( '<span class="subtitle">' . sprintf( __( 'Search results for &#8220;%s&#8221;' ), wp_html_excerpt( esc_html( stripslashes( $_GET['s'] ) ), 50 ) ) . '</span>' ); ?></h2><?phpif ( isset( $_GET['error'] ) ) {	$error = (int) $_GET['error'];	$error_msg = '';	switch ( $error ) {		case 1 :			$error_msg = __( 'Oops, no comment with this ID.' );			break;		case 2 :			$error_msg = __( 'You are not allowed to edit comments on this post.' );			break;	}	if ( $error_msg )		echo '<div id="moderated" class="error"><p>' . $error_msg . '</p></div>';}if ( isset($_GET['approved']) || isset($_GET['deleted']) || isset($_GET['trashed']) || isset($_GET['untrashed']) || isset($_GET['spammed']) || isset($_GET['unspammed']) || isset($_GET['same']) ) {	$approved  = isset( $_GET['approved']  ) ? (int) $_GET['approved']  : 0;	$deleted   = isset( $_GET['deleted']   ) ? (int) $_GET['deleted']   : 0;	$trashed   = isset( $_GET['trashed']   ) ? (int) $_GET['trashed']   : 0;	$untrashed = isset( $_GET['untrashed'] ) ? (int) $_GET['untrashed'] : 0;	$spammed   = isset( $_GET['spammed']   ) ? (int) $_GET['spammed']   : 0;	$unspammed = isset( $_GET['unspammed'] ) ? (int) $_GET['unspammed'] : 0;	$same      = isset( $_GET['same'] )      ? (int) $_GET['same']      : 0;	if ( $approved > 0 || $deleted > 0 || $trashed > 0 || $untrashed > 0 || $spammed > 0 || $unspammed > 0 || $same > 0 ) {		if ( $approved > 0 )			$messages[] = sprintf( _n( '%s comment approved', '%s comments approved', $approved ), $approved );		if ( $spammed > 0 ) {			$ids = isset($_GET['ids']) ? $_GET['ids'] : 0;			$messages[] = sprintf( _n( '%s comment marked as spam.', '%s comments marked as spam.', $spammed ), $spammed ) . ' <a href="' . esc_url( wp_nonce_url( "edit-comments.php?doaction=undo&action=unspam&ids=$ids", "bulk-comments" ) ) . '">' . __('Undo') . '</a><br />';		}		if ( $unspammed > 0 )			$messages[] = sprintf( _n( '%s comment restored from the spam', '%s comments restored from the spam', $unspammed ), $unspammed );		if ( $trashed > 0 ) {			$ids = isset($_GET['ids']) ? $_GET['ids'] : 0;			$messages[] = sprintf( _n( '%s comment moved to the Trash.', '%s comments moved to the Trash.', $trashed ), $trashed ) . ' <a href="' . esc_url( wp_nonce_url( "edit-comments.php?doaction=undo&action=untrash&ids=$ids", "bulk-comments" ) ) . '">' . __('Undo') . '</a><br />';		}		if ( $untrashed > 0 )			$messages[] = sprintf( _n( '%s comment restored from the Trash', '%s comments restored from the Trash', $untrashed ), $untrashed );		if ( $deleted > 0 )			$messages[] = sprintf( _n( '%s comment permanently deleted', '%s comments permanently deleted', $deleted ), $deleted );		if ( $same > 0 && $comment = get_comment( $same ) ) {			switch ( $comment->comment_approved ) {				case '1' :					$messages[] = __('This comment is already approved.') . ' <a href="' . esc_url( admin_url( "comment.php?action=editcomment&c=$same" ) ) . '">' . __( 'Edit comment' ) . '</a>';					break;				case 'trash' :					$messages[] = __( 'This comment is already in the Trash.' ) . ' <a href="' . esc_url( admin_url( 'edit-comments.php?comment_status=trash' ) ) . '"> ' . __( 'View Trash' ) . '</a>';					break;				case 'spam' :					$messages[] = __( 'This comment is already marked as spam.' ) . ' <a href="' . esc_url( admin_url( "comment.php?action=editcomment&c=$same" ) ) . '">' . __( 'Edit comment' ) . '</a>';					break;			}		}		echo '<div id="moderated" class="updated"><p>' . implode( "<br/>\n", $messages ) . '</p></div>';	}}?><form id="comments-form" action="" method="get"><ul class="subsubsub"><?php$status_links = array();$num_comments = ( $post_id ) ? wp_count_comments( $post_id ) : wp_count_comments();//, number_format_i18n($num_comments->moderated) ), "<span class='comment-count'>" . number_format_i18n($num_comments->moderated) . "</span>"),//, number_format_i18n($num_comments->spam) ), "<span class='spam-comment-count'>" . number_format_i18n($num_comments->spam) . "</span>")$stati = array(		'all' => _nx_noop('All', 'All', 'comments'), // singular not used		'moderated' => _n_noop('Pending <span class="count">(<span class="pending-count">%s</span>)</span>', 'Pending <span class="count">(<span class="pending-count">%s</span>)</span>'),		'approved' => _n_noop('Approved', 'Approved'), // singular not used		'spam' => _n_noop('Spam <span class="count">(<span class="spam-count">%s</span>)</span>', 'Spam <span class="count">(<span class="spam-count">%s</span>)</span>'),		'trash' => _n_noop('Trash <span class="count">(<span class="trash-count">%s</span>)</span>', 'Trash <span class="count">(<span class="trash-count">%s</span>)</span>')	);if ( !EMPTY_TRASH_DAYS )	unset($stati['trash']);$link = 'edit-comments.php';if ( !empty($comment_type) && 'all' != $comment_type )	$link = add_query_arg( 'comment_type', $comment_type, $link );foreach ( $stati as $status => $label ) {	$class = ( $status == $comment_status ) ? ' class="current"' : '';	if ( !isset( $num_comments->$status ) )		$num_comments->$status = 10;	$link = add_query_arg( 'comment_status', $status, $link );	if ( $post_id )		$link = add_query_arg( 'p', absint( $post_id ), $link );	/*	// I toyed with this, but decided against it. Leaving it in here in case anyone thinks it is a good idea. ~ Mark	if ( !empty( $_GET['s'] ) )		$link = add_query_arg( 's', esc_attr( stripslashes( $_GET['s'] ) ), $link );	*/	$status_links[] = "<li class='$status'><a href='$link'$class>" . sprintf(		_n( $label[0], $label[1], $num_comments->$status ),		number_format_i18n( $num_comments->$status )	) . '</a>';}$status_links = apply_filters( 'comment_status_links', $status_links );echo implode( " |</li>\n", $status_links) . '</li>';unset($status_links);?></ul><p class="search-box">	<label class="screen-reader-text" for="comment-search-input"><?php _e( 'Search Comments' ); ?>:</label>	<input type="text" id="comment-search-input" name="s" value="<?php _admin_search_query(); ?>" />	<input type="submit" value="<?php esc_attr_e( 'Search Comments' ); ?>" class="button" /></p><?php$comments_per_page = (int) get_user_option( 'edit_comments_per_page' );if ( empty( $comments_per_page ) || $comments_per_page < 1 )	$comments_per_page = 20;$comments_per_page = apply_filters( 'comments_per_page', $comments_per_page, $comment_status );if ( isset( $_GET['apage'] ) )	$page = abs( (int) $_GET['apage'] );else	$page = 1;$start = $offset = ( $page - 1 ) * $comments_per_page;list($_comments, $total) = _wp_get_comment_list( $comment_status, $search_dirty, $start, $comments_per_page + 8, $post_id, $comment_type ); // Grab a few extra$_comment_post_ids = array();foreach ( $_comments as $_c ) {	$_comment_post_ids[] = $_c->comment_post_ID;}$_comment_pending_count = get_pending_comments_num($_comment_post_ids);$comments = array_slice($_comments, 0, $comments_per_page);$extra_comments = array_slice($_comments, $comments_per_page);$page_links = paginate_links( array(	'base' => add_query_arg( 'apage', '%#%' ),	'format' => '',	'prev_text' => __('&laquo;'),	'next_text' => __('&raquo;'),	'total' => ceil($total / $comments_per_page),	'current' => $page));?><input type="hidden" name="mode" value="<?php echo esc_attr($mode); ?>" /><?php if ( $post_id ) : ?><input type="hidden" name="p" value="<?php echo esc_attr( intval( $post_id ) ); ?>" /><?php endif; ?><input type="hidden" name="comment_status" value="<?php echo esc_attr($comment_status); ?>" /><input type="hidden" name="pagegen_timestamp" value="<?php echo esc_attr(current_time('mysql', 1)); ?>" /><div class="tablenav"><?php if ( $page_links ) : ?><div class="tablenav-pages"><?php $page_links_text = sprintf( '<span class="displaying-num">' . __( 'Displaying %s&#8211;%s of %s' ) . '</span>%s',	number_format_i18n( $start + 1 ),	number_format_i18n( min( $page * $comments_per_page, $total ) ),	'<span class="total-type-count">' . number_format_i18n( $total ) . '</span>',	$page_links); echo $page_links_text; ?></div><input type="hidden" name="_total" value="<?php echo esc_attr($total); ?>" /><input type="hidden" name="_per_page" value="<?php echo esc_attr($comments_per_page); ?>" /><input type="hidden" name="_page" value="<?php echo esc_attr($page); ?>" /><?php endif; ?><?php if ( $comments ) : ?><div class="alignleft actions"><select name="action"><option value="-1" selected="selected"><?php _e('Bulk Actions') ?></option><?php if ( 'all' == $comment_status || 'approved' == $comment_status ): ?><option value="unapprove"><?php _e('Unapprove'); ?></option><?php endif; ?><?php if ( 'all' == $comment_status || 'moderated' == $comment_status || 'spam' == $comment_status ): ?><option value="approve"><?php _e('Approve'); ?></option><?php endif; ?><?php if ( 'all' == $comment_status || 'approved' == $comment_status || 'moderated' == $comment_status ): ?><option value="spam"><?php _ex('Mark as Spam', 'comment'); ?></option><?php endif; ?><?php if ( 'trash' == $comment_status ): ?><option value="untrash"><?php _e('Restore'); ?></option><?php elseif ( 'spam' == $comment_status ): ?><option value="unspam"><?php _ex('Not Spam', 'comment'); ?></option><?php endif; ?><?php if ( 'trash' == $comment_status || 'spam' == $comment_status || !EMPTY_TRASH_DAYS ): ?><option value="delete"><?php _e('Delete Permanently'); ?></option><?php else: ?><option value="trash"><?php _e('Move to Trash'); ?></option><?php endif; ?></select><input type="submit" name="doaction" id="doaction" value="<?php esc_attr_e('Apply'); ?>" class="button-secondary apply" /><?php wp_nonce_field('bulk-comments'); ?><?php endif; ?><select name="comment_type">	<option value="all"><?php _e('Show all comment types'); ?></option><?php	$comment_types = apply_filters( 'admin_comment_types_dropdown', array(		'comment' => __('Comments'),		'pings' => __('Pings'),	) );	foreach ( $comment_types as $type => $label ) {		echo "	<option value='" . esc_attr($type) . "'";		selected( $comment_type, $type );		echo ">$label</option>\n";	}?></select><input type="submit" id="post-query-submit" value="<?php esc_attr_e('Filter'); ?>" class="button-secondary" /><?php if ( isset($_GET['apage']) ) { ?>	<input type="hidden" name="apage" value="<?php echo esc_attr( absint( $_GET['apage'] ) ); ?>" /><?php }if ( ( 'spam' == $comment_status || 'trash' == $comment_status) && current_user_can ('moderate_comments') ) {	wp_nonce_field('bulk-destroy', '_destroy_nonce');    if ( 'spam' == $comment_status && current_user_can('moderate_comments') ) { ?>		<input type="submit" name="delete_all" id="delete_all" value="<?php esc_attr_e('Empty Spam'); ?>" class="button-secondary apply" /><?php } elseif ( 'trash' == $comment_status && current_user_can('moderate_comments') ) { ?>		<input type="submit" name="delete_all" id="delete_all" value="<?php esc_attr_e('Empty Trash'); ?>" class="button-secondary apply" /><?php }} ?><?php do_action('manage_comments_nav', $comment_status); ?></div><br class="clear" /></div><div class="clear"></div><?php if ( $comments ) { ?><table class="widefat comments fixed" cellspacing="0"><thead>	<tr><?php print_column_headers('edit-comments'); ?>	</tr></thead><tfoot>	<tr><?php print_column_headers('edit-comments', false); ?>	</tr></tfoot><tbody id="the-comment-list" class="list:comment"><?php	foreach ($comments as $comment)		_wp_comment_row( $comment->comment_ID, $mode, $comment_status );?></tbody><tbody id="the-extra-comment-list" class="list:comment" style="display: none;"><?php	foreach ($extra_comments as $comment)		_wp_comment_row( $comment->comment_ID, $mode, $comment_status );?></tbody></table><div class="tablenav"><?phpif ( $page_links )	echo "<div class='tablenav-pages'>$page_links_text</div>";?><div class="alignleft actions"><select name="action2"><option value="-1" selected="selected"><?php _e('Bulk Actions') ?></option><?php if ( 'all' == $comment_status || 'approved' == $comment_status ): ?><option value="unapprove"><?php _e('Unapprove'); ?></option><?php endif; ?><?php if ( 'all' == $comment_status || 'moderated' == $comment_status || 'spam' == $comment_status ): ?><option value="approve"><?php _e('Approve'); ?></option><?php endif; ?><?php if ( 'all' == $comment_status || 'approved' == $comment_status || 'moderated' == $comment_status ): ?><option value="spam"><?php _ex('Mark as Spam', 'comment'); ?></option><?php endif; ?><?php if ( 'trash' == $comment_status ): ?><option value="untrash"><?php _e('Restore'); ?></option><?php endif; ?><?php if ( 'trash' == $comment_status || 'spam' == $comment_status || !EMPTY_TRASH_DAYS ): ?><option value="delete"><?php _e('Delete Permanently'); ?></option><?php elseif ( 'spam' == $comment_status ): ?><option value="unspam"><?php _ex('Not Spam', 'comment'); ?></option><?php else: ?><option value="trash"><?php _e('Move to Trash'); ?></option><?php endif; ?></select><input type="submit" name="doaction2" id="doaction2" value="<?php esc_attr_e('Apply'); ?>" class="button-secondary apply" /><?php if ( 'spam' == $comment_status && current_user_can('moderate_comments') ) { ?><input type="submit" name="delete_all2" id="delete_all2" value="<?php esc_attr_e('Empty Spam'); ?>" class="button-secondary apply" /><?php } elseif ( 'trash' == $comment_status && current_user_can('moderate_comments') ) { ?><input type="submit" name="delete_all2" id="delete_all2" value="<?php esc_attr_e('Empty Trash'); ?>" class="button-secondary apply" /><?php } ?><?php do_action('manage_comments_nav', $comment_status); ?></div><br class="clear" /></div></form><form id="get-extra-comments" method="post" action="" class="add:the-extra-comment-list:" style="display: none;">	<input type="hidden" name="s" value="<?php echo esc_attr($search); ?>" />	<input type="hidden" name="mode" value="<?php echo esc_attr($mode); ?>" />	<input type="hidden" name="comment_status" value="<?php echo esc_attr($comment_status); ?>" />	<input type="hidden" name="page" value="<?php echo esc_attr($page); ?>" />	<input type="hidden" name="per_page" value="<?php echo esc_attr($comments_per_page); ?>" />	<input type="hidden" name="p" value="<?php echo esc_attr( $post_id ); ?>" />	<input type="hidden" name="comment_type" value="<?php echo esc_attr( $comment_type ); ?>" />	<?php wp_nonce_field( 'add-comment', '_ajax_nonce', false ); ?></form><div id="ajax-response"></div><?php } elseif ( 'moderated' == $comment_status ) { ?><p><?php _e('No comments awaiting moderation&hellip; yet.') ?></p></div></form><?php } else { ?><p><?php _e('No comments found.') ?></p></div></form><?php } ?></div><?phpwp_comment_reply('-1', true, 'detail');wp_comment_trashnotice();include('./admin-footer.php'); ?>
